{"issue_key": "AMQCPP-515", "project": "AMQCPP", "title": "Stomp frame mishandled duplicate headers", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-10-07T09:30:32.000+0000", "updated": "2013-10-07T13:58:36.000+0000", "description": "http://stomp.github.io/stomp-specification-1.1.html#Repeated_Header_Entries", "comments": [], "text": "Stomp frame mishandled duplicate headers\n\nDescription:\nhttp://stomp.github.io/stomp-specification-1.1.html#Repeated_Header_Entries\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stomp frame mishandled duplicate headers\n\nDescription:\nhttp://stomp.github.io/stomp-specification-1.1.html#Repeated_Header_Entries\n\nComments:\n", "classification": "Classify the issue 'Stomp frame mishandled duplicate headers' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-515?\nA: http://stomp.github.io/stomp-specification-1.1.html#Repeated_Header_Entries"}}
{"issue_key": "AMQCPP-514", "project": "AMQCPP", "title": "ActiveMQBytesMessage destruction may cause unhandle exception", "status": "Resolved", "reporter": "Christian Mamen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-10-02T22:08:39.000+0000", "updated": "2013-10-07T13:58:00.000+0000", "description": "While creating a cms::bytesMessage and sending it in a function, i encounter an unhandle exception\n\nthe application code resemble this\n{code}\nvoid sendMessage()\n{\n    auto_ptr<cms::BytesMessage> msg( session->createBytesMessage() );\n\n    // populate message\n    [...]\n\n    // send the message\n    _producer->send( msg.get() );\n}\n\nvoid caller()\n{\n    try\n    {\n        sendMessage()\n    }\n    catch( cms::CMSException & ex )\n    {\n        // exception\n    }\n}\n{code}\n\nThe call stack, when the unhandle exception happens, is the following\n\nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::reset() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::~ActiveMQBytesMessage() \nactivemq-cpp.dll!cms::CMSException::setMark(const char * file=0x00000000, const int lineNumber=1974618930) \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \n\nThe exception from ActiveMQBytesMessage::storeContent() causes a double throw, from the send, and afterwards from the smart pointer when the message is destroyed\n\n////\n\nIm guessing that \n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() throw() {\n    this->reset();\n}\n{code}\n\nshould be something like :\n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() {\n    try {    \n        this->reset();\n    }\n    AMQ_CATCHALL_NOTHROW()\n}\n{code}", "comments": [], "text": "ActiveMQBytesMessage destruction may cause unhandle exception\n\nDescription:\nWhile creating a cms::bytesMessage and sending it in a function, i encounter an unhandle exception\n\nthe application code resemble this\n{code}\nvoid sendMessage()\n{\n    auto_ptr<cms::BytesMessage> msg( session->createBytesMessage() );\n\n    // populate message\n    [...]\n\n    // send the message\n    _producer->send( msg.get() );\n}\n\nvoid caller()\n{\n    try\n    {\n        sendMessage()\n    }\n    catch( cms::CMSException & ex )\n    {\n        // exception\n    }\n}\n{code}\n\nThe call stack, when the unhandle exception happens, is the following\n\nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::reset() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::~ActiveMQBytesMessage() \nactivemq-cpp.dll!cms::CMSException::setMark(const char * file=0x00000000, const int lineNumber=1974618930) \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \n\nThe exception from ActiveMQBytesMessage::storeContent() causes a double throw, from the send, and afterwards from the smart pointer when the message is destroyed\n\n////\n\nIm guessing that \n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() throw() {\n    this->reset();\n}\n{code}\n\nshould be something like :\n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() {\n    try {    \n        this->reset();\n    }\n    AMQ_CATCHALL_NOTHROW()\n}\n{code}\n\n\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQBytesMessage destruction may cause unhandle exception\n\nDescription:\nWhile creating a cms::bytesMessage and sending it in a function, i encounter an unhandle exception\n\nthe application code resemble this\n{code}\nvoid sendMessage()\n{\n    auto_ptr<cms::BytesMessage> msg( session->createBytesMessage() );\n\n    // populate message\n    [...]\n\n    // send the message\n    _producer->send( msg.get() );\n}\n\nvoid caller()\n{\n    try\n    {\n        sendMessage()\n    }\n    catch( cms::CMSException & ex )\n    {\n        // exception\n    }\n}\n{code}\n\nThe call stack, when the unhandle exception happens, is the following\n\nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::reset() \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::~ActiveMQBytesMessage() \nactivemq-cpp.dll!cms::CMSException::setMark(const char * file=0x00000000, const int lineNumber=1974618930) \nactivemq-cpp.dll!activemq::commands::ActiveMQBytesMessage::storeContent() \n\nThe exception from ActiveMQBytesMessage::storeContent() causes a double throw, from the send, and afterwards from the smart pointer when the message is destroyed\n\n////\n\nIm guessing that \n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() throw() {\n    this->reset();\n}\n{code}\n\nshould be something like :\n{code}\nActiveMQBytesMessage::~ActiveMQBytesMessage() {\n    try {    \n        this->reset();\n    }\n    AMQ_CATCHALL_NOTHROW()\n}\n{code}\n\n\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQBytesMessage destruction may cause unhandle exception' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-514?\nA: While creating a cms::bytesMessage and sending it in a function, i encounter an unhandle exception\n\nthe application code resemble this\n{code}\nvoid sendMessage()\n{\n    auto_ptr<cms::BytesMessage> msg( session->createBytesMessage() );\n\n    // populate message\n    [...]\n\n    // send the message\n    _producer->send( msg.get() );\n}\n\nvoid caller()\n{\n    try\n    {\n        sendMessage()\n    }\n    catch( c"}}
{"issue_key": "AMQCPP-513", "project": "AMQCPP", "title": "On closing a connection, ActiveMQ crashes", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-09-20T16:12:02.000+0000", "updated": "2013-10-16T08:40:53.000+0000", "description": "By closing the connection, ActiveMQConnection::close() and AdvisoryConsumer::processDestinationInfo() access/modify in the same time on config.activeTempDestinations. This gives a crash.\n\nTest case:\n- compile test.cc\n- run the two command lines in parallel\n  + test.exe client1\n  + test.exe client2\n\nProposed fix:\nDispose the advisory consumer on closing the connection.", "comments": [], "text": "On closing a connection, ActiveMQ crashes\n\nDescription:\nBy closing the connection, ActiveMQConnection::close() and AdvisoryConsumer::processDestinationInfo() access/modify in the same time on config.activeTempDestinations. This gives a crash.\n\nTest case:\n- compile test.cc\n- run the two command lines in parallel\n  + test.exe client1\n  + test.exe client2\n\nProposed fix:\nDispose the advisory consumer on closing the connection.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: On closing a connection, ActiveMQ crashes\n\nDescription:\nBy closing the connection, ActiveMQConnection::close() and AdvisoryConsumer::processDestinationInfo() access/modify in the same time on config.activeTempDestinations. This gives a crash.\n\nTest case:\n- compile test.cc\n- run the two command lines in parallel\n  + test.exe client1\n  + test.exe client2\n\nProposed fix:\nDispose the advisory consumer on closing the connection.\n\nComments:\n", "classification": "Classify the issue 'On closing a connection, ActiveMQ crashes' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-513?\nA: By closing the connection, ActiveMQConnection::close() and AdvisoryConsumer::processDestinationInfo() access/modify in the same time on config.activeTempDestinations. This gives a crash.\n\nTest case:\n- compile test.cc\n- run the two command lines in parallel\n  + test.exe client1\n  + test.exe client2\n\nProposed fix:\nDispose the advisory consumer on closing the connection."}}
{"issue_key": "AMQCPP-512", "project": "AMQCPP", "title": "Update to support openwire v10", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-09-17T16:01:05.000+0000", "updated": "2013-09-17T20:28:09.000+0000", "description": "Generate Openwire v10 code and support setting new message fields.", "comments": [], "text": "Update to support openwire v10\n\nDescription:\nGenerate Openwire v10 code and support setting new message fields. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update to support openwire v10\n\nDescription:\nGenerate Openwire v10 code and support setting new message fields. \n\nComments:\n", "classification": "Classify the issue 'Update to support openwire v10' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-512?\nA: Generate Openwire v10 code and support setting new message fields. "}}
{"issue_key": "AMQCPP-511", "project": "AMQCPP", "title": "Add support for fabric HTTP discovery", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-09-12T15:13:47.000+0000", "updated": "2015-07-09T21:51:43.000+0000", "description": "Add support for discovery of Brokers via HTTP such as that supported in upcoming Fabric releases.  Could also add in the plumbing needed for basic multicast discovery at this time also.  \n\nRequires some work to provide an HTTP client or use of an external lib to to HTTP gets etc.", "comments": [], "text": "Add support for fabric HTTP discovery\n\nDescription:\nAdd support for discovery of Brokers via HTTP such as that supported in upcoming Fabric releases.  Could also add in the plumbing needed for basic multicast discovery at this time also.  \n\nRequires some work to provide an HTTP client or use of an external lib to to HTTP gets etc. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for fabric HTTP discovery\n\nDescription:\nAdd support for discovery of Brokers via HTTP such as that supported in upcoming Fabric releases.  Could also add in the plumbing needed for basic multicast discovery at this time also.  \n\nRequires some work to provide an HTTP client or use of an external lib to to HTTP gets etc. \n\nComments:\n", "classification": "Classify the issue 'Add support for fabric HTTP discovery' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-511?\nA: Add support for discovery of Brokers via HTTP such as that supported in upcoming Fabric releases.  Could also add in the plumbing needed for basic multicast discovery at this time also.  \n\nRequires some work to provide an HTTP client or use of an external lib to to HTTP gets etc. "}}
{"issue_key": "AMQCPP-510", "project": "AMQCPP", "title": "Consumer leaks memory with failover and checkForDuplicates=true", "status": "Resolved", "reporter": "Sam Parsons", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-09-10T14:59:49.000+0000", "updated": "2013-09-20T14:24:36.000+0000", "description": "The example application (examples/main.cpp) leaks memory in the consumer. \n\nTo reproduce the problem, add a usleep(100000) after the producer->send, set useTopics = false and numMessages = 2000000.\n\nWith the following url, the example application remains on 4% CPU and 15 meg of memory on my development machine: \n\n\"failover:(tcp://localhost:61616)?connection.checkForDuplicates=false\" \n\nWithout the \"checkForDuplicates=false\" the cpu and memory usage grows constantly. I eventually stopped it at 100% CPU and 340 meg of memory. \n\nValgrind suggested that the leak was in ConnectionAudit.cpp:100. I added the following debug: \n\n{noformat}\ntry { \n  audit = this->impl->destinations.get(destination); \n} catch (NoSuchElementException& ex) { \n  audit.reset(new ActiveMQMessageAudit(auditDepth,auditMaximumProducerNumber)); \n  this->impl->destinations.put(destination, audit); \n  std::cout << \"New destination audit: \" << destination->toString() \n            << \", size: \" << this->impl->destinations.keySet().size() << std::endl; \n} \n{noformat}\n\n...and it prints... \n\n{noformat}\nSent message #410 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 410 \nMessage #410 Received: Hello world! from thread 140736021874568 \nSent message #411 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 411 \nMessage #411 Received: Hello world! from thread 140736021874568 \n{noformat}\n\nSo the size of the destinations map keeps increasing. It seems to think every message has a new destination, but this is not the case. It's just the example code in main.cpp which creates the TEST.FOO destination and sends messages to it in a loop. \n\nI tested 3.7.0, 3.7.1 and 3.8.0 and the problem is in all of these versions. 3.4.4 does not have this problem, but that version does not have duplicates detection so that's probably why.", "comments": [], "text": "Consumer leaks memory with failover and checkForDuplicates=true\n\nDescription:\nThe example application (examples/main.cpp) leaks memory in the consumer. \n\nTo reproduce the problem, add a usleep(100000) after the producer->send, set useTopics = false and numMessages = 2000000.\n\nWith the following url, the example application remains on 4% CPU and 15 meg of memory on my development machine: \n\n\"failover:(tcp://localhost:61616)?connection.checkForDuplicates=false\" \n\nWithout the \"checkForDuplicates=false\" the cpu and memory usage grows constantly. I eventually stopped it at 100% CPU and 340 meg of memory. \n\nValgrind suggested that the leak was in ConnectionAudit.cpp:100. I added the following debug: \n\n{noformat}\ntry { \n  audit = this->impl->destinations.get(destination); \n} catch (NoSuchElementException& ex) { \n  audit.reset(new ActiveMQMessageAudit(auditDepth,auditMaximumProducerNumber)); \n  this->impl->destinations.put(destination, audit); \n  std::cout << \"New destination audit: \" << destination->toString() \n            << \", size: \" << this->impl->destinations.keySet().size() << std::endl; \n} \n{noformat}\n\n...and it prints... \n\n{noformat}\nSent message #410 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 410 \nMessage #410 Received: Hello world! from thread 140736021874568 \nSent message #411 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 411 \nMessage #411 Received: Hello world! from thread 140736021874568 \n{noformat}\n\nSo the size of the destinations map keeps increasing. It seems to think every message has a new destination, but this is not the case. It's just the example code in main.cpp which creates the TEST.FOO destination and sends messages to it in a loop. \n\nI tested 3.7.0, 3.7.1 and 3.8.0 and the problem is in all of these versions. 3.4.4 does not have this problem, but that version does not have duplicates detection so that's probably why.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consumer leaks memory with failover and checkForDuplicates=true\n\nDescription:\nThe example application (examples/main.cpp) leaks memory in the consumer. \n\nTo reproduce the problem, add a usleep(100000) after the producer->send, set useTopics = false and numMessages = 2000000.\n\nWith the following url, the example application remains on 4% CPU and 15 meg of memory on my development machine: \n\n\"failover:(tcp://localhost:61616)?connection.checkForDuplicates=false\" \n\nWithout the \"checkForDuplicates=false\" the cpu and memory usage grows constantly. I eventually stopped it at 100% CPU and 340 meg of memory. \n\nValgrind suggested that the leak was in ConnectionAudit.cpp:100. I added the following debug: \n\n{noformat}\ntry { \n  audit = this->impl->destinations.get(destination); \n} catch (NoSuchElementException& ex) { \n  audit.reset(new ActiveMQMessageAudit(auditDepth,auditMaximumProducerNumber)); \n  this->impl->destinations.put(destination, audit); \n  std::cout << \"New destination audit: \" << destination->toString() \n            << \", size: \" << this->impl->destinations.keySet().size() << std::endl; \n} \n{noformat}\n\n...and it prints... \n\n{noformat}\nSent message #410 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 410 \nMessage #410 Received: Hello world! from thread 140736021874568 \nSent message #411 from thread 140736021874568 \nNew destination audit: queue://TEST.FOO, size: 411 \nMessage #411 Received: Hello world! from thread 140736021874568 \n{noformat}\n\nSo the size of the destinations map keeps increasing. It seems to think every message has a new destination, but this is not the case. It's just the example code in main.cpp which creates the TEST.FOO destination and sends messages to it in a loop. \n\nI tested 3.7.0, 3.7.1 and 3.8.0 and the problem is in all of these versions. 3.4.4 does not have this problem, but that version does not have duplicates detection so that's probably why.\n\nComments:\n", "classification": "Classify the issue 'Consumer leaks memory with failover and checkForDuplicates=true' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-510?\nA: The example application (examples/main.cpp) leaks memory in the consumer. \n\nTo reproduce the problem, add a usleep(100000) after the producer->send, set useTopics = false and numMessages = 2000000.\n\nWith the following url, the example application remains on 4% CPU and 15 meg of memory on my development machine: \n\n\"failover:(tcp://localhost:61616)?connection.checkForDuplicates=false\" \n\nWithout the "}}
{"issue_key": "AMQCPP-509", "project": "AMQCPP", "title": "Support for AlwaysSessionAsync in AMQ CMS CPP library", "status": "Resolved", "reporter": "D V Gangadhar Rao", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-09-04T14:52:04.000+0000", "updated": "2013-09-06T21:55:58.000+0000", "description": "On the consumer side, there are two layers of threads responsible for receiving\nincoming messages: the Session threads and the MessageConsumer threads.\nIn the special case where only one session is associated with a connection,\nthe two layers are redundant and it is possible to optimize the threading model by setting the alwaysSessionAsync to false.\n\nSetting the AlwaysSessionAsync to false would have the consumer directly pull the messages from the transport without the need for IO thread. \n\n\n\nThis feature is not supported in the latest version of CMS CPP library.", "comments": [], "text": "Support for AlwaysSessionAsync in AMQ CMS CPP library\n\nDescription:\nOn the consumer side, there are two layers of threads responsible for receiving\nincoming messages: the Session threads and the MessageConsumer threads.\nIn the special case where only one session is associated with a connection,\nthe two layers are redundant and it is possible to optimize the threading model by setting the alwaysSessionAsync to false.\n\nSetting the AlwaysSessionAsync to false would have the consumer directly pull the messages from the transport without the need for IO thread. \n\n\n\nThis feature is not supported in the latest version of CMS CPP library.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Support for AlwaysSessionAsync in AMQ CMS CPP library\n\nDescription:\nOn the consumer side, there are two layers of threads responsible for receiving\nincoming messages: the Session threads and the MessageConsumer threads.\nIn the special case where only one session is associated with a connection,\nthe two layers are redundant and it is possible to optimize the threading model by setting the alwaysSessionAsync to false.\n\nSetting the AlwaysSessionAsync to false would have the consumer directly pull the messages from the transport without the need for IO thread. \n\n\n\nThis feature is not supported in the latest version of CMS CPP library.\n\n\n\nComments:\n", "classification": "Classify the issue 'Support for AlwaysSessionAsync in AMQ CMS CPP library' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-509?\nA: On the consumer side, there are two layers of threads responsible for receiving\nincoming messages: the Session threads and the MessageConsumer threads.\nIn the special case where only one session is associated with a connection,\nthe two layers are redundant and it is possible to optimize the threading model by setting the alwaysSessionAsync to false.\n\nSetting the AlwaysSessionAsync to false would h"}}
{"issue_key": "AMQCPP-508", "project": "AMQCPP", "title": "Add DestinationSource interfaces in CMS and provide an ActiveMQ implementation", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-08-28T22:07:04.000+0000", "updated": "2013-09-03T21:40:36.000+0000", "description": "And optional EnhancedConnection and DestinationSource APIs to CMS and provide an implementation for ActiveMQ using Advisory listeners.", "comments": [], "text": "Add DestinationSource interfaces in CMS and provide an ActiveMQ implementation\n\nDescription:\nAnd optional EnhancedConnection and DestinationSource APIs to CMS and provide an implementation for ActiveMQ using Advisory listeners. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add DestinationSource interfaces in CMS and provide an ActiveMQ implementation\n\nDescription:\nAnd optional EnhancedConnection and DestinationSource APIs to CMS and provide an implementation for ActiveMQ using Advisory listeners. \n\nComments:\n", "classification": "Classify the issue 'Add DestinationSource interfaces in CMS and provide an ActiveMQ implementation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-508?\nA: And optional EnhancedConnection and DestinationSource APIs to CMS and provide an implementation for ActiveMQ using Advisory listeners. "}}
{"issue_key": "AMQCPP-507", "project": "AMQCPP", "title": "Add new Visual Studio 2010 Project files", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-08-20T14:04:39.000+0000", "updated": "2013-08-27T21:20:05.000+0000", "description": "Since vs2008 is a bit long in the tooth now we should move on to vs2010 as our lowest common denominator on Windows.  We can keep the 2008 around for a release cycle or two while the 2010 one's are refined.", "comments": [], "text": "Add new Visual Studio 2010 Project files\n\nDescription:\nSince vs2008 is a bit long in the tooth now we should move on to vs2010 as our lowest common denominator on Windows.  We can keep the 2008 around for a release cycle or two while the 2010 one's are refined.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add new Visual Studio 2010 Project files\n\nDescription:\nSince vs2008 is a bit long in the tooth now we should move on to vs2010 as our lowest common denominator on Windows.  We can keep the 2008 around for a release cycle or two while the 2010 one's are refined.  \n\nComments:\n", "classification": "Classify the issue 'Add new Visual Studio 2010 Project files' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-507?\nA: Since vs2008 is a bit long in the tooth now we should move on to vs2010 as our lowest common denominator on Windows.  We can keep the 2008 around for a release cycle or two while the 2010 one's are refined.  "}}
{"issue_key": "AMQCPP-506", "project": "AMQCPP", "title": "Exception \"attempt to unlock read lock, not locked by current thread\" when doing performance testing", "status": "Resolved", "reporter": "Jonathan Fortier", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-08-09T19:46:08.000+0000", "updated": "2013-08-14T13:41:56.000+0000", "description": "While doing long-term performance testing of our application (~10,000 messages/second), an exception is thrown after a few hours of operation. Here is the details of the exception:\nIllegalMonitorStateException: attempt to unlock read lock, not locked by current thread\nStack trace:\n{quote}\n`anonymous namespace}}'::Sync::tryReleaseShared(int unused=1)  Line 205\ndecaf::util::concurrent::locks::AbstractQueuedSynchronizer::releaseShared(int arg=1)  Line 1630 + 0x11 bytes\n`anonymous namespace'::ReadLock::unlock()  Line 660\nactivemq::core::kernels::ActiveMQSessionKernel::lookupConsumerKernel(...)  Line 1336\nactivemq::core::ActiveMQSessionExecutor::dispatch(...)  Line 151 + 0x47 bytes\nactivemq::core::ActiveMQSessionExecutor::iterate()  Line 182\nactivemq::threads::DedicatedTaskRunner::run()  Line 141 + 0x13 bytes\ndecaf::lang::Thread::run()  Line 143\n{quote}\n\nAfter a little debugging, I identified a code defect that seems to be the cause of our problem. In class decaf::util::concurrent::locks::ReentrantReadWriteLock, the class member \"cachedHoldCounter\" is used to optimize performance. However, that member is accessed concurrently by multiple thread, but the modifications of that member are not atomic, which implies that a thread can read a partly updated member (i.e. the count of thread #2 with pointer to thread #1). In that case, lock logic get all messed up, and we end up with strange behavior (eg. infinite waiting for lock). \n\nI wrote a unit test to reproduce the problem (see attachment). However, since this is a race condition, it may take a few run to reproduce.\n\nWhen I commented cachedHoldCounter-related code from ReentrantReadWriteLock (i.e. always go in ThreadLocal), the problem seems to be gone.", "comments": [], "text": "Exception \"attempt to unlock read lock, not locked by current thread\" when doing performance testing\n\nDescription:\nWhile doing long-term performance testing of our application (~10,000 messages/second), an exception is thrown after a few hours of operation. Here is the details of the exception:\nIllegalMonitorStateException: attempt to unlock read lock, not locked by current thread\nStack trace:\n{quote}\n`anonymous namespace}}'::Sync::tryReleaseShared(int unused=1)  Line 205\ndecaf::util::concurrent::locks::AbstractQueuedSynchronizer::releaseShared(int arg=1)  Line 1630 + 0x11 bytes\n`anonymous namespace'::ReadLock::unlock()  Line 660\nactivemq::core::kernels::ActiveMQSessionKernel::lookupConsumerKernel(...)  Line 1336\nactivemq::core::ActiveMQSessionExecutor::dispatch(...)  Line 151 + 0x47 bytes\nactivemq::core::ActiveMQSessionExecutor::iterate()  Line 182\nactivemq::threads::DedicatedTaskRunner::run()  Line 141 + 0x13 bytes\ndecaf::lang::Thread::run()  Line 143\n{quote}\n\nAfter a little debugging, I identified a code defect that seems to be the cause of our problem. In class decaf::util::concurrent::locks::ReentrantReadWriteLock, the class member \"cachedHoldCounter\" is used to optimize performance. However, that member is accessed concurrently by multiple thread, but the modifications of that member are not atomic, which implies that a thread can read a partly updated member (i.e. the count of thread #2 with pointer to thread #1). In that case, lock logic get all messed up, and we end up with strange behavior (eg. infinite waiting for lock). \n\nI wrote a unit test to reproduce the problem (see attachment). However, since this is a race condition, it may take a few run to reproduce.\n\nWhen I commented cachedHoldCounter-related code from ReentrantReadWriteLock (i.e. always go in ThreadLocal), the problem seems to be gone. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception \"attempt to unlock read lock, not locked by current thread\" when doing performance testing\n\nDescription:\nWhile doing long-term performance testing of our application (~10,000 messages/second), an exception is thrown after a few hours of operation. Here is the details of the exception:\nIllegalMonitorStateException: attempt to unlock read lock, not locked by current thread\nStack trace:\n{quote}\n`anonymous namespace}}'::Sync::tryReleaseShared(int unused=1)  Line 205\ndecaf::util::concurrent::locks::AbstractQueuedSynchronizer::releaseShared(int arg=1)  Line 1630 + 0x11 bytes\n`anonymous namespace'::ReadLock::unlock()  Line 660\nactivemq::core::kernels::ActiveMQSessionKernel::lookupConsumerKernel(...)  Line 1336\nactivemq::core::ActiveMQSessionExecutor::dispatch(...)  Line 151 + 0x47 bytes\nactivemq::core::ActiveMQSessionExecutor::iterate()  Line 182\nactivemq::threads::DedicatedTaskRunner::run()  Line 141 + 0x13 bytes\ndecaf::lang::Thread::run()  Line 143\n{quote}\n\nAfter a little debugging, I identified a code defect that seems to be the cause of our problem. In class decaf::util::concurrent::locks::ReentrantReadWriteLock, the class member \"cachedHoldCounter\" is used to optimize performance. However, that member is accessed concurrently by multiple thread, but the modifications of that member are not atomic, which implies that a thread can read a partly updated member (i.e. the count of thread #2 with pointer to thread #1). In that case, lock logic get all messed up, and we end up with strange behavior (eg. infinite waiting for lock). \n\nI wrote a unit test to reproduce the problem (see attachment). However, since this is a race condition, it may take a few run to reproduce.\n\nWhen I commented cachedHoldCounter-related code from ReentrantReadWriteLock (i.e. always go in ThreadLocal), the problem seems to be gone. \n\nComments:\n", "classification": "Classify the issue 'Exception \"attempt to unlock read lock, not locked by current thread\" when doing performance testing' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-506?\nA: While doing long-term performance testing of our application (~10,000 messages/second), an exception is thrown after a few hours of operation. Here is the details of the exception:\nIllegalMonitorStateException: attempt to unlock read lock, not locked by current thread\nStack trace:\n{quote}\n`anonymous namespace}}'::Sync::tryReleaseShared(int unused=1)  Line 205\ndecaf::util::concurrent::locks::Abstra"}}
{"issue_key": "AMQCPP-505", "project": "AMQCPP", "title": "For SSL connections ensure the SNI field is set.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-08-07T16:10:11.000+0000", "updated": "2013-11-08T22:30:10.000+0000", "description": "Provide a way in the Decaf OpenSSL implementation to set the SNI field and then ensure it gets set in the SSL transport layer.", "comments": [], "text": "For SSL connections ensure the SNI field is set.\n\nDescription:\nProvide a way in the Decaf OpenSSL implementation to set the SNI field and then ensure it gets set in the SSL transport layer.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: For SSL connections ensure the SNI field is set.\n\nDescription:\nProvide a way in the Decaf OpenSSL implementation to set the SNI field and then ensure it gets set in the SSL transport layer.\n\nComments:\n", "classification": "Classify the issue 'For SSL connections ensure the SNI field is set.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-505?\nA: Provide a way in the Decaf OpenSSL implementation to set the SNI field and then ensure it gets set in the SSL transport layer."}}
{"issue_key": "AMQCPP-504", "project": "AMQCPP", "title": "Add support for ActiveMQ Discovery Agents", "status": "Resolved", "reporter": "Francisco Facioni", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-07-31T21:57:18.000+0000", "updated": "2015-07-16T16:35:54.000+0000", "description": "Zeroconf transport would be really useful.", "comments": [], "text": "Add support for ActiveMQ Discovery Agents\n\nDescription:\nZeroconf transport would be really useful.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for ActiveMQ Discovery Agents\n\nDescription:\nZeroconf transport would be really useful.\n\nComments:\n", "classification": "Classify the issue 'Add support for ActiveMQ Discovery Agents' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-504?\nA: Zeroconf transport would be really useful."}}
{"issue_key": "AMQCPP-503", "project": "AMQCPP", "title": "JMSXDeliveryCount isn't correct if a message is received by a another consumer", "status": "Closed", "reporter": "Andrei Gheorghe", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2013-07-24T07:07:33.000+0000", "updated": "2013-07-25T16:12:12.000+0000", "description": "Everytime a message is redelivered for the same consumer the property is increased by one which is correct but if a second consumer gets the same message, the property is set to 1, for the third consumer it's 2 and so on.", "comments": [], "text": "JMSXDeliveryCount isn't correct if a message is received by a another consumer\n\nDescription:\nEverytime a message is redelivered for the same consumer the property is increased by one which is correct but if a second consumer gets the same message, the property is set to 1, for the third consumer it's 2 and so on. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: JMSXDeliveryCount isn't correct if a message is received by a another consumer\n\nDescription:\nEverytime a message is redelivered for the same consumer the property is increased by one which is correct but if a second consumer gets the same message, the property is set to 1, for the third consumer it's 2 and so on. \n\nComments:\n", "classification": "Classify the issue 'JMSXDeliveryCount isn't correct if a message is received by a another consumer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-503?\nA: Everytime a message is redelivered for the same consumer the property is increased by one which is correct but if a second consumer gets the same message, the property is set to 1, for the third consumer it's 2 and so on. "}}
{"issue_key": "AMQCPP-502", "project": "AMQCPP", "title": "Can't send to temporary queues created by name", "status": "Resolved", "reporter": "Thomas Krammer", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-07-22T13:19:50.000+0000", "updated": "2013-07-23T16:35:49.000+0000", "description": "I have a Java process and a C++ process communicating using ActiveMQ. For some messages the C++ process will produce big results which are sent in chunks in separate ByteMessages (very similar to ActiveMQInput/OutputStream). To receive these chunks the Java process generates a temporary queue and sends the name of the queue (result of getQueueName) to the C++ process. The C++ process then sends the ByteMessages to this temporary queue using this code:\n\n  std::string targetQueue = // get queue name sent by Java\n\n  session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n  queue = session->createQueue(targetQueue);\n  producer = session->createProducer(queue);\n  producer->setDeliveryMode(cms::DeliveryMode::PERSISTENT);\n\n  while(fillBuffer()) {\n    std::auto_ptr<cms::BytesMessage> blockMessage(session->createBytesMessage());\n    blockMessage->writeBytes(reinterpret_cast<unsigned char *>(buffer), 0, bc);\n    producer->send(blockMessage.get());\n  }\n\nOn the Java side I never receive the messages sent by C++ but I don't get any error from the C++ code either. When I change the Java code to create a regular queue instead of a temporary queue the code works fine.\n\nI had a look at the Java implementation of ActiveMQSession::createQueue and found that they have a special case handling for temporary queues that is missing from the C++ code. After adding this special case to the C++ implementation the code above works fine.", "comments": [], "text": "Can't send to temporary queues created by name\n\nDescription:\nI have a Java process and a C++ process communicating using ActiveMQ. For some messages the C++ process will produce big results which are sent in chunks in separate ByteMessages (very similar to ActiveMQInput/OutputStream). To receive these chunks the Java process generates a temporary queue and sends the name of the queue (result of getQueueName) to the C++ process. The C++ process then sends the ByteMessages to this temporary queue using this code:\n\n  std::string targetQueue = // get queue name sent by Java\n\n  session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n  queue = session->createQueue(targetQueue);\n  producer = session->createProducer(queue);\n  producer->setDeliveryMode(cms::DeliveryMode::PERSISTENT);\n\n  while(fillBuffer()) {\n    std::auto_ptr<cms::BytesMessage> blockMessage(session->createBytesMessage());\n    blockMessage->writeBytes(reinterpret_cast<unsigned char *>(buffer), 0, bc);\n    producer->send(blockMessage.get());\n  }\n\nOn the Java side I never receive the messages sent by C++ but I don't get any error from the C++ code either. When I change the Java code to create a regular queue instead of a temporary queue the code works fine.\n\nI had a look at the Java implementation of ActiveMQSession::createQueue and found that they have a special case handling for temporary queues that is missing from the C++ code. After adding this special case to the C++ implementation the code above works fine.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't send to temporary queues created by name\n\nDescription:\nI have a Java process and a C++ process communicating using ActiveMQ. For some messages the C++ process will produce big results which are sent in chunks in separate ByteMessages (very similar to ActiveMQInput/OutputStream). To receive these chunks the Java process generates a temporary queue and sends the name of the queue (result of getQueueName) to the C++ process. The C++ process then sends the ByteMessages to this temporary queue using this code:\n\n  std::string targetQueue = // get queue name sent by Java\n\n  session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n  queue = session->createQueue(targetQueue);\n  producer = session->createProducer(queue);\n  producer->setDeliveryMode(cms::DeliveryMode::PERSISTENT);\n\n  while(fillBuffer()) {\n    std::auto_ptr<cms::BytesMessage> blockMessage(session->createBytesMessage());\n    blockMessage->writeBytes(reinterpret_cast<unsigned char *>(buffer), 0, bc);\n    producer->send(blockMessage.get());\n  }\n\nOn the Java side I never receive the messages sent by C++ but I don't get any error from the C++ code either. When I change the Java code to create a regular queue instead of a temporary queue the code works fine.\n\nI had a look at the Java implementation of ActiveMQSession::createQueue and found that they have a special case handling for temporary queues that is missing from the C++ code. After adding this special case to the C++ implementation the code above works fine.\n\nComments:\n", "classification": "Classify the issue 'Can't send to temporary queues created by name' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-502?\nA: I have a Java process and a C++ process communicating using ActiveMQ. For some messages the C++ process will produce big results which are sent in chunks in separate ByteMessages (very similar to ActiveMQInput/OutputStream). To receive these chunks the Java process generates a temporary queue and sends the name of the queue (result of getQueueName) to the C++ process. The C++ process then sends th"}}
{"issue_key": "AMQCPP-501", "project": "AMQCPP", "title": "Consumers remain active after being deleted", "status": "Closed", "reporter": "Andrei Gheorghe", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2013-07-18T12:59:15.000+0000", "updated": "2013-07-19T13:47:05.000+0000", "description": "I'm not really sure if this is a problem or not. Deleting a consumer doesn't free all his prefetched messsages so they can't be consumed by another consumer and the number of consumers remains the same in the web interface. Calling close before deleting them solves the problem but I was expecting the destructor cu cleanup after itself.", "comments": [], "text": "Consumers remain active after being deleted\n\nDescription:\nI'm not really sure if this is a problem or not. Deleting a consumer doesn't free all his prefetched messsages so they can't be consumed by another consumer and the number of consumers remains the same in the web interface. Calling close before deleting them solves the problem but I was expecting the destructor cu cleanup after itself.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consumers remain active after being deleted\n\nDescription:\nI'm not really sure if this is a problem or not. Deleting a consumer doesn't free all his prefetched messsages so they can't be consumed by another consumer and the number of consumers remains the same in the web interface. Calling close before deleting them solves the problem but I was expecting the destructor cu cleanup after itself.\n\nComments:\n", "classification": "Classify the issue 'Consumers remain active after being deleted' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-501?\nA: I'm not really sure if this is a problem or not. Deleting a consumer doesn't free all his prefetched messsages so they can't be consumed by another consumer and the number of consumers remains the same in the web interface. Calling close before deleting them solves the problem but I was expecting the destructor cu cleanup after itself."}}
{"issue_key": "AMQCPP-500", "project": "AMQCPP", "title": "http://activemq.apache.org/cms/api.html contains obsolete links", "status": "Resolved", "reporter": "Martin Lichtin", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-07-16T08:58:40.000+0000", "updated": "2013-07-16T13:37:01.000+0000", "description": "Can you update http://activemq.apache.org/cms/api.html ?\nThe \"ActiveMQ-CPP API\" links are outdated.", "comments": [], "text": "http://activemq.apache.org/cms/api.html contains obsolete links\n\nDescription:\nCan you update http://activemq.apache.org/cms/api.html ?\nThe \"ActiveMQ-CPP API\" links are outdated.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: http://activemq.apache.org/cms/api.html contains obsolete links\n\nDescription:\nCan you update http://activemq.apache.org/cms/api.html ?\nThe \"ActiveMQ-CPP API\" links are outdated.\n\n\nComments:\n", "classification": "Classify the issue 'http://activemq.apache.org/cms/api.html contains obsolete links' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-500?\nA: Can you update http://activemq.apache.org/cms/api.html ?\nThe \"ActiveMQ-CPP API\" links are outdated.\n"}}
{"issue_key": "AMQCPP-499", "project": "AMQCPP", "title": "Mutex created as part of a static object causes runtime exception during destruction", "status": "Closed", "reporter": "Martin Lichtin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-07-02T09:14:05.000+0000", "updated": "2013-07-02T13:58:07.000+0000", "description": "A Mutex created as part of a static object causes runtime exception during destruction.\n\n (gdb) bt\n#0 0x000000397b0306f7 in kill () from /lib64/libc.so.6\n#1 0x00002b3a7f8d43c1 in EXsignal () from /ingres/I1/ingres/lib/libcompat.1.so\n#2 0x00002b3a7f8d3ffa in i_EXcatch () from /ingres/I1/ingres/lib/libcompat.1.so\n#3 <signal handler called>\n#4 apr_pvsprintf (pool=0x0, fmt=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", ap=0x7ffff8644e80) at memory/unix/apr_pools.c:1125\n#5 0x00002b3a7d791b3f in decaf::lang::Exception::buildMessage (this=0x2aaaac002da0, format=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", vargs=...) at decaf/lang/Exception.cpp:124\n#6 0x00002b3a7d7b2a0f in decaf::lang::exceptions::RuntimeException::RuntimeException (this=0x2aaaac002da0, file=0x2b3a7d89e360 \"decaf/internal/util/concurrent/unix/PlatformThread.cpp\", lineNumber=77, msg=0x2b3a7d89e50c \"Failed to Lock OS Mutex\")\n    at decaf/lang/exceptions/RuntimeException.cpp:51\n#7 0x00002b3a7d75dc0c in decaf::internal::util::concurrent::PlatformThread::lockMutex (mutex=0x6338650) at decaf/internal/util/concurrent/unix/PlatformThread.cpp:77\n#8 0x00002b3a7d758d06 in decaf::internal::util::concurrent::Threading::returnMonitor (monitor=0x61af4d0, alreadyLocked=false) at decaf/internal/util/concurrent/Threading.cpp:1496\n#9 0x00002b3a7d80553a in decaf::util::concurrent::Mutex::~Mutex (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:84\n#10 0x00002b3a7c578d67 in MyObject::~MyObject (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at MyObjectTrace.h:30\n#11 0x00002b3a7c578900 in __tcf_1 () at MyObjectTrace.cpp:45\n#12 0x000000397b03368e in __cxa_finalize () from /lib64/libc.so.6\n#13 0x00002b3a7c574916 in __do_global_dtors_aux () from libmylib.so\n#14 0x0000000000000000 in ?? ()\n(gdb)", "comments": [], "text": "Mutex created as part of a static object causes runtime exception during destruction\n\nDescription:\nA Mutex created as part of a static object causes runtime exception during destruction.\n\n (gdb) bt\n#0 0x000000397b0306f7 in kill () from /lib64/libc.so.6\n#1 0x00002b3a7f8d43c1 in EXsignal () from /ingres/I1/ingres/lib/libcompat.1.so\n#2 0x00002b3a7f8d3ffa in i_EXcatch () from /ingres/I1/ingres/lib/libcompat.1.so\n#3 <signal handler called>\n#4 apr_pvsprintf (pool=0x0, fmt=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", ap=0x7ffff8644e80) at memory/unix/apr_pools.c:1125\n#5 0x00002b3a7d791b3f in decaf::lang::Exception::buildMessage (this=0x2aaaac002da0, format=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", vargs=...) at decaf/lang/Exception.cpp:124\n#6 0x00002b3a7d7b2a0f in decaf::lang::exceptions::RuntimeException::RuntimeException (this=0x2aaaac002da0, file=0x2b3a7d89e360 \"decaf/internal/util/concurrent/unix/PlatformThread.cpp\", lineNumber=77, msg=0x2b3a7d89e50c \"Failed to Lock OS Mutex\")\n    at decaf/lang/exceptions/RuntimeException.cpp:51\n#7 0x00002b3a7d75dc0c in decaf::internal::util::concurrent::PlatformThread::lockMutex (mutex=0x6338650) at decaf/internal/util/concurrent/unix/PlatformThread.cpp:77\n#8 0x00002b3a7d758d06 in decaf::internal::util::concurrent::Threading::returnMonitor (monitor=0x61af4d0, alreadyLocked=false) at decaf/internal/util/concurrent/Threading.cpp:1496\n#9 0x00002b3a7d80553a in decaf::util::concurrent::Mutex::~Mutex (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:84\n#10 0x00002b3a7c578d67 in MyObject::~MyObject (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at MyObjectTrace.h:30\n#11 0x00002b3a7c578900 in __tcf_1 () at MyObjectTrace.cpp:45\n#12 0x000000397b03368e in __cxa_finalize () from /lib64/libc.so.6\n#13 0x00002b3a7c574916 in __do_global_dtors_aux () from libmylib.so\n#14 0x0000000000000000 in ?? ()\n(gdb) \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Mutex created as part of a static object causes runtime exception during destruction\n\nDescription:\nA Mutex created as part of a static object causes runtime exception during destruction.\n\n (gdb) bt\n#0 0x000000397b0306f7 in kill () from /lib64/libc.so.6\n#1 0x00002b3a7f8d43c1 in EXsignal () from /ingres/I1/ingres/lib/libcompat.1.so\n#2 0x00002b3a7f8d3ffa in i_EXcatch () from /ingres/I1/ingres/lib/libcompat.1.so\n#3 <signal handler called>\n#4 apr_pvsprintf (pool=0x0, fmt=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", ap=0x7ffff8644e80) at memory/unix/apr_pools.c:1125\n#5 0x00002b3a7d791b3f in decaf::lang::Exception::buildMessage (this=0x2aaaac002da0, format=0x2b3a7d89e50c \"Failed to Lock OS Mutex\", vargs=...) at decaf/lang/Exception.cpp:124\n#6 0x00002b3a7d7b2a0f in decaf::lang::exceptions::RuntimeException::RuntimeException (this=0x2aaaac002da0, file=0x2b3a7d89e360 \"decaf/internal/util/concurrent/unix/PlatformThread.cpp\", lineNumber=77, msg=0x2b3a7d89e50c \"Failed to Lock OS Mutex\")\n    at decaf/lang/exceptions/RuntimeException.cpp:51\n#7 0x00002b3a7d75dc0c in decaf::internal::util::concurrent::PlatformThread::lockMutex (mutex=0x6338650) at decaf/internal/util/concurrent/unix/PlatformThread.cpp:77\n#8 0x00002b3a7d758d06 in decaf::internal::util::concurrent::Threading::returnMonitor (monitor=0x61af4d0, alreadyLocked=false) at decaf/internal/util/concurrent/Threading.cpp:1496\n#9 0x00002b3a7d80553a in decaf::util::concurrent::Mutex::~Mutex (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:84\n#10 0x00002b3a7c578d67 in MyObject::~MyObject (this=0x2b3a7c77ce80, __in_chrg=<value optimized out>) at MyObjectTrace.h:30\n#11 0x00002b3a7c578900 in __tcf_1 () at MyObjectTrace.cpp:45\n#12 0x000000397b03368e in __cxa_finalize () from /lib64/libc.so.6\n#13 0x00002b3a7c574916 in __do_global_dtors_aux () from libmylib.so\n#14 0x0000000000000000 in ?? ()\n(gdb) \n\nComments:\n", "classification": "Classify the issue 'Mutex created as part of a static object causes runtime exception during destruction' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-499?\nA: A Mutex created as part of a static object causes runtime exception during destruction.\n\n (gdb) bt\n#0 0x000000397b0306f7 in kill () from /lib64/libc.so.6\n#1 0x00002b3a7f8d43c1 in EXsignal () from /ingres/I1/ingres/lib/libcompat.1.so\n#2 0x00002b3a7f8d3ffa in i_EXcatch () from /ingres/I1/ingres/lib/libcompat.1.so\n#3 <signal handler called>\n#4 apr_pvsprintf (pool=0x0, fmt=0x2b3a7d89e50c \"Failed to Lo"}}
{"issue_key": "AMQCPP-498", "project": "AMQCPP", "title": "Client doesn't work on Linux Red Hat 6.4 systems, fails when setting thread priority", "status": "Resolved", "reporter": "John Rocha", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": ["decaf", "priority", "pthreads", "scheduling", "thread"], "created": "2013-06-28T23:26:25.000+0000", "updated": "2013-07-01T18:06:33.000+0000", "description": "Client doesn't work on Linux Red Hat 6.4 systems. It fails throwing the exception {panel}Failed to set new Therad priority to value: 18{panel}\n\nThis is coming from the file\n{{{color:brown}src/main/decaf/internal/util/concurrent/unix/PlatformThread.cpp{color}}}\nwhen it's creating a new thread.\n\n\nWe encountered this problem when we started running our code on a new operating system. It worked fine on Redhat 5.8 and SuSE SLES10, but then it started failing on Redhat 6.4.\n\n\nI did some digging and found a defect logged against the _+pthread+_ library at: http://sourceware.org/bugzilla/show_bug.cgi?id=10828.\n\n\n\n\n{panel}(This problem was found by analyzing a failure of LSB distribution compliance test, lsb-runtime, v. 4.0.2.)\n\nA relatively new change in $GITROOT/glibc/nptl/pthread_attr_setschedparam.c (2009-04-23 according to git) adds a check to pthread_attr_setschedparam() call whether the priority being set is compatible with the scheduling policy already set in the structure; if the priority is not in the prescribed range, it fails, generating the EINVAL error.\n\nThis check, although well intended, has a side effect that can break existing code (at least the LSB tests): it makes the process of initializing a pthread_attr structure order-dependent on Linux.\n\nAs Linux does not use the numeric priority for SCHED_OTHER, which is the default, and sched_get_priority_min() and sched_priority_max() return 0. Therefore:\n\nIf a programmer calls pthread_attr_init(), then pthread_attr_setschedpolicy() to set SCHED_RR or SCHED_FIFO, and then pthread_attr_setschedparam(), it works. But if the other way around (priority first, then scheduling policy), it fails for \"no apparent reason\".{panel}\n\n\n\nI did some debugging in the code and found that {{unix/PlatformThread.cpp}}'s method {{createNewThread()}} sets the scheduling priority but doesn't set the scheduling policy. And the default value for the scheduling policy is SCHED_OTHER(0) which only supports a priority value of 0.\n\n\nI have a proposed patch which:\n# validates the return values of all pthread calls and\n# only sets the priority iff the policy is sset to SCHED_FIFO or SCHED_RR\n\n\nGranted, we never set the policy so one could argue that we should just remove setting of the priority. However, I suspect that the true desire is to inherit the current threads scheduling value and set the priority based on that. So I anticipate tha future changes may actually set the policy. I didn't do this though.", "comments": [], "text": "Client doesn't work on Linux Red Hat 6.4 systems, fails when setting thread priority\n\nDescription:\nClient doesn't work on Linux Red Hat 6.4 systems. It fails throwing the exception {panel}Failed to set new Therad priority to value: 18{panel}\n\nThis is coming from the file\n{{{color:brown}src/main/decaf/internal/util/concurrent/unix/PlatformThread.cpp{color}}}\nwhen it's creating a new thread.\n\n\nWe encountered this problem when we started running our code on a new operating system. It worked fine on Redhat 5.8 and SuSE SLES10, but then it started failing on Redhat 6.4.\n\n\nI did some digging and found a defect logged against the _+pthread+_ library at: http://sourceware.org/bugzilla/show_bug.cgi?id=10828.\n\n\n\n\n{panel}(This problem was found by analyzing a failure of LSB distribution compliance test, lsb-runtime, v. 4.0.2.)\n\nA relatively new change in $GITROOT/glibc/nptl/pthread_attr_setschedparam.c (2009-04-23 according to git) adds a check to pthread_attr_setschedparam() call whether the priority being set is compatible with the scheduling policy already set in the structure; if the priority is not in the prescribed range, it fails, generating the EINVAL error.\n\nThis check, although well intended, has a side effect that can break existing code (at least the LSB tests): it makes the process of initializing a pthread_attr structure order-dependent on Linux.\n\nAs Linux does not use the numeric priority for SCHED_OTHER, which is the default, and sched_get_priority_min() and sched_priority_max() return 0. Therefore:\n\nIf a programmer calls pthread_attr_init(), then pthread_attr_setschedpolicy() to set SCHED_RR or SCHED_FIFO, and then pthread_attr_setschedparam(), it works. But if the other way around (priority first, then scheduling policy), it fails for \"no apparent reason\".{panel}\n\n\n\nI did some debugging in the code and found that {{unix/PlatformThread.cpp}}'s method {{createNewThread()}} sets the scheduling priority but doesn't set the scheduling policy. And the default value for the scheduling policy is SCHED_OTHER(0) which only supports a priority value of 0.\n\n\nI have a proposed patch which:\n# validates the return values of all pthread calls and\n# only sets the priority iff the policy is sset to SCHED_FIFO or SCHED_RR\n\n\nGranted, we never set the policy so one could argue that we should just remove setting of the priority. However, I suspect that the true desire is to inherit the current threads scheduling value and set the priority based on that. So I anticipate tha future changes may actually set the policy. I didn't do this though.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Client doesn't work on Linux Red Hat 6.4 systems, fails when setting thread priority\n\nDescription:\nClient doesn't work on Linux Red Hat 6.4 systems. It fails throwing the exception {panel}Failed to set new Therad priority to value: 18{panel}\n\nThis is coming from the file\n{{{color:brown}src/main/decaf/internal/util/concurrent/unix/PlatformThread.cpp{color}}}\nwhen it's creating a new thread.\n\n\nWe encountered this problem when we started running our code on a new operating system. It worked fine on Redhat 5.8 and SuSE SLES10, but then it started failing on Redhat 6.4.\n\n\nI did some digging and found a defect logged against the _+pthread+_ library at: http://sourceware.org/bugzilla/show_bug.cgi?id=10828.\n\n\n\n\n{panel}(This problem was found by analyzing a failure of LSB distribution compliance test, lsb-runtime, v. 4.0.2.)\n\nA relatively new change in $GITROOT/glibc/nptl/pthread_attr_setschedparam.c (2009-04-23 according to git) adds a check to pthread_attr_setschedparam() call whether the priority being set is compatible with the scheduling policy already set in the structure; if the priority is not in the prescribed range, it fails, generating the EINVAL error.\n\nThis check, although well intended, has a side effect that can break existing code (at least the LSB tests): it makes the process of initializing a pthread_attr structure order-dependent on Linux.\n\nAs Linux does not use the numeric priority for SCHED_OTHER, which is the default, and sched_get_priority_min() and sched_priority_max() return 0. Therefore:\n\nIf a programmer calls pthread_attr_init(), then pthread_attr_setschedpolicy() to set SCHED_RR or SCHED_FIFO, and then pthread_attr_setschedparam(), it works. But if the other way around (priority first, then scheduling policy), it fails for \"no apparent reason\".{panel}\n\n\n\nI did some debugging in the code and found that {{unix/PlatformThread.cpp}}'s method {{createNewThread()}} sets the scheduling priority but doesn't set the scheduling policy. And the default value for the scheduling policy is SCHED_OTHER(0) which only supports a priority value of 0.\n\n\nI have a proposed patch which:\n# validates the return values of all pthread calls and\n# only sets the priority iff the policy is sset to SCHED_FIFO or SCHED_RR\n\n\nGranted, we never set the policy so one could argue that we should just remove setting of the priority. However, I suspect that the true desire is to inherit the current threads scheduling value and set the priority based on that. So I anticipate tha future changes may actually set the policy. I didn't do this though.\n\n\nComments:\n", "classification": "Classify the issue 'Client doesn't work on Linux Red Hat 6.4 systems, fails when setting thread priority' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-498?\nA: Client doesn't work on Linux Red Hat 6.4 systems. It fails throwing the exception {panel}Failed to set new Therad priority to value: 18{panel}\n\nThis is coming from the file\n{{{color:brown}src/main/decaf/internal/util/concurrent/unix/PlatformThread.cpp{color}}}\nwhen it's creating a new thread.\n\n\nWe encountered this problem when we started running our code on a new operating system. It worked fine o"}}
{"issue_key": "AMQCPP-497", "project": "AMQCPP", "title": "Compilation of 3.7.0 fails for Linux systems (Redhat 5.8 and SuSE SLES 10)", "status": "Resolved", "reporter": "John Rocha", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["compile-error", "linux"], "created": "2013-06-28T21:20:14.000+0000", "updated": "2013-07-01T17:01:11.000+0000", "description": "Compilation of 3.7.0 fails for Linux systems (RedHat 5.8 and SuSE SLES 10)\n\nI found that even after applying the patch for AMQCPP-483, compilation of the 3.7.0 source base on Linux systems would still fail. I reproduced this problem on two diffent flavors of Linux. RedHat 5.8 and SuSE SLES10.\n\nThe failures are as follows:\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo \\-MD \\-MP \\-MF decaf/internal/util/.deps/libactivemq\\_cpp\\_la\\-HexStringParser.Tpo \\-c decaf/internal/util/HexStringParser.cpp  \\-fPIC \\-DPIC \\-o decaf/internal/util/.libs/libactivemq\\_cpp\\_la\\-HexStringParser.o\ndecaf/internal/util/HexStringParser.cpp:28:26: error: apr\\_strmatch.h: No such file or directory\nmake\\[3]: \\*\\*\\* \\[decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\nand\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo \\-MD \\-MP \\-MF decaf/util/.deps/libactivemq\\_cpp\\_la\\-UUID.Tpo \\-c decaf/util/UUID.cpp  \\-fPIC \\-DPIC \\-o decaf/util/.libs/libactivemq\\_cpp\\_la\\-UUID.o\ndecaf/util/UUID.cpp:112: error: integer constant is too large for 'long' type\ndecaf/util/UUID.cpp: In copy constructor 'decaf::util::UUID::UUID(const decaf::util::UUID&)':\ndecaf/util/UUID.cpp:151: warning: base class 'class decaf::lang::Comparable<decaf::util::UUID>' should be explicitly initialized in the copy constructor\nmake\\[3]: \\*\\*\\* \\[decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\n\n\nI've attached a patch file for what I think might be the fixes.\n\nFor the first I removed the inclusion of the file {{apr_strmatch.h}} as it comes from apr\\-util which according to [AMQCPP\\-469|https://issues.apache.org/jira/browse/AMQCPP\\-469] is no longer needed. Moreover, compilation works even with it's removal.\n\nFor the second I changed the casting from L to LL.", "comments": [], "text": "Compilation of 3.7.0 fails for Linux systems (Redhat 5.8 and SuSE SLES 10)\n\nDescription:\nCompilation of 3.7.0 fails for Linux systems (RedHat 5.8 and SuSE SLES 10)\n\nI found that even after applying the patch for AMQCPP-483, compilation of the 3.7.0 source base on Linux systems would still fail. I reproduced this problem on two diffent flavors of Linux. RedHat 5.8 and SuSE SLES10.\n\nThe failures are as follows:\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo \\-MD \\-MP \\-MF decaf/internal/util/.deps/libactivemq\\_cpp\\_la\\-HexStringParser.Tpo \\-c decaf/internal/util/HexStringParser.cpp  \\-fPIC \\-DPIC \\-o decaf/internal/util/.libs/libactivemq\\_cpp\\_la\\-HexStringParser.o\ndecaf/internal/util/HexStringParser.cpp:28:26: error: apr\\_strmatch.h: No such file or directory\nmake\\[3]: \\*\\*\\* \\[decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\nand\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo \\-MD \\-MP \\-MF decaf/util/.deps/libactivemq\\_cpp\\_la\\-UUID.Tpo \\-c decaf/util/UUID.cpp  \\-fPIC \\-DPIC \\-o decaf/util/.libs/libactivemq\\_cpp\\_la\\-UUID.o\ndecaf/util/UUID.cpp:112: error: integer constant is too large for 'long' type\ndecaf/util/UUID.cpp: In copy constructor 'decaf::util::UUID::UUID(const decaf::util::UUID&)':\ndecaf/util/UUID.cpp:151: warning: base class 'class decaf::lang::Comparable<decaf::util::UUID>' should be explicitly initialized in the copy constructor\nmake\\[3]: \\*\\*\\* \\[decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\n\n\nI've attached a patch file for what I think might be the fixes.\n\nFor the first I removed the inclusion of the file {{apr_strmatch.h}} as it comes from apr\\-util which according to [AMQCPP\\-469|https://issues.apache.org/jira/browse/AMQCPP\\-469] is no longer needed. Moreover, compilation works even with it's removal.\n\nFor the second I changed the casting from L to LL.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation of 3.7.0 fails for Linux systems (Redhat 5.8 and SuSE SLES 10)\n\nDescription:\nCompilation of 3.7.0 fails for Linux systems (RedHat 5.8 and SuSE SLES 10)\n\nI found that even after applying the patch for AMQCPP-483, compilation of the 3.7.0 source base on Linux systems would still fail. I reproduced this problem on two diffent flavors of Linux. RedHat 5.8 and SuSE SLES10.\n\nThe failures are as follows:\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo \\-MD \\-MP \\-MF decaf/internal/util/.deps/libactivemq\\_cpp\\_la\\-HexStringParser.Tpo \\-c decaf/internal/util/HexStringParser.cpp  \\-fPIC \\-DPIC \\-o decaf/internal/util/.libs/libactivemq\\_cpp\\_la\\-HexStringParser.o\ndecaf/internal/util/HexStringParser.cpp:28:26: error: apr\\_strmatch.h: No such file or directory\nmake\\[3]: \\*\\*\\* \\[decaf/internal/util/libactivemq\\_cpp\\_la\\-HexStringParser.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\nand\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-pedantic \\-DLINUX=2 \\-D\\_REENTRANT \\-D\\_GNU\\_SOURCE \\-D\\_LARGEFILE64\\_SOURCE \\-I/views/LU\\-7.2\\-AMQ\\-3.7.1/server/gpl/apr\\-1.4.2\\-src/BUILD\\_DIR\\_RhatFive0206\\-i686\\-gnu0401/include/apr\\-1 \\-I/usr/kerberos/include \\-W \\-Wall \\-Wextra \\-Wconversion \\-fPIC \\-fstrict\\-aliasing \\-Wstrict\\-aliasing=2 \\-Wno\\-long\\-long \\-g \\-O2 \\-pthread \\-MT decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo \\-MD \\-MP \\-MF decaf/util/.deps/libactivemq\\_cpp\\_la\\-UUID.Tpo \\-c decaf/util/UUID.cpp  \\-fPIC \\-DPIC \\-o decaf/util/.libs/libactivemq\\_cpp\\_la\\-UUID.o\ndecaf/util/UUID.cpp:112: error: integer constant is too large for 'long' type\ndecaf/util/UUID.cpp: In copy constructor 'decaf::util::UUID::UUID(const decaf::util::UUID&)':\ndecaf/util/UUID.cpp:151: warning: base class 'class decaf::lang::Comparable<decaf::util::UUID>' should be explicitly initialized in the copy constructor\nmake\\[3]: \\*\\*\\* \\[decaf/util/libactivemq\\_cpp\\_la\\-UUID.lo] Error 1\nmake\\[2]: \\*\\*\\* \\[all\\-recursive] Error 1\nmake\\[1]: \\*\\*\\* \\[all] Error 2\nmake: \\*\\*\\* \\[os\\_release] Error 2\n{panel}\n\n\n\n\nI've attached a patch file for what I think might be the fixes.\n\nFor the first I removed the inclusion of the file {{apr_strmatch.h}} as it comes from apr\\-util which according to [AMQCPP\\-469|https://issues.apache.org/jira/browse/AMQCPP\\-469] is no longer needed. Moreover, compilation works even with it's removal.\n\nFor the second I changed the casting from L to LL.\n\nComments:\n", "classification": "Classify the issue 'Compilation of 3.7.0 fails for Linux systems (Redhat 5.8 and SuSE SLES 10)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-497?\nA: Compilation of 3.7.0 fails for Linux systems (RedHat 5.8 and SuSE SLES 10)\n\nI found that even after applying the patch for AMQCPP-483, compilation of the 3.7.0 source base on Linux systems would still fail. I reproduced this problem on two diffent flavors of Linux. RedHat 5.8 and SuSE SLES10.\n\nThe failures are as follows:\n\n{panel}\nlibtool: compile:  g\\+\\+ \\-DHAVE\\_CONFIG\\_H \\-I. \\-I../.. \\-ansi \\-"}}
{"issue_key": "AMQCPP-496", "project": "AMQCPP", "title": "Number Of Connections Limited By DECAF_MAX_TLS_SLOTS in ThreadingTypes.h", "status": "Closed", "reporter": "Kevin Urciolo", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-06-27T20:00:44.000+0000", "updated": "2018-11-15T19:28:45.000+0000", "description": "#define DECAF_MAX_TLS_SLOTS 256 in ThreadTypes.h seems to impose a limit of 51 connections for a CMS client on our systems because of its use with threading.  We would like to request this number be increased a larger value, such as 1536, to allow a client to maintain additional connections.", "comments": [], "text": "Number Of Connections Limited By DECAF_MAX_TLS_SLOTS in ThreadingTypes.h\n\nDescription:\n#define DECAF_MAX_TLS_SLOTS 256 in ThreadTypes.h seems to impose a limit of 51 connections for a CMS client on our systems because of its use with threading.  We would like to request this number be increased a larger value, such as 1536, to allow a client to maintain additional connections.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Number Of Connections Limited By DECAF_MAX_TLS_SLOTS in ThreadingTypes.h\n\nDescription:\n#define DECAF_MAX_TLS_SLOTS 256 in ThreadTypes.h seems to impose a limit of 51 connections for a CMS client on our systems because of its use with threading.  We would like to request this number be increased a larger value, such as 1536, to allow a client to maintain additional connections.\n\nComments:\n", "classification": "Classify the issue 'Number Of Connections Limited By DECAF_MAX_TLS_SLOTS in ThreadingTypes.h' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-496?\nA: #define DECAF_MAX_TLS_SLOTS 256 in ThreadTypes.h seems to impose a limit of 51 connections for a CMS client on our systems because of its use with threading.  We would like to request this number be increased a larger value, such as 1536, to allow a client to maintain additional connections."}}
{"issue_key": "AMQCPP-495", "project": "AMQCPP", "title": "CPP clients support IPv6 and ssl transportation through http/socks(4or5) proxy", "status": "Closed", "reporter": "Kimi Wu", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-06-20T05:47:04.000+0000", "updated": "2016-10-10T12:57:59.000+0000", "description": "1. ActiveMQ broker supports IPv6 protocol. But current ActiveMQ-CPP clients don't. My partner and I modified ActiveMQ-CPP 3.4.5 to support IPv6.\n\n2. In some cases activemq-cpp clients have to connect to activemq through a proxy. But current tcp/ssl transport does not provide this functionality.\nMy partner and I modified ActiveMQ-CPP 3.4.5 to enable SSL transport to support http/socks4/socks5 proxy.\n\n3. In some cases the certification of ActiveMQ broker can't be regenerated. However, ActiveMQ-CPP clients need the \"commonName\" field in the certification matches the server host name. My partner and I modified ActiveMQ-CPP 3.4.5 to overwrite the server host name.\n\n*******************************************\nWhat is changed:\nA local patched ActiveMQ-CPP, based on 3.4.5, \nwhich supports IPv6 and Http / Socks 4 / Socks 5 proxy for SSL transport.\n\nProxy usgae:\nTo enable proxy for SSL transport, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.proxyType     values:http/socks4/socks5\ndecaf.net.ssl.proxyHost     proxy address\ndecaf.net.ssl.proxyPort     proxy port\ndecaf.net.ssl.proxyUser     proxy user name\ndecaf.net.ssl.proxyPassword proxy password\n\n\nOverwriting server host name usage:\nTo overwrite the field, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.serverName    the name matched \"CommonName\" field\n\nsource: ipv6_proxy.patch\n\n*******************************************", "comments": [], "text": "CPP clients support IPv6 and ssl transportation through http/socks(4or5) proxy\n\nDescription:\n1. ActiveMQ broker supports IPv6 protocol. But current ActiveMQ-CPP clients don't. My partner and I modified ActiveMQ-CPP 3.4.5 to support IPv6.\n\n2. In some cases activemq-cpp clients have to connect to activemq through a proxy. But current tcp/ssl transport does not provide this functionality.\nMy partner and I modified ActiveMQ-CPP 3.4.5 to enable SSL transport to support http/socks4/socks5 proxy.\n\n3. In some cases the certification of ActiveMQ broker can't be regenerated. However, ActiveMQ-CPP clients need the \"commonName\" field in the certification matches the server host name. My partner and I modified ActiveMQ-CPP 3.4.5 to overwrite the server host name.\n\n*******************************************\nWhat is changed:\nA local patched ActiveMQ-CPP, based on 3.4.5, \nwhich supports IPv6 and Http / Socks 4 / Socks 5 proxy for SSL transport.\n\nProxy usgae:\nTo enable proxy for SSL transport, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.proxyType     values:http/socks4/socks5\ndecaf.net.ssl.proxyHost     proxy address\ndecaf.net.ssl.proxyPort     proxy port\ndecaf.net.ssl.proxyUser     proxy user name\ndecaf.net.ssl.proxyPassword proxy password\n\n\nOverwriting server host name usage:\nTo overwrite the field, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.serverName    the name matched \"CommonName\" field\n\nsource: ipv6_proxy.patch\n\n*******************************************\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CPP clients support IPv6 and ssl transportation through http/socks(4or5) proxy\n\nDescription:\n1. ActiveMQ broker supports IPv6 protocol. But current ActiveMQ-CPP clients don't. My partner and I modified ActiveMQ-CPP 3.4.5 to support IPv6.\n\n2. In some cases activemq-cpp clients have to connect to activemq through a proxy. But current tcp/ssl transport does not provide this functionality.\nMy partner and I modified ActiveMQ-CPP 3.4.5 to enable SSL transport to support http/socks4/socks5 proxy.\n\n3. In some cases the certification of ActiveMQ broker can't be regenerated. However, ActiveMQ-CPP clients need the \"commonName\" field in the certification matches the server host name. My partner and I modified ActiveMQ-CPP 3.4.5 to overwrite the server host name.\n\n*******************************************\nWhat is changed:\nA local patched ActiveMQ-CPP, based on 3.4.5, \nwhich supports IPv6 and Http / Socks 4 / Socks 5 proxy for SSL transport.\n\nProxy usgae:\nTo enable proxy for SSL transport, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.proxyType     values:http/socks4/socks5\ndecaf.net.ssl.proxyHost     proxy address\ndecaf.net.ssl.proxyPort     proxy port\ndecaf.net.ssl.proxyUser     proxy user name\ndecaf.net.ssl.proxyPassword proxy password\n\n\nOverwriting server host name usage:\nTo overwrite the field, use these system properties \n\nproperty comments\n----------------------------------------------------------------\ndecaf.net.ssl.serverName    the name matched \"CommonName\" field\n\nsource: ipv6_proxy.patch\n\n*******************************************\n\nComments:\n", "classification": "Classify the issue 'CPP clients support IPv6 and ssl transportation through http/socks(4or5) proxy' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-495?\nA: 1. ActiveMQ broker supports IPv6 protocol. But current ActiveMQ-CPP clients don't. My partner and I modified ActiveMQ-CPP 3.4.5 to support IPv6.\n\n2. In some cases activemq-cpp clients have to connect to activemq through a proxy. But current tcp/ssl transport does not provide this functionality.\nMy partner and I modified ActiveMQ-CPP 3.4.5 to enable SSL transport to support http/socks4/socks5 proxy"}}
{"issue_key": "AMQCPP-494", "project": "AMQCPP", "title": "Commiting a session with a deleted consumer causes access violation", "status": "Resolved", "reporter": "Andrei Gheorghe", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-06-19T14:02:21.000+0000", "updated": "2013-07-02T00:38:29.000+0000", "description": "I'm not sure if this is a bug or if I'm using the library wrong.\nThe attached test file will cause an access violation error when trying to commit the session.", "comments": [], "text": "Commiting a session with a deleted consumer causes access violation\n\nDescription:\nI'm not sure if this is a bug or if I'm using the library wrong.\nThe attached test file will cause an access violation error when trying to commit the session.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Commiting a session with a deleted consumer causes access violation\n\nDescription:\nI'm not sure if this is a bug or if I'm using the library wrong.\nThe attached test file will cause an access violation error when trying to commit the session.\n\n\nComments:\n", "classification": "Classify the issue 'Commiting a session with a deleted consumer causes access violation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-494?\nA: I'm not sure if this is a bug or if I'm using the library wrong.\nThe attached test file will cause an access violation error when trying to commit the session.\n"}}
{"issue_key": "AMQCPP-493", "project": "AMQCPP", "title": "cannot compile on hpux", "status": "Closed", "reporter": "Massimo Cora'", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-06-17T10:00:01.000+0000", "updated": "2013-07-03T08:09:26.000+0000", "description": "I have ./configure and then make.\n\nThis is the error returned by the compiling process:\n\nMaking all in src/main\n        /bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE  -I/diap6/home/jaeco/dev-root/usr/include/apr-1   -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c -o decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo `test -f 'decaf/internal/util/concurrent/unix/PlatformThread.cpp' || echo './'`decaf/internal/util/concurrent/unix/PlatformThread.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE -I/diap6/home/jaeco/dev-root/usr/include/apr-1 -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c decaf/internal/util/concurrent/unix/PlatformThread.cpp  -fPIC -DPIC -o decaf/internal/util/concurrent/unix/.libs/libactivemq_cpp_la-PlatformThread.o\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp: In static member function 'static void decaf::internal::util::concurrent::PlatformThread::yeild()':\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp:450: error: 'pthread_yield' was not declared in this scope\n*** Error exit code 1\n\nStop.\n*** Error exit code 1\n\nStop.\n*** Error exit code 1", "comments": [], "text": "cannot compile on hpux\n\nDescription:\nI have ./configure and then make.\n\nThis is the error returned by the compiling process:\n\nMaking all in src/main\n        /bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE  -I/diap6/home/jaeco/dev-root/usr/include/apr-1   -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c -o decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo `test -f 'decaf/internal/util/concurrent/unix/PlatformThread.cpp' || echo './'`decaf/internal/util/concurrent/unix/PlatformThread.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE -I/diap6/home/jaeco/dev-root/usr/include/apr-1 -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c decaf/internal/util/concurrent/unix/PlatformThread.cpp  -fPIC -DPIC -o decaf/internal/util/concurrent/unix/.libs/libactivemq_cpp_la-PlatformThread.o\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp: In static member function 'static void decaf::internal::util::concurrent::PlatformThread::yeild()':\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp:450: error: 'pthread_yield' was not declared in this scope\n*** Error exit code 1\n\nStop.\n*** Error exit code 1\n\nStop.\n*** Error exit code 1\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: cannot compile on hpux\n\nDescription:\nI have ./configure and then make.\n\nThis is the error returned by the compiling process:\n\nMaking all in src/main\n        /bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE  -I/diap6/home/jaeco/dev-root/usr/include/apr-1   -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c -o decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo `test -f 'decaf/internal/util/concurrent/unix/PlatformThread.cpp' || echo './'`decaf/internal/util/concurrent/unix/PlatformThread.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE -I/diap6/home/jaeco/dev-root/usr/include/apr-1 -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/util/concurrent/unix/libactivemq_cpp_la-PlatformThread.lo -MD -MP -MF decaf/internal/util/concurrent/unix/.deps/libactivemq_cpp_la-PlatformThread.Tpo -c decaf/internal/util/concurrent/unix/PlatformThread.cpp  -fPIC -DPIC -o decaf/internal/util/concurrent/unix/.libs/libactivemq_cpp_la-PlatformThread.o\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp: In static member function 'static void decaf::internal::util::concurrent::PlatformThread::yeild()':\ndecaf/internal/util/concurrent/unix/PlatformThread.cpp:450: error: 'pthread_yield' was not declared in this scope\n*** Error exit code 1\n\nStop.\n*** Error exit code 1\n\nStop.\n*** Error exit code 1\n\n\n\nComments:\n", "classification": "Classify the issue 'cannot compile on hpux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-493?\nA: I have ./configure and then make.\n\nThis is the error returned by the compiling process:\n\nMaking all in src/main\n        /bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DHPUX11 -D_REENTRANT -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE  -I/diap6/home/jaeco/dev-root/usr/include/apr-1   -I/usr/local/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-al"}}
{"issue_key": "AMQCPP-492", "project": "AMQCPP", "title": "Seg fault in decaf::util::concurrent::Mutex::Mutex MutexProperties (memcpy)", "status": "Closed", "reporter": "Josh Schwartz", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-06-13T22:40:34.000+0000", "updated": "2016-03-17T15:57:04.000+0000", "description": "This happened during a failover test so it's likely that there were non-nominal things occurring such as connections being terminated abruptly.\n\nI looked at the release notes for 3.6.0 and 3.7.0 and I don't see a fix for this issue.\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\nMissing separate debuginfos, use: debuginfo-install apr-util-1.3.9-3.el6_0.1.x86_64 cyrus-sasl-lib-2.1.23-13.el6.x86_64 db4-4.7.25-17.el6.x86_64 expat-2.0.1-11.el6_2.x86_64 glibc-2.12-1.80.el6.x86_64 keyutils-libs-1.4-4.el6.x86_64 krb5-libs-1.9-33.el6.x86_64 libcom_err-1.41.12-12.el6.x86_64 libgcc-4.4.6-4.el6.x86_64 libselinux-2.0.94-5.3.el6.x86_64 libstdc++-4.4.6-4.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nspr-devel-4.9-1.el6.x86_64 nss-3.13.3-6.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64 nss-util-3.13.3-2.el6.x86_64 openssl-1.0.0-20.el6_2.5.x86_64 zlib-1.2.3-27.el6.x86_64\n(gdb) where\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\n#1  0x0000003ef489d1c6 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Rep::_M_clone(std::allocator<char> const&, unsigned long) () from /usr/lib64/libstdc++.so.6\n#2  0x0000003ef489d26c in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n   from /usr/lib64/libstdc++.so.6\n#3  0x000000000041d75a in std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n#4  0x00007f04aeb66a0b in MutexProperties (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:48\n#5  decaf::util::concurrent::Mutex::Mutex (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:72\n#6  0x00007f04ae7db9e0 in AbstractCollection (this=0x7f0398002530) at ./decaf/util/AbstractCollection.h:65\n#7  AbstractList (this=0x7f0398002530) at ./decaf/util/AbstractList.h:341\n#8  ArrayList (this=0x7f0398002530) at ./decaf/util/ArrayList.h:49\n#9  activemq::commands::ActiveMQDestination::ActiveMQDestination (this=0x7f0398002530)\n    at activemq/commands/ActiveMQDestination.cpp:74\n#10 0x00007f04ae827d49 in activemq::commands::ActiveMQTopic::ActiveMQTopic (this=0x7f0398002530)\n    at activemq/commands/ActiveMQTopic.cpp:26\n#11 0x00007f04aea7a15a in activemq::wireformat::openwire::marshal::generated::ActiveMQTopicMarshaller::createObject (this=<value optimized out>)\n    at activemq/wireformat/openwire/marshal/generated/ActiveMQTopicMarshaller.cpp:45\n#12 0x00007f04aea64c8b in activemq::wireformat::openwire::OpenWireFormat::tightUnmarshalNestedObject (\n    this=0x109ccf0, dis=0x109d0e0, bs=0x7f03aaf11b50) at activemq/wireformat/openwire/OpenWireFormat.cpp:400\n#13 0x00007f04aea6bccc in activemq::wireformat::openwire::marshal::BaseDataStreamMarshaller::tightUnmarshalCachedObject (this=<value optimized out>, wireFormat=<value optimized out>, dataIn=<value optimized out>,\n    bs=<value optimized out>) at activemq/wireformat/openwire/marshal/BaseDataStreamMarshaller.cpp:51\n#14 0x00007f04aea99c16 in activemq::wireformat::openwire::marshal::generated::MessageDispatchMarshaller::tightUnmarshal (this=0x1140910, wireFormat=0x109ccf0, dataStructure=<value optimized out>, dataIn=0x109d0e0,\n    bs=0x7f03aaf11b50) at activemq/wireformat/openwire/marshal/generated/MessageDispatchMarshaller.cpp:65\n#15 0x00007f04aea65bb1 in activemq::wireformat::openwire::OpenWireFormat::doUnmarshal (this=0x109ccf0,\n    dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:295\n#16 0x00007f04aea65fb7 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x109ccf0,\n    transport=<value optimized out>, dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:230\n#17 0x00007f04ae9c8350 in activemq::transport::IOTransport::run (this=0xf6d6f0)\n    at activemq/transport/IOTransport.cpp:247\n#18 0x00007f04aeafa84f in (anonymous namespace)::runCallback (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:262\n#19 0x00007f04aeafa5c4 in (anonymous namespace)::threadEntryMethod (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:250\n---Type <return> to continue, or q <return> to quit---\n#20 0x0000003eecc07851 in start_thread () from /lib64/libpthread.so.0\n#21 0x0000003eec8e767d in clone () from /lib64/libc.so.6", "comments": [], "text": "Seg fault in decaf::util::concurrent::Mutex::Mutex MutexProperties (memcpy)\n\nDescription:\nThis happened during a failover test so it's likely that there were non-nominal things occurring such as connections being terminated abruptly.\n\nI looked at the release notes for 3.6.0 and 3.7.0 and I don't see a fix for this issue.\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\nMissing separate debuginfos, use: debuginfo-install apr-util-1.3.9-3.el6_0.1.x86_64 cyrus-sasl-lib-2.1.23-13.el6.x86_64 db4-4.7.25-17.el6.x86_64 expat-2.0.1-11.el6_2.x86_64 glibc-2.12-1.80.el6.x86_64 keyutils-libs-1.4-4.el6.x86_64 krb5-libs-1.9-33.el6.x86_64 libcom_err-1.41.12-12.el6.x86_64 libgcc-4.4.6-4.el6.x86_64 libselinux-2.0.94-5.3.el6.x86_64 libstdc++-4.4.6-4.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nspr-devel-4.9-1.el6.x86_64 nss-3.13.3-6.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64 nss-util-3.13.3-2.el6.x86_64 openssl-1.0.0-20.el6_2.5.x86_64 zlib-1.2.3-27.el6.x86_64\n(gdb) where\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\n#1  0x0000003ef489d1c6 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Rep::_M_clone(std::allocator<char> const&, unsigned long) () from /usr/lib64/libstdc++.so.6\n#2  0x0000003ef489d26c in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n   from /usr/lib64/libstdc++.so.6\n#3  0x000000000041d75a in std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n#4  0x00007f04aeb66a0b in MutexProperties (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:48\n#5  decaf::util::concurrent::Mutex::Mutex (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:72\n#6  0x00007f04ae7db9e0 in AbstractCollection (this=0x7f0398002530) at ./decaf/util/AbstractCollection.h:65\n#7  AbstractList (this=0x7f0398002530) at ./decaf/util/AbstractList.h:341\n#8  ArrayList (this=0x7f0398002530) at ./decaf/util/ArrayList.h:49\n#9  activemq::commands::ActiveMQDestination::ActiveMQDestination (this=0x7f0398002530)\n    at activemq/commands/ActiveMQDestination.cpp:74\n#10 0x00007f04ae827d49 in activemq::commands::ActiveMQTopic::ActiveMQTopic (this=0x7f0398002530)\n    at activemq/commands/ActiveMQTopic.cpp:26\n#11 0x00007f04aea7a15a in activemq::wireformat::openwire::marshal::generated::ActiveMQTopicMarshaller::createObject (this=<value optimized out>)\n    at activemq/wireformat/openwire/marshal/generated/ActiveMQTopicMarshaller.cpp:45\n#12 0x00007f04aea64c8b in activemq::wireformat::openwire::OpenWireFormat::tightUnmarshalNestedObject (\n    this=0x109ccf0, dis=0x109d0e0, bs=0x7f03aaf11b50) at activemq/wireformat/openwire/OpenWireFormat.cpp:400\n#13 0x00007f04aea6bccc in activemq::wireformat::openwire::marshal::BaseDataStreamMarshaller::tightUnmarshalCachedObject (this=<value optimized out>, wireFormat=<value optimized out>, dataIn=<value optimized out>,\n    bs=<value optimized out>) at activemq/wireformat/openwire/marshal/BaseDataStreamMarshaller.cpp:51\n#14 0x00007f04aea99c16 in activemq::wireformat::openwire::marshal::generated::MessageDispatchMarshaller::tightUnmarshal (this=0x1140910, wireFormat=0x109ccf0, dataStructure=<value optimized out>, dataIn=0x109d0e0,\n    bs=0x7f03aaf11b50) at activemq/wireformat/openwire/marshal/generated/MessageDispatchMarshaller.cpp:65\n#15 0x00007f04aea65bb1 in activemq::wireformat::openwire::OpenWireFormat::doUnmarshal (this=0x109ccf0,\n    dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:295\n#16 0x00007f04aea65fb7 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x109ccf0,\n    transport=<value optimized out>, dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:230\n#17 0x00007f04ae9c8350 in activemq::transport::IOTransport::run (this=0xf6d6f0)\n    at activemq/transport/IOTransport.cpp:247\n#18 0x00007f04aeafa84f in (anonymous namespace)::runCallback (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:262\n#19 0x00007f04aeafa5c4 in (anonymous namespace)::threadEntryMethod (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:250\n---Type <return> to continue, or q <return> to quit---\n#20 0x0000003eecc07851 in start_thread () from /lib64/libpthread.so.0\n#21 0x0000003eec8e767d in clone () from /lib64/libc.so.6\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Seg fault in decaf::util::concurrent::Mutex::Mutex MutexProperties (memcpy)\n\nDescription:\nThis happened during a failover test so it's likely that there were non-nominal things occurring such as connections being terminated abruptly.\n\nI looked at the release notes for 3.6.0 and 3.7.0 and I don't see a fix for this issue.\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\nMissing separate debuginfos, use: debuginfo-install apr-util-1.3.9-3.el6_0.1.x86_64 cyrus-sasl-lib-2.1.23-13.el6.x86_64 db4-4.7.25-17.el6.x86_64 expat-2.0.1-11.el6_2.x86_64 glibc-2.12-1.80.el6.x86_64 keyutils-libs-1.4-4.el6.x86_64 krb5-libs-1.9-33.el6.x86_64 libcom_err-1.41.12-12.el6.x86_64 libgcc-4.4.6-4.el6.x86_64 libselinux-2.0.94-5.3.el6.x86_64 libstdc++-4.4.6-4.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nspr-devel-4.9-1.el6.x86_64 nss-3.13.3-6.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64 nss-util-3.13.3-2.el6.x86_64 openssl-1.0.0-20.el6_2.5.x86_64 zlib-1.2.3-27.el6.x86_64\n(gdb) where\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\n#1  0x0000003ef489d1c6 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Rep::_M_clone(std::allocator<char> const&, unsigned long) () from /usr/lib64/libstdc++.so.6\n#2  0x0000003ef489d26c in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n   from /usr/lib64/libstdc++.so.6\n#3  0x000000000041d75a in std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n#4  0x00007f04aeb66a0b in MutexProperties (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:48\n#5  decaf::util::concurrent::Mutex::Mutex (this=<value optimized out>) at decaf/util/concurrent/Mutex.cpp:72\n#6  0x00007f04ae7db9e0 in AbstractCollection (this=0x7f0398002530) at ./decaf/util/AbstractCollection.h:65\n#7  AbstractList (this=0x7f0398002530) at ./decaf/util/AbstractList.h:341\n#8  ArrayList (this=0x7f0398002530) at ./decaf/util/ArrayList.h:49\n#9  activemq::commands::ActiveMQDestination::ActiveMQDestination (this=0x7f0398002530)\n    at activemq/commands/ActiveMQDestination.cpp:74\n#10 0x00007f04ae827d49 in activemq::commands::ActiveMQTopic::ActiveMQTopic (this=0x7f0398002530)\n    at activemq/commands/ActiveMQTopic.cpp:26\n#11 0x00007f04aea7a15a in activemq::wireformat::openwire::marshal::generated::ActiveMQTopicMarshaller::createObject (this=<value optimized out>)\n    at activemq/wireformat/openwire/marshal/generated/ActiveMQTopicMarshaller.cpp:45\n#12 0x00007f04aea64c8b in activemq::wireformat::openwire::OpenWireFormat::tightUnmarshalNestedObject (\n    this=0x109ccf0, dis=0x109d0e0, bs=0x7f03aaf11b50) at activemq/wireformat/openwire/OpenWireFormat.cpp:400\n#13 0x00007f04aea6bccc in activemq::wireformat::openwire::marshal::BaseDataStreamMarshaller::tightUnmarshalCachedObject (this=<value optimized out>, wireFormat=<value optimized out>, dataIn=<value optimized out>,\n    bs=<value optimized out>) at activemq/wireformat/openwire/marshal/BaseDataStreamMarshaller.cpp:51\n#14 0x00007f04aea99c16 in activemq::wireformat::openwire::marshal::generated::MessageDispatchMarshaller::tightUnmarshal (this=0x1140910, wireFormat=0x109ccf0, dataStructure=<value optimized out>, dataIn=0x109d0e0,\n    bs=0x7f03aaf11b50) at activemq/wireformat/openwire/marshal/generated/MessageDispatchMarshaller.cpp:65\n#15 0x00007f04aea65bb1 in activemq::wireformat::openwire::OpenWireFormat::doUnmarshal (this=0x109ccf0,\n    dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:295\n#16 0x00007f04aea65fb7 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x109ccf0,\n    transport=<value optimized out>, dis=0x109d0e0) at activemq/wireformat/openwire/OpenWireFormat.cpp:230\n#17 0x00007f04ae9c8350 in activemq::transport::IOTransport::run (this=0xf6d6f0)\n    at activemq/transport/IOTransport.cpp:247\n#18 0x00007f04aeafa84f in (anonymous namespace)::runCallback (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:262\n#19 0x00007f04aeafa5c4 in (anonymous namespace)::threadEntryMethod (arg=0x13afa20)\n    at decaf/internal/util/concurrent/Threading.cpp:250\n---Type <return> to continue, or q <return> to quit---\n#20 0x0000003eecc07851 in start_thread () from /lib64/libpthread.so.0\n#21 0x0000003eec8e767d in clone () from /lib64/libc.so.6\n\nComments:\n", "classification": "Classify the issue 'Seg fault in decaf::util::concurrent::Mutex::Mutex MutexProperties (memcpy)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-492?\nA: This happened during a failover test so it's likely that there were non-nominal things occurring such as connections being terminated abruptly.\n\nI looked at the release notes for 3.6.0 and 3.7.0 and I don't see a fix for this issue.\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003eec888ea3 in memcpy () from /lib64/libc.so.6\nMissing separate debuginfos, use: debuginfo-install a"}}
{"issue_key": "AMQCPP-491", "project": "AMQCPP", "title": "Connection didn't switch to the slave broker when the master broker is down", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-06-13T18:11:15.000+0000", "updated": "2013-06-13T18:51:05.000+0000", "description": "Master/Slave configuration with a shared data directory:\nActiveMQ Configuration (activemq.xml):\n<persistenceAdapter>\n  <kahaDB directory=\"\\\\host1\\kahadb\"/>\n</persistenceAdapter>\n\nURL:\nfailover:(tcp://host1:port1,tcp://host2:port2)?randomize=false\n\nTest case:\n1) Run ActiveMQ on host2, it becomes the master\n2) Run ActiveMQ on host1, it becomes the slave\n3) Run a program that opens an ActiveMQ connection with the url\n4) Shutdown ActiveMQ on host2\n5) The ActiveMQ connection is not able to switch to host1.\n\nExplanation:\nThe test case has randomize=false to be able to reproduce the problem anytime. If randomize=true, the problem occurs randomly.\n\nAt step 3, ActiveMQ-CPP tries to open first a connection with host1. It fails as host1 is the slave. Then it tries to open a connection with host2. This time, it succeeds but it forgets to put back the failure hosts (host1) to the broker list. At this point, the broker list = (host2).\n\nAt step 5, ActiveMQ-CPP tries to open a connection with the broker list. As the broker list = (host2), it will try to open a connection only with host2.", "comments": [], "text": "Connection didn't switch to the slave broker when the master broker is down\n\nDescription:\nMaster/Slave configuration with a shared data directory:\nActiveMQ Configuration (activemq.xml):\n<persistenceAdapter>\n  <kahaDB directory=\"\\\\host1\\kahadb\"/>\n</persistenceAdapter>\n\nURL:\nfailover:(tcp://host1:port1,tcp://host2:port2)?randomize=false\n\nTest case:\n1) Run ActiveMQ on host2, it becomes the master\n2) Run ActiveMQ on host1, it becomes the slave\n3) Run a program that opens an ActiveMQ connection with the url\n4) Shutdown ActiveMQ on host2\n5) The ActiveMQ connection is not able to switch to host1.\n\nExplanation:\nThe test case has randomize=false to be able to reproduce the problem anytime. If randomize=true, the problem occurs randomly.\n\nAt step 3, ActiveMQ-CPP tries to open first a connection with host1. It fails as host1 is the slave. Then it tries to open a connection with host2. This time, it succeeds but it forgets to put back the failure hosts (host1) to the broker list. At this point, the broker list = (host2).\n\nAt step 5, ActiveMQ-CPP tries to open a connection with the broker list. As the broker list = (host2), it will try to open a connection only with host2.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Connection didn't switch to the slave broker when the master broker is down\n\nDescription:\nMaster/Slave configuration with a shared data directory:\nActiveMQ Configuration (activemq.xml):\n<persistenceAdapter>\n  <kahaDB directory=\"\\\\host1\\kahadb\"/>\n</persistenceAdapter>\n\nURL:\nfailover:(tcp://host1:port1,tcp://host2:port2)?randomize=false\n\nTest case:\n1) Run ActiveMQ on host2, it becomes the master\n2) Run ActiveMQ on host1, it becomes the slave\n3) Run a program that opens an ActiveMQ connection with the url\n4) Shutdown ActiveMQ on host2\n5) The ActiveMQ connection is not able to switch to host1.\n\nExplanation:\nThe test case has randomize=false to be able to reproduce the problem anytime. If randomize=true, the problem occurs randomly.\n\nAt step 3, ActiveMQ-CPP tries to open first a connection with host1. It fails as host1 is the slave. Then it tries to open a connection with host2. This time, it succeeds but it forgets to put back the failure hosts (host1) to the broker list. At this point, the broker list = (host2).\n\nAt step 5, ActiveMQ-CPP tries to open a connection with the broker list. As the broker list = (host2), it will try to open a connection only with host2.\n\n\nComments:\n", "classification": "Classify the issue 'Connection didn't switch to the slave broker when the master broker is down' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-491?\nA: Master/Slave configuration with a shared data directory:\nActiveMQ Configuration (activemq.xml):\n<persistenceAdapter>\n  <kahaDB directory=\"\\\\host1\\kahadb\"/>\n</persistenceAdapter>\n\nURL:\nfailover:(tcp://host1:port1,tcp://host2:port2)?randomize=false\n\nTest case:\n1) Run ActiveMQ on host2, it becomes the master\n2) Run ActiveMQ on host1, it becomes the slave\n3) Run a program that opens an ActiveMQ connec"}}
{"issue_key": "AMQCPP-490", "project": "AMQCPP", "title": "Exception lifetime confusion can cause the application to crash", "status": "Resolved", "reporter": "Jonathan Fortier", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-06-13T02:53:48.000+0000", "updated": "2013-06-26T01:05:41.000+0000", "description": "In changeset #139775, the \"decaf::lang::Exception\" class changed its ownership policy for its std::exception cause. Before the changeset, Exception class would clone the cause, and after the change, the Exception class took ownership of the std::exception. \nHowever, many code paths still assume that the Exception class will clone the std::exception, which makes the application crash when a std::exception is thrown in their protected region.\nHere is a incomplete list of places in the code that makes this bad assumption (line numbers from version 3.7.0):\n-decaf\\util\\concurrent\\FutureTask.h, line 272\n-decaf\\util\\concurrent\\FutureTask.h, line 301\n-decaf\\util\\concurrent\\ThreadPoolExecutor.cpp, line 742\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 646\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 757\n-decaf\\internal\\net\\tcp\\TcpSocket.cpp, line 361\n\nNote that subclasses of Exception may also be affected, since they normally forward the cause to their parent. \nThe comments on many of those classes still wrongly indicates that the cause will be cloned. For example, the comments for Exception::Exception(const std::exception*) is inconsistent with the comments for Exception::initCause()\n\nAn easy way to reproduce the bug is to throw a std::exception from an onException callback, which should make the application crash.", "comments": [], "text": "Exception lifetime confusion can cause the application to crash\n\nDescription:\nIn changeset #139775, the \"decaf::lang::Exception\" class changed its ownership policy for its std::exception cause. Before the changeset, Exception class would clone the cause, and after the change, the Exception class took ownership of the std::exception. \nHowever, many code paths still assume that the Exception class will clone the std::exception, which makes the application crash when a std::exception is thrown in their protected region.\nHere is a incomplete list of places in the code that makes this bad assumption (line numbers from version 3.7.0):\n-decaf\\util\\concurrent\\FutureTask.h, line 272\n-decaf\\util\\concurrent\\FutureTask.h, line 301\n-decaf\\util\\concurrent\\ThreadPoolExecutor.cpp, line 742\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 646\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 757\n-decaf\\internal\\net\\tcp\\TcpSocket.cpp, line 361\n\nNote that subclasses of Exception may also be affected, since they normally forward the cause to their parent. \nThe comments on many of those classes still wrongly indicates that the cause will be cloned. For example, the comments for Exception::Exception(const std::exception*) is inconsistent with the comments for Exception::initCause()\n\nAn easy way to reproduce the bug is to throw a std::exception from an onException callback, which should make the application crash.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception lifetime confusion can cause the application to crash\n\nDescription:\nIn changeset #139775, the \"decaf::lang::Exception\" class changed its ownership policy for its std::exception cause. Before the changeset, Exception class would clone the cause, and after the change, the Exception class took ownership of the std::exception. \nHowever, many code paths still assume that the Exception class will clone the std::exception, which makes the application crash when a std::exception is thrown in their protected region.\nHere is a incomplete list of places in the code that makes this bad assumption (line numbers from version 3.7.0):\n-decaf\\util\\concurrent\\FutureTask.h, line 272\n-decaf\\util\\concurrent\\FutureTask.h, line 301\n-decaf\\util\\concurrent\\ThreadPoolExecutor.cpp, line 742\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 646\n-activemq\\core\\ActiveMQTransactionContext.cpp, line 757\n-decaf\\internal\\net\\tcp\\TcpSocket.cpp, line 361\n\nNote that subclasses of Exception may also be affected, since they normally forward the cause to their parent. \nThe comments on many of those classes still wrongly indicates that the cause will be cloned. For example, the comments for Exception::Exception(const std::exception*) is inconsistent with the comments for Exception::initCause()\n\nAn easy way to reproduce the bug is to throw a std::exception from an onException callback, which should make the application crash.\n\n\nComments:\n", "classification": "Classify the issue 'Exception lifetime confusion can cause the application to crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-490?\nA: In changeset #139775, the \"decaf::lang::Exception\" class changed its ownership policy for its std::exception cause. Before the changeset, Exception class would clone the cause, and after the change, the Exception class took ownership of the std::exception. \nHowever, many code paths still assume that the Exception class will clone the std::exception, which makes the application crash when a std::ex"}}
{"issue_key": "AMQCPP-489", "project": "AMQCPP", "title": "Compilation Error Fix for Sun Studio under Solaris 10", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2013-06-11T05:47:53.000+0000", "updated": "2013-06-11T15:22:30.000+0000", "description": "Some errors affect the compilation of the library under Solaris 10 with Sun Studio", "comments": [], "text": "Compilation Error Fix for Sun Studio under Solaris 10\n\nDescription:\nSome errors affect the compilation of the library under Solaris 10 with Sun Studio\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation Error Fix for Sun Studio under Solaris 10\n\nDescription:\nSome errors affect the compilation of the library under Solaris 10 with Sun Studio\n\nComments:\n", "classification": "Classify the issue 'Compilation Error Fix for Sun Studio under Solaris 10' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-489?\nA: Some errors affect the compilation of the library under Solaris 10 with Sun Studio"}}
{"issue_key": "AMQCPP-488", "project": "AMQCPP", "title": "closing a connection stalled in start because of failover should stop the transport safely. ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-06-10T20:54:15.000+0000", "updated": "2013-06-10T20:55:44.000+0000", "description": "Closing a Connection when its stalled waiting to connect should safely shutdown the transports and allow the client app to terminate cleanly.", "comments": [], "text": "closing a connection stalled in start because of failover should stop the transport safely. \n\nDescription:\nClosing a Connection when its stalled waiting to connect should safely shutdown the transports and allow the client app to terminate cleanly. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: closing a connection stalled in start because of failover should stop the transport safely. \n\nDescription:\nClosing a Connection when its stalled waiting to connect should safely shutdown the transports and allow the client app to terminate cleanly. \n\nComments:\n", "classification": "Classify the issue 'closing a connection stalled in start because of failover should stop the transport safely. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-488?\nA: Closing a Connection when its stalled waiting to connect should safely shutdown the transports and allow the client app to terminate cleanly. "}}
{"issue_key": "AMQCPP-487", "project": "AMQCPP", "title": "CMS FailoverTransport Leaks Socket Descriptors", "status": "Resolved", "reporter": "Kevin Urciolo", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-06-10T18:48:19.000+0000", "updated": "2013-06-10T22:32:21.000+0000", "description": "See the discussion by following the link below.\n\nhttp://activemq.2283324.n4.nabble.com/CMS-3-6-Socket-Descriptor-Leak-With-Failover-td4667966.html\n\nThe FailoverTransport.cpp taskRunner includes the FailoverTransport and CloseTransports tasks.  The FailoverTransport is added first, and appears to always be pending.  This means the taskRunner always executes the iterate on the FailoverTransport and the CloseTransports tasks are never run, which causes a build up of socket descriptors (and threads).\n\nWe worked around the issue by adding the CloseTransportsTask to the taskRunner first.  This allows the CompositeTaskRunner to iterate the CloseTransportsTask when there is work, and then switching back to iterating the FailoverTransport.", "comments": [], "text": "CMS FailoverTransport Leaks Socket Descriptors\n\nDescription:\nSee the discussion by following the link below.\n\nhttp://activemq.2283324.n4.nabble.com/CMS-3-6-Socket-Descriptor-Leak-With-Failover-td4667966.html\n\nThe FailoverTransport.cpp taskRunner includes the FailoverTransport and CloseTransports tasks.  The FailoverTransport is added first, and appears to always be pending.  This means the taskRunner always executes the iterate on the FailoverTransport and the CloseTransports tasks are never run, which causes a build up of socket descriptors (and threads).\n\nWe worked around the issue by adding the CloseTransportsTask to the taskRunner first.  This allows the CompositeTaskRunner to iterate the CloseTransportsTask when there is work, and then switching back to iterating the FailoverTransport.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS FailoverTransport Leaks Socket Descriptors\n\nDescription:\nSee the discussion by following the link below.\n\nhttp://activemq.2283324.n4.nabble.com/CMS-3-6-Socket-Descriptor-Leak-With-Failover-td4667966.html\n\nThe FailoverTransport.cpp taskRunner includes the FailoverTransport and CloseTransports tasks.  The FailoverTransport is added first, and appears to always be pending.  This means the taskRunner always executes the iterate on the FailoverTransport and the CloseTransports tasks are never run, which causes a build up of socket descriptors (and threads).\n\nWe worked around the issue by adding the CloseTransportsTask to the taskRunner first.  This allows the CompositeTaskRunner to iterate the CloseTransportsTask when there is work, and then switching back to iterating the FailoverTransport.\n\nComments:\n", "classification": "Classify the issue 'CMS FailoverTransport Leaks Socket Descriptors' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-487?\nA: See the discussion by following the link below.\n\nhttp://activemq.2283324.n4.nabble.com/CMS-3-6-Socket-Descriptor-Leak-With-Failover-td4667966.html\n\nThe FailoverTransport.cpp taskRunner includes the FailoverTransport and CloseTransports tasks.  The FailoverTransport is added first, and appears to always be pending.  This means the taskRunner always executes the iterate on the FailoverTransport and "}}
{"issue_key": "AMQCPP-485", "project": "AMQCPP", "title": "APR-Util header include missed in latest release.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-28T15:22:14.000+0000", "updated": "2013-05-28T15:22:52.000+0000", "description": "File is still including an APR-Util header.", "comments": [], "text": "APR-Util header include missed in latest release.\n\nDescription:\nFile is still including an APR-Util header.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: APR-Util header include missed in latest release.\n\nDescription:\nFile is still including an APR-Util header.\n\nComments:\n", "classification": "Classify the issue 'APR-Util header include missed in latest release.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-485?\nA: File is still including an APR-Util header."}}
{"issue_key": "AMQCPP-484", "project": "AMQCPP", "title": "Can't connect via Stomp to Apollo broker - ActiveMq-Cpp version: 3.7.0", "status": "Closed", "reporter": "Mariana Monnerat", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-23T17:19:12.000+0000", "updated": "2013-05-29T11:15:53.000+0000", "description": "I'm using the version 3.7.0 from activemq-cpp and trying to connect with Stomp to Apollo. \n* I tested with version 3.7.0 from activemq-cpp Openwire Apollo - worked fine. \n* I tested with version 3.3.0 from activemq-cpp Stomp Apollo - worked fine \n\nThe version 3.7.0 doesn't work with Stomp Apollo!.", "comments": [], "text": "Can't connect via Stomp to Apollo broker - ActiveMq-Cpp version: 3.7.0\n\nDescription:\nI'm using the version 3.7.0 from activemq-cpp and trying to connect with Stomp to Apollo. \n* I tested with version 3.7.0 from activemq-cpp Openwire Apollo - worked fine. \n* I tested with version 3.3.0 from activemq-cpp Stomp Apollo - worked fine \n\nThe version 3.7.0 doesn't work with Stomp Apollo!.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't connect via Stomp to Apollo broker - ActiveMq-Cpp version: 3.7.0\n\nDescription:\nI'm using the version 3.7.0 from activemq-cpp and trying to connect with Stomp to Apollo. \n* I tested with version 3.7.0 from activemq-cpp Openwire Apollo - worked fine. \n* I tested with version 3.3.0 from activemq-cpp Stomp Apollo - worked fine \n\nThe version 3.7.0 doesn't work with Stomp Apollo!.\n\nComments:\n", "classification": "Classify the issue 'Can't connect via Stomp to Apollo broker - ActiveMq-Cpp version: 3.7.0' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-484?\nA: I'm using the version 3.7.0 from activemq-cpp and trying to connect with Stomp to Apollo. \n* I tested with version 3.7.0 from activemq-cpp Openwire Apollo - worked fine. \n* I tested with version 3.3.0 from activemq-cpp Stomp Apollo - worked fine \n\nThe version 3.7.0 doesn't work with Stomp Apollo!."}}
{"issue_key": "AMQCPP-483", "project": "AMQCPP", "title": "3.7.0 does not compile with gcc-4.4.7 on CentOS-6", "status": "Resolved", "reporter": "Matevz Tadel", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-22T18:28:52.000+0000", "updated": "2013-05-22T20:43:40.000+0000", "description": "libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/opt/gled/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -O2 -pthread -MT activemq/state/libactivemq_cpp_la-ConnectionStateTracker.lo -MD -MP -MF activemq/state/.deps/libactivemq_cpp_la-ConnectionStateTracker.Tpo -c activemq/state/ConnectionStateTracker.cpp  -fPIC -DPIC -o activemq/state/.libs/libactivemq_cpp_la-ConnectionStateTracker.o\nactivemq/state/ConnectionStateTracker.cpp: In constructor 'activemq::state::MessageCache::MessageCache(activemq::state::ConnectionStateTracker*)':\nactivemq/state/ConnectionStateTracker.cpp:61: error: class 'activemq::state::MessageCache' does not have any field named 'LinkedHashMap'", "comments": [], "text": "3.7.0 does not compile with gcc-4.4.7 on CentOS-6\n\nDescription:\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/opt/gled/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -O2 -pthread -MT activemq/state/libactivemq_cpp_la-ConnectionStateTracker.lo -MD -MP -MF activemq/state/.deps/libactivemq_cpp_la-ConnectionStateTracker.Tpo -c activemq/state/ConnectionStateTracker.cpp  -fPIC -DPIC -o activemq/state/.libs/libactivemq_cpp_la-ConnectionStateTracker.o\nactivemq/state/ConnectionStateTracker.cpp: In constructor 'activemq::state::MessageCache::MessageCache(activemq::state::ConnectionStateTracker*)':\nactivemq/state/ConnectionStateTracker.cpp:61: error: class 'activemq::state::MessageCache' does not have any field named 'LinkedHashMap'\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: 3.7.0 does not compile with gcc-4.4.7 on CentOS-6\n\nDescription:\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/opt/gled/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -O2 -pthread -MT activemq/state/libactivemq_cpp_la-ConnectionStateTracker.lo -MD -MP -MF activemq/state/.deps/libactivemq_cpp_la-ConnectionStateTracker.Tpo -c activemq/state/ConnectionStateTracker.cpp  -fPIC -DPIC -o activemq/state/.libs/libactivemq_cpp_la-ConnectionStateTracker.o\nactivemq/state/ConnectionStateTracker.cpp: In constructor 'activemq::state::MessageCache::MessageCache(activemq::state::ConnectionStateTracker*)':\nactivemq/state/ConnectionStateTracker.cpp:61: error: class 'activemq::state::MessageCache' does not have any field named 'LinkedHashMap'\n\n\nComments:\n", "classification": "Classify the issue '3.7.0 does not compile with gcc-4.4.7 on CentOS-6' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-483?\nA: libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/opt/gled/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -O2 -pthread -MT activemq/state/libactivemq_cpp_la-ConnectionStateTracker.lo -MD -MP -MF activemq/state/.deps/libactivemq_cpp_la-ConnectionStateTracker.Tpo -c activemq/state/Connect"}}
{"issue_key": "AMQCPP-482", "project": "AMQCPP", "title": "Message.getCMSMessageID() returns an empty string after send", "status": "Resolved", "reporter": "Jonathan Fortier", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-09T16:03:20.000+0000", "updated": "2013-05-21T16:08:10.000+0000", "description": "The JMS specification states the following:\n\"When a message is sent, JMSMessageID is ignored. When the send method\nreturns it contains a provider-assigned value.\"\n\nHowever, when I use ActiveMQ-cpp to send a message, it returns an empty CMSMessageID after the send operation completes.\n\nLooking a little deeper for the problem, I saw that in ActiveMQSessionKernel::send(...), if the message doesn't need transformation, we clone the message before sending it. However, the message ID is set on the clone rather than on the original message, which could explain why the original message stays with an empty CMSMessageID.\n\nTo reproduce the bug, I used the \"example\" application that comes with ActiveMQ-CPP, and I added the following line in HelloWorldProducer::run(), after sending the message:\n  printf(\"Sent message with ID: '%s'\\n\", message->getCMSMessageID().c_str());\nThis always print an empty ID.\n\nI wanted to retrieve this ID to later match a response to a request sent by ActiveMQ-cpp, and I didn't find any workaround to retrieve this ID by other means...", "comments": [], "text": "Message.getCMSMessageID() returns an empty string after send\n\nDescription:\nThe JMS specification states the following:\n\"When a message is sent, JMSMessageID is ignored. When the send method\nreturns it contains a provider-assigned value.\"\n\nHowever, when I use ActiveMQ-cpp to send a message, it returns an empty CMSMessageID after the send operation completes.\n\nLooking a little deeper for the problem, I saw that in ActiveMQSessionKernel::send(...), if the message doesn't need transformation, we clone the message before sending it. However, the message ID is set on the clone rather than on the original message, which could explain why the original message stays with an empty CMSMessageID.\n\nTo reproduce the bug, I used the \"example\" application that comes with ActiveMQ-CPP, and I added the following line in HelloWorldProducer::run(), after sending the message:\n  printf(\"Sent message with ID: '%s'\\n\", message->getCMSMessageID().c_str());\nThis always print an empty ID.\n\nI wanted to retrieve this ID to later match a response to a request sent by ActiveMQ-cpp, and I didn't find any workaround to retrieve this ID by other means...\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Message.getCMSMessageID() returns an empty string after send\n\nDescription:\nThe JMS specification states the following:\n\"When a message is sent, JMSMessageID is ignored. When the send method\nreturns it contains a provider-assigned value.\"\n\nHowever, when I use ActiveMQ-cpp to send a message, it returns an empty CMSMessageID after the send operation completes.\n\nLooking a little deeper for the problem, I saw that in ActiveMQSessionKernel::send(...), if the message doesn't need transformation, we clone the message before sending it. However, the message ID is set on the clone rather than on the original message, which could explain why the original message stays with an empty CMSMessageID.\n\nTo reproduce the bug, I used the \"example\" application that comes with ActiveMQ-CPP, and I added the following line in HelloWorldProducer::run(), after sending the message:\n  printf(\"Sent message with ID: '%s'\\n\", message->getCMSMessageID().c_str());\nThis always print an empty ID.\n\nI wanted to retrieve this ID to later match a response to a request sent by ActiveMQ-cpp, and I didn't find any workaround to retrieve this ID by other means...\n\nComments:\n", "classification": "Classify the issue 'Message.getCMSMessageID() returns an empty string after send' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-482?\nA: The JMS specification states the following:\n\"When a message is sent, JMSMessageID is ignored. When the send method\nreturns it contains a provider-assigned value.\"\n\nHowever, when I use ActiveMQ-cpp to send a message, it returns an empty CMSMessageID after the send operation completes.\n\nLooking a little deeper for the problem, I saw that in ActiveMQSessionKernel::send(...), if the message doesn't ne"}}
{"issue_key": "AMQCPP-481", "project": "AMQCPP", "title": "NullPointerException while handling broker exception", "status": "Closed", "reporter": "Martin Lichtin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-07T21:22:01.000+0000", "updated": "2013-05-08T20:04:16.000+0000", "description": "(Running with a modified library that aborts in case of a NullPointerException.)\n\n(gdb) bt\n#0  0x000000397b030265 in raise () from /lib64/libc.so.6\n#1  0x000000397b031d10 in abort () from /lib64/libc.so.6\n#2  0x00002aebc6308b48 in decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::operator-> (this=0x15b32da8) at ./decaf/lang/Pointer.h:264\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n#4  0x00002aebc634956e in activemq::core::ActiveMQConnection::syncRequest (this=0x2aaaac037600, command=..., timeout=0) at activemq/core/ActiveMQConnection.cpp:1251\n#5  0x00002aebc634b55b in activemq::core::ActiveMQConnection::asyncRequest (this=0x2aaaac037600, command=..., onComplete=0x0) at activemq/core/ActiveMQConnection.cpp:1275\n#6  0x00002aebc6431de4 in activemq::core::kernels::ActiveMQSessionKernel::send (this=0x2aaaac03daa0, producer=0x2aaaac040800, destination=..., message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, producerWindow=0x0,\n    sendTimeout=0, onComplete=0x0) at activemq/core/kernels/ActiveMQSessionKernel.cpp:985\n#7  0x00002aebc64254e8 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, destination=0x2aaaac040068, message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, onComplete=0x0)\n    at activemq/core/kernels/ActiveMQProducerKernel.cpp:269\n#8  0x00002aebc6423c99 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, message=0x2aaaac0574b0) at activemq/core/kernels/ActiveMQProducerKernel.cpp:139\n#9  0x00002aebc63cc270 in activemq::core::ActiveMQProducer::send (this=0x2aaaac040de0, message=0x2aaaac0574b0) at activemq/core/ActiveMQProducer.cpp:62\netc...\n\n(gdb) frame 3\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n(gdb) p *this\n$10 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {\n            _vptr.MarshalAware = 0x2aebc6c88230}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, message = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f528 \"malformed input around byte 0\"}}, exceptionClass = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f4e8 \"java.io.UTFDataFormatException\"}},\n  stackTraceElements = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter>, std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x15b33dc0, _M_finish = 0x15b34120, _M_end_of_storage = 0x15b34120}}, <No data fields>},\n  cause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c88490, counter = 0x15b33cd0}, value = 0x0,\n    onDelete = 0x2aebc6307434 <decaf::lang::Pointer<activemq::commands::BrokerError, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::BrokerError*)>},\n  exCause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c884d0, counter = 0x15a9ec70}, value = 0x0,\n    onDelete = 0x2aebc6307348 <decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Exception*)>}}\n(gdb) l\n123             cause = new cms::UnsupportedOperationException(this->message);\n124         } else {\n125             if (exCause != NULL) {\n126                 cause = new cms::CMSException(this->message);\n127             } else {\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n129             }\n130         }\n131\n132         // Wrap in a Decaf exception to carry the pointer until it can be\n\nThe check on line 125 seems wrong. It should be ==, not?", "comments": [], "text": "NullPointerException while handling broker exception\n\nDescription:\n(Running with a modified library that aborts in case of a NullPointerException.)\n\n(gdb) bt\n#0  0x000000397b030265 in raise () from /lib64/libc.so.6\n#1  0x000000397b031d10 in abort () from /lib64/libc.so.6\n#2  0x00002aebc6308b48 in decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::operator-> (this=0x15b32da8) at ./decaf/lang/Pointer.h:264\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n#4  0x00002aebc634956e in activemq::core::ActiveMQConnection::syncRequest (this=0x2aaaac037600, command=..., timeout=0) at activemq/core/ActiveMQConnection.cpp:1251\n#5  0x00002aebc634b55b in activemq::core::ActiveMQConnection::asyncRequest (this=0x2aaaac037600, command=..., onComplete=0x0) at activemq/core/ActiveMQConnection.cpp:1275\n#6  0x00002aebc6431de4 in activemq::core::kernels::ActiveMQSessionKernel::send (this=0x2aaaac03daa0, producer=0x2aaaac040800, destination=..., message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, producerWindow=0x0,\n    sendTimeout=0, onComplete=0x0) at activemq/core/kernels/ActiveMQSessionKernel.cpp:985\n#7  0x00002aebc64254e8 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, destination=0x2aaaac040068, message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, onComplete=0x0)\n    at activemq/core/kernels/ActiveMQProducerKernel.cpp:269\n#8  0x00002aebc6423c99 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, message=0x2aaaac0574b0) at activemq/core/kernels/ActiveMQProducerKernel.cpp:139\n#9  0x00002aebc63cc270 in activemq::core::ActiveMQProducer::send (this=0x2aaaac040de0, message=0x2aaaac0574b0) at activemq/core/ActiveMQProducer.cpp:62\netc...\n\n(gdb) frame 3\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n(gdb) p *this\n$10 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {\n            _vptr.MarshalAware = 0x2aebc6c88230}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, message = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f528 \"malformed input around byte 0\"}}, exceptionClass = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f4e8 \"java.io.UTFDataFormatException\"}},\n  stackTraceElements = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter>, std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x15b33dc0, _M_finish = 0x15b34120, _M_end_of_storage = 0x15b34120}}, <No data fields>},\n  cause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c88490, counter = 0x15b33cd0}, value = 0x0,\n    onDelete = 0x2aebc6307434 <decaf::lang::Pointer<activemq::commands::BrokerError, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::BrokerError*)>},\n  exCause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c884d0, counter = 0x15a9ec70}, value = 0x0,\n    onDelete = 0x2aebc6307348 <decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Exception*)>}}\n(gdb) l\n123             cause = new cms::UnsupportedOperationException(this->message);\n124         } else {\n125             if (exCause != NULL) {\n126                 cause = new cms::CMSException(this->message);\n127             } else {\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n129             }\n130         }\n131\n132         // Wrap in a Decaf exception to carry the pointer until it can be\n\nThe check on line 125 seems wrong. It should be ==, not?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: NullPointerException while handling broker exception\n\nDescription:\n(Running with a modified library that aborts in case of a NullPointerException.)\n\n(gdb) bt\n#0  0x000000397b030265 in raise () from /lib64/libc.so.6\n#1  0x000000397b031d10 in abort () from /lib64/libc.so.6\n#2  0x00002aebc6308b48 in decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::operator-> (this=0x15b32da8) at ./decaf/lang/Pointer.h:264\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n#4  0x00002aebc634956e in activemq::core::ActiveMQConnection::syncRequest (this=0x2aaaac037600, command=..., timeout=0) at activemq/core/ActiveMQConnection.cpp:1251\n#5  0x00002aebc634b55b in activemq::core::ActiveMQConnection::asyncRequest (this=0x2aaaac037600, command=..., onComplete=0x0) at activemq/core/ActiveMQConnection.cpp:1275\n#6  0x00002aebc6431de4 in activemq::core::kernels::ActiveMQSessionKernel::send (this=0x2aaaac03daa0, producer=0x2aaaac040800, destination=..., message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, producerWindow=0x0,\n    sendTimeout=0, onComplete=0x0) at activemq/core/kernels/ActiveMQSessionKernel.cpp:985\n#7  0x00002aebc64254e8 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, destination=0x2aaaac040068, message=0x2aaaac0574b0, deliveryMode=0, priority=4, timeToLive=0, onComplete=0x0)\n    at activemq/core/kernels/ActiveMQProducerKernel.cpp:269\n#8  0x00002aebc6423c99 in activemq::core::kernels::ActiveMQProducerKernel::send (this=0x2aaaac040800, message=0x2aaaac0574b0) at activemq/core/kernels/ActiveMQProducerKernel.cpp:139\n#9  0x00002aebc63cc270 in activemq::core::ActiveMQProducer::send (this=0x2aaaac040de0, message=0x2aaaac0574b0) at activemq/core/ActiveMQProducer.cpp:62\netc...\n\n(gdb) frame 3\n#3  0x00002aebc63065ad in activemq::commands::BrokerError::createExceptionObject (this=0x15b32d50) at activemq/commands/BrokerError.cpp:128\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n(gdb) p *this\n$10 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {\n            _vptr.MarshalAware = 0x2aebc6c88230}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, message = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f528 \"malformed input around byte 0\"}}, exceptionClass = {static npos = 18446744073709551615,\n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x15b2f4e8 \"java.io.UTFDataFormatException\"}},\n  stackTraceElements = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter>, std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerError::StackTraceElement, decaf::util::concurrent::atomic::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x15b33dc0, _M_finish = 0x15b34120, _M_end_of_storage = 0x15b34120}}, <No data fields>},\n  cause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c88490, counter = 0x15b33cd0}, value = 0x0,\n    onDelete = 0x2aebc6307434 <decaf::lang::Pointer<activemq::commands::BrokerError, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::BrokerError*)>},\n  exCause = {<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x2aebc6c884d0, counter = 0x15a9ec70}, value = 0x0,\n    onDelete = 0x2aebc6307348 <decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Exception*)>}}\n(gdb) l\n123             cause = new cms::UnsupportedOperationException(this->message);\n124         } else {\n125             if (exCause != NULL) {\n126                 cause = new cms::CMSException(this->message);\n127             } else {\n128                 cause = new cms::CMSException(this->exCause->getMessage());\n129             }\n130         }\n131\n132         // Wrap in a Decaf exception to carry the pointer until it can be\n\nThe check on line 125 seems wrong. It should be ==, not?\n\nComments:\n", "classification": "Classify the issue 'NullPointerException while handling broker exception' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-481?\nA: (Running with a modified library that aborts in case of a NullPointerException.)\n\n(gdb) bt\n#0  0x000000397b030265 in raise () from /lib64/libc.so.6\n#1  0x000000397b031d10 in abort () from /lib64/libc.so.6\n#2  0x00002aebc6308b48 in decaf::lang::Pointer<decaf::lang::Exception, decaf::util::concurrent::atomic::AtomicRefCounter>::operator-> (this=0x15b32da8) at ./decaf/lang/Pointer.h:264\n#3  0x00002ae"}}
{"issue_key": "AMQCPP-480", "project": "AMQCPP", "title": "Add complete support for Update Cluster clients and rebalancing to Failover Transport.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-02T22:17:31.000+0000", "updated": "2013-05-02T22:17:48.000+0000", "description": "Clean up the Update cluster clients functionality in the Failover Transport and fully support the rebalance requests from the broker.", "comments": [], "text": "Add complete support for Update Cluster clients and rebalancing to Failover Transport.\n\nDescription:\nClean up the Update cluster clients functionality in the Failover Transport and fully support the rebalance requests from the broker.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add complete support for Update Cluster clients and rebalancing to Failover Transport.\n\nDescription:\nClean up the Update cluster clients functionality in the Failover Transport and fully support the rebalance requests from the broker.\n\nComments:\n", "classification": "Classify the issue 'Add complete support for Update Cluster clients and rebalancing to Failover Transport.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-480?\nA: Clean up the Update cluster clients functionality in the Failover Transport and fully support the rebalance requests from the broker."}}
{"issue_key": "AMQCPP-479", "project": "AMQCPP", "title": "Add support for priority backups to failover transport.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-05-02T22:15:50.000+0000", "updated": "2013-05-02T22:16:05.000+0000", "description": "Port Priority Backups feature to v3.7.0", "comments": [], "text": "Add support for priority backups to failover transport.\n\nDescription:\nPort Priority Backups feature to v3.7.0\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for priority backups to failover transport.\n\nDescription:\nPort Priority Backups feature to v3.7.0\n\nComments:\n", "classification": "Classify the issue 'Add support for priority backups to failover transport.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-479?\nA: Port Priority Backups feature to v3.7.0"}}
{"issue_key": "AMQCPP-478", "project": "AMQCPP", "title": "Can't specify empty prefixes for the STOMP queues/topics", "status": "Closed", "reporter": "Valeriy V. Argunov", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-27T04:57:32.000+0000", "updated": "2013-04-28T15:00:47.000+0000", "description": "ActiveMQ-CPP uses prefixes for STOMP queues/topics (defaults are /topic/, /queue/ etc).\n\nSTOMP specification (http://stomp.github.io/stomp-specification-1.2.html) says that queues/topics names are not required to contain any special prefixes:\n\n(from the SEND sample)\nThis sends a message to a destination named /queue/a. Note that STOMP treats this destination as an opaque string and no delivery semantics are assumed by the name of a destination.\n\nBut if the prefix is not required for me, I can't specify empty string (here was a bug https://issues.apache.org/jira/browse/AMQCPP-477).\nActiveMQ-CPP doesn't allow to remove prefixes at all.", "comments": [], "text": "Can't specify empty prefixes for the STOMP queues/topics\n\nDescription:\nActiveMQ-CPP uses prefixes for STOMP queues/topics (defaults are /topic/, /queue/ etc).\n\nSTOMP specification (http://stomp.github.io/stomp-specification-1.2.html) says that queues/topics names are not required to contain any special prefixes:\n\n(from the SEND sample)\nThis sends a message to a destination named /queue/a. Note that STOMP treats this destination as an opaque string and no delivery semantics are assumed by the name of a destination.\n\nBut if the prefix is not required for me, I can't specify empty string (here was a bug https://issues.apache.org/jira/browse/AMQCPP-477).\nActiveMQ-CPP doesn't allow to remove prefixes at all.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't specify empty prefixes for the STOMP queues/topics\n\nDescription:\nActiveMQ-CPP uses prefixes for STOMP queues/topics (defaults are /topic/, /queue/ etc).\n\nSTOMP specification (http://stomp.github.io/stomp-specification-1.2.html) says that queues/topics names are not required to contain any special prefixes:\n\n(from the SEND sample)\nThis sends a message to a destination named /queue/a. Note that STOMP treats this destination as an opaque string and no delivery semantics are assumed by the name of a destination.\n\nBut if the prefix is not required for me, I can't specify empty string (here was a bug https://issues.apache.org/jira/browse/AMQCPP-477).\nActiveMQ-CPP doesn't allow to remove prefixes at all.\n\nComments:\n", "classification": "Classify the issue 'Can't specify empty prefixes for the STOMP queues/topics' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-478?\nA: ActiveMQ-CPP uses prefixes for STOMP queues/topics (defaults are /topic/, /queue/ etc).\n\nSTOMP specification (http://stomp.github.io/stomp-specification-1.2.html) says that queues/topics names are not required to contain any special prefixes:\n\n(from the SEND sample)\nThis sends a message to a destination named /queue/a. Note that STOMP treats this destination as an opaque string and no delivery sem"}}
{"issue_key": "AMQCPP-477", "project": "AMQCPP", "title": "Can't specify empty values in URIs", "status": "Closed", "reporter": "Valeriy V. Argunov", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-26T07:49:53.000+0000", "updated": "2013-04-26T22:30:44.000+0000", "description": "Can't specify empty values for wireFormat.topicPrefix, wireFormat.queuePrefix etc in URIs because URISupport::parseQuery doesn't support this.\n\nIt can't parse such URI correctly:\ntcp://10.0.0.1:333?wireFormat=stomp&wireFormat.topicPrefix=&wireFormat.queuePrefix=\n\nI've fixed this by the following code in URISupport::parseQuery:\n\nint tokensCount = tokenizer.countTokens();\nif (tokensCount != 2 && tokensCount != 1) {\n    throw IllegalArgumentException(__FILE__, __LINE__, \"URISupport::parseQuery - Invalid URI Option.\");\n}", "comments": [], "text": "Can't specify empty values in URIs\n\nDescription:\nCan't specify empty values for wireFormat.topicPrefix, wireFormat.queuePrefix etc in URIs because URISupport::parseQuery doesn't support this.\n\nIt can't parse such URI correctly:\ntcp://10.0.0.1:333?wireFormat=stomp&wireFormat.topicPrefix=&wireFormat.queuePrefix=\n\nI've fixed this by the following code in URISupport::parseQuery:\n\nint tokensCount = tokenizer.countTokens();\nif (tokensCount != 2 && tokensCount != 1) {\n    throw IllegalArgumentException(__FILE__, __LINE__, \"URISupport::parseQuery - Invalid URI Option.\");\n}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't specify empty values in URIs\n\nDescription:\nCan't specify empty values for wireFormat.topicPrefix, wireFormat.queuePrefix etc in URIs because URISupport::parseQuery doesn't support this.\n\nIt can't parse such URI correctly:\ntcp://10.0.0.1:333?wireFormat=stomp&wireFormat.topicPrefix=&wireFormat.queuePrefix=\n\nI've fixed this by the following code in URISupport::parseQuery:\n\nint tokensCount = tokenizer.countTokens();\nif (tokensCount != 2 && tokensCount != 1) {\n    throw IllegalArgumentException(__FILE__, __LINE__, \"URISupport::parseQuery - Invalid URI Option.\");\n}\n\n\nComments:\n", "classification": "Classify the issue 'Can't specify empty values in URIs' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-477?\nA: Can't specify empty values for wireFormat.topicPrefix, wireFormat.queuePrefix etc in URIs because URISupport::parseQuery doesn't support this.\n\nIt can't parse such URI correctly:\ntcp://10.0.0.1:333?wireFormat=stomp&wireFormat.topicPrefix=&wireFormat.queuePrefix=\n\nI've fixed this by the following code in URISupport::parseQuery:\n\nint tokensCount = tokenizer.countTokens();\nif (tokensCount != 2 && tok"}}
{"issue_key": "AMQCPP-476", "project": "AMQCPP", "title": "Reading of Stomp Frame with content length may throw excecption", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-09T10:32:29.000+0000", "updated": "2013-05-02T01:14:53.000+0000", "description": "-- HOW TO REPRODUCE --\n1) Setup a consumer to listen for messages on Topic XXX using CMS with stomp.\n2) Setup a publisher to send a messages from java JMS interface to Topic XXX continually. (with org.fusesource.stomp.jms.*)\n3) An exception is thrown in consumer from StompWireFormat::readStompBody() with description \"Read Content Length, and no trailing null\"\n\n-- BLOCK DIAGRAM --\nAll components are in different hosts and all run under Solaris 10 environment.\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | JAVA PUBLISHER |\n\nor\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | C++ PUBLISHER |", "comments": [], "text": "Reading of Stomp Frame with content length may throw excecption\n\nDescription:\n-- HOW TO REPRODUCE --\n1) Setup a consumer to listen for messages on Topic XXX using CMS with stomp.\n2) Setup a publisher to send a messages from java JMS interface to Topic XXX continually. (with org.fusesource.stomp.jms.*)\n3) An exception is thrown in consumer from StompWireFormat::readStompBody() with description \"Read Content Length, and no trailing null\"\n\n-- BLOCK DIAGRAM --\nAll components are in different hosts and all run under Solaris 10 environment.\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | JAVA PUBLISHER |\n\nor\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | C++ PUBLISHER |\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Reading of Stomp Frame with content length may throw excecption\n\nDescription:\n-- HOW TO REPRODUCE --\n1) Setup a consumer to listen for messages on Topic XXX using CMS with stomp.\n2) Setup a publisher to send a messages from java JMS interface to Topic XXX continually. (with org.fusesource.stomp.jms.*)\n3) An exception is thrown in consumer from StompWireFormat::readStompBody() with description \"Read Content Length, and no trailing null\"\n\n-- BLOCK DIAGRAM --\nAll components are in different hosts and all run under Solaris 10 environment.\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | JAVA PUBLISHER |\n\nor\n\n| C++ CONSUMER | <- | APOLLO 1.6 / AMQ 5.4.2 | <- | C++ PUBLISHER |\n\n\nComments:\n", "classification": "Classify the issue 'Reading of Stomp Frame with content length may throw excecption' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-476?\nA: -- HOW TO REPRODUCE --\n1) Setup a consumer to listen for messages on Topic XXX using CMS with stomp.\n2) Setup a publisher to send a messages from java JMS interface to Topic XXX continually. (with org.fusesource.stomp.jms.*)\n3) An exception is thrown in consumer from StompWireFormat::readStompBody() with description \"Read Content Length, and no trailing null\"\n\n-- BLOCK DIAGRAM --\nAll components ar"}}
{"issue_key": "AMQCPP-475", "project": "AMQCPP", "title": "Fix for Atomics Helper for Solaris 10", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": ["atomic", "solaris"], "created": "2013-04-08T07:20:35.000+0000", "updated": "2013-04-08T15:33:57.000+0000", "description": "activemq-cpp/src/main/decaf/internal/util/concurrent/unix/Atomics is not compile-able under Solaris 10 with Sun Studio 11 (CC: Sun C++ 5.8 Patch 121018-20).\n\nThe Attached Patch Fixed:\n- Atomics::compareAndSet32 and Atomics::compareAndSet is not working as expected and will caused the IOTransport not started correctly\n- CC Compiler Errors", "comments": [], "text": "Fix for Atomics Helper for Solaris 10\n\nDescription:\nactivemq-cpp/src/main/decaf/internal/util/concurrent/unix/Atomics is not compile-able under Solaris 10 with Sun Studio 11 (CC: Sun C++ 5.8 Patch 121018-20).\n\nThe Attached Patch Fixed:\n- Atomics::compareAndSet32 and Atomics::compareAndSet is not working as expected and will caused the IOTransport not started correctly\n- CC Compiler Errors\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Fix for Atomics Helper for Solaris 10\n\nDescription:\nactivemq-cpp/src/main/decaf/internal/util/concurrent/unix/Atomics is not compile-able under Solaris 10 with Sun Studio 11 (CC: Sun C++ 5.8 Patch 121018-20).\n\nThe Attached Patch Fixed:\n- Atomics::compareAndSet32 and Atomics::compareAndSet is not working as expected and will caused the IOTransport not started correctly\n- CC Compiler Errors\n\n\nComments:\n", "classification": "Classify the issue 'Fix for Atomics Helper for Solaris 10' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-475?\nA: activemq-cpp/src/main/decaf/internal/util/concurrent/unix/Atomics is not compile-able under Solaris 10 with Sun Studio 11 (CC: Sun C++ 5.8 Patch 121018-20).\n\nThe Attached Patch Fixed:\n- Atomics::compareAndSet32 and Atomics::compareAndSet is not working as expected and will caused the IOTransport not started correctly\n- CC Compiler Errors\n"}}
{"issue_key": "AMQCPP-474", "project": "AMQCPP", "title": "On closing a connection, ActiveMQ raises the exception: StlMap modified outside this iterator", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-04-05T08:30:26.000+0000", "updated": "2013-04-08T15:27:51.000+0000", "description": "By closing the connection, activeMQ iterates on config.activeTempDestinations to close the active temporary destinations. The method ActiveMQTempDestination.close() removes the destination from config.activeTempDestinations. So the iterator is invalid for the next iterations.", "comments": [], "text": "On closing a connection, ActiveMQ raises the exception: StlMap modified outside this iterator\n\nDescription:\nBy closing the connection, activeMQ iterates on config.activeTempDestinations to close the active temporary destinations. The method ActiveMQTempDestination.close() removes the destination from config.activeTempDestinations. So the iterator is invalid for the next iterations.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: On closing a connection, ActiveMQ raises the exception: StlMap modified outside this iterator\n\nDescription:\nBy closing the connection, activeMQ iterates on config.activeTempDestinations to close the active temporary destinations. The method ActiveMQTempDestination.close() removes the destination from config.activeTempDestinations. So the iterator is invalid for the next iterations.\n\nComments:\n", "classification": "Classify the issue 'On closing a connection, ActiveMQ raises the exception: StlMap modified outside this iterator' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-474?\nA: By closing the connection, activeMQ iterates on config.activeTempDestinations to close the active temporary destinations. The method ActiveMQTempDestination.close() removes the destination from config.activeTempDestinations. So the iterator is invalid for the next iterations."}}
{"issue_key": "AMQCPP-473", "project": "AMQCPP", "title": "Add some additional configuration options for URI support", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-01T21:53:17.000+0000", "updated": "2013-04-03T22:42:32.000+0000", "description": "Add the following options to ActiveMQConnectionFactory to allow URI configuration of more client options.\n\nuseRetroactiveConsumer\nexclusiveConsumer\ncheckForDuplicates\ntransactedIndividualAck\nsendAcksAsync", "comments": [], "text": "Add some additional configuration options for URI support\n\nDescription:\nAdd the following options to ActiveMQConnectionFactory to allow URI configuration of more client options.\n\nuseRetroactiveConsumer\nexclusiveConsumer\ncheckForDuplicates\ntransactedIndividualAck\nsendAcksAsync\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add some additional configuration options for URI support\n\nDescription:\nAdd the following options to ActiveMQConnectionFactory to allow URI configuration of more client options.\n\nuseRetroactiveConsumer\nexclusiveConsumer\ncheckForDuplicates\ntransactedIndividualAck\nsendAcksAsync\n\n\nComments:\n", "classification": "Classify the issue 'Add some additional configuration options for URI support' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-473?\nA: Add the following options to ActiveMQConnectionFactory to allow URI configuration of more client options.\n\nuseRetroactiveConsumer\nexclusiveConsumer\ncheckForDuplicates\ntransactedIndividualAck\nsendAcksAsync\n"}}
{"issue_key": "AMQCPP-472", "project": "AMQCPP", "title": "Add support for Non-Blocking redelivery. ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-01T21:47:34.000+0000", "updated": "2013-04-09T22:22:46.000+0000", "description": "", "comments": [], "text": "Add support for Non-Blocking redelivery. \n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for Non-Blocking redelivery. \n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Add support for Non-Blocking redelivery. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-472?\nA: "}}
{"issue_key": "AMQCPP-471", "project": "AMQCPP", "title": "Add support for Optimize Acknowledge", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-04-01T21:46:57.000+0000", "updated": "2013-04-03T22:42:54.000+0000", "description": "", "comments": [], "text": "Add support for Optimize Acknowledge\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for Optimize Acknowledge\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Add support for Optimize Acknowledge' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-471?\nA: "}}
{"issue_key": "AMQCPP-470", "project": "AMQCPP", "title": "ConnectionStateTracker needs to enforce message cache size restrictions ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-03-22T19:46:48.000+0000", "updated": "2013-03-22T19:48:33.000+0000", "description": "If the track messages option is enabled the connection state tracker will store and replay sent messages, however we don't currently enforce the set size limit on the cache.  We also don't have a size limit for pull requests.", "comments": [], "text": "ConnectionStateTracker needs to enforce message cache size restrictions \n\nDescription:\nIf the track messages option is enabled the connection state tracker will store and replay sent messages, however we don't currently enforce the set size limit on the cache.  We also don't have a size limit for pull requests.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ConnectionStateTracker needs to enforce message cache size restrictions \n\nDescription:\nIf the track messages option is enabled the connection state tracker will store and replay sent messages, however we don't currently enforce the set size limit on the cache.  We also don't have a size limit for pull requests.  \n\nComments:\n", "classification": "Classify the issue 'ConnectionStateTracker needs to enforce message cache size restrictions ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-470?\nA: If the track messages option is enabled the connection state tracker will store and replay sent messages, however we don't currently enforce the set size limit on the cache.  We also don't have a size limit for pull requests.  "}}
{"issue_key": "AMQCPP-469", "project": "AMQCPP", "title": "Remove linkage to APR-Util", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-03-16T21:30:04.000+0000", "updated": "2013-07-01T13:33:24.000+0000", "description": "Next release won't need APR-Util, update the scripts and dev projects to remove the linkage.", "comments": [], "text": "Remove linkage to APR-Util\n\nDescription:\nNext release won't need APR-Util, update the scripts and dev projects to remove the linkage. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Remove linkage to APR-Util\n\nDescription:\nNext release won't need APR-Util, update the scripts and dev projects to remove the linkage. \n\nComments:\n", "classification": "Classify the issue 'Remove linkage to APR-Util' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-469?\nA: Next release won't need APR-Util, update the scripts and dev projects to remove the linkage. "}}
{"issue_key": "AMQCPP-468", "project": "AMQCPP", "title": "Session recover() does not seem to restart message delivery", "status": "Closed", "reporter": "Martin Lichtin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-03-01T14:59:58.000+0000", "updated": "2013-03-03T22:39:26.000+0000", "description": "Session recover() method (implemented in AMQCPP-383) does not seem to restart message delivery.\n\nWill attach some test code.\nIt runs a consumer that keeps received messages pending (does not ack them).\nI expected that after a Session recover(), the messages would be redelivered.", "comments": [], "text": "Session recover() does not seem to restart message delivery\n\nDescription:\nSession recover() method (implemented in AMQCPP-383) does not seem to restart message delivery.\n\nWill attach some test code.\nIt runs a consumer that keeps received messages pending (does not ack them).\nI expected that after a Session recover(), the messages would be redelivered.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Session recover() does not seem to restart message delivery\n\nDescription:\nSession recover() method (implemented in AMQCPP-383) does not seem to restart message delivery.\n\nWill attach some test code.\nIt runs a consumer that keeps received messages pending (does not ack them).\nI expected that after a Session recover(), the messages would be redelivered.\n\nComments:\n", "classification": "Classify the issue 'Session recover() does not seem to restart message delivery' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-468?\nA: Session recover() method (implemented in AMQCPP-383) does not seem to restart message delivery.\n\nWill attach some test code.\nIt runs a consumer that keeps received messages pending (does not ack them).\nI expected that after a Session recover(), the messages would be redelivered."}}
{"issue_key": "AMQCPP-467", "project": "AMQCPP", "title": "Improve the CMSException types thrown from errors sent back from the broker.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-26T20:31:21.000+0000", "updated": "2013-02-26T22:40:56.000+0000", "description": "Need to ensure we try to throw a matching CMSException type for the error that was sent back from the broker.", "comments": [], "text": "Improve the CMSException types thrown from errors sent back from the broker.\n\nDescription:\nNeed to ensure we try to throw a matching CMSException type for the error that was sent back from the broker.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Improve the CMSException types thrown from errors sent back from the broker.\n\nDescription:\nNeed to ensure we try to throw a matching CMSException type for the error that was sent back from the broker.\n\nComments:\n", "classification": "Classify the issue 'Improve the CMSException types thrown from errors sent back from the broker.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-467?\nA: Need to ensure we try to throw a matching CMSException type for the error that was sent back from the broker."}}
{"issue_key": "AMQCPP-466", "project": "AMQCPP", "title": "Segmentation Fault in Temporary Queue consumer (incorrect Exception construction)", "status": "Resolved", "reporter": "Aaron Riekenberg", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-24T13:22:33.000+0000", "updated": "2013-02-24T21:03:46.000+0000", "description": "I have a program that creates a TemporaryQueue consumer in CMS.  It listens for exceptions from CMS and tries to close and recreate the connection when an exception happens.  \n\nI'm finding the program crashes sometimes when closing the connection after an exception.  I can't recreate this behavior with a consumer on a normal non-temporary queue or topic.\n\nI've extracted the issue into a small test program (test.cpp) that I'm attaching to this issue.\n\nSteps to reproduce:\n\n1. Run activemq (activemq start)\n2. Run attached test program\n3. Stop activemq (activemq stop)\n4. Restart activemq (activemq start)\n5. Repeat steps 3 and 4.  Eventually the test program will crash with a segmentation fault just after activemq is stopped and an exception is detected.\n\nIf I run the test program in valgrind, I see this output:\n\n{noformat:title=Test Program Valgrind Output}\n==4055== Invalid read of size 8\n==4055==    at 0x58E64D5: decaf::lang::Pointer<std::exception const, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(std::exception const*) (in /home/aaron/amqcpp350/lib/libactivemq-cpp.so.15.0.0)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid write of size 8\n==4055==    at 0x5F0817B: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x5F081C8: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid free() / delete / delete[] / realloc()\n==4055==    at 0x4C2A44B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n{noformat}\n\n\nI believe the bug is ActiveMQConnection.cpp is doing this around line 714:\n\n{code:title=ActiveMQConnection.cpp line 716}\n 714         } catch (std::exception& stdex) {\n 715             if (!hasException) {\n 716                 ex = Exception(&stdex);\n 717                 ex.setMark(__FILE__, __LINE__);\n 718                 hasException = true;\n 719             }\n 720         }\n{code}\n\nThe problem is line 716.  The pointer passed to the Exception constructor transfers ownership to the Exception instance, meaning ~Exception will delete &stdex.  But we don't own &stdex here.  stdex will automatically be destroyed when we leave the catch block.\n\nSo I think this code needs to clone the stdex instance here somehow before passing it to Exception().  I think the reason this only happens with a TemporaryQueue consumer is the code around line 716 is trying to clean up temporary destinations and is skipped for a normal queue/topic.\n\nNote line 716 isn't the only instance of this problem.  Also see lines 645 and lines 710 for other instances of incorrectly creating an Exception that will crash when they are executed:\n\n{code:title=ActiveMQConnection.cpp line 645}\n 643             } catch (cms::CMSException& error) {\n 644                 if (!hasException) {\n 645                     ex = Exception(&error);\n 646                     ex.setMark(__FILE__, __LINE__);\n 647                     hasException = true;\n 648                 }\n 649             }\n{code}\n\n{code:title=ActiveMQConnection.cpp line 710}\n 708         } catch (cms::CMSException& error) {\n 709             if (!hasException) {\n 710                 ex = Exception(&error);\n 711                 ex.setMark(__FILE__, __LINE__);\n 712                 hasException = true;\n 713             }\n{code}", "comments": [], "text": "Segmentation Fault in Temporary Queue consumer (incorrect Exception construction)\n\nDescription:\nI have a program that creates a TemporaryQueue consumer in CMS.  It listens for exceptions from CMS and tries to close and recreate the connection when an exception happens.  \n\nI'm finding the program crashes sometimes when closing the connection after an exception.  I can't recreate this behavior with a consumer on a normal non-temporary queue or topic.\n\nI've extracted the issue into a small test program (test.cpp) that I'm attaching to this issue.\n\nSteps to reproduce:\n\n1. Run activemq (activemq start)\n2. Run attached test program\n3. Stop activemq (activemq stop)\n4. Restart activemq (activemq start)\n5. Repeat steps 3 and 4.  Eventually the test program will crash with a segmentation fault just after activemq is stopped and an exception is detected.\n\nIf I run the test program in valgrind, I see this output:\n\n{noformat:title=Test Program Valgrind Output}\n==4055== Invalid read of size 8\n==4055==    at 0x58E64D5: decaf::lang::Pointer<std::exception const, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(std::exception const*) (in /home/aaron/amqcpp350/lib/libactivemq-cpp.so.15.0.0)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid write of size 8\n==4055==    at 0x5F0817B: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x5F081C8: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid free() / delete / delete[] / realloc()\n==4055==    at 0x4C2A44B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n{noformat}\n\n\nI believe the bug is ActiveMQConnection.cpp is doing this around line 714:\n\n{code:title=ActiveMQConnection.cpp line 716}\n 714         } catch (std::exception& stdex) {\n 715             if (!hasException) {\n 716                 ex = Exception(&stdex);\n 717                 ex.setMark(__FILE__, __LINE__);\n 718                 hasException = true;\n 719             }\n 720         }\n{code}\n\nThe problem is line 716.  The pointer passed to the Exception constructor transfers ownership to the Exception instance, meaning ~Exception will delete &stdex.  But we don't own &stdex here.  stdex will automatically be destroyed when we leave the catch block.\n\nSo I think this code needs to clone the stdex instance here somehow before passing it to Exception().  I think the reason this only happens with a TemporaryQueue consumer is the code around line 716 is trying to clean up temporary destinations and is skipped for a normal queue/topic.\n\nNote line 716 isn't the only instance of this problem.  Also see lines 645 and lines 710 for other instances of incorrectly creating an Exception that will crash when they are executed:\n\n{code:title=ActiveMQConnection.cpp line 645}\n 643             } catch (cms::CMSException& error) {\n 644                 if (!hasException) {\n 645                     ex = Exception(&error);\n 646                     ex.setMark(__FILE__, __LINE__);\n 647                     hasException = true;\n 648                 }\n 649             }\n{code}\n\n{code:title=ActiveMQConnection.cpp line 710}\n 708         } catch (cms::CMSException& error) {\n 709             if (!hasException) {\n 710                 ex = Exception(&error);\n 711                 ex.setMark(__FILE__, __LINE__);\n 712                 hasException = true;\n 713             }\n{code}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation Fault in Temporary Queue consumer (incorrect Exception construction)\n\nDescription:\nI have a program that creates a TemporaryQueue consumer in CMS.  It listens for exceptions from CMS and tries to close and recreate the connection when an exception happens.  \n\nI'm finding the program crashes sometimes when closing the connection after an exception.  I can't recreate this behavior with a consumer on a normal non-temporary queue or topic.\n\nI've extracted the issue into a small test program (test.cpp) that I'm attaching to this issue.\n\nSteps to reproduce:\n\n1. Run activemq (activemq start)\n2. Run attached test program\n3. Stop activemq (activemq stop)\n4. Restart activemq (activemq start)\n5. Repeat steps 3 and 4.  Eventually the test program will crash with a segmentation fault just after activemq is stopped and an exception is detected.\n\nIf I run the test program in valgrind, I see this output:\n\n{noformat:title=Test Program Valgrind Output}\n==4055== Invalid read of size 8\n==4055==    at 0x58E64D5: decaf::lang::Pointer<std::exception const, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(std::exception const*) (in /home/aaron/amqcpp350/lib/libactivemq-cpp.so.15.0.0)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid write of size 8\n==4055==    at 0x5F0817B: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x5F081C8: std::exception::~exception() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055== \n==4055== Invalid free() / delete / delete[] / realloc()\n==4055==    at 0x4C2A44B: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x58E546C: decaf::lang::Exception::~Exception() (Pointer.h:148)\n==4055==    by 0x58E5538: decaf::lang::Exception::~Exception() (Exception.cpp:107)\n==4055==    by 0x588BBA4: cms::CMSException::~CMSException() (auto_ptr.h:170)\n==4055==    by 0x5F090F8: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17)\n==4055==    by 0x4034E7: SimpleAsyncConsumer::cleanup() (test.cpp:211)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n==4055==  Address 0x8427600 is 128 bytes inside a block of size 144 free'd\n==4055==    at 0x4C2A739: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==4055==    by 0x56747E8: activemq::core::ActiveMQConnection::close() (ActiveMQConnection.cpp:714)\n==4055==    by 0x4033F1: SimpleAsyncConsumer::cleanup() (test.cpp:210)\n==4055==    by 0x402D05: SimpleAsyncConsumer::close() (test.cpp:94)\n==4055==    by 0x401EB6: main (test.cpp:278)\n{noformat}\n\n\nI believe the bug is ActiveMQConnection.cpp is doing this around line 714:\n\n{code:title=ActiveMQConnection.cpp line 716}\n 714         } catch (std::exception& stdex) {\n 715             if (!hasException) {\n 716                 ex = Exception(&stdex);\n 717                 ex.setMark(__FILE__, __LINE__);\n 718                 hasException = true;\n 719             }\n 720         }\n{code}\n\nThe problem is line 716.  The pointer passed to the Exception constructor transfers ownership to the Exception instance, meaning ~Exception will delete &stdex.  But we don't own &stdex here.  stdex will automatically be destroyed when we leave the catch block.\n\nSo I think this code needs to clone the stdex instance here somehow before passing it to Exception().  I think the reason this only happens with a TemporaryQueue consumer is the code around line 716 is trying to clean up temporary destinations and is skipped for a normal queue/topic.\n\nNote line 716 isn't the only instance of this problem.  Also see lines 645 and lines 710 for other instances of incorrectly creating an Exception that will crash when they are executed:\n\n{code:title=ActiveMQConnection.cpp line 645}\n 643             } catch (cms::CMSException& error) {\n 644                 if (!hasException) {\n 645                     ex = Exception(&error);\n 646                     ex.setMark(__FILE__, __LINE__);\n 647                     hasException = true;\n 648                 }\n 649             }\n{code}\n\n{code:title=ActiveMQConnection.cpp line 710}\n 708         } catch (cms::CMSException& error) {\n 709             if (!hasException) {\n 710                 ex = Exception(&error);\n 711                 ex.setMark(__FILE__, __LINE__);\n 712                 hasException = true;\n 713             }\n{code}\n\nComments:\n", "classification": "Classify the issue 'Segmentation Fault in Temporary Queue consumer (incorrect Exception construction)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-466?\nA: I have a program that creates a TemporaryQueue consumer in CMS.  It listens for exceptions from CMS and tries to close and recreate the connection when an exception happens.  \n\nI'm finding the program crashes sometimes when closing the connection after an exception.  I can't recreate this behavior with a consumer on a normal non-temporary queue or topic.\n\nI've extracted the issue into a small test"}}
{"issue_key": "AMQCPP-465", "project": "AMQCPP", "title": "Periodic access violation originating from Openwire::unmarshal", "status": "Resolved", "reporter": "Scott Weaver", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-21T17:42:05.000+0000", "updated": "2013-02-28T18:12:57.000+0000", "description": "Running a sustained test produced 5 separate access violations all within the Openwire::unmarshal. It appears only one occurred during termination. Attaching all 5 dumps.", "comments": [], "text": "Periodic access violation originating from Openwire::unmarshal\n\nDescription:\nRunning a sustained test produced 5 separate access violations all within the Openwire::unmarshal. It appears only one occurred during termination. Attaching all 5 dumps.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Periodic access violation originating from Openwire::unmarshal\n\nDescription:\nRunning a sustained test produced 5 separate access violations all within the Openwire::unmarshal. It appears only one occurred during termination. Attaching all 5 dumps.\n\nComments:\n", "classification": "Classify the issue 'Periodic access violation originating from Openwire::unmarshal' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-465?\nA: Running a sustained test produced 5 separate access violations all within the Openwire::unmarshal. It appears only one occurred during termination. Attaching all 5 dumps."}}
{"issue_key": "AMQCPP-464", "project": "AMQCPP", "title": "Deadlock during normal task termination", "status": "Closed", "reporter": "Scott Weaver", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-02-18T19:00:27.000+0000", "updated": "2013-02-20T14:14:51.000+0000", "description": "Normal task termination hangs occasionally.", "comments": [], "text": "Deadlock during normal task termination\n\nDescription:\nNormal task termination hangs occasionally.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock during normal task termination\n\nDescription:\nNormal task termination hangs occasionally.\n\nComments:\n", "classification": "Classify the issue 'Deadlock during normal task termination' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-464?\nA: Normal task termination hangs occasionally."}}
{"issue_key": "AMQCPP-463", "project": "AMQCPP", "title": "Add support for priority backups to the FailoverTransport", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-13T21:15:24.000+0000", "updated": "2013-02-27T15:11:05.000+0000", "description": "Add support for defining priority backups in the Failover URI as is done in AMQ-3699", "comments": [], "text": "Add support for priority backups to the FailoverTransport\n\nDescription:\nAdd support for defining priority backups in the Failover URI as is done in AMQ-3699\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for priority backups to the FailoverTransport\n\nDescription:\nAdd support for defining priority backups in the Failover URI as is done in AMQ-3699\n\nComments:\n", "classification": "Classify the issue 'Add support for priority backups to the FailoverTransport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-463?\nA: Add support for defining priority backups in the Failover URI as is done in AMQ-3699"}}
{"issue_key": "AMQCPP-462", "project": "AMQCPP", "title": "Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()", "status": "Resolved", "reporter": "John Rocha", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["abort", "activemq", "core", "crash", "decaf", "shutdown"], "created": "2013-02-12T22:35:33.000+0000", "updated": "2013-02-27T19:26:23.000+0000", "description": "Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\n\nWe recently upgrade from the AMQ-CPP-Client from 3.4.5 to 3.5.0. After doing\nthis we found that we would get aborts and core files when shutting down the\nproces.\n\nI've also been able to reproduce the problem with the simple consumer, which\nequates to basically.\n\n# Invoke the initializeLibrary() routine.\n# Print the library version and CMSX properties\n# Invoke shutdownLibrary()\n\n\nWhen I link against the 3.4.5 library there is no abort/core. When I link\nagainst 3.5.0 we abort/core.\n\n\n+Environments:+ This has been observed on both RedHat 5.8 and SUSE SLES10\n32bit. We are linking with apr version 1.4.2 and apri-util version 1.3.9\n\nI've attached gdb output as well as the modified SimpleProducer.cpp that I see\nthe problem with.\n\n\n{panel:title=It works with the previous version}\n%>  SimpleProducer.exe \n=====================================================\nStarting the example with version 3.4.4:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n{panel}\n\n\\\\\n\n\n{panel:title=It fails with 3.5.0}\n----------------------------------------\n%>  SimpleProducer.exe\n=====================================================\nStarting the example with version 3.5.0:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Failed to Lock OS Mutex\nAbort (core dumped)\n{panel}", "comments": [], "text": "Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\nDescription:\nProducer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\n\nWe recently upgrade from the AMQ-CPP-Client from 3.4.5 to 3.5.0. After doing\nthis we found that we would get aborts and core files when shutting down the\nproces.\n\nI've also been able to reproduce the problem with the simple consumer, which\nequates to basically.\n\n# Invoke the initializeLibrary() routine.\n# Print the library version and CMSX properties\n# Invoke shutdownLibrary()\n\n\nWhen I link against the 3.4.5 library there is no abort/core. When I link\nagainst 3.5.0 we abort/core.\n\n\n+Environments:+ This has been observed on both RedHat 5.8 and SUSE SLES10\n32bit. We are linking with apr version 1.4.2 and apri-util version 1.3.9\n\nI've attached gdb output as well as the modified SimpleProducer.cpp that I see\nthe problem with.\n\n\n{panel:title=It works with the previous version}\n%>  SimpleProducer.exe \n=====================================================\nStarting the example with version 3.4.4:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n{panel}\n\n\\\\\n\n\n{panel:title=It fails with 3.5.0}\n----------------------------------------\n%>  SimpleProducer.exe\n=====================================================\nStarting the example with version 3.5.0:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Failed to Lock OS Mutex\nAbort (core dumped)\n{panel}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\nDescription:\nProducer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\n\nWe recently upgrade from the AMQ-CPP-Client from 3.4.5 to 3.5.0. After doing\nthis we found that we would get aborts and core files when shutting down the\nproces.\n\nI've also been able to reproduce the problem with the simple consumer, which\nequates to basically.\n\n# Invoke the initializeLibrary() routine.\n# Print the library version and CMSX properties\n# Invoke shutdownLibrary()\n\n\nWhen I link against the 3.4.5 library there is no abort/core. When I link\nagainst 3.5.0 we abort/core.\n\n\n+Environments:+ This has been observed on both RedHat 5.8 and SUSE SLES10\n32bit. We are linking with apr version 1.4.2 and apri-util version 1.3.9\n\nI've attached gdb output as well as the modified SimpleProducer.cpp that I see\nthe problem with.\n\n\n{panel:title=It works with the previous version}\n%>  SimpleProducer.exe \n=====================================================\nStarting the example with version 3.4.4:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n{panel}\n\n\\\\\n\n\n{panel:title=It fails with 3.5.0}\n----------------------------------------\n%>  SimpleProducer.exe\n=====================================================\nStarting the example with version 3.5.0:\n-----------------------------------------------------\n0: JMSXGroupID\n1: JMSXGroupSeq\n2: JMSXDeliveryCount\n3: JMSXProducerTXID\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Failed to Lock OS Mutex\nAbort (core dumped)\n{panel}\n\nComments:\n", "classification": "Classify the issue 'Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-462?\nA: Producer aborts/core dump during ActiveMQCPP::shutdownLibrary()\n\n\nWe recently upgrade from the AMQ-CPP-Client from 3.4.5 to 3.5.0. After doing\nthis we found that we would get aborts and core files when shutting down the\nproces.\n\nI've also been able to reproduce the problem with the simple consumer, which\nequates to basically.\n\n# Invoke the initializeLibrary() routine.\n# Print the library version a"}}
{"issue_key": "AMQCPP-461", "project": "AMQCPP", "title": "Create Thread objects that aren't started can leak their suspended thread on destroy.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-11T20:42:17.000+0000", "updated": "2013-05-02T02:30:01.000+0000", "description": "If a Thread object is created but its start method is never called. When destroyed the actual thread can leak if its sitting in the suspended state waiting to be started.  This happens right now in the case where a task is submitted to a ThreadPoolExecutor but is rejected for some reason such as the ExecutorService already being shut down.  We need to check for the suspended state on destroy and wake the thread with its cancel flag set so it shuts down normally.", "comments": [], "text": "Create Thread objects that aren't started can leak their suspended thread on destroy.\n\nDescription:\nIf a Thread object is created but its start method is never called. When destroyed the actual thread can leak if its sitting in the suspended state waiting to be started.  This happens right now in the case where a task is submitted to a ThreadPoolExecutor but is rejected for some reason such as the ExecutorService already being shut down.  We need to check for the suspended state on destroy and wake the thread with its cancel flag set so it shuts down normally. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create Thread objects that aren't started can leak their suspended thread on destroy.\n\nDescription:\nIf a Thread object is created but its start method is never called. When destroyed the actual thread can leak if its sitting in the suspended state waiting to be started.  This happens right now in the case where a task is submitted to a ThreadPoolExecutor but is rejected for some reason such as the ExecutorService already being shut down.  We need to check for the suspended state on destroy and wake the thread with its cancel flag set so it shuts down normally. \n\nComments:\n", "classification": "Classify the issue 'Create Thread objects that aren't started can leak their suspended thread on destroy.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-461?\nA: If a Thread object is created but its start method is never called. When destroyed the actual thread can leak if its sitting in the suspended state waiting to be started.  This happens right now in the case where a task is submitted to a ThreadPoolExecutor but is rejected for some reason such as the ExecutorService already being shut down.  We need to check for the suspended state on destroy and w"}}
{"issue_key": "AMQCPP-460", "project": "AMQCPP", "title": "Access Violation", "status": "Closed", "reporter": "Scott Weaver", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-08T20:19:21.000+0000", "updated": "2013-05-02T02:30:00.000+0000", "description": "Access violation using 3.6.x snapshot from 2/8.\n\n>\tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 102 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::tcp::TcpTransport::stop()  Line 151\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::inactivity::InactivityMonitor::stop()  Line 289\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::core::OnExceptionRunnable::run()  Line 371 + 0x1e bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x0e855350)  Line 726 + 0xd bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::runCallback(void * arg=0x143358a0)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x143358a0)  Line 250 + 0x15 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x0e6f07f0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]", "comments": [], "text": "Access Violation\n\nDescription:\nAccess violation using 3.6.x snapshot from 2/8.\n\n>\tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 102 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::tcp::TcpTransport::stop()  Line 151\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::inactivity::InactivityMonitor::stop()  Line 289\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::core::OnExceptionRunnable::run()  Line 371 + 0x1e bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x0e855350)  Line 726 + 0xd bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::runCallback(void * arg=0x143358a0)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x143358a0)  Line 250 + 0x15 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x0e6f07f0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Access Violation\n\nDescription:\nAccess violation using 3.6.x snapshot from 2/8.\n\n>\tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 102 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::tcp::TcpTransport::stop()  Line 151\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::inactivity::InactivityMonitor::stop()  Line 289\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::core::OnExceptionRunnable::run()  Line 371 + 0x1e bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x0e855350)  Line 726 + 0xd bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::runCallback(void * arg=0x143358a0)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x143358a0)  Line 250 + 0x15 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x0e6f07f0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\n\nComments:\n", "classification": "Classify the issue 'Access Violation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-460?\nA: Access violation using 3.6.x snapshot from 2/8.\n\n>\tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 102 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::tcp::TcpTransport::stop()  Line 151\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::stop()  Line 103\tC++\n \tactivemq-cppd.dll!activemq::transport::inactivity::InactivityMonitor::stop()  Line 289\tC++\n \tacti"}}
{"issue_key": "AMQCPP-459", "project": "AMQCPP", "title": "Found an access violation in NodePool::ReturNode(Node* node)", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-02-08T19:01:14.000+0000", "updated": "2013-02-19T21:47:18.000+0000", "description": "Caught an access violation in NodePool::ReturNode(Node* node)\n\nThe following is the call stack:\n\nactivemq-cppud.dll!`anonymous namespace'::NodePool::returnNode(`anonymous-namespace'::Node * node=0x05237488)  Line 311 + 0x6 bytes\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::unlinkCancelledWaiters()  Line 1450\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::await()  Line 1145\nCmsMessageHandlerCOMUD.dll!decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable *>::take()  Line 435 + 0x32 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::getTask()  Line 1288 + 0x24 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x052359b8)  Line 720 + 0xe bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0523a690)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0523a690)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x0523ab30)  Line 331\nkernel32.dll!7c80b729()", "comments": [], "text": "Found an access violation in NodePool::ReturNode(Node* node)\n\nDescription:\nCaught an access violation in NodePool::ReturNode(Node* node)\n\nThe following is the call stack:\n\nactivemq-cppud.dll!`anonymous namespace'::NodePool::returnNode(`anonymous-namespace'::Node * node=0x05237488)  Line 311 + 0x6 bytes\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::unlinkCancelledWaiters()  Line 1450\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::await()  Line 1145\nCmsMessageHandlerCOMUD.dll!decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable *>::take()  Line 435 + 0x32 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::getTask()  Line 1288 + 0x24 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x052359b8)  Line 720 + 0xe bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0523a690)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0523a690)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x0523ab30)  Line 331\nkernel32.dll!7c80b729() \n\n \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Found an access violation in NodePool::ReturNode(Node* node)\n\nDescription:\nCaught an access violation in NodePool::ReturNode(Node* node)\n\nThe following is the call stack:\n\nactivemq-cppud.dll!`anonymous namespace'::NodePool::returnNode(`anonymous-namespace'::Node * node=0x05237488)  Line 311 + 0x6 bytes\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::unlinkCancelledWaiters()  Line 1450\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::await()  Line 1145\nCmsMessageHandlerCOMUD.dll!decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable *>::take()  Line 435 + 0x32 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::getTask()  Line 1288 + 0x24 bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::runWorker(decaf::util::concurrent::ExecutorKernel::Worker * w=0x052359b8)  Line 720 + 0xe bytes\nactivemq-cppud.dll!decaf::util::concurrent::ExecutorKernel::Worker::run()  Line 184\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0523a690)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0523a690)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x0523ab30)  Line 331\nkernel32.dll!7c80b729() \n\n \n\nComments:\n", "classification": "Classify the issue 'Found an access violation in NodePool::ReturNode(Node* node)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-459?\nA: Caught an access violation in NodePool::ReturNode(Node* node)\n\nThe following is the call stack:\n\nactivemq-cppud.dll!`anonymous namespace'::NodePool::returnNode(`anonymous-namespace'::Node * node=0x05237488)  Line 311 + 0x6 bytes\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultConditionObject::unlinkCancelledWaiters()  Line 1450\nactivemq-cppud.dll!decaf::util::concurrent::locks::DefaultCo"}}
{"issue_key": "AMQCPP-458", "project": "AMQCPP", "title": "Segment Fault in ~Thread when thread creation fails", "status": "Resolved", "reporter": "Ben Wilder", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2013-02-07T22:32:47.000+0000", "updated": "2013-02-11T19:12:20.000+0000", "description": "Crash occurs in freeing Thread if the original creation of the thread failed. Since it is rare that a thread creation fails this probally isn't a big deal: \n\nConditions: \n - call throws CMSException with message \"Failed to create new Thread.\"\n - When freeing the allocated cms::Connection object, it looks like it is trying to join the thread that it failed to create.\n\nBacktrace:\n#0  0x0000003845407fc3 in pthread_join () from /lib64/libpthread.so.0\n#1  0x00007fb62fc20409 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:351\n#2  0x00007fb62fc20519 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:361\n#3  0x00007fb62faf0b72 in ~Pointer (this=0x431ce50) at ./decaf/lang/Pointer.h:145\n#4  reset (this=0x431ce50) at ./decaf/lang/Pointer.h:158\n#5  activemq::transport::IOTransport::close (this=0x431ce50) at activemq/transport/IOTransport.cpp:206\n#6  0x00007fb62faf1a0a in activemq::transport::TransportFilter::close (this=<value optimized out>) at activemq/transport/TransportFilter.cpp:106\n#7  0x00007fb62fb342ac in activemq::transport::tcp::TcpTransport::close (this=0x431cef0) at activemq/transport/tcp/TcpTransport.cpp:74\n#8  0x00007fb62fb34466 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:54\n#9  0x00007fb62fb345c9 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:59\n#10 0x00007fb62faf149e in ~Pointer (this=0x431abd0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#11 activemq::transport::TransportFilter::~TransportFilter (this=0x431abd0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#12 0x00007fb62fb2b56f in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#13 0x00007fb62fb2b5f9 in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#14 0x00007fb62faf149e in ~Pointer (this=0x431a130, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#15 activemq::transport::TransportFilter::~TransportFilter (this=0x431a130, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#16 0x00007fb62fb66039 in activemq::wireformat::openwire::OpenWireFormatNegotiator::~OpenWireFormatNegotiator (this=0x431a130, \n    __in_chrg=<value optimized out>) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:56\n#17 0x00007fb62faf149e in ~Pointer (this=0x4319df0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#18 activemq::transport::TransportFilter::~TransportFilter (this=0x4319df0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#19 0x00007fb62faf4f99 in activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator (this=0x4319df0, \n    __in_chrg=<value optimized out>) at activemq/transport/correlator/ResponseCorrelator.cpp:70\n#20 0x00007fb62fa4ae95 in decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer (\n    this=0x7fffac1de080, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145", "comments": [], "text": "Segment Fault in ~Thread when thread creation fails\n\nDescription:\nCrash occurs in freeing Thread if the original creation of the thread failed. Since it is rare that a thread creation fails this probally isn't a big deal: \n\nConditions: \n - call throws CMSException with message \"Failed to create new Thread.\"\n - When freeing the allocated cms::Connection object, it looks like it is trying to join the thread that it failed to create.\n\nBacktrace:\n#0  0x0000003845407fc3 in pthread_join () from /lib64/libpthread.so.0\n#1  0x00007fb62fc20409 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:351\n#2  0x00007fb62fc20519 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:361\n#3  0x00007fb62faf0b72 in ~Pointer (this=0x431ce50) at ./decaf/lang/Pointer.h:145\n#4  reset (this=0x431ce50) at ./decaf/lang/Pointer.h:158\n#5  activemq::transport::IOTransport::close (this=0x431ce50) at activemq/transport/IOTransport.cpp:206\n#6  0x00007fb62faf1a0a in activemq::transport::TransportFilter::close (this=<value optimized out>) at activemq/transport/TransportFilter.cpp:106\n#7  0x00007fb62fb342ac in activemq::transport::tcp::TcpTransport::close (this=0x431cef0) at activemq/transport/tcp/TcpTransport.cpp:74\n#8  0x00007fb62fb34466 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:54\n#9  0x00007fb62fb345c9 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:59\n#10 0x00007fb62faf149e in ~Pointer (this=0x431abd0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#11 activemq::transport::TransportFilter::~TransportFilter (this=0x431abd0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#12 0x00007fb62fb2b56f in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#13 0x00007fb62fb2b5f9 in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#14 0x00007fb62faf149e in ~Pointer (this=0x431a130, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#15 activemq::transport::TransportFilter::~TransportFilter (this=0x431a130, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#16 0x00007fb62fb66039 in activemq::wireformat::openwire::OpenWireFormatNegotiator::~OpenWireFormatNegotiator (this=0x431a130, \n    __in_chrg=<value optimized out>) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:56\n#17 0x00007fb62faf149e in ~Pointer (this=0x4319df0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#18 activemq::transport::TransportFilter::~TransportFilter (this=0x4319df0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#19 0x00007fb62faf4f99 in activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator (this=0x4319df0, \n    __in_chrg=<value optimized out>) at activemq/transport/correlator/ResponseCorrelator.cpp:70\n#20 0x00007fb62fa4ae95 in decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer (\n    this=0x7fffac1de080, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segment Fault in ~Thread when thread creation fails\n\nDescription:\nCrash occurs in freeing Thread if the original creation of the thread failed. Since it is rare that a thread creation fails this probally isn't a big deal: \n\nConditions: \n - call throws CMSException with message \"Failed to create new Thread.\"\n - When freeing the allocated cms::Connection object, it looks like it is trying to join the thread that it failed to create.\n\nBacktrace:\n#0  0x0000003845407fc3 in pthread_join () from /lib64/libpthread.so.0\n#1  0x00007fb62fc20409 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:351\n#2  0x00007fb62fc20519 in decaf::lang::Thread::~Thread (this=0x4319210, __in_chrg=<value optimized out>) at decaf/lang/Thread.cpp:361\n#3  0x00007fb62faf0b72 in ~Pointer (this=0x431ce50) at ./decaf/lang/Pointer.h:145\n#4  reset (this=0x431ce50) at ./decaf/lang/Pointer.h:158\n#5  activemq::transport::IOTransport::close (this=0x431ce50) at activemq/transport/IOTransport.cpp:206\n#6  0x00007fb62faf1a0a in activemq::transport::TransportFilter::close (this=<value optimized out>) at activemq/transport/TransportFilter.cpp:106\n#7  0x00007fb62fb342ac in activemq::transport::tcp::TcpTransport::close (this=0x431cef0) at activemq/transport/tcp/TcpTransport.cpp:74\n#8  0x00007fb62fb34466 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:54\n#9  0x00007fb62fb345c9 in activemq::transport::tcp::TcpTransport::~TcpTransport (this=0x431cef0, __in_chrg=<value optimized out>)\n    at activemq/transport/tcp/TcpTransport.cpp:59\n#10 0x00007fb62faf149e in ~Pointer (this=0x431abd0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#11 activemq::transport::TransportFilter::~TransportFilter (this=0x431abd0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#12 0x00007fb62fb2b56f in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#13 0x00007fb62fb2b5f9 in activemq::transport::inactivity::InactivityMonitor::~InactivityMonitor (this=0x431abd0, \n    __in_chrg=<value optimized out>) at activemq/transport/inactivity/InactivityMonitor.cpp:254\n#14 0x00007fb62faf149e in ~Pointer (this=0x431a130, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#15 activemq::transport::TransportFilter::~TransportFilter (this=0x431a130, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#16 0x00007fb62fb66039 in activemq::wireformat::openwire::OpenWireFormatNegotiator::~OpenWireFormatNegotiator (this=0x431a130, \n    __in_chrg=<value optimized out>) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:56\n#17 0x00007fb62faf149e in ~Pointer (this=0x4319df0, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n#18 activemq::transport::TransportFilter::~TransportFilter (this=0x4319df0, __in_chrg=<value optimized out>)\n    at activemq/transport/TransportFilter.cpp:37\n#19 0x00007fb62faf4f99 in activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator (this=0x4319df0, \n    __in_chrg=<value optimized out>) at activemq/transport/correlator/ResponseCorrelator.cpp:70\n#20 0x00007fb62fa4ae95 in decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer (\n    this=0x7fffac1de080, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:145\n\n\n\nComments:\n", "classification": "Classify the issue 'Segment Fault in ~Thread when thread creation fails' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-458?\nA: Crash occurs in freeing Thread if the original creation of the thread failed. Since it is rare that a thread creation fails this probally isn't a big deal: \n\nConditions: \n - call throws CMSException with message \"Failed to create new Thread.\"\n - When freeing the allocated cms::Connection object, it looks like it is trying to join the thread that it failed to create.\n\nBacktrace:\n#0  0x0000003845407"}}
{"issue_key": "AMQCPP-457", "project": "AMQCPP", "title": "Refactor Transports layer for more control over started / stopped state during initialization", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-02-07T17:30:58.000+0000", "updated": "2013-05-02T02:30:00.000+0000", "description": "Need to revisit the Transports layer and make the whole create / start / stop process more deterministic.  The transports should do any connection logic until the filter chain is built and started as a whole, and once stopped no more async exceptions should come out.  \n\nThe filter chain also needs to be modified to better deal with close and destroy.  We need to ensure that the next Transport is held until destroy and that we walk down the chain and destroy the lowest one first before allowing high levels Transports to be destroyed.", "comments": [], "text": "Refactor Transports layer for more control over started / stopped state during initialization\n\nDescription:\nNeed to revisit the Transports layer and make the whole create / start / stop process more deterministic.  The transports should do any connection logic until the filter chain is built and started as a whole, and once stopped no more async exceptions should come out.  \n\nThe filter chain also needs to be modified to better deal with close and destroy.  We need to ensure that the next Transport is held until destroy and that we walk down the chain and destroy the lowest one first before allowing high levels Transports to be destroyed. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Refactor Transports layer for more control over started / stopped state during initialization\n\nDescription:\nNeed to revisit the Transports layer and make the whole create / start / stop process more deterministic.  The transports should do any connection logic until the filter chain is built and started as a whole, and once stopped no more async exceptions should come out.  \n\nThe filter chain also needs to be modified to better deal with close and destroy.  We need to ensure that the next Transport is held until destroy and that we walk down the chain and destroy the lowest one first before allowing high levels Transports to be destroyed. \n\nComments:\n", "classification": "Classify the issue 'Refactor Transports layer for more control over started / stopped state during initialization' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-457?\nA: Need to revisit the Transports layer and make the whole create / start / stop process more deterministic.  The transports should do any connection logic until the filter chain is built and started as a whole, and once stopped no more async exceptions should come out.  \n\nThe filter chain also needs to be modified to better deal with close and destroy.  We need to ensure that the next Transport is h"}}
{"issue_key": "AMQCPP-456", "project": "AMQCPP", "title": "Add ability to set updateURIsSupported for failover transport", "status": "Resolved", "reporter": "bryant scott", "assignee": "Unassigned", "priority": "Minor", "labels": [], "created": "2013-02-06T20:43:41.000+0000", "updated": "2013-02-27T19:26:24.000+0000", "description": "FailoverTransportFactory is missing the ability to parse the updateURIsSupported property from the broker URI.", "comments": [], "text": "Add ability to set updateURIsSupported for failover transport\n\nDescription:\nFailoverTransportFactory is missing the ability to parse the updateURIsSupported property from the broker URI.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add ability to set updateURIsSupported for failover transport\n\nDescription:\nFailoverTransportFactory is missing the ability to parse the updateURIsSupported property from the broker URI.\n\nComments:\n", "classification": "Classify the issue 'Add ability to set updateURIsSupported for failover transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-456?\nA: FailoverTransportFactory is missing the ability to parse the updateURIsSupported property from the broker URI."}}
{"issue_key": "AMQCPP-455", "project": "AMQCPP", "title": "Found an access violation in CMS when creating a new connection", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-02-06T19:13:12.000+0000", "updated": "2013-02-27T19:26:24.000+0000", "description": "Caught an access violation in CMS. The iterator seemed to be out of bound. The following is the call stack:\n\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++()  Line 264\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator>(std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _First=(<Bad Ptr>,<Bad Ptr>), std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _Last=(<Bad Ptr>,<Bad Ptr>))  Line 742 + 0xa bytes\nactivemq-cppud.dll!decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::copy(const decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & source={...})  Line 701\nactivemq-cppud.dll!decaf::util::Properties::clone()  Line 280\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::doCreateConnection(const decaf::net::URI & uri={...}, const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & username=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & password=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & clientId=\"\")  Line 289 + 0x1f bytes\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::createConnection()  Line 245\nactivemq-cppud.dll!activemq::cmsutil::CmsAccessor::createConnection()  Line 58 + 0x32 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::getConnection()  Line 258 + 0xd bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::takeSession()  Line 283\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::SessionCallback * action=0x02abfac4)  Line 433 + 0x8 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::ProducerCallback * action=0x02abfb3c)  Line 458\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::send(activemq::cmsutil::MessageCreator * messageCreator=0x02abfc48)  Line 539\nCMSMessageHandler-MultiTest.exe!cmstemplate::Sender::SendMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char> > & message=\"25040;CTBZMRWGBGIUAHHKNRRBBDZUQYMTZFTPYUOCLPLUTHNSBVFZFDTIMKBUIYAQBYBINKJLHQWUNEOUBILUSFBOVSHAPJICGMQYXALGF\", cmstemplate::ErrorCode & errorCode=CMS_SUCCESS)  Line 65 + 0x2d bytes\nCMSMessageHandler-MultiTest.exe!cmstemplate::TestSenderAndReceiver::run()  Line 91\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x00beeb68)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x00beeb68)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x00bf0ee8)  Line 331", "comments": [], "text": "Found an access violation in CMS when creating a new connection\n\nDescription:\nCaught an access violation in CMS. The iterator seemed to be out of bound. The following is the call stack:\n\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++()  Line 264\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator>(std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _First=(<Bad Ptr>,<Bad Ptr>), std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _Last=(<Bad Ptr>,<Bad Ptr>))  Line 742 + 0xa bytes\nactivemq-cppud.dll!decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::copy(const decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & source={...})  Line 701\nactivemq-cppud.dll!decaf::util::Properties::clone()  Line 280\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::doCreateConnection(const decaf::net::URI & uri={...}, const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & username=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & password=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & clientId=\"\")  Line 289 + 0x1f bytes\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::createConnection()  Line 245\nactivemq-cppud.dll!activemq::cmsutil::CmsAccessor::createConnection()  Line 58 + 0x32 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::getConnection()  Line 258 + 0xd bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::takeSession()  Line 283\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::SessionCallback * action=0x02abfac4)  Line 433 + 0x8 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::ProducerCallback * action=0x02abfb3c)  Line 458\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::send(activemq::cmsutil::MessageCreator * messageCreator=0x02abfc48)  Line 539\nCMSMessageHandler-MultiTest.exe!cmstemplate::Sender::SendMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char> > & message=\"25040;CTBZMRWGBGIUAHHKNRRBBDZUQYMTZFTPYUOCLPLUTHNSBVFZFDTIMKBUIYAQBYBINKJLHQWUNEOUBILUSFBOVSHAPJICGMQYXALGF\", cmstemplate::ErrorCode & errorCode=CMS_SUCCESS)  Line 65 + 0x2d bytes\nCMSMessageHandler-MultiTest.exe!cmstemplate::TestSenderAndReceiver::run()  Line 91\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x00beeb68)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x00beeb68)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x00bf0ee8)  Line 331\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Found an access violation in CMS when creating a new connection\n\nDescription:\nCaught an access violation in CMS. The iterator seemed to be out of bound. The following is the call stack:\n\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++()  Line 264\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator>(std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _First=(<Bad Ptr>,<Bad Ptr>), std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator _Last=(<Bad Ptr>,<Bad Ptr>))  Line 742 + 0xa bytes\nactivemq-cppud.dll!decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::copy(const decaf::util::StlMap<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & source={...})  Line 701\nactivemq-cppud.dll!decaf::util::Properties::clone()  Line 280\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::doCreateConnection(const decaf::net::URI & uri={...}, const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & username=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & password=\"\", const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & clientId=\"\")  Line 289 + 0x1f bytes\nactivemq-cppud.dll!activemq::core::ActiveMQConnectionFactory::createConnection()  Line 245\nactivemq-cppud.dll!activemq::cmsutil::CmsAccessor::createConnection()  Line 58 + 0x32 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::getConnection()  Line 258 + 0xd bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::takeSession()  Line 283\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::SessionCallback * action=0x02abfac4)  Line 433 + 0x8 bytes\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::execute(activemq::cmsutil::ProducerCallback * action=0x02abfb3c)  Line 458\nactivemq-cppud.dll!activemq::cmsutil::CmsTemplate::send(activemq::cmsutil::MessageCreator * messageCreator=0x02abfc48)  Line 539\nCMSMessageHandler-MultiTest.exe!cmstemplate::Sender::SendMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char> > & message=\"25040;CTBZMRWGBGIUAHHKNRRBBDZUQYMTZFTPYUOCLPLUTHNSBVFZFDTIMKBUIYAQBYBINKJLHQWUNEOUBILUSFBOVSHAPJICGMQYXALGF\", cmstemplate::ErrorCode & errorCode=CMS_SUCCESS)  Line 65 + 0x2d bytes\nCMSMessageHandler-MultiTest.exe!cmstemplate::TestSenderAndReceiver::run()  Line 91\nactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\nactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x00beeb68)  Line 262 + 0x11 bytes\nactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x00beeb68)  Line 250 + 0x15 bytes\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\nmsvcr80d.dll!_threadstartex(void * ptd=0x00bf0ee8)  Line 331\n\n\nComments:\n", "classification": "Classify the issue 'Found an access violation in CMS when creating a new connection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-455?\nA: Caught an access violation in CMS. The iterator seemed to be out of bound. The following is the call stack:\n\nactivemq-cppud.dll!std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair"}}
{"issue_key": "AMQCPP-454", "project": "AMQCPP", "title": "Found pure function call error in CMS", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-02-05T23:00:00.000+0000", "updated": "2013-02-14T18:30:39.000+0000", "description": "WeEncountered a pure function call error in CMS during our test. The following is the call stack:\n\n\tmsvcr80d.dll!_NMSG_WRITE(int rterrnum=0x00000019)  Line 198\tC\n \tmsvcr80d.dll!_purecall()  Line 54 + 0x7 bytes\tC\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::lock()  Line 55\tC++\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object=0x0cb6de90, const bool intiallyLocked=true)  Line 34\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads()  Line 469 + 0x20 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})  Line 310\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::fire(const decaf::lang::Exception & ex={...})  Line 53 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})  Line 46\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})  Line 64 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::run()  Line 259\tC++\n \tactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0c85e460)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0c85e460)  Line 250 + 0x15 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x1898e470)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nWe have 25 senders and receivers in our test, and we restart the broker every 10 seconds.", "comments": [], "text": "Found pure function call error in CMS\n\nDescription:\nWeEncountered a pure function call error in CMS during our test. The following is the call stack:\n\n\tmsvcr80d.dll!_NMSG_WRITE(int rterrnum=0x00000019)  Line 198\tC\n \tmsvcr80d.dll!_purecall()  Line 54 + 0x7 bytes\tC\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::lock()  Line 55\tC++\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object=0x0cb6de90, const bool intiallyLocked=true)  Line 34\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads()  Line 469 + 0x20 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})  Line 310\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::fire(const decaf::lang::Exception & ex={...})  Line 53 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})  Line 46\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})  Line 64 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::run()  Line 259\tC++\n \tactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0c85e460)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0c85e460)  Line 250 + 0x15 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x1898e470)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nWe have 25 senders and receivers in our test, and we restart the broker every 10 seconds.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Found pure function call error in CMS\n\nDescription:\nWeEncountered a pure function call error in CMS during our test. The following is the call stack:\n\n\tmsvcr80d.dll!_NMSG_WRITE(int rterrnum=0x00000019)  Line 198\tC\n \tmsvcr80d.dll!_purecall()  Line 54 + 0x7 bytes\tC\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::lock()  Line 55\tC++\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object=0x0cb6de90, const bool intiallyLocked=true)  Line 34\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads()  Line 469 + 0x20 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})  Line 310\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::fire(const decaf::lang::Exception & ex={...})  Line 53 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})  Line 46\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})  Line 64 + 0x17 bytes\tC++\n \tactivemq-cppud.dll!activemq::transport::IOTransport::run()  Line 259\tC++\n \tactivemq-cppud.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::runCallback(void * arg=0x0c85e460)  Line 262 + 0x11 bytes\tC++\n \tactivemq-cppud.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x0c85e460)  Line 250 + 0x15 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x1898e470)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nWe have 25 senders and receivers in our test, and we restart the broker every 10 seconds.\n\n\nComments:\n", "classification": "Classify the issue 'Found pure function call error in CMS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-454?\nA: WeEncountered a pure function call error in CMS during our test. The following is the call stack:\n\n\tmsvcr80d.dll!_NMSG_WRITE(int rterrnum=0x00000019)  Line 198\tC\n \tmsvcr80d.dll!_purecall()  Line 54 + 0x7 bytes\tC\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::lock()  Line 55\tC++\n \tactivemq-cppud.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object=0x0cb6de90"}}
{"issue_key": "AMQCPP-453", "project": "AMQCPP", "title": "Persistence Flag ActiveMQ C++ - WRONG FLAG CONSTANTS", "status": "Closed", "reporter": "Nikolaus Klimek", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["bug"], "created": "2013-02-05T09:56:03.000+0000", "updated": "2013-02-14T18:35:26.000+0000", "description": "We are using the ActiveMQ Broker 5.6.0 and the ActiveMQ C++ Client 2.1.1,\nboth running on SuSe Linux. We have the problem, that setting persistence in the C++-client doenst effect at the broker. The Messages in the broker are non-persistent, although we have set persistence in the activemq.xml, too.\n\n\n[...]\n <broker xmlns=\"http://activemq.apache.org/schema/core\" brokerName=\"localhost\" dataDirectory=\"${activemq.data}\" persistent=\"true\">\n\n        <!--\n            For better performances use VM cursor and small memory limit.\n            For more information, see:\n\n            http://activemq.apache.org/message-cursors.html\n\n            Also, if your producer is \"hanging\", it's probably due to producer flow control.\n            For more information, see:\n            http://activemq.apache.org/producer-flow-control.html\n        -->\n[...]\n\nFor my unterstanding, the Broker uses javax.jms.DeliveryMode for checking, if the Message is PERSISTENT or NON_PERSISTENT. Looking into the constant-spec. for java.jmx.DeliveryMode shows: \n\njavax.jms.DeliveryMode\npublic static final int \tNON_PERSISTENT \t1\npublic static final int \tPERSISTENT \t2\n\n\nIn the C++-Client-Application, we set \n\nproducer->setDeliveryMode(DeliveryMode::PERSISTENT);\n\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h shows:\n\n[...]\nenum DELIVERY_MODE {\n            PERSISTENT = 0,\n            NON_PERSISTENT = 1\n        };\n[...]\n\nSetting producer->setDeliveryMode(2) works for us. So my question is:\n\nIs this a Bug or are there other possibilities to configure it right?\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h of the C++-Clients version 3.5 shows still 0 and 1 for PERSISNT and NON_PERSISTENT. Should this be changed to 1 and 2?\n  \nThank you and best regards\nKlimek", "comments": [], "text": "Persistence Flag ActiveMQ C++ - WRONG FLAG CONSTANTS\n\nDescription:\nWe are using the ActiveMQ Broker 5.6.0 and the ActiveMQ C++ Client 2.1.1,\nboth running on SuSe Linux. We have the problem, that setting persistence in the C++-client doenst effect at the broker. The Messages in the broker are non-persistent, although we have set persistence in the activemq.xml, too.\n\n\n[...]\n <broker xmlns=\"http://activemq.apache.org/schema/core\" brokerName=\"localhost\" dataDirectory=\"${activemq.data}\" persistent=\"true\">\n\n        <!--\n            For better performances use VM cursor and small memory limit.\n            For more information, see:\n\n            http://activemq.apache.org/message-cursors.html\n\n            Also, if your producer is \"hanging\", it's probably due to producer flow control.\n            For more information, see:\n            http://activemq.apache.org/producer-flow-control.html\n        -->\n[...]\n\nFor my unterstanding, the Broker uses javax.jms.DeliveryMode for checking, if the Message is PERSISTENT or NON_PERSISTENT. Looking into the constant-spec. for java.jmx.DeliveryMode shows: \n\njavax.jms.DeliveryMode\npublic static final int \tNON_PERSISTENT \t1\npublic static final int \tPERSISTENT \t2\n\n\nIn the C++-Client-Application, we set \n\nproducer->setDeliveryMode(DeliveryMode::PERSISTENT);\n\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h shows:\n\n[...]\nenum DELIVERY_MODE {\n            PERSISTENT = 0,\n            NON_PERSISTENT = 1\n        };\n[...]\n\nSetting producer->setDeliveryMode(2) works for us. So my question is:\n\nIs this a Bug or are there other possibilities to configure it right?\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h of the C++-Clients version 3.5 shows still 0 and 1 for PERSISNT and NON_PERSISTENT. Should this be changed to 1 and 2?\n  \nThank you and best regards\nKlimek\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Persistence Flag ActiveMQ C++ - WRONG FLAG CONSTANTS\n\nDescription:\nWe are using the ActiveMQ Broker 5.6.0 and the ActiveMQ C++ Client 2.1.1,\nboth running on SuSe Linux. We have the problem, that setting persistence in the C++-client doenst effect at the broker. The Messages in the broker are non-persistent, although we have set persistence in the activemq.xml, too.\n\n\n[...]\n <broker xmlns=\"http://activemq.apache.org/schema/core\" brokerName=\"localhost\" dataDirectory=\"${activemq.data}\" persistent=\"true\">\n\n        <!--\n            For better performances use VM cursor and small memory limit.\n            For more information, see:\n\n            http://activemq.apache.org/message-cursors.html\n\n            Also, if your producer is \"hanging\", it's probably due to producer flow control.\n            For more information, see:\n            http://activemq.apache.org/producer-flow-control.html\n        -->\n[...]\n\nFor my unterstanding, the Broker uses javax.jms.DeliveryMode for checking, if the Message is PERSISTENT or NON_PERSISTENT. Looking into the constant-spec. for java.jmx.DeliveryMode shows: \n\njavax.jms.DeliveryMode\npublic static final int \tNON_PERSISTENT \t1\npublic static final int \tPERSISTENT \t2\n\n\nIn the C++-Client-Application, we set \n\nproducer->setDeliveryMode(DeliveryMode::PERSISTENT);\n\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h shows:\n\n[...]\nenum DELIVERY_MODE {\n            PERSISTENT = 0,\n            NON_PERSISTENT = 1\n        };\n[...]\n\nSetting producer->setDeliveryMode(2) works for us. So my question is:\n\nIs this a Bug or are there other possibilities to configure it right?\nLooking into activemq-cpp/src/main/cms/DeliveryMode.h of the C++-Clients version 3.5 shows still 0 and 1 for PERSISNT and NON_PERSISTENT. Should this be changed to 1 and 2?\n  \nThank you and best regards\nKlimek\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Persistence Flag ActiveMQ C++ - WRONG FLAG CONSTANTS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-453?\nA: We are using the ActiveMQ Broker 5.6.0 and the ActiveMQ C++ Client 2.1.1,\nboth running on SuSe Linux. We have the problem, that setting persistence in the C++-client doenst effect at the broker. The Messages in the broker are non-persistent, although we have set persistence in the activemq.xml, too.\n\n\n[...]\n <broker xmlns=\"http://activemq.apache.org/schema/core\" brokerName=\"localhost\" dataDirector"}}
{"issue_key": "AMQCPP-452", "project": "AMQCPP", "title": "Shutdown causing core dump in 3.5.0", "status": "Closed", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": ["shutdown", "thread"], "created": "2013-02-04T18:05:35.000+0000", "updated": "2013-02-04T19:55:16.000+0000", "description": "Whenever a thread is created in my receiver program, The use of the activemq::library::ActiveMQCPP::shutdownLibrary(); causes a core dump after my return 0; statement\n\nIt does not happen on my sender after applying patch for a similar issue, and this is almost identical, so I can not find the difference.\n\nThe cause is trying to lock a null mutex in the function Threading.cpp::attachToCurrentThread().  This gets called only once in my sender program, during the activemq::library::ActiveMQCPP::initializeLibrary(); call, but it gets called twice in my receiver program, once in the same place and then after the return 0; line.  At that point library->globalLock is NULL.\n\nWill attach my source in a moment, but I have literally taken it down to the bare minimum so that it has no function.", "comments": [], "text": "Shutdown causing core dump in 3.5.0\n\nDescription:\nWhenever a thread is created in my receiver program, The use of the activemq::library::ActiveMQCPP::shutdownLibrary(); causes a core dump after my return 0; statement\n\nIt does not happen on my sender after applying patch for a similar issue, and this is almost identical, so I can not find the difference.\n\nThe cause is trying to lock a null mutex in the function Threading.cpp::attachToCurrentThread().  This gets called only once in my sender program, during the activemq::library::ActiveMQCPP::initializeLibrary(); call, but it gets called twice in my receiver program, once in the same place and then after the return 0; line.  At that point library->globalLock is NULL.\n\nWill attach my source in a moment, but I have literally taken it down to the bare minimum so that it has no function.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Shutdown causing core dump in 3.5.0\n\nDescription:\nWhenever a thread is created in my receiver program, The use of the activemq::library::ActiveMQCPP::shutdownLibrary(); causes a core dump after my return 0; statement\n\nIt does not happen on my sender after applying patch for a similar issue, and this is almost identical, so I can not find the difference.\n\nThe cause is trying to lock a null mutex in the function Threading.cpp::attachToCurrentThread().  This gets called only once in my sender program, during the activemq::library::ActiveMQCPP::initializeLibrary(); call, but it gets called twice in my receiver program, once in the same place and then after the return 0; line.  At that point library->globalLock is NULL.\n\nWill attach my source in a moment, but I have literally taken it down to the bare minimum so that it has no function.\n\nComments:\n", "classification": "Classify the issue 'Shutdown causing core dump in 3.5.0' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-452?\nA: Whenever a thread is created in my receiver program, The use of the activemq::library::ActiveMQCPP::shutdownLibrary(); causes a core dump after my return 0; statement\n\nIt does not happen on my sender after applying patch for a similar issue, and this is almost identical, so I can not find the difference.\n\nThe cause is trying to lock a null mutex in the function Threading.cpp::attachToCurrentThread"}}
{"issue_key": "AMQCPP-451", "project": "AMQCPP", "title": "The number of CMS threads increases when we restart the message broker repeatedly ", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-02-01T23:16:08.000+0000", "updated": "2013-05-02T02:30:01.000+0000", "description": "The number of CMS threads increases when we restart the message broker repeatedly. We have ten senders and ten receivers in out test. Every sender sends out 10-20 messages every second. We restart the broker every 1 minute. The number of threads in CMS grew from about 50 to 600 after about 15 hours of testing. The attached dump was created after we ran two hours of test. From the dump we find a large number of threads are stuck at the following place:\n\nFunction   Source \nntdll!KiFastSystemCallRet    \nntdll!ZwWaitForSingleObject+c    \nkernel32!WaitForSingleObjectEx+a8    \nkernel32!WaitForSingleObject+12    \nactivemq_cppud!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition+25    \nactivemq_cppud!`anonymous namespace'::threadEntryMethod+9b    \nmsvcr80d!_callthreadstartex+51    \nmsvcr80d!_threadstartex+87    \nkernel32!BaseThreadStart+37", "comments": [], "text": "The number of CMS threads increases when we restart the message broker repeatedly \n\nDescription:\nThe number of CMS threads increases when we restart the message broker repeatedly. We have ten senders and ten receivers in out test. Every sender sends out 10-20 messages every second. We restart the broker every 1 minute. The number of threads in CMS grew from about 50 to 600 after about 15 hours of testing. The attached dump was created after we ran two hours of test. From the dump we find a large number of threads are stuck at the following place:\n\nFunction   Source \nntdll!KiFastSystemCallRet    \nntdll!ZwWaitForSingleObject+c    \nkernel32!WaitForSingleObjectEx+a8    \nkernel32!WaitForSingleObject+12    \nactivemq_cppud!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition+25    \nactivemq_cppud!`anonymous namespace'::threadEntryMethod+9b    \nmsvcr80d!_callthreadstartex+51    \nmsvcr80d!_threadstartex+87    \nkernel32!BaseThreadStart+37 \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The number of CMS threads increases when we restart the message broker repeatedly \n\nDescription:\nThe number of CMS threads increases when we restart the message broker repeatedly. We have ten senders and ten receivers in out test. Every sender sends out 10-20 messages every second. We restart the broker every 1 minute. The number of threads in CMS grew from about 50 to 600 after about 15 hours of testing. The attached dump was created after we ran two hours of test. From the dump we find a large number of threads are stuck at the following place:\n\nFunction   Source \nntdll!KiFastSystemCallRet    \nntdll!ZwWaitForSingleObject+c    \nkernel32!WaitForSingleObjectEx+a8    \nkernel32!WaitForSingleObject+12    \nactivemq_cppud!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition+25    \nactivemq_cppud!`anonymous namespace'::threadEntryMethod+9b    \nmsvcr80d!_callthreadstartex+51    \nmsvcr80d!_threadstartex+87    \nkernel32!BaseThreadStart+37 \n\n\nComments:\n", "classification": "Classify the issue 'The number of CMS threads increases when we restart the message broker repeatedly ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-451?\nA: The number of CMS threads increases when we restart the message broker repeatedly. We have ten senders and ten receivers in out test. Every sender sends out 10-20 messages every second. We restart the broker every 1 minute. The number of threads in CMS grew from about 50 to 600 after about 15 hours of testing. The attached dump was created after we ran two hours of test. From the dump we find a la"}}
{"issue_key": "AMQCPP-450", "project": "AMQCPP", "title": "Win32 Thread Handle Leak", "status": "Resolved", "reporter": "Scott Weaver", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-01-31T00:15:24.000+0000", "updated": "2013-02-27T19:26:23.000+0000", "description": "PlatformThread::detachOSThread(thread->handle) missing from threading library's dereferenceThread() method right before deleting thread. Adding this in prevents large thread handle leak in win32 environment. Recreate by cycling the broker with an active subscription and watch the handle count grow each time it is cycled.", "comments": [], "text": "Win32 Thread Handle Leak\n\nDescription:\nPlatformThread::detachOSThread(thread->handle) missing from threading library's dereferenceThread() method right before deleting thread. Adding this in prevents large thread handle leak in win32 environment. Recreate by cycling the broker with an active subscription and watch the handle count grow each time it is cycled.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Win32 Thread Handle Leak\n\nDescription:\nPlatformThread::detachOSThread(thread->handle) missing from threading library's dereferenceThread() method right before deleting thread. Adding this in prevents large thread handle leak in win32 environment. Recreate by cycling the broker with an active subscription and watch the handle count grow each time it is cycled.\n\nComments:\n", "classification": "Classify the issue 'Win32 Thread Handle Leak' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-450?\nA: PlatformThread::detachOSThread(thread->handle) missing from threading library's dereferenceThread() method right before deleting thread. Adding this in prevents large thread handle leak in win32 environment. Recreate by cycling the broker with an active subscription and watch the handle count grow each time it is cycled."}}
{"issue_key": "AMQCPP-449", "project": "AMQCPP", "title": "activemq::library::ActiveMQCPP::shutdownLibrary(); causing runtime exception", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": ["HPUX", "crash", "destructor", "exception", "runtime", "thread"], "created": "2013-01-16T14:41:05.000+0000", "updated": "2013-02-27T19:26:23.000+0000", "description": "Whenever my simple driver application or my receiver application call the shutdownLibrary() method at the end, as the program is going through desctuctors for threads it prints and causes a core dump\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\". \naCC runtime: what(): Failed to Lock OS Mutex \nAbort(coredump) \n\nI added another catch and print in decaf/lang/Thread.cpp about line 133 and on decaf/internal/util/concurrent/unix/PlatformThread.cpp about line 76 i printed out ther error number return from pthread_mutex_lock()\n\nNow i get:\nFailed to Lock OS Mutex, Error num: 22\n        FILE: decaf/internal/util/concurrent/unix/PlatformThread.cpp, LINE: 78\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\".\naCC runtime: what(): Failed to Lock OS Mutex, Error num: 22\nAbort(coredump)\n\n\nError 22 is EINVAL and can have two meanings on my system:\n     mutex is a PTHREAD_PRIO_PROTECT mutex and the caller's priority is higher than mutex's priority ceiling.\n     mutex is not an initialized mutex.\n\nI'll try and upload my code to see if this happens on other systems as well.", "comments": [], "text": "activemq::library::ActiveMQCPP::shutdownLibrary(); causing runtime exception\n\nDescription:\nWhenever my simple driver application or my receiver application call the shutdownLibrary() method at the end, as the program is going through desctuctors for threads it prints and causes a core dump\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\". \naCC runtime: what(): Failed to Lock OS Mutex \nAbort(coredump) \n\nI added another catch and print in decaf/lang/Thread.cpp about line 133 and on decaf/internal/util/concurrent/unix/PlatformThread.cpp about line 76 i printed out ther error number return from pthread_mutex_lock()\n\nNow i get:\nFailed to Lock OS Mutex, Error num: 22\n        FILE: decaf/internal/util/concurrent/unix/PlatformThread.cpp, LINE: 78\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\".\naCC runtime: what(): Failed to Lock OS Mutex, Error num: 22\nAbort(coredump)\n\n\nError 22 is EINVAL and can have two meanings on my system:\n     mutex is a PTHREAD_PRIO_PROTECT mutex and the caller's priority is higher than mutex's priority ceiling.\n     mutex is not an initialized mutex.\n\nI'll try and upload my code to see if this happens on other systems as well.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq::library::ActiveMQCPP::shutdownLibrary(); causing runtime exception\n\nDescription:\nWhenever my simple driver application or my receiver application call the shutdownLibrary() method at the end, as the program is going through desctuctors for threads it prints and causes a core dump\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\". \naCC runtime: what(): Failed to Lock OS Mutex \nAbort(coredump) \n\nI added another catch and print in decaf/lang/Thread.cpp about line 133 and on decaf/internal/util/concurrent/unix/PlatformThread.cpp about line 76 i printed out ther error number return from pthread_mutex_lock()\n\nNow i get:\nFailed to Lock OS Mutex, Error num: 22\n        FILE: decaf/internal/util/concurrent/unix/PlatformThread.cpp, LINE: 78\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\".\naCC runtime: what(): Failed to Lock OS Mutex, Error num: 22\nAbort(coredump)\n\n\nError 22 is EINVAL and can have two meanings on my system:\n     mutex is a PTHREAD_PRIO_PROTECT mutex and the caller's priority is higher than mutex's priority ceiling.\n     mutex is not an initialized mutex.\n\nI'll try and upload my code to see if this happens on other systems as well.\n\nComments:\n", "classification": "Classify the issue 'activemq::library::ActiveMQCPP::shutdownLibrary(); causing runtime exception' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-449?\nA: Whenever my simple driver application or my receiver application call the shutdownLibrary() method at the end, as the program is going through desctuctors for threads it prints and causes a core dump\naCC runtime: Unexpected exception of type \"decaf::lang::exceptions::RuntimeException\". \naCC runtime: what(): Failed to Lock OS Mutex \nAbort(coredump) \n\nI added another catch and print in decaf/lang/Th"}}
{"issue_key": "AMQCPP-448", "project": "AMQCPP", "title": "Problem to recive a BytesMessage ", "status": "Closed", "reporter": "Jorge Omar", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-01-16T01:28:23.000+0000", "updated": "2013-01-17T16:39:18.000+0000", "description": "I recive the ByteMessage with wrong information, but if i compile the same progrma with api 3.4.5 it works fine:\n\n\nHere the code: \n\nconst TextMessage* textMessage = dynamic_cast< const TextMessage* >( message );\n            const BytesMessage* bytetMessage = dynamic_cast< const BytesMessage* >( message );\n            //const StreamMessage* bytetMessage = dynamic_cast< const StreamMessage* >( message );\n           \n            string text = \"\";\n            \n            if( textMessage != NULL ) {\n                text = textMessage->getText();\n                std::cout << \"Message \" << count << \" Received: \" << text.c_str() << endl;\n            }\n            else if( bytetMessage != NULL ) {\n                \n                int size = bytetMessage->getBodyLength();\n                \n                std::cout << \"BYTES RECIVIDOS: \" << size << endl;\n                printBytesHex((char*)bytetMessage->getBodyBytes(),size,\"BUFFER\");\n\n\n\nThe probles is:\n\nBYTES RECIVIDOS: 59768832\nMessage Body is Read-Only.\n\tFILE: activemq/commands/ActiveMQBytesMessage.cpp, LINE: 135\n\nAt the moment of read message size it reads 59768832 against 32 bytes of my message that was sended.", "comments": [], "text": "Problem to recive a BytesMessage \n\nDescription:\nI recive the ByteMessage with wrong information, but if i compile the same progrma with api 3.4.5 it works fine:\n\n\nHere the code: \n\nconst TextMessage* textMessage = dynamic_cast< const TextMessage* >( message );\n            const BytesMessage* bytetMessage = dynamic_cast< const BytesMessage* >( message );\n            //const StreamMessage* bytetMessage = dynamic_cast< const StreamMessage* >( message );\n           \n            string text = \"\";\n            \n            if( textMessage != NULL ) {\n                text = textMessage->getText();\n                std::cout << \"Message \" << count << \" Received: \" << text.c_str() << endl;\n            }\n            else if( bytetMessage != NULL ) {\n                \n                int size = bytetMessage->getBodyLength();\n                \n                std::cout << \"BYTES RECIVIDOS: \" << size << endl;\n                printBytesHex((char*)bytetMessage->getBodyBytes(),size,\"BUFFER\");\n\n\n\nThe probles is:\n\nBYTES RECIVIDOS: 59768832\nMessage Body is Read-Only.\n\tFILE: activemq/commands/ActiveMQBytesMessage.cpp, LINE: 135\n\nAt the moment of read message size it reads 59768832 against 32 bytes of my message that was sended.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Problem to recive a BytesMessage \n\nDescription:\nI recive the ByteMessage with wrong information, but if i compile the same progrma with api 3.4.5 it works fine:\n\n\nHere the code: \n\nconst TextMessage* textMessage = dynamic_cast< const TextMessage* >( message );\n            const BytesMessage* bytetMessage = dynamic_cast< const BytesMessage* >( message );\n            //const StreamMessage* bytetMessage = dynamic_cast< const StreamMessage* >( message );\n           \n            string text = \"\";\n            \n            if( textMessage != NULL ) {\n                text = textMessage->getText();\n                std::cout << \"Message \" << count << \" Received: \" << text.c_str() << endl;\n            }\n            else if( bytetMessage != NULL ) {\n                \n                int size = bytetMessage->getBodyLength();\n                \n                std::cout << \"BYTES RECIVIDOS: \" << size << endl;\n                printBytesHex((char*)bytetMessage->getBodyBytes(),size,\"BUFFER\");\n\n\n\nThe probles is:\n\nBYTES RECIVIDOS: 59768832\nMessage Body is Read-Only.\n\tFILE: activemq/commands/ActiveMQBytesMessage.cpp, LINE: 135\n\nAt the moment of read message size it reads 59768832 against 32 bytes of my message that was sended.\n\n\nComments:\n", "classification": "Classify the issue 'Problem to recive a BytesMessage ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-448?\nA: I recive the ByteMessage with wrong information, but if i compile the same progrma with api 3.4.5 it works fine:\n\n\nHere the code: \n\nconst TextMessage* textMessage = dynamic_cast< const TextMessage* >( message );\n            const BytesMessage* bytetMessage = dynamic_cast< const BytesMessage* >( message );\n            //const StreamMessage* bytetMessage = dynamic_cast< const StreamMessage* >( messa"}}
{"issue_key": "AMQCPP-447", "project": "AMQCPP", "title": "Unix platform, CMS expample client can't communicate with server", "status": "Closed", "reporter": "xue", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-12-15T13:58:52.000+0000", "updated": "2013-01-05T19:16:44.000+0000", "description": "Unix platform, CMS expample client can't communicate with server;But the Windows client can  communicate with server;The server is in the UNIX host,The server is the default configuration,The server's IP address is 192.168.4.124,the connection code changed to connect unix hosts IP.Windows client code and UNIX client code is the same.", "comments": [], "text": "Unix platform, CMS expample client can't communicate with server\n\nDescription:\nUnix platform, CMS expample client can't communicate with server;But the Windows client can  communicate with server;The server is in the UNIX host,The server is the default configuration,The server's IP address is 192.168.4.124,the connection code changed to connect unix hosts IP.Windows client code and UNIX client code is the same.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unix platform, CMS expample client can't communicate with server\n\nDescription:\nUnix platform, CMS expample client can't communicate with server;But the Windows client can  communicate with server;The server is in the UNIX host,The server is the default configuration,The server's IP address is 192.168.4.124,the connection code changed to connect unix hosts IP.Windows client code and UNIX client code is the same.\n\nComments:\n", "classification": "Classify the issue 'Unix platform, CMS expample client can't communicate with server' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-447?\nA: Unix platform, CMS expample client can't communicate with server;But the Windows client can  communicate with server;The server is in the UNIX host,The server is the default configuration,The server's IP address is 192.168.4.124,the connection code changed to connect unix hosts IP.Windows client code and UNIX client code is the same."}}
{"issue_key": "AMQCPP-446", "project": "AMQCPP", "title": "AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads", "status": "Resolved", "reporter": "John Rocha", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-12-14T20:11:46.000+0000", "updated": "2013-01-05T19:18:00.000+0000", "description": "AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nI have a scenario where the AMQ CPP Client (v3.4.5) locks up in\nstopMonitorThreads(), and it somehow seems to be related to the system load.\n\nWe have a product that run on a Linux platform (RH or SUSE) and records video\nstreams. The low level server code is written in C++ and it has a web interface\nwritten in Java and Javascript. We use AMQ to communicate between the two, all\nrunning on the same server.\n\nWhat I've found is it all works well when we have 250 streams and a total disk\nI/O of 74Mbps. However, if we increase to 250 streams with 185Mbps then it\nworks fine for about 1 hour and 20 minutes. After that something happens to the\nbroker and the CPP code has to reconnect. When it tries to reconnect we get\nthis lockup.\n\nI've determined it's an indefinate lock up because the thread has been locked\nfor more than 24 hours. I used GDB to attach and I was able to view the state\nof all the threads. I'm including a sanitized GDB dump.\n\nWe are not using failover when we connect to the broker. We have an\ninfrastructure that stores a boost shared pointer to the connection and checks\nthat the connection is valid before each attempt. If ok then it setups up\neverything to send a message and does so.\n\nIf there's a problem then it drops the shared pointer, which triggers the\ncms:Connection destructor and tries to establish a new connection to the\nbroker.\n\nFrom the stack dump it appears that it is locking up during the Connection's\ndestructor. I've also noticed that there appear to be other AMQ related threads\nrunning (also in the stack dump) although I don't know what they're doing\n(yet).", "comments": [], "text": "AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nDescription:\nAMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nI have a scenario where the AMQ CPP Client (v3.4.5) locks up in\nstopMonitorThreads(), and it somehow seems to be related to the system load.\n\nWe have a product that run on a Linux platform (RH or SUSE) and records video\nstreams. The low level server code is written in C++ and it has a web interface\nwritten in Java and Javascript. We use AMQ to communicate between the two, all\nrunning on the same server.\n\nWhat I've found is it all works well when we have 250 streams and a total disk\nI/O of 74Mbps. However, if we increase to 250 streams with 185Mbps then it\nworks fine for about 1 hour and 20 minutes. After that something happens to the\nbroker and the CPP code has to reconnect. When it tries to reconnect we get\nthis lockup.\n\nI've determined it's an indefinate lock up because the thread has been locked\nfor more than 24 hours. I used GDB to attach and I was able to view the state\nof all the threads. I'm including a sanitized GDB dump.\n\nWe are not using failover when we connect to the broker. We have an\ninfrastructure that stores a boost shared pointer to the connection and checks\nthat the connection is valid before each attempt. If ok then it setups up\neverything to send a message and does so.\n\nIf there's a problem then it drops the shared pointer, which triggers the\ncms:Connection destructor and tries to establish a new connection to the\nbroker.\n\nFrom the stack dump it appears that it is locking up during the Connection's\ndestructor. I've also noticed that there appear to be other AMQ related threads\nrunning (also in the stack dump) although I don't know what they're doing\n(yet).\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nDescription:\nAMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nI have a scenario where the AMQ CPP Client (v3.4.5) locks up in\nstopMonitorThreads(), and it somehow seems to be related to the system load.\n\nWe have a product that run on a Linux platform (RH or SUSE) and records video\nstreams. The low level server code is written in C++ and it has a web interface\nwritten in Java and Javascript. We use AMQ to communicate between the two, all\nrunning on the same server.\n\nWhat I've found is it all works well when we have 250 streams and a total disk\nI/O of 74Mbps. However, if we increase to 250 streams with 185Mbps then it\nworks fine for about 1 hour and 20 minutes. After that something happens to the\nbroker and the CPP code has to reconnect. When it tries to reconnect we get\nthis lockup.\n\nI've determined it's an indefinate lock up because the thread has been locked\nfor more than 24 hours. I used GDB to attach and I was able to view the state\nof all the threads. I'm including a sanitized GDB dump.\n\nWe are not using failover when we connect to the broker. We have an\ninfrastructure that stores a boost shared pointer to the connection and checks\nthat the connection is valid before each attempt. If ok then it setups up\neverything to send a message and does so.\n\nIf there's a problem then it drops the shared pointer, which triggers the\ncms:Connection destructor and tries to establish a new connection to the\nbroker.\n\nFrom the stack dump it appears that it is locking up during the Connection's\ndestructor. I've also noticed that there appear to be other AMQ related threads\nrunning (also in the stack dump) although I don't know what they're doing\n(yet).\n\n\n\nComments:\n", "classification": "Classify the issue 'AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-446?\nA: AMQ CPP Client locks in activemq::transport::inactivity::InactivityMonitor::stopMonitorThreads\n\nI have a scenario where the AMQ CPP Client (v3.4.5) locks up in\nstopMonitorThreads(), and it somehow seems to be related to the system load.\n\nWe have a product that run on a Linux platform (RH or SUSE) and records video\nstreams. The low level server code is written in C++ and it has a web interface\nwrit"}}
{"issue_key": "AMQCPP-445", "project": "AMQCPP", "title": "Prefetch_size = 0 and failover: consumer blocked in receive() when broker restarts", "status": "Resolved", "reporter": "Thomas Riccardi", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["blocked", "consumer", "dequeue", "failover", "prefetch_size", "receive"], "created": "2012-12-11T17:02:41.000+0000", "updated": "2012-12-12T15:50:49.000+0000", "description": "With prefetch_size=0, the consumer.receive() sends a pull request to the broker, and then waits on dequeue() for a new message.\nWith failover, if the broker is restarted after having received the pull request, then the consumer is blocked indefinitely in receive(), and the broker never sends messages to it.\n\n\nHere is the stack of the blocked consumer. It never returned from the first call to receive().\n{quote}\n#0  pthread_cond_wait@@GLIBC_2.3.2 ()\nat ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:162\n#1  0x00007f2528c8fdd7 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x118a024)\nat decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x00007f2528b23075 in activemq::core::SimplePriorityMessageDispatchChannel::dequeue (this=0x1181b40, timeout=-1)\nat activemq/core/SimplePriorityMessageDispatchChannel.cpp:77\n#3  0x00007f2528ad6d78 in activemq::core::ActiveMQConsumer::dequeue (this=0x11892d0, timeout=-1) at activemq/core/ActiveMQConsumer.cpp:553\n#4  0x00007f2528adbef1 in activemq::core::ActiveMQConsumer::receive (this=0x11892d0) at activemq/core/ActiveMQConsumer.cpp:601\n{quote}\n\nIt seems the failover mechanism never notifies the consumer->internal->unconsumedMessages fifo, so the consumer stays blocked on dequeue(), while the new broker doesn't know the consumer has sent a pull request.\n\nI haven't found any use of the callback transportResumed() from the failover transport.\nA solution would be to use this callback to notifyAll() on all consumers internal queues.", "comments": [], "text": "Prefetch_size = 0 and failover: consumer blocked in receive() when broker restarts\n\nDescription:\nWith prefetch_size=0, the consumer.receive() sends a pull request to the broker, and then waits on dequeue() for a new message.\nWith failover, if the broker is restarted after having received the pull request, then the consumer is blocked indefinitely in receive(), and the broker never sends messages to it.\n\n\nHere is the stack of the blocked consumer. It never returned from the first call to receive().\n{quote}\n#0  pthread_cond_wait@@GLIBC_2.3.2 ()\nat ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:162\n#1  0x00007f2528c8fdd7 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x118a024)\nat decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x00007f2528b23075 in activemq::core::SimplePriorityMessageDispatchChannel::dequeue (this=0x1181b40, timeout=-1)\nat activemq/core/SimplePriorityMessageDispatchChannel.cpp:77\n#3  0x00007f2528ad6d78 in activemq::core::ActiveMQConsumer::dequeue (this=0x11892d0, timeout=-1) at activemq/core/ActiveMQConsumer.cpp:553\n#4  0x00007f2528adbef1 in activemq::core::ActiveMQConsumer::receive (this=0x11892d0) at activemq/core/ActiveMQConsumer.cpp:601\n{quote}\n\nIt seems the failover mechanism never notifies the consumer->internal->unconsumedMessages fifo, so the consumer stays blocked on dequeue(), while the new broker doesn't know the consumer has sent a pull request.\n\nI haven't found any use of the callback transportResumed() from the failover transport.\nA solution would be to use this callback to notifyAll() on all consumers internal queues.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Prefetch_size = 0 and failover: consumer blocked in receive() when broker restarts\n\nDescription:\nWith prefetch_size=0, the consumer.receive() sends a pull request to the broker, and then waits on dequeue() for a new message.\nWith failover, if the broker is restarted after having received the pull request, then the consumer is blocked indefinitely in receive(), and the broker never sends messages to it.\n\n\nHere is the stack of the blocked consumer. It never returned from the first call to receive().\n{quote}\n#0  pthread_cond_wait@@GLIBC_2.3.2 ()\nat ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:162\n#1  0x00007f2528c8fdd7 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x118a024)\nat decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x00007f2528b23075 in activemq::core::SimplePriorityMessageDispatchChannel::dequeue (this=0x1181b40, timeout=-1)\nat activemq/core/SimplePriorityMessageDispatchChannel.cpp:77\n#3  0x00007f2528ad6d78 in activemq::core::ActiveMQConsumer::dequeue (this=0x11892d0, timeout=-1) at activemq/core/ActiveMQConsumer.cpp:553\n#4  0x00007f2528adbef1 in activemq::core::ActiveMQConsumer::receive (this=0x11892d0) at activemq/core/ActiveMQConsumer.cpp:601\n{quote}\n\nIt seems the failover mechanism never notifies the consumer->internal->unconsumedMessages fifo, so the consumer stays blocked on dequeue(), while the new broker doesn't know the consumer has sent a pull request.\n\nI haven't found any use of the callback transportResumed() from the failover transport.\nA solution would be to use this callback to notifyAll() on all consumers internal queues.\n\nComments:\n", "classification": "Classify the issue 'Prefetch_size = 0 and failover: consumer blocked in receive() when broker restarts' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-445?\nA: With prefetch_size=0, the consumer.receive() sends a pull request to the broker, and then waits on dequeue() for a new message.\nWith failover, if the broker is restarted after having received the pull request, then the consumer is blocked indefinitely in receive(), and the broker never sends messages to it.\n\n\nHere is the stack of the blocked consumer. It never returned from the first call to recei"}}
{"issue_key": "AMQCPP-444", "project": "AMQCPP", "title": "Exception too general", "status": "Closed", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["exception-reporting", "ssl"], "created": "2012-11-29T20:05:47.000+0000", "updated": "2013-01-05T19:14:31.000+0000", "description": "In decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp the function OpenSSLSocket::write after the call to SSL_write, the switch statement goes across possible errors and throws exceptions if necessary, but there are many more errors that what is checked for.  My program was getting SSL_ERROR_SYSCALL, but was just being thrown as the default.\n\nI added some code, its not the best messages, but you can change that\n\n{noformat}\n\nswitch( SSL_get_error( this->parameters->getSSL(), written ) ) {\n                case SSL_ERROR_NONE:\n                    offset += written;\n                    remaining -= written;\n                    break;\n                case SSL_ERROR_ZERO_RETURN:\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The connection was broken unexpectedly.\" );\n                case SSL_ERROR_WANT_WRITE:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_WRITE.\" );\n                    break;\n                case SSL_ERROR_WANT_READ:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_READ.\" );\n                    break;\n                case SSL_ERROR_WANT_X509_LOOKUP:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was WANT_X509_LOOKUP.\" );\n                    break;\n                case SSL_ERROR_SYSCALL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    fprintf(stderr, \"errno=%d\", errno);\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was ERROR_SYSCALL. ret=%d\", written ); \n                    break;\n                case SSL_ERROR_SSL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was general ERROR_SSL\" );\n                    break;\n                default:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw OpenSSLSocketException( __FILE__, __LINE__, \"Default case, I cannot happen now\" );\n                    break;\n            }\n\n{noformat}\n\nYou also need to include errno.h and openssl/err.h for some for some of the messages I was printing.\nThanks and please add something similar to the trunk if no objection.", "comments": [], "text": "Exception too general\n\nDescription:\nIn decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp the function OpenSSLSocket::write after the call to SSL_write, the switch statement goes across possible errors and throws exceptions if necessary, but there are many more errors that what is checked for.  My program was getting SSL_ERROR_SYSCALL, but was just being thrown as the default.\n\nI added some code, its not the best messages, but you can change that\n\n{noformat}\n\nswitch( SSL_get_error( this->parameters->getSSL(), written ) ) {\n                case SSL_ERROR_NONE:\n                    offset += written;\n                    remaining -= written;\n                    break;\n                case SSL_ERROR_ZERO_RETURN:\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The connection was broken unexpectedly.\" );\n                case SSL_ERROR_WANT_WRITE:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_WRITE.\" );\n                    break;\n                case SSL_ERROR_WANT_READ:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_READ.\" );\n                    break;\n                case SSL_ERROR_WANT_X509_LOOKUP:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was WANT_X509_LOOKUP.\" );\n                    break;\n                case SSL_ERROR_SYSCALL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    fprintf(stderr, \"errno=%d\", errno);\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was ERROR_SYSCALL. ret=%d\", written ); \n                    break;\n                case SSL_ERROR_SSL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was general ERROR_SSL\" );\n                    break;\n                default:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw OpenSSLSocketException( __FILE__, __LINE__, \"Default case, I cannot happen now\" );\n                    break;\n            }\n\n{noformat}\n\nYou also need to include errno.h and openssl/err.h for some for some of the messages I was printing.\nThanks and please add something similar to the trunk if no objection.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception too general\n\nDescription:\nIn decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp the function OpenSSLSocket::write after the call to SSL_write, the switch statement goes across possible errors and throws exceptions if necessary, but there are many more errors that what is checked for.  My program was getting SSL_ERROR_SYSCALL, but was just being thrown as the default.\n\nI added some code, its not the best messages, but you can change that\n\n{noformat}\n\nswitch( SSL_get_error( this->parameters->getSSL(), written ) ) {\n                case SSL_ERROR_NONE:\n                    offset += written;\n                    remaining -= written;\n                    break;\n                case SSL_ERROR_ZERO_RETURN:\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The connection was broken unexpectedly.\" );\n                case SSL_ERROR_WANT_WRITE:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_WRITE.\" );\n                    break;\n                case SSL_ERROR_WANT_READ:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The exception was WANT_READ.\" );\n                    break;\n                case SSL_ERROR_WANT_X509_LOOKUP:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was WANT_X509_LOOKUP.\" );\n                    break;\n                case SSL_ERROR_SYSCALL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    fprintf(stderr, \"errno=%d\", errno);\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was ERROR_SYSCALL. ret=%d\", written ); \n                    break;\n                case SSL_ERROR_SSL:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw SocketException(\n                        __FILE__, __LINE__,\n                        \"The Exception was general ERROR_SSL\" );\n                    break;\n                default:\n                    fprintf(stderr, \"Err_get_error()=%d\\n\", ERR_get_error());\n                    throw OpenSSLSocketException( __FILE__, __LINE__, \"Default case, I cannot happen now\" );\n                    break;\n            }\n\n{noformat}\n\nYou also need to include errno.h and openssl/err.h for some for some of the messages I was printing.\nThanks and please add something similar to the trunk if no objection.\n\nComments:\n", "classification": "Classify the issue 'Exception too general' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-444?\nA: In decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp the function OpenSSLSocket::write after the call to SSL_write, the switch statement goes across possible errors and throws exceptions if necessary, but there are many more errors that what is checked for.  My program was getting SSL_ERROR_SYSCALL, but was just being thrown as the default.\n\nI added some code, its not the best messages, but you can"}}
{"issue_key": "AMQCPP-443", "project": "AMQCPP", "title": "Configure adding invalid option", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["compilation", "configure", "error"], "created": "2012-11-26T19:53:31.000+0000", "updated": "2012-11-26T20:10:42.000+0000", "description": "in configure script under the section *hpux11*, it sets \nPLAT_CXXFLAGS=\"-Wc,-ansi_for_scope,on\"\nI dont know where this is a valid option, but it is not on my system and this causes problems.  I change this to \nPLAT_CXXFLAGS=\"-AA\"\n\nand this seems to work fine\n\nPlease add on trunk", "comments": [], "text": "Configure adding invalid option\n\nDescription:\nin configure script under the section *hpux11*, it sets \nPLAT_CXXFLAGS=\"-Wc,-ansi_for_scope,on\"\nI dont know where this is a valid option, but it is not on my system and this causes problems.  I change this to \nPLAT_CXXFLAGS=\"-AA\"\n\nand this seems to work fine\n\nPlease add on trunk\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Configure adding invalid option\n\nDescription:\nin configure script under the section *hpux11*, it sets \nPLAT_CXXFLAGS=\"-Wc,-ansi_for_scope,on\"\nI dont know where this is a valid option, but it is not on my system and this causes problems.  I change this to \nPLAT_CXXFLAGS=\"-AA\"\n\nand this seems to work fine\n\nPlease add on trunk\n\nComments:\n", "classification": "Classify the issue 'Configure adding invalid option' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-443?\nA: in configure script under the section *hpux11*, it sets \nPLAT_CXXFLAGS=\"-Wc,-ansi_for_scope,on\"\nI dont know where this is a valid option, but it is not on my system and this causes problems.  I change this to \nPLAT_CXXFLAGS=\"-AA\"\n\nand this seems to work fine\n\nPlease add on trunk"}}
{"issue_key": "AMQCPP-442", "project": "AMQCPP", "title": "Segfaults, aborts in ActiveMQConnection::close()/InactivityMonitor::close()", "status": "Resolved", "reporter": "Geoff Simmons", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-11-25T18:18:18.000+0000", "updated": "2013-01-05T19:15:36.000+0000", "description": "I'm working on a C application that uses AMQ-CPP 3.4.4 to send messages to an ActiveMQ broker. The app encompasses a C++ class that encapsulates the MessageProducer and ActiveMQ connection, and it uses an instance of the class in each of a group of worker threads (Unix pthreads) that send the messages (I'll attach the header and CPP source for the class). I've been testing with 10, 15 and 20 worker threads.\n\nThe app is experiencing intermittent crashes in the destructor for activemq::core::ActiveMQConnection, when ActiveMQConnection::close() is called (when it's time to shut down the app's worker threads). In the lowest levels of the stacktrace, there is apparently an attempt to free or move unallocated memory, causing either a segfault or abort (I'll also attach stack traces). Most of the time, the connection closes normally; I haven't been able to identify circumstances under which the crashes occur.\n\nI'm new to AMQ-CPP, but here's my guess as to what's happening: as a part of the connection close, activemq::transport::inactivity::InactivityMonitor::close() is called. That in turn calls activemq::threads::CompositeTaskRunner::shutdown(), which calls decaf::lang::Thread::currentThread(). currentThread() calls pthread_getspecific() with the key currentThreadKey, which returns NULL, so Thread::createForeignThreadInstance() is called. But that doesn't seem right -- the connection is being closed so that the current pthread can be shut down.\n\nAt any rate, the stacktrace after the crashes have always included InactivityMonitor::close() -> CompositeTaskRunner::shutdown() -> Thread::currentThread() -> Thread::createForeignThreadInstance().\n\nOf course, I may be setting things up incorrectly. Is there an assumption that ActiveMQConnections are called from decaf Threads, rather than from pthreads in C?\n\nThe problem is not critical because the app is about to shut down anyway. As a workaround to prevent connection closes before shutdown, I'm using wireFormat.maxInactivityDuration=0 in the MQ URI.\n\nlibactivemq was built from source.", "comments": [], "text": "Segfaults, aborts in ActiveMQConnection::close()/InactivityMonitor::close()\n\nDescription:\nI'm working on a C application that uses AMQ-CPP 3.4.4 to send messages to an ActiveMQ broker. The app encompasses a C++ class that encapsulates the MessageProducer and ActiveMQ connection, and it uses an instance of the class in each of a group of worker threads (Unix pthreads) that send the messages (I'll attach the header and CPP source for the class). I've been testing with 10, 15 and 20 worker threads.\n\nThe app is experiencing intermittent crashes in the destructor for activemq::core::ActiveMQConnection, when ActiveMQConnection::close() is called (when it's time to shut down the app's worker threads). In the lowest levels of the stacktrace, there is apparently an attempt to free or move unallocated memory, causing either a segfault or abort (I'll also attach stack traces). Most of the time, the connection closes normally; I haven't been able to identify circumstances under which the crashes occur.\n\nI'm new to AMQ-CPP, but here's my guess as to what's happening: as a part of the connection close, activemq::transport::inactivity::InactivityMonitor::close() is called. That in turn calls activemq::threads::CompositeTaskRunner::shutdown(), which calls decaf::lang::Thread::currentThread(). currentThread() calls pthread_getspecific() with the key currentThreadKey, which returns NULL, so Thread::createForeignThreadInstance() is called. But that doesn't seem right -- the connection is being closed so that the current pthread can be shut down.\n\nAt any rate, the stacktrace after the crashes have always included InactivityMonitor::close() -> CompositeTaskRunner::shutdown() -> Thread::currentThread() -> Thread::createForeignThreadInstance().\n\nOf course, I may be setting things up incorrectly. Is there an assumption that ActiveMQConnections are called from decaf Threads, rather than from pthreads in C?\n\nThe problem is not critical because the app is about to shut down anyway. As a workaround to prevent connection closes before shutdown, I'm using wireFormat.maxInactivityDuration=0 in the MQ URI.\n\nlibactivemq was built from source.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segfaults, aborts in ActiveMQConnection::close()/InactivityMonitor::close()\n\nDescription:\nI'm working on a C application that uses AMQ-CPP 3.4.4 to send messages to an ActiveMQ broker. The app encompasses a C++ class that encapsulates the MessageProducer and ActiveMQ connection, and it uses an instance of the class in each of a group of worker threads (Unix pthreads) that send the messages (I'll attach the header and CPP source for the class). I've been testing with 10, 15 and 20 worker threads.\n\nThe app is experiencing intermittent crashes in the destructor for activemq::core::ActiveMQConnection, when ActiveMQConnection::close() is called (when it's time to shut down the app's worker threads). In the lowest levels of the stacktrace, there is apparently an attempt to free or move unallocated memory, causing either a segfault or abort (I'll also attach stack traces). Most of the time, the connection closes normally; I haven't been able to identify circumstances under which the crashes occur.\n\nI'm new to AMQ-CPP, but here's my guess as to what's happening: as a part of the connection close, activemq::transport::inactivity::InactivityMonitor::close() is called. That in turn calls activemq::threads::CompositeTaskRunner::shutdown(), which calls decaf::lang::Thread::currentThread(). currentThread() calls pthread_getspecific() with the key currentThreadKey, which returns NULL, so Thread::createForeignThreadInstance() is called. But that doesn't seem right -- the connection is being closed so that the current pthread can be shut down.\n\nAt any rate, the stacktrace after the crashes have always included InactivityMonitor::close() -> CompositeTaskRunner::shutdown() -> Thread::currentThread() -> Thread::createForeignThreadInstance().\n\nOf course, I may be setting things up incorrectly. Is there an assumption that ActiveMQConnections are called from decaf Threads, rather than from pthreads in C?\n\nThe problem is not critical because the app is about to shut down anyway. As a workaround to prevent connection closes before shutdown, I'm using wireFormat.maxInactivityDuration=0 in the MQ URI.\n\nlibactivemq was built from source.\n\nComments:\n", "classification": "Classify the issue 'Segfaults, aborts in ActiveMQConnection::close()/InactivityMonitor::close()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-442?\nA: I'm working on a C application that uses AMQ-CPP 3.4.4 to send messages to an ActiveMQ broker. The app encompasses a C++ class that encapsulates the MessageProducer and ActiveMQ connection, and it uses an instance of the class in each of a group of worker threads (Unix pthreads) that send the messages (I'll attach the header and CPP source for the class). I've been testing with 10, 15 and 20 worke"}}
{"issue_key": "AMQCPP-441", "project": "AMQCPP", "title": "Incorrect propagation of AMQ-2489 to CMS/C++ (causes performance degradation) in r833769.", "status": "Resolved", "reporter": "Sean J Donovan", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-11-20T19:16:53.000+0000", "updated": "2012-11-28T18:44:27.000+0000", "description": "With CMS/C++ V3.4.5 (and a snapshot of V3.5.0) I was getting the symptom reported in AMQ-2489.  I found that this occurs in CMS/C++ when you have a consumer prefetch value of 1 or 2.  The exception doesn't happen when prefetch is > 2.  Although the exception can be ignored, it **does** affect performance significantly.  \n\nI did some research, I think there is a bug in how AMQ-2489 was propagated to CMS/C++.\n\nThe problem was introduced here:\n\n   src/main/activemq/core/ActiveMQConsumer.cpp (r833769)\n\nThe link to that version of the file is here:\n\nhttp://svn.apache.org/viewvc/activemq/activemq-cpp/trunk/activemq-cpp/src/main/activemq/core/ActiveMQConsumer.cpp?revision=883469&view=markup\n\nI think that line #595 **shouldn't** exist.  That line is:\n\n   ackLater( message, ActiveMQConstants::ACK_TYPE_DELIVERED );\n\nThis link contains details on the original Java fix:\n\nhttp://mail-archives.apache.org/mod_mbox/activemq-commits/200911.mbox/%3C20091123184303.EBB2D23889C5@eris.apache.org%3E\n\n. . . in the code changes to ActiveMQMessageConsumer.java, you'll notice \nthat the following line was **removed**:\n\n      -                ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n\nThus, I believe the propogation was incorrect.  Fortunately, the fix is simple.  The code has been refactored for V3.5.0 and I'm not sure where the logic has moved to -- should be easy to find.\n\nSean", "comments": [], "text": "Incorrect propagation of AMQ-2489 to CMS/C++ (causes performance degradation) in r833769.\n\nDescription:\nWith CMS/C++ V3.4.5 (and a snapshot of V3.5.0) I was getting the symptom reported in AMQ-2489.  I found that this occurs in CMS/C++ when you have a consumer prefetch value of 1 or 2.  The exception doesn't happen when prefetch is > 2.  Although the exception can be ignored, it **does** affect performance significantly.  \n\nI did some research, I think there is a bug in how AMQ-2489 was propagated to CMS/C++.\n\nThe problem was introduced here:\n\n   src/main/activemq/core/ActiveMQConsumer.cpp (r833769)\n\nThe link to that version of the file is here:\n\nhttp://svn.apache.org/viewvc/activemq/activemq-cpp/trunk/activemq-cpp/src/main/activemq/core/ActiveMQConsumer.cpp?revision=883469&view=markup\n\nI think that line #595 **shouldn't** exist.  That line is:\n\n   ackLater( message, ActiveMQConstants::ACK_TYPE_DELIVERED );\n\nThis link contains details on the original Java fix:\n\nhttp://mail-archives.apache.org/mod_mbox/activemq-commits/200911.mbox/%3C20091123184303.EBB2D23889C5@eris.apache.org%3E\n\n. . . in the code changes to ActiveMQMessageConsumer.java, you'll notice \nthat the following line was **removed**:\n\n      -                ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n\nThus, I believe the propogation was incorrect.  Fortunately, the fix is simple.  The code has been refactored for V3.5.0 and I'm not sure where the logic has moved to -- should be easy to find.\n\nSean\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Incorrect propagation of AMQ-2489 to CMS/C++ (causes performance degradation) in r833769.\n\nDescription:\nWith CMS/C++ V3.4.5 (and a snapshot of V3.5.0) I was getting the symptom reported in AMQ-2489.  I found that this occurs in CMS/C++ when you have a consumer prefetch value of 1 or 2.  The exception doesn't happen when prefetch is > 2.  Although the exception can be ignored, it **does** affect performance significantly.  \n\nI did some research, I think there is a bug in how AMQ-2489 was propagated to CMS/C++.\n\nThe problem was introduced here:\n\n   src/main/activemq/core/ActiveMQConsumer.cpp (r833769)\n\nThe link to that version of the file is here:\n\nhttp://svn.apache.org/viewvc/activemq/activemq-cpp/trunk/activemq-cpp/src/main/activemq/core/ActiveMQConsumer.cpp?revision=883469&view=markup\n\nI think that line #595 **shouldn't** exist.  That line is:\n\n   ackLater( message, ActiveMQConstants::ACK_TYPE_DELIVERED );\n\nThis link contains details on the original Java fix:\n\nhttp://mail-archives.apache.org/mod_mbox/activemq-commits/200911.mbox/%3C20091123184303.EBB2D23889C5@eris.apache.org%3E\n\n. . . in the code changes to ActiveMQMessageConsumer.java, you'll notice \nthat the following line was **removed**:\n\n      -                ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n\nThus, I believe the propogation was incorrect.  Fortunately, the fix is simple.  The code has been refactored for V3.5.0 and I'm not sure where the logic has moved to -- should be easy to find.\n\nSean\n\n\n\nComments:\n", "classification": "Classify the issue 'Incorrect propagation of AMQ-2489 to CMS/C++ (causes performance degradation) in r833769.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-441?\nA: With CMS/C++ V3.4.5 (and a snapshot of V3.5.0) I was getting the symptom reported in AMQ-2489.  I found that this occurs in CMS/C++ when you have a consumer prefetch value of 1 or 2.  The exception doesn't happen when prefetch is > 2.  Although the exception can be ignored, it **does** affect performance significantly.  \n\nI did some research, I think there is a bug in how AMQ-2489 was propagated t"}}
{"issue_key": "AMQCPP-440", "project": "AMQCPP", "title": "Compilation/archive error - activemq-cpp library 3.4.5 make complains about ranlib", "status": "Closed", "reporter": "Suresh Velupula", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-11-16T16:38:35.000+0000", "updated": "2012-12-08T16:58:17.000+0000", "description": "Problem while running make while creating archive.. Complains about ranlib.\n\n/.libs/libactivemq_cpp_la-OpenSSLContextSpi.o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLParameters.o ... decaf/util/zip/.libs/libactivemq_cpp_la-InflaterInputStream.o decaf/util/zip/.libs/libactivemq_cpp_la-ZipException.o  -Wl,-rpath -Wl,/usr/local/suresh/lib -Wl,-rpath -Wl,/usr/local/suresh/lib /usr/local/suresh/lib/libapr-1.so -luuid -lrt -lcrypt /usr/local/suresh/lib/libaprutil-1.so /usr/lib/libexpat.so -lssl -lcrypto -lgssapi_krb5 -lkrb5 -lcom_err -lk5crypto -lresolv -ldl -lz -L/usr/kerberos/lib -lpthread -L/usr/lib/gcc/i386-redhat-linux/3.4.6 -L/usr/lib/gcc/i386-redhat-linux/3.4.6/../../.. -lstdc++ -lm -lc -lgcc_s /usr/lib/gcc/i386-redhat-linux/3.4.6/crtendS.o /usr/lib/gcc/i386-redhat-linux/3.4.6/../../../crtn.o  -pthread -Wl,-soname -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\n(cd .libs && rm -f libactivemq-cpp.so.14 && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so.14)\n(cd .libs && rm -f libactivemq-cpp.so && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so)\ncopying selected object files to avoid basename conflicts...\nrm -fr .libs/libactivemq-cpp.lax\nmkdir .libs/libactivemq-cpp.lax\nln cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o || cp cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o\nln decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o || cp decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o\nln decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o || cp decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o\nar cru .libs/libactivemq-cpp.a ... decaf/util/zip/libactivemq_cpp_la-ZipException.o\nranlib\nUsage: ranlib [options] archive\n Generate an index to speed access to archives\n The options are:\n  -h --help                    Print this help message\n  -V --version                 Print version information\nranlib: supported targets: elf32-i386 a.out-i386-linux efi-app-ia32 elf32-little elf32-big srec symbolsrec tekhex binary ihex trad-core\nmake[2]: *** [libactivemq-cpp.la] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.5/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.5'\nmake: *** [all] Error 2\n[activemq-cpp-library-3.4.5]#", "comments": [], "text": "Compilation/archive error - activemq-cpp library 3.4.5 make complains about ranlib\n\nDescription:\nProblem while running make while creating archive.. Complains about ranlib.\n\n/.libs/libactivemq_cpp_la-OpenSSLContextSpi.o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLParameters.o ... decaf/util/zip/.libs/libactivemq_cpp_la-InflaterInputStream.o decaf/util/zip/.libs/libactivemq_cpp_la-ZipException.o  -Wl,-rpath -Wl,/usr/local/suresh/lib -Wl,-rpath -Wl,/usr/local/suresh/lib /usr/local/suresh/lib/libapr-1.so -luuid -lrt -lcrypt /usr/local/suresh/lib/libaprutil-1.so /usr/lib/libexpat.so -lssl -lcrypto -lgssapi_krb5 -lkrb5 -lcom_err -lk5crypto -lresolv -ldl -lz -L/usr/kerberos/lib -lpthread -L/usr/lib/gcc/i386-redhat-linux/3.4.6 -L/usr/lib/gcc/i386-redhat-linux/3.4.6/../../.. -lstdc++ -lm -lc -lgcc_s /usr/lib/gcc/i386-redhat-linux/3.4.6/crtendS.o /usr/lib/gcc/i386-redhat-linux/3.4.6/../../../crtn.o  -pthread -Wl,-soname -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\n(cd .libs && rm -f libactivemq-cpp.so.14 && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so.14)\n(cd .libs && rm -f libactivemq-cpp.so && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so)\ncopying selected object files to avoid basename conflicts...\nrm -fr .libs/libactivemq-cpp.lax\nmkdir .libs/libactivemq-cpp.lax\nln cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o || cp cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o\nln decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o || cp decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o\nln decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o || cp decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o\nar cru .libs/libactivemq-cpp.a ... decaf/util/zip/libactivemq_cpp_la-ZipException.o\nranlib\nUsage: ranlib [options] archive\n Generate an index to speed access to archives\n The options are:\n  -h --help                    Print this help message\n  -V --version                 Print version information\nranlib: supported targets: elf32-i386 a.out-i386-linux efi-app-ia32 elf32-little elf32-big srec symbolsrec tekhex binary ihex trad-core\nmake[2]: *** [libactivemq-cpp.la] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.5/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.5'\nmake: *** [all] Error 2\n[activemq-cpp-library-3.4.5]#\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation/archive error - activemq-cpp library 3.4.5 make complains about ranlib\n\nDescription:\nProblem while running make while creating archive.. Complains about ranlib.\n\n/.libs/libactivemq_cpp_la-OpenSSLContextSpi.o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLParameters.o ... decaf/util/zip/.libs/libactivemq_cpp_la-InflaterInputStream.o decaf/util/zip/.libs/libactivemq_cpp_la-ZipException.o  -Wl,-rpath -Wl,/usr/local/suresh/lib -Wl,-rpath -Wl,/usr/local/suresh/lib /usr/local/suresh/lib/libapr-1.so -luuid -lrt -lcrypt /usr/local/suresh/lib/libaprutil-1.so /usr/lib/libexpat.so -lssl -lcrypto -lgssapi_krb5 -lkrb5 -lcom_err -lk5crypto -lresolv -ldl -lz -L/usr/kerberos/lib -lpthread -L/usr/lib/gcc/i386-redhat-linux/3.4.6 -L/usr/lib/gcc/i386-redhat-linux/3.4.6/../../.. -lstdc++ -lm -lc -lgcc_s /usr/lib/gcc/i386-redhat-linux/3.4.6/crtendS.o /usr/lib/gcc/i386-redhat-linux/3.4.6/../../../crtn.o  -pthread -Wl,-soname -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\n(cd .libs && rm -f libactivemq-cpp.so.14 && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so.14)\n(cd .libs && rm -f libactivemq-cpp.so && ln -s libactivemq-cpp.so.14.0.4 libactivemq-cpp.so)\ncopying selected object files to avoid basename conflicts...\nrm -fr .libs/libactivemq-cpp.lax\nmkdir .libs/libactivemq-cpp.lax\nln cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o || cp cms/libactivemq_cpp_la-Message.o .libs/libactivemq-cpp.lax/lt1-libactivemq_cpp_la-Message.o\nln decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o || cp decaf/internal/util/libactivemq_cpp_la-ResourceLifecycleManager.o .libs/libactivemq-cpp.lax/lt2-libactivemq_cpp_la-ResourceLifecycleManager.o\nln decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o || cp decaf/util/libactivemq_cpp_la-Queue.o .libs/libactivemq-cpp.lax/lt3-libactivemq_cpp_la-Queue.o\nar cru .libs/libactivemq-cpp.a ... decaf/util/zip/libactivemq_cpp_la-ZipException.o\nranlib\nUsage: ranlib [options] archive\n Generate an index to speed access to archives\n The options are:\n  -h --help                    Print this help message\n  -V --version                 Print version information\nranlib: supported targets: elf32-i386 a.out-i386-linux efi-app-ia32 elf32-little elf32-big srec symbolsrec tekhex binary ihex trad-core\nmake[2]: *** [libactivemq-cpp.la] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.5/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.5'\nmake: *** [all] Error 2\n[activemq-cpp-library-3.4.5]#\n\nComments:\n", "classification": "Classify the issue 'Compilation/archive error - activemq-cpp library 3.4.5 make complains about ranlib' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-440?\nA: Problem while running make while creating archive.. Complains about ranlib.\n\n/.libs/libactivemq_cpp_la-OpenSSLContextSpi.o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLParameters.o ... decaf/util/zip/.libs/libactivemq_cpp_la-InflaterInputStream.o decaf/util/zip/.libs/libactivemq_cpp_la-ZipException.o  -Wl,-rpath -Wl,/usr/local/suresh/lib -Wl,-rpath -Wl,/usr/local/suresh/lib /usr/"}}
{"issue_key": "AMQCPP-439", "project": "AMQCPP", "title": "Compilation error - activemq-cpp library 3.4.1 - invalid conversion from \"const unsigned char**\" to \"unsigned char**\"", "status": "Closed", "reporter": "Suresh Velupula", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-11-15T23:49:48.000+0000", "updated": "2013-07-12T12:55:49.000+0000", "description": "Compilation error while building activemq-cpp-library 3.4.1. \n\n[activemq-cpp-library-3.4.1]# make\nmake  all-recursive\nmake[1]: Entering directory `/suresh/activemq-cpp-library-3.4.1'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/activemq-cpp-library-3.4.1/src/main'\n/bin/sh ../../libtool --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/usr/local/suresh/include/apr-1   -I/usr/local/suresh/include/apr-1  -I/usr/kerberos/include   -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c -o decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo `test -f 'decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp' || echo './'`decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp\n g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/usr/local/suresh/include/apr-1 -I/usr/local/suresh/include/apr-1 -I/usr/kerberos/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp  -fPIC -DPIC -o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLSocket.o\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp: In member function `void decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(const std::string&)':\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:679: error: invalid conversion from `const unsigned char**' to `unsigned char**'\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:680: error: invalid conversion from `const unsigned char**' to `unsigned char**'\nmake[2]: *** [decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.1/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.1'\nmake: *** [all] Error 2", "comments": [], "text": "Compilation error - activemq-cpp library 3.4.1 - invalid conversion from \"const unsigned char**\" to \"unsigned char**\"\n\nDescription:\nCompilation error while building activemq-cpp-library 3.4.1. \n\n[activemq-cpp-library-3.4.1]# make\nmake  all-recursive\nmake[1]: Entering directory `/suresh/activemq-cpp-library-3.4.1'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/activemq-cpp-library-3.4.1/src/main'\n/bin/sh ../../libtool --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/usr/local/suresh/include/apr-1   -I/usr/local/suresh/include/apr-1  -I/usr/kerberos/include   -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c -o decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo `test -f 'decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp' || echo './'`decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp\n g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/usr/local/suresh/include/apr-1 -I/usr/local/suresh/include/apr-1 -I/usr/kerberos/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp  -fPIC -DPIC -o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLSocket.o\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp: In member function `void decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(const std::string&)':\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:679: error: invalid conversion from `const unsigned char**' to `unsigned char**'\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:680: error: invalid conversion from `const unsigned char**' to `unsigned char**'\nmake[2]: *** [decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.1/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.1'\nmake: *** [all] Error 2\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation error - activemq-cpp library 3.4.1 - invalid conversion from \"const unsigned char**\" to \"unsigned char**\"\n\nDescription:\nCompilation error while building activemq-cpp-library 3.4.1. \n\n[activemq-cpp-library-3.4.1]# make\nmake  all-recursive\nmake[1]: Entering directory `/suresh/activemq-cpp-library-3.4.1'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/activemq-cpp-library-3.4.1/src/main'\n/bin/sh ../../libtool --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/usr/local/suresh/include/apr-1   -I/usr/local/suresh/include/apr-1  -I/usr/kerberos/include   -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c -o decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo `test -f 'decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp' || echo './'`decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp\n g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/usr/local/suresh/include/apr-1 -I/usr/local/suresh/include/apr-1 -I/usr/kerberos/include -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo -MD -MP -MF decaf/internal/net/ssl/openssl/.deps/libactivemq_cpp_la-OpenSSLSocket.Tpo -c decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp  -fPIC -DPIC -o decaf/internal/net/ssl/openssl/.libs/libactivemq_cpp_la-OpenSSLSocket.o\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp: In member function `void decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(const std::string&)':\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:679: error: invalid conversion from `const unsigned char**' to `unsigned char**'\ndecaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:680: error: invalid conversion from `const unsigned char**' to `unsigned char**'\nmake[2]: *** [decaf/internal/net/ssl/openssl/libactivemq_cpp_la-OpenSSLSocket.lo] Error 1\nmake[2]: Leaving directory `/suresh/activemq-cpp-library-3.4.1/src/main'\nmake[1]: *** [all-recursive] Error 1\nmake[1]: Leaving directory `/suresh/activemq-cpp-library-3.4.1'\nmake: *** [all] Error 2\n\n\nComments:\n", "classification": "Classify the issue 'Compilation error - activemq-cpp library 3.4.1 - invalid conversion from \"const unsigned char**\" to \"unsigned char**\"' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-439?\nA: Compilation error while building activemq-cpp-library 3.4.1. \n\n[activemq-cpp-library-3.4.1]# make\nmake  all-recursive\nmake[1]: Entering directory `/suresh/activemq-cpp-library-3.4.1'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/activemq-cpp-library-3.4.1/src/main'\n/bin/sh ../../libtool --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENT"}}
{"issue_key": "AMQCPP-438", "project": "AMQCPP", "title": "ssl doesnt match the hostname when there are multiple CN's", "status": "Closed", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["decaf", "hostname", "ssl"], "created": "2012-11-13T16:10:53.000+0000", "updated": "2013-04-26T22:31:15.000+0000", "description": "If the ssl certificate on the server has its hostname in the cn field to be compatable, but it also has other cn's on the same entry, which openssl allows and we always use for all of our certificates, the file OpenSSLSocket.cpp finds that they do not match.\nIt is only checking one item, so it is not iterating through different cn's.  This sometimes returns the error that the servers certificate did not match the hostname, and sometimes it simply says that peer did not send his wireformat.  This has no doesnt have an option to diable it like in NMS, at least not that I ahave found.", "comments": [], "text": "ssl doesnt match the hostname when there are multiple CN's\n\nDescription:\nIf the ssl certificate on the server has its hostname in the cn field to be compatable, but it also has other cn's on the same entry, which openssl allows and we always use for all of our certificates, the file OpenSSLSocket.cpp finds that they do not match.\nIt is only checking one item, so it is not iterating through different cn's.  This sometimes returns the error that the servers certificate did not match the hostname, and sometimes it simply says that peer did not send his wireformat.  This has no doesnt have an option to diable it like in NMS, at least not that I ahave found.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ssl doesnt match the hostname when there are multiple CN's\n\nDescription:\nIf the ssl certificate on the server has its hostname in the cn field to be compatable, but it also has other cn's on the same entry, which openssl allows and we always use for all of our certificates, the file OpenSSLSocket.cpp finds that they do not match.\nIt is only checking one item, so it is not iterating through different cn's.  This sometimes returns the error that the servers certificate did not match the hostname, and sometimes it simply says that peer did not send his wireformat.  This has no doesnt have an option to diable it like in NMS, at least not that I ahave found.\n\nComments:\n", "classification": "Classify the issue 'ssl doesnt match the hostname when there are multiple CN's' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-438?\nA: If the ssl certificate on the server has its hostname in the cn field to be compatable, but it also has other cn's on the same entry, which openssl allows and we always use for all of our certificates, the file OpenSSLSocket.cpp finds that they do not match.\nIt is only checking one item, so it is not iterating through different cn's.  This sometimes returns the error that the servers certificate d"}}
{"issue_key": "AMQCPP-437", "project": "AMQCPP", "title": "ActiveMQ crashes on subscribing one listener on several topics with a same session.", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-10-25T15:19:37.000+0000", "updated": "2012-10-26T19:30:36.000+0000", "description": "ActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nIt crashes on freeing an object in ActiveMQSessionExecutor::wakeup() and ActiveMQSessionExecutor::stop().\n\nEach time that a listener is subscribed to a topic, ActiveMQ stops the session. In ActiveMQSessionExecutor::stop(), the shared pointer (this->taskRunner) is read but in the same time the shared pointer can be modified by ActiveMQSessionExecutor::wakeup() when a message is received from the topic. Reading and modifying a shared pointer is not thread safe and should be protected by a mutex.\n\nI've attached a test case and a proposal patch.", "comments": [], "text": "ActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nDescription:\nActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nIt crashes on freeing an object in ActiveMQSessionExecutor::wakeup() and ActiveMQSessionExecutor::stop().\n\nEach time that a listener is subscribed to a topic, ActiveMQ stops the session. In ActiveMQSessionExecutor::stop(), the shared pointer (this->taskRunner) is read but in the same time the shared pointer can be modified by ActiveMQSessionExecutor::wakeup() when a message is received from the topic. Reading and modifying a shared pointer is not thread safe and should be protected by a mutex.\n\nI've attached a test case and a proposal patch.\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nDescription:\nActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nIt crashes on freeing an object in ActiveMQSessionExecutor::wakeup() and ActiveMQSessionExecutor::stop().\n\nEach time that a listener is subscribed to a topic, ActiveMQ stops the session. In ActiveMQSessionExecutor::stop(), the shared pointer (this->taskRunner) is read but in the same time the shared pointer can be modified by ActiveMQSessionExecutor::wakeup() when a message is received from the topic. Reading and modifying a shared pointer is not thread safe and should be protected by a mutex.\n\nI've attached a test case and a proposal patch.\n\n\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ crashes on subscribing one listener on several topics with a same session.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-437?\nA: ActiveMQ crashes on subscribing one listener on several topics with a same session.\n\nIt crashes on freeing an object in ActiveMQSessionExecutor::wakeup() and ActiveMQSessionExecutor::stop().\n\nEach time that a listener is subscribed to a topic, ActiveMQ stops the session. In ActiveMQSessionExecutor::stop(), the shared pointer (this->taskRunner) is read but in the same time the shared pointer can be"}}
{"issue_key": "AMQCPP-436", "project": "AMQCPP", "title": "Add MessageAvailableListener to CMS API", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2012-10-15T22:26:34.000+0000", "updated": "2012-10-15T22:27:22.000+0000", "description": "", "comments": [], "text": "Add MessageAvailableListener to CMS API\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add MessageAvailableListener to CMS API\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Add MessageAvailableListener to CMS API' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-436?\nA: "}}
{"issue_key": "AMQCPP-435", "project": "AMQCPP", "title": " Support doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-10-11T22:38:45.000+0000", "updated": "2012-10-15T20:19:53.000+0000", "description": "Add Support for doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker.  This is a port of AMQ-3679.", "comments": [], "text": "Support doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker \n\nDescription:\nAdd Support for doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker.  This is a port of AMQ-3679.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue:  Support doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker \n\nDescription:\nAdd Support for doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker.  This is a port of AMQ-3679.\n\nComments:\n", "classification": "Classify the issue ' Support doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-435?\nA: Add Support for doing non-blocking sends that uses an async callback that gets notified when the send has been received by the broker.  This is a port of AMQ-3679."}}
{"issue_key": "AMQCPP-434", "project": "AMQCPP", "title": "Compilation error on Solaris", "status": "Closed", "reporter": "S R", "assignee": "Unassigned", "priority": "Minor", "labels": [], "created": "2012-10-10T20:19:35.000+0000", "updated": "2012-11-28T18:45:39.000+0000", "description": "SUN Solaris 10\n\nCMS Version : activemq-cpp-library-3.4.3\n\ncc: Sun WorkShop 6 update 2 C 5.3 2001/05/15\n\nOpenSSL 0.9.7d 17 Mar 2004 (+ security fixes for: CVE-2005-2969 CVE-2006-2937 CVE-2006-2940 CVE-2006-3738 CVE-2006-4339 CVE-2006-4343 CVE-2007-5135 CVE-2008-5077)\n\n>make\nmake  all-recursive\nMaking all in src/main\nsource='activemq/cmsutil/CmsAccessor.cpp' object='activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo' libtool=yes \\\nDEPDIR=.deps depmode=none /bin/bash ../../config/depcomp \\\n/bin/bash ../../libtool  --tag=CXX   --mode=compile CC -DHAVE_CONFIG_H -I. -I../..    -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/dev/apr-1.4.5/solaris/include/apr-1   -I/dev/apr-util-1.3.12/solaris/include/apr-1  -I/usr/sfw/include   -PIC -g -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=stlport4 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/dev/apr-1.4.5/solaris/include/apr-1 -I/dev/apr-util-1.3.12/solaris/include/apr-1 -I/usr/sfw/include -PIC -g -c activemq/cmsutil/CmsAccessor.cpp  -KPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nCC: Warning: illegal option stlport4 ignored\n\"./decaf/util/LinkedList.h\", line 63: Error: decaf::util::LinkedList<cms::Connection*> is not a direct base class of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> to public.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Use \";\" to terminate declarations.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: \"}\" expected instead of \"<\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> because of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.", "comments": [], "text": "Compilation error on Solaris\n\nDescription:\nSUN Solaris 10\n\nCMS Version : activemq-cpp-library-3.4.3\n\ncc: Sun WorkShop 6 update 2 C 5.3 2001/05/15\n\nOpenSSL 0.9.7d 17 Mar 2004 (+ security fixes for: CVE-2005-2969 CVE-2006-2937 CVE-2006-2940 CVE-2006-3738 CVE-2006-4339 CVE-2006-4343 CVE-2007-5135 CVE-2008-5077)\n\n>make\nmake  all-recursive\nMaking all in src/main\nsource='activemq/cmsutil/CmsAccessor.cpp' object='activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo' libtool=yes \\\nDEPDIR=.deps depmode=none /bin/bash ../../config/depcomp \\\n/bin/bash ../../libtool  --tag=CXX   --mode=compile CC -DHAVE_CONFIG_H -I. -I../..    -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/dev/apr-1.4.5/solaris/include/apr-1   -I/dev/apr-util-1.3.12/solaris/include/apr-1  -I/usr/sfw/include   -PIC -g -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=stlport4 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/dev/apr-1.4.5/solaris/include/apr-1 -I/dev/apr-util-1.3.12/solaris/include/apr-1 -I/usr/sfw/include -PIC -g -c activemq/cmsutil/CmsAccessor.cpp  -KPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nCC: Warning: illegal option stlport4 ignored\n\"./decaf/util/LinkedList.h\", line 63: Error: decaf::util::LinkedList<cms::Connection*> is not a direct base class of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> to public.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Use \";\" to terminate declarations.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: \"}\" expected instead of \"<\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> because of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation error on Solaris\n\nDescription:\nSUN Solaris 10\n\nCMS Version : activemq-cpp-library-3.4.3\n\ncc: Sun WorkShop 6 update 2 C 5.3 2001/05/15\n\nOpenSSL 0.9.7d 17 Mar 2004 (+ security fixes for: CVE-2005-2969 CVE-2006-2937 CVE-2006-2940 CVE-2006-3738 CVE-2006-4339 CVE-2006-4343 CVE-2007-5135 CVE-2008-5077)\n\n>make\nmake  all-recursive\nMaking all in src/main\nsource='activemq/cmsutil/CmsAccessor.cpp' object='activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo' libtool=yes \\\nDEPDIR=.deps depmode=none /bin/bash ../../config/depcomp \\\n/bin/bash ../../libtool  --tag=CXX   --mode=compile CC -DHAVE_CONFIG_H -I. -I../..    -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/dev/apr-1.4.5/solaris/include/apr-1   -I/dev/apr-util-1.3.12/solaris/include/apr-1  -I/usr/sfw/include   -PIC -g -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=stlport4 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/dev/apr-1.4.5/solaris/include/apr-1 -I/dev/apr-util-1.3.12/solaris/include/apr-1 -I/usr/sfw/include -PIC -g -c activemq/cmsutil/CmsAccessor.cpp  -KPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nCC: Warning: illegal option stlport4 ignored\n\"./decaf/util/LinkedList.h\", line 63: Error: decaf::util::LinkedList<cms::Connection*> is not a direct base class of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> to public.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Use \";\" to terminate declarations.\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: \"}\" expected instead of \"<\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: While specializing \"decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>\".\n\"./decaf/util/LinkedList.h\", line 88:     Where: Specialized in decaf::util::LinkedList<cms::Connection*>.\n\"./activemq/cmsutil/ResourceLifecycleManager.h\", line 46:     Where: Specialized in non-template code.\n\"./decaf/util/LinkedList.h\", line 63: Error: Cannot change access of decaf::util::LinkedList<cms::Connection*>::ListNode<decaf::util::LinkedList<cms::Connection*>::U> because of decaf::util::LinkedList<cms::Connection*>::ListNode<cms::Connection*>.\n\n\nComments:\n", "classification": "Classify the issue 'Compilation error on Solaris' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-434?\nA: SUN Solaris 10\n\nCMS Version : activemq-cpp-library-3.4.3\n\ncc: Sun WorkShop 6 update 2 C 5.3 2001/05/15\n\nOpenSSL 0.9.7d 17 Mar 2004 (+ security fixes for: CVE-2005-2969 CVE-2006-2937 CVE-2006-2940 CVE-2006-3738 CVE-2006-4339 CVE-2006-4343 CVE-2007-5135 CVE-2008-5077)\n\n>make\nmake  all-recursive\nMaking all in src/main\nsource='activemq/cmsutil/CmsAccessor.cpp' object='activemq/cmsutil/libactivemq_cpp_"}}
{"issue_key": "AMQCPP-433", "project": "AMQCPP", "title": "Message::getCMSCorrelationID() returns different value from Java's Message.getJMSCorrelationID()", "status": "Resolved", "reporter": "Jon Tsui", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-10-04T23:43:56.000+0000", "updated": "2012-10-05T13:03:09.000+0000", "description": "Apache ActiveMQ-CPP's cms::Message::getCMSCorrelationID() returns the string \"correlation-id\".\n\nJava's javax.jms.Message.getJMSCorrelationID() returns the actual correlation ID (the string value of the property \"correlation-id\").\n\nI would expect the two to do the same thing, so cms::Message::getCMSCorrelationID() should return the String value of the property \"correlation-id\". I also base this expectation on the current behavior of cms::Message::getCMSReplyTo() returning the Destination value of the property \"reply-to\" instead of returning the string \"reply-to\".", "comments": [], "text": "Message::getCMSCorrelationID() returns different value from Java's Message.getJMSCorrelationID()\n\nDescription:\nApache ActiveMQ-CPP's cms::Message::getCMSCorrelationID() returns the string \"correlation-id\".\n\nJava's javax.jms.Message.getJMSCorrelationID() returns the actual correlation ID (the string value of the property \"correlation-id\").\n\nI would expect the two to do the same thing, so cms::Message::getCMSCorrelationID() should return the String value of the property \"correlation-id\". I also base this expectation on the current behavior of cms::Message::getCMSReplyTo() returning the Destination value of the property \"reply-to\" instead of returning the string \"reply-to\".\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Message::getCMSCorrelationID() returns different value from Java's Message.getJMSCorrelationID()\n\nDescription:\nApache ActiveMQ-CPP's cms::Message::getCMSCorrelationID() returns the string \"correlation-id\".\n\nJava's javax.jms.Message.getJMSCorrelationID() returns the actual correlation ID (the string value of the property \"correlation-id\").\n\nI would expect the two to do the same thing, so cms::Message::getCMSCorrelationID() should return the String value of the property \"correlation-id\". I also base this expectation on the current behavior of cms::Message::getCMSReplyTo() returning the Destination value of the property \"reply-to\" instead of returning the string \"reply-to\".\n\nComments:\n", "classification": "Classify the issue 'Message::getCMSCorrelationID() returns different value from Java's Message.getJMSCorrelationID()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-433?\nA: Apache ActiveMQ-CPP's cms::Message::getCMSCorrelationID() returns the string \"correlation-id\".\n\nJava's javax.jms.Message.getJMSCorrelationID() returns the actual correlation ID (the string value of the property \"correlation-id\").\n\nI would expect the two to do the same thing, so cms::Message::getCMSCorrelationID() should return the String value of the property \"correlation-id\". I also base this exp"}}
{"issue_key": "AMQCPP-432", "project": "AMQCPP", "title": "Possible Segfault on Connection close during a failover cycle", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-10-04T15:03:15.000+0000", "updated": "2012-10-04T15:10:36.000+0000", "description": "During connection close + destruction of Connection object during a failover cycle a segfault is possible due to a latch wait in onCommand processing.  Need to ensure the latch is opened before close finishes.", "comments": [], "text": "Possible Segfault on Connection close during a failover cycle\n\nDescription:\nDuring connection close + destruction of Connection object during a failover cycle a segfault is possible due to a latch wait in onCommand processing.  Need to ensure the latch is opened before close finishes. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Possible Segfault on Connection close during a failover cycle\n\nDescription:\nDuring connection close + destruction of Connection object during a failover cycle a segfault is possible due to a latch wait in onCommand processing.  Need to ensure the latch is opened before close finishes. \n\nComments:\n", "classification": "Classify the issue 'Possible Segfault on Connection close during a failover cycle' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-432?\nA: During connection close + destruction of Connection object during a failover cycle a segfault is possible due to a latch wait in onCommand processing.  Need to ensure the latch is opened before close finishes. "}}
{"issue_key": "AMQCPP-431", "project": "AMQCPP", "title": "Memory leak possible in OpenWireFormat and BaseDataStreamMarshaller when connection drops during read.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-10-04T14:25:26.000+0000", "updated": "2012-10-04T14:49:53.000+0000", "description": "During unmarshaling there is a possiblilty of leaking an object if the connection drops at a particular point reading the next incoming message.  This can lead to a lot of leakage over time, especially when using the failover transport.", "comments": [], "text": "Memory leak possible in OpenWireFormat and BaseDataStreamMarshaller when connection drops during read.\n\nDescription:\nDuring unmarshaling there is a possiblilty of leaking an object if the connection drops at a particular point reading the next incoming message.  This can lead to a lot of leakage over time, especially when using the failover transport.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak possible in OpenWireFormat and BaseDataStreamMarshaller when connection drops during read.\n\nDescription:\nDuring unmarshaling there is a possiblilty of leaking an object if the connection drops at a particular point reading the next incoming message.  This can lead to a lot of leakage over time, especially when using the failover transport.  \n\nComments:\n", "classification": "Classify the issue 'Memory leak possible in OpenWireFormat and BaseDataStreamMarshaller when connection drops during read.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-431?\nA: During unmarshaling there is a possiblilty of leaking an object if the connection drops at a particular point reading the next incoming message.  This can lead to a lot of leakage over time, especially when using the failover transport.  "}}
{"issue_key": "AMQCPP-430", "project": "AMQCPP", "title": "CMS crashes in decaf::internal::util::concurrent::MutexImpl::destroy", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-10-02T20:07:18.000+0000", "updated": "2012-10-09T15:40:44.000+0000", "description": "Found a crash in CMS. The following is the call stack. Please take a look. Thanks!\n\nntdll!RtlDeleteCriticalSection+51     0a42e258     0a42fcec     0f6be6d0    \nactivemq_cppu!decaf::internal::util::concurrent::MutexImpl::destroy+3b     0a42e258     36901bd1     00000000    \nactivemq_cppu!decaf::util::concurrent::Mutex::~Mutex+5f     36901a31     0a42fce0     00000000    \nactivemq_cppu!decaf::io::OutputStream::~OutputStream+4e     36901a09     0a42fce0     00000000    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::~ByteArrayOutputStream+60     0a4053f8     00000000     062aa6b9    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::`vector deleting destructor'+3d     05f40000     00000000     05ea4c58    \nmsvcr80!free+cd     0a16a948     0a16a950     060d418d    \nactivemq_cppu!decaf::io::DataOutputStream::`vector deleting destructor'+51     000001f0     00000000     7c9115f9    \nntdll!RtlAllocateHeap+eac     0a16a950     0a16ab40     36901719    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::copyDataStructure+43     0a16a950     3690175d     0a35a3b0    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::cloneDataStructure+6a     7c91019b     7c9101db     00000008    \nntdll!RtlpAllocateFromHeapLookaside+42     0a4358e0     0a3f8ae0     060d0ff0    \nactivemq_cppu!decaf::lang::Pointer<activemq::commands::MessageId,decaf::util::concurrent::atomic::AtomicRefCounter>::`vftable'     0a3f949c     0000000f     0a37748c    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign+7e     0f6bee30     0a3f9564     0000000b    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+46     00000000     0000000c     0f6bee64    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+21     00000000     0f6bee2c     7c42319e    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy+47     00000001     00000000     060b4e45    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >+9     369012d5     0a3f9488     0f6bee64    \nactivemq_cppu!std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>+45     0a16aafc     0a3f9488     00000000    \nntdll!RtlpAllocateFromHeapLookaside+42     00000000     00000000     00000000    \n0x0a3f9488     00000000     00000000     063477c4    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+1e     7c83194f     00002d54     0f6bef90    \nntdll!NtQueryValueKey+c     0000192d     0f6bed0c     0f6becec    \nkernel32!GetNameFromValue+10d     00000020     0f6bef2c     0f6bf1ec    \nmsvcp80!std::_Allocate<char>+15", "comments": [], "text": "CMS crashes in decaf::internal::util::concurrent::MutexImpl::destroy\n\nDescription:\nFound a crash in CMS. The following is the call stack. Please take a look. Thanks!\n\nntdll!RtlDeleteCriticalSection+51     0a42e258     0a42fcec     0f6be6d0    \nactivemq_cppu!decaf::internal::util::concurrent::MutexImpl::destroy+3b     0a42e258     36901bd1     00000000    \nactivemq_cppu!decaf::util::concurrent::Mutex::~Mutex+5f     36901a31     0a42fce0     00000000    \nactivemq_cppu!decaf::io::OutputStream::~OutputStream+4e     36901a09     0a42fce0     00000000    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::~ByteArrayOutputStream+60     0a4053f8     00000000     062aa6b9    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::`vector deleting destructor'+3d     05f40000     00000000     05ea4c58    \nmsvcr80!free+cd     0a16a948     0a16a950     060d418d    \nactivemq_cppu!decaf::io::DataOutputStream::`vector deleting destructor'+51     000001f0     00000000     7c9115f9    \nntdll!RtlAllocateHeap+eac     0a16a950     0a16ab40     36901719    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::copyDataStructure+43     0a16a950     3690175d     0a35a3b0    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::cloneDataStructure+6a     7c91019b     7c9101db     00000008    \nntdll!RtlpAllocateFromHeapLookaside+42     0a4358e0     0a3f8ae0     060d0ff0    \nactivemq_cppu!decaf::lang::Pointer<activemq::commands::MessageId,decaf::util::concurrent::atomic::AtomicRefCounter>::`vftable'     0a3f949c     0000000f     0a37748c    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign+7e     0f6bee30     0a3f9564     0000000b    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+46     00000000     0000000c     0f6bee64    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+21     00000000     0f6bee2c     7c42319e    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy+47     00000001     00000000     060b4e45    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >+9     369012d5     0a3f9488     0f6bee64    \nactivemq_cppu!std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>+45     0a16aafc     0a3f9488     00000000    \nntdll!RtlpAllocateFromHeapLookaside+42     00000000     00000000     00000000    \n0x0a3f9488     00000000     00000000     063477c4    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+1e     7c83194f     00002d54     0f6bef90    \nntdll!NtQueryValueKey+c     0000192d     0f6bed0c     0f6becec    \nkernel32!GetNameFromValue+10d     00000020     0f6bef2c     0f6bf1ec    \nmsvcp80!std::_Allocate<char>+15 \n\n \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS crashes in decaf::internal::util::concurrent::MutexImpl::destroy\n\nDescription:\nFound a crash in CMS. The following is the call stack. Please take a look. Thanks!\n\nntdll!RtlDeleteCriticalSection+51     0a42e258     0a42fcec     0f6be6d0    \nactivemq_cppu!decaf::internal::util::concurrent::MutexImpl::destroy+3b     0a42e258     36901bd1     00000000    \nactivemq_cppu!decaf::util::concurrent::Mutex::~Mutex+5f     36901a31     0a42fce0     00000000    \nactivemq_cppu!decaf::io::OutputStream::~OutputStream+4e     36901a09     0a42fce0     00000000    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::~ByteArrayOutputStream+60     0a4053f8     00000000     062aa6b9    \nactivemq_cppu!decaf::io::ByteArrayOutputStream::`vector deleting destructor'+3d     05f40000     00000000     05ea4c58    \nmsvcr80!free+cd     0a16a948     0a16a950     060d418d    \nactivemq_cppu!decaf::io::DataOutputStream::`vector deleting destructor'+51     000001f0     00000000     7c9115f9    \nntdll!RtlAllocateHeap+eac     0a16a950     0a16ab40     36901719    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::copyDataStructure+43     0a16a950     3690175d     0a35a3b0    \nactivemq_cppu!activemq::commands::ActiveMQBytesMessage::cloneDataStructure+6a     7c91019b     7c9101db     00000008    \nntdll!RtlpAllocateFromHeapLookaside+42     0a4358e0     0a3f8ae0     060d0ff0    \nactivemq_cppu!decaf::lang::Pointer<activemq::commands::MessageId,decaf::util::concurrent::atomic::AtomicRefCounter>::`vftable'     0a3f949c     0000000f     0a37748c    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign+7e     0f6bee30     0a3f9564     0000000b    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+46     00000000     0000000c     0f6bee64    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+21     00000000     0f6bee2c     7c42319e    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy+47     00000001     00000000     060b4e45    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >+9     369012d5     0a3f9488     0f6bee64    \nactivemq_cppu!std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,activemq::util::PrimitiveValueNode>+45     0a16aafc     0a3f9488     00000000    \nntdll!RtlpAllocateFromHeapLookaside+42     00000000     00000000     00000000    \n0x0a3f9488     00000000     00000000     063477c4    \nmsvcp80!std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare+1e     7c83194f     00002d54     0f6bef90    \nntdll!NtQueryValueKey+c     0000192d     0f6bed0c     0f6becec    \nkernel32!GetNameFromValue+10d     00000020     0f6bef2c     0f6bf1ec    \nmsvcp80!std::_Allocate<char>+15 \n\n \n\n\nComments:\n", "classification": "Classify the issue 'CMS crashes in decaf::internal::util::concurrent::MutexImpl::destroy' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-430?\nA: Found a crash in CMS. The following is the call stack. Please take a look. Thanks!\n\nntdll!RtlDeleteCriticalSection+51     0a42e258     0a42fcec     0f6be6d0    \nactivemq_cppu!decaf::internal::util::concurrent::MutexImpl::destroy+3b     0a42e258     36901bd1     00000000    \nactivemq_cppu!decaf::util::concurrent::Mutex::~Mutex+5f     36901a31     0a42fce0     00000000    \nactivemq_cppu!decaf::io::O"}}
{"issue_key": "AMQCPP-429", "project": "AMQCPP", "title": "Response correlator can let a future into its mapping after its been closed causing a hang", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-10-02T20:01:36.000+0000", "updated": "2012-10-02T22:57:33.000+0000", "description": "There's a timing bug that could allow for a request to be put into the request map after the transport is closed meaning it would never be responded to and could lead to a hang.", "comments": [], "text": "Response correlator can let a future into its mapping after its been closed causing a hang\n\nDescription:\nThere's a timing bug that could allow for a request to be put into the request map after the transport is closed meaning it would never be responded to and could lead to a hang. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Response correlator can let a future into its mapping after its been closed causing a hang\n\nDescription:\nThere's a timing bug that could allow for a request to be put into the request map after the transport is closed meaning it would never be responded to and could lead to a hang. \n\nComments:\n", "classification": "Classify the issue 'Response correlator can let a future into its mapping after its been closed causing a hang' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-429?\nA: There's a timing bug that could allow for a request to be put into the request map after the transport is closed meaning it would never be responded to and could lead to a hang. "}}
{"issue_key": "AMQCPP-428", "project": "AMQCPP", "title": "setTimeToLive not working", "status": "Resolved", "reporter": "Oscar Pernas", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["discarded", "expired", "message,", "timeToLive,"], "created": "2012-09-28T10:03:33.000+0000", "updated": "2012-10-16T11:44:34.000+0000", "description": "Making tests, method setTimeToLive of message is not working and messages are never discarded by the broker. This can produce an out of memory in some situations.\n\nExample code:\n//sending message\nproducer->send(\ttextMessage,\n\t\tgetPersistent(),\n\t\tactiveMessageToSend.getPriority(),\n\t\t30000);", "comments": [], "text": "setTimeToLive not working\n\nDescription:\nMaking tests, method setTimeToLive of message is not working and messages are never discarded by the broker. This can produce an out of memory in some situations.\n\nExample code:\n//sending message\nproducer->send(\ttextMessage,\n\t\tgetPersistent(),\n\t\tactiveMessageToSend.getPriority(),\n\t\t30000);\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: setTimeToLive not working\n\nDescription:\nMaking tests, method setTimeToLive of message is not working and messages are never discarded by the broker. This can produce an out of memory in some situations.\n\nExample code:\n//sending message\nproducer->send(\ttextMessage,\n\t\tgetPersistent(),\n\t\tactiveMessageToSend.getPriority(),\n\t\t30000);\n\n\n\nComments:\n", "classification": "Classify the issue 'setTimeToLive not working' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-428?\nA: Making tests, method setTimeToLive of message is not working and messages are never discarded by the broker. This can produce an out of memory in some situations.\n\nExample code:\n//sending message\nproducer->send(\ttextMessage,\n\t\tgetPersistent(),\n\t\tactiveMessageToSend.getPriority(),\n\t\t30000);\n\n"}}
{"issue_key": "AMQCPP-427", "project": "AMQCPP", "title": "Cannot correctly interpret MapMessage from Java broker 5.6", "status": "Closed", "reporter": "Andres Velasco", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-09-25T10:59:52.000+0000", "updated": "2012-09-25T12:11:17.000+0000", "description": "I am trying to receive MapMessage (in C++) generated from Java application via broker version 5.6.\n\nThe message is received and is interpreted as a MapMessage. However, it reports all properties as non existent. But I can see the properties using Wireshark.\n\nI have the network capture, but dont find a place to paste it here.\n\nthis is the relevant code:\n\n<pre>\n    // Called from the consumer since this class is a registered MessageListener.\n    virtual void onMessage( const Message* message ) throw() {\n\n        static int count = 0;\n\n        try\n        {\n            count++;\n\n            const MapMessage* mapMessage =\n                dynamic_cast<const MapMessage* >( message );\n            string text = \"\";\n\n            if( mapMessage != NULL ) {\n                //text = textMessage->getText();\n                //text = mapMessage->toString();\n                //text = mapMessage->getString(\"TEXT\");\n                //text = mapMessage->getString(\"DESTINATION_ADDRESS\");\n                text = mapMessage->getString(\"ORIGIN_ADDRESS\");\n                if ( mapMessage->itemExists(\"TEXT\") ) {\n                  printf(\"EXISTS\\n\");\n                }\n\n            } else {\n                text = \"NOT A MAP MESSAGE!\";\n            }", "comments": [], "text": "Cannot correctly interpret MapMessage from Java broker 5.6\n\nDescription:\nI am trying to receive MapMessage (in C++) generated from Java application via broker version 5.6.\n\nThe message is received and is interpreted as a MapMessage. However, it reports all properties as non existent. But I can see the properties using Wireshark.\n\nI have the network capture, but dont find a place to paste it here.\n\nthis is the relevant code:\n\n<pre>\n    // Called from the consumer since this class is a registered MessageListener.\n    virtual void onMessage( const Message* message ) throw() {\n\n        static int count = 0;\n\n        try\n        {\n            count++;\n\n            const MapMessage* mapMessage =\n                dynamic_cast<const MapMessage* >( message );\n            string text = \"\";\n\n            if( mapMessage != NULL ) {\n                //text = textMessage->getText();\n                //text = mapMessage->toString();\n                //text = mapMessage->getString(\"TEXT\");\n                //text = mapMessage->getString(\"DESTINATION_ADDRESS\");\n                text = mapMessage->getString(\"ORIGIN_ADDRESS\");\n                if ( mapMessage->itemExists(\"TEXT\") ) {\n                  printf(\"EXISTS\\n\");\n                }\n\n            } else {\n                text = \"NOT A MAP MESSAGE!\";\n            }\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Cannot correctly interpret MapMessage from Java broker 5.6\n\nDescription:\nI am trying to receive MapMessage (in C++) generated from Java application via broker version 5.6.\n\nThe message is received and is interpreted as a MapMessage. However, it reports all properties as non existent. But I can see the properties using Wireshark.\n\nI have the network capture, but dont find a place to paste it here.\n\nthis is the relevant code:\n\n<pre>\n    // Called from the consumer since this class is a registered MessageListener.\n    virtual void onMessage( const Message* message ) throw() {\n\n        static int count = 0;\n\n        try\n        {\n            count++;\n\n            const MapMessage* mapMessage =\n                dynamic_cast<const MapMessage* >( message );\n            string text = \"\";\n\n            if( mapMessage != NULL ) {\n                //text = textMessage->getText();\n                //text = mapMessage->toString();\n                //text = mapMessage->getString(\"TEXT\");\n                //text = mapMessage->getString(\"DESTINATION_ADDRESS\");\n                text = mapMessage->getString(\"ORIGIN_ADDRESS\");\n                if ( mapMessage->itemExists(\"TEXT\") ) {\n                  printf(\"EXISTS\\n\");\n                }\n\n            } else {\n                text = \"NOT A MAP MESSAGE!\";\n            }\n\n\nComments:\n", "classification": "Classify the issue 'Cannot correctly interpret MapMessage from Java broker 5.6' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-427?\nA: I am trying to receive MapMessage (in C++) generated from Java application via broker version 5.6.\n\nThe message is received and is interpreted as a MapMessage. However, it reports all properties as non existent. But I can see the properties using Wireshark.\n\nI have the network capture, but dont find a place to paste it here.\n\nthis is the relevant code:\n\n<pre>\n    // Called from the consumer since "}}
{"issue_key": "AMQCPP-426", "project": "AMQCPP", "title": "Connection setClientID doesn't catch and convert all exceptions to CMSException", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-09-17T05:30:01.000+0000", "updated": "2012-09-17T06:15:41.000+0000", "description": "When using the setClientID method to configure a client identifier for Connections that create durable consumers the method shuold be ensuring that only CMSException types are thrown, but it misses that and can lead to uncaught exceptions.", "comments": [], "text": "Connection setClientID doesn't catch and convert all exceptions to CMSException\n\nDescription:\nWhen using the setClientID method to configure a client identifier for Connections that create durable consumers the method shuold be ensuring that only CMSException types are thrown, but it misses that and can lead to uncaught exceptions.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Connection setClientID doesn't catch and convert all exceptions to CMSException\n\nDescription:\nWhen using the setClientID method to configure a client identifier for Connections that create durable consumers the method shuold be ensuring that only CMSException types are thrown, but it misses that and can lead to uncaught exceptions.\n\nComments:\n", "classification": "Classify the issue 'Connection setClientID doesn't catch and convert all exceptions to CMSException' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-426?\nA: When using the setClientID method to configure a client identifier for Connections that create durable consumers the method shuold be ensuring that only CMSException types are thrown, but it misses that and can lead to uncaught exceptions."}}
{"issue_key": "AMQCPP-425", "project": "AMQCPP", "title": "Crash found in CMS", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-09-12T22:08:55.000+0000", "updated": "2012-12-04T20:28:53.000+0000", "description": "CMS cause a crash of our application. The following is the fault thread. Attached please find the dump. Could you please take a look and see what is wrong. Thanks!\n\n*----> State Dump for Thread Id 0xa6c <----*\n\neax=00000000 ebx=11850f70 ecx=00000000 edx=7c97e140 esi=149cd450 edi=11883610\neip=7c9113f7 esp=0f5fdba8 ebp=0f5fdbe0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\nfunction: ntdll!RtlDeleteCriticalSection\n        7c9113dd 8b33             mov     esi,[ebx]\n        7c9113df 8975e0           mov     [ebp-0x20],esi\n        7c9113e2 85f6             test    esi,esi\n        7c9113e4 741f             jz   ntdll!RtlDeleteCriticalSection+0x54 (7c911405)\n        7c9113e6 8d4608           lea     eax,[esi+0x8]\n        7c9113e9 8945dc           mov     [ebp-0x24],eax\n        7c9113ec 8b08             mov     ecx,[eax]\n        7c9113ee 894dd8           mov     [ebp-0x28],ecx\n        7c9113f1 8b4004           mov     eax,[eax+0x4]\n        7c9113f4 8945d4           mov     [ebp-0x2c],eax\nFAULT ->7c9113f7 8908             mov     [eax],ecx         ds:0023:00000000=????????\n        7c9113f9 894104           mov     [ecx+0x4],eax\n        7c9113fc 6a08             push    0x8\n        7c9113fe 59               pop     ecx\n        7c9113ff 33c0             xor     eax,eax\n        7c911401 8bfe             mov     edi,esi\n        7c911403 f3ab             rep     stosd\n        7c911405 834dfcff         or      dword ptr [ebp-0x4],0xffffffff\n        7c911409 e893ffffff       call    ntdll!wcsncpy+0xdc8 (7c9113a1)\n        7c91140e 85f6             test    esi,esi\n        7c911410 7406             jz   ntdll!RtlDeleteCriticalSection+0x67 (7c911418)\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n0f5fdbe0 063bd60b 11850f70 1186ae0c 7c9100b8 ntdll!RtlDeleteCriticalSection+0x46\n0f5fdd14 0622c7be b4610385 116f9d70 0607fe30 activemq-cppu!decaf__internal__util__concurrent__MutexImpl__destroy+0x3b\n0f5fdd90 063194e7 0607fe30 b46100e5 0000001c activemq-cppu!activemq__commands__ActiveMQTextMessage__beforeMarshal+0x20e\n0f5fde40 061d9022 000003e8 11881168 0669f690 activemq-cppu!activemq__wireformat__openwire__marshal__generated__ActiveMQTextMessageMarshaller__tightMarshal1+0x77\n0f5fdeac 06340205 b461001d b46100e5 0f5fe0d0 activemq-cppu!decaf__lang__Comparable<short>__~Comparable<short>+0x312\n0f5fe0d0 0f5fe044 0f5fe180 0642a828 00000000 activemq-cppu!activemq__wireformat__openwire__utils__BooleanStream__BooleanStream+0x55\nb4613e41 00000000 00000000 00000000 00000000 0xf5fe044", "comments": [], "text": "Crash found in CMS\n\nDescription:\nCMS cause a crash of our application. The following is the fault thread. Attached please find the dump. Could you please take a look and see what is wrong. Thanks!\n\n*----> State Dump for Thread Id 0xa6c <----*\n\neax=00000000 ebx=11850f70 ecx=00000000 edx=7c97e140 esi=149cd450 edi=11883610\neip=7c9113f7 esp=0f5fdba8 ebp=0f5fdbe0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\nfunction: ntdll!RtlDeleteCriticalSection\n        7c9113dd 8b33             mov     esi,[ebx]\n        7c9113df 8975e0           mov     [ebp-0x20],esi\n        7c9113e2 85f6             test    esi,esi\n        7c9113e4 741f             jz   ntdll!RtlDeleteCriticalSection+0x54 (7c911405)\n        7c9113e6 8d4608           lea     eax,[esi+0x8]\n        7c9113e9 8945dc           mov     [ebp-0x24],eax\n        7c9113ec 8b08             mov     ecx,[eax]\n        7c9113ee 894dd8           mov     [ebp-0x28],ecx\n        7c9113f1 8b4004           mov     eax,[eax+0x4]\n        7c9113f4 8945d4           mov     [ebp-0x2c],eax\nFAULT ->7c9113f7 8908             mov     [eax],ecx         ds:0023:00000000=????????\n        7c9113f9 894104           mov     [ecx+0x4],eax\n        7c9113fc 6a08             push    0x8\n        7c9113fe 59               pop     ecx\n        7c9113ff 33c0             xor     eax,eax\n        7c911401 8bfe             mov     edi,esi\n        7c911403 f3ab             rep     stosd\n        7c911405 834dfcff         or      dword ptr [ebp-0x4],0xffffffff\n        7c911409 e893ffffff       call    ntdll!wcsncpy+0xdc8 (7c9113a1)\n        7c91140e 85f6             test    esi,esi\n        7c911410 7406             jz   ntdll!RtlDeleteCriticalSection+0x67 (7c911418)\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n0f5fdbe0 063bd60b 11850f70 1186ae0c 7c9100b8 ntdll!RtlDeleteCriticalSection+0x46\n0f5fdd14 0622c7be b4610385 116f9d70 0607fe30 activemq-cppu!decaf__internal__util__concurrent__MutexImpl__destroy+0x3b\n0f5fdd90 063194e7 0607fe30 b46100e5 0000001c activemq-cppu!activemq__commands__ActiveMQTextMessage__beforeMarshal+0x20e\n0f5fde40 061d9022 000003e8 11881168 0669f690 activemq-cppu!activemq__wireformat__openwire__marshal__generated__ActiveMQTextMessageMarshaller__tightMarshal1+0x77\n0f5fdeac 06340205 b461001d b46100e5 0f5fe0d0 activemq-cppu!decaf__lang__Comparable<short>__~Comparable<short>+0x312\n0f5fe0d0 0f5fe044 0f5fe180 0642a828 00000000 activemq-cppu!activemq__wireformat__openwire__utils__BooleanStream__BooleanStream+0x55\nb4613e41 00000000 00000000 00000000 00000000 0xf5fe044\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash found in CMS\n\nDescription:\nCMS cause a crash of our application. The following is the fault thread. Attached please find the dump. Could you please take a look and see what is wrong. Thanks!\n\n*----> State Dump for Thread Id 0xa6c <----*\n\neax=00000000 ebx=11850f70 ecx=00000000 edx=7c97e140 esi=149cd450 edi=11883610\neip=7c9113f7 esp=0f5fdba8 ebp=0f5fdbe0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\nfunction: ntdll!RtlDeleteCriticalSection\n        7c9113dd 8b33             mov     esi,[ebx]\n        7c9113df 8975e0           mov     [ebp-0x20],esi\n        7c9113e2 85f6             test    esi,esi\n        7c9113e4 741f             jz   ntdll!RtlDeleteCriticalSection+0x54 (7c911405)\n        7c9113e6 8d4608           lea     eax,[esi+0x8]\n        7c9113e9 8945dc           mov     [ebp-0x24],eax\n        7c9113ec 8b08             mov     ecx,[eax]\n        7c9113ee 894dd8           mov     [ebp-0x28],ecx\n        7c9113f1 8b4004           mov     eax,[eax+0x4]\n        7c9113f4 8945d4           mov     [ebp-0x2c],eax\nFAULT ->7c9113f7 8908             mov     [eax],ecx         ds:0023:00000000=????????\n        7c9113f9 894104           mov     [ecx+0x4],eax\n        7c9113fc 6a08             push    0x8\n        7c9113fe 59               pop     ecx\n        7c9113ff 33c0             xor     eax,eax\n        7c911401 8bfe             mov     edi,esi\n        7c911403 f3ab             rep     stosd\n        7c911405 834dfcff         or      dword ptr [ebp-0x4],0xffffffff\n        7c911409 e893ffffff       call    ntdll!wcsncpy+0xdc8 (7c9113a1)\n        7c91140e 85f6             test    esi,esi\n        7c911410 7406             jz   ntdll!RtlDeleteCriticalSection+0x67 (7c911418)\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n0f5fdbe0 063bd60b 11850f70 1186ae0c 7c9100b8 ntdll!RtlDeleteCriticalSection+0x46\n0f5fdd14 0622c7be b4610385 116f9d70 0607fe30 activemq-cppu!decaf__internal__util__concurrent__MutexImpl__destroy+0x3b\n0f5fdd90 063194e7 0607fe30 b46100e5 0000001c activemq-cppu!activemq__commands__ActiveMQTextMessage__beforeMarshal+0x20e\n0f5fde40 061d9022 000003e8 11881168 0669f690 activemq-cppu!activemq__wireformat__openwire__marshal__generated__ActiveMQTextMessageMarshaller__tightMarshal1+0x77\n0f5fdeac 06340205 b461001d b46100e5 0f5fe0d0 activemq-cppu!decaf__lang__Comparable<short>__~Comparable<short>+0x312\n0f5fe0d0 0f5fe044 0f5fe180 0642a828 00000000 activemq-cppu!activemq__wireformat__openwire__utils__BooleanStream__BooleanStream+0x55\nb4613e41 00000000 00000000 00000000 00000000 0xf5fe044\n\n\nComments:\n", "classification": "Classify the issue 'Crash found in CMS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-425?\nA: CMS cause a crash of our application. The following is the fault thread. Attached please find the dump. Could you please take a look and see what is wrong. Thanks!\n\n*----> State Dump for Thread Id 0xa6c <----*\n\neax=00000000 ebx=11850f70 ecx=00000000 edx=7c97e140 esi=149cd450 edi=11883610\neip=7c9113f7 esp=0f5fdba8 ebp=0f5fdbe0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=002"}}
{"issue_key": "AMQCPP-424", "project": "AMQCPP", "title": "Cannot clone() and then update properties of the newly cloned message", "status": "Resolved", "reporter": "Martin Lichtin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-08-30T12:41:23.000+0000", "updated": "2012-08-30T15:38:55.000+0000", "description": "Consuming a message, then cloning it and subsequently attempting to make the\nproperties of the new message writable (using setReadOnlyProperties(false)) does not seem to work.\n\nCalling cms::Message::setStringProperty() will result in a 'cms::MessageNotWriteableException' being thrown.\n\nWill try to provide test code to demonstrate.", "comments": [], "text": "Cannot clone() and then update properties of the newly cloned message\n\nDescription:\nConsuming a message, then cloning it and subsequently attempting to make the\nproperties of the new message writable (using setReadOnlyProperties(false)) does not seem to work.\n\nCalling cms::Message::setStringProperty() will result in a 'cms::MessageNotWriteableException' being thrown.\n\nWill try to provide test code to demonstrate.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Cannot clone() and then update properties of the newly cloned message\n\nDescription:\nConsuming a message, then cloning it and subsequently attempting to make the\nproperties of the new message writable (using setReadOnlyProperties(false)) does not seem to work.\n\nCalling cms::Message::setStringProperty() will result in a 'cms::MessageNotWriteableException' being thrown.\n\nWill try to provide test code to demonstrate.\n\nComments:\n", "classification": "Classify the issue 'Cannot clone() and then update properties of the newly cloned message' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-424?\nA: Consuming a message, then cloning it and subsequently attempting to make the\nproperties of the new message writable (using setReadOnlyProperties(false)) does not seem to work.\n\nCalling cms::Message::setStringProperty() will result in a 'cms::MessageNotWriteableException' being thrown.\n\nWill try to provide test code to demonstrate."}}
{"issue_key": "AMQCPP-423", "project": "AMQCPP", "title": "Compiling with clang++", "status": "Closed", "reporter": "Steve Pietrowicz", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-08-27T12:56:45.000+0000", "updated": "2012-12-08T17:00:05.000+0000", "description": "We're trying to get our entire software stack running under clang.  One of the third party packages we use is ActiveMQCPP.  We're using an older version of the library, which builds, but results in an error when we try to use it (see the last part of this message).\n\n\nThe ActiveMQCPP 3.4.3 package fails to compile under clang 3.0, first giving many warnings in other files, and then the error in ExecutorService.cpp:\n\nlibtool: compile:  clang++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.lo -MD -MP -MF decaf/util/concurrent/.deps/libactivemq_cpp_la-ExecutorService.Tpo -c decaf/util/concurrent/ExecutorService.cpp -o decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.o >/dev/null 2>&1\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\nIn file included from ./decaf/util/AbstractQueue.h:28:\n./decaf/util/Queue.h:101:19: warning: 'decaf::util::Queue<decaf::lang::Runnable\n      *>::remove' hides overloaded virtual function [-Woverloaded-virtual]\n        virtual E remove() = 0;\n                  ^\n./decaf/util/AbstractQueue.h:47:34: note: in instantiation of template class\n      'decaf::util::Queue<decaf::lang::Runnable *>' requested here\n    class AbstractQueue : public decaf::util::Queue<E>,\n                                 ^\n./decaf/util/concurrent/BlockingQueue.h:164:34: note: in instantiation of\n      template class 'decaf::util::AbstractQueue<decaf::lang::Runnable *>'\n      requested here\n    class BlockingQueue : public AbstractQueue<E> {\n                                 ^\n./decaf/util/concurrent/ThreadPoolExecutor.h:598:45: note: in instantiation of\n      template class\n      'decaf::util::concurrent::BlockingQueue<decaf::lang::Runnable *>'\n      requested here\n                        executer->getQueue()->poll(oldest);\n                                            ^\n./decaf/util/Collection.h:214:22: note: hidden overloaded virtual function\n      'decaf::util::Collection<decaf::lang::Runnable *>::remove' declared here\n        virtual bool remove( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:28:\n./decaf/util/concurrent/LinkedBlockingQueue.h:465:27: warning: implicit\n      conversion changes signedness: 'int' to 'size_type' (aka 'unsigned long')\n      [-Wsign-conversion]\n            array.reserve(size);\n            ~~~~~         ^~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function\n      'decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\n./decaf/util/AbstractQueue.h:63:17: error: use of undeclared identifier 'offer'\n            if( offer( value ) ) {\n                ^\n                this->\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractQueue<decaf::lang::Runnable *>::add'\n      requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n./decaf/util/Queue.h:76:22: note: must qualify identifier to find this\n      declaration in dependent base class\n        virtual bool offer( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:18:\nIn file included from decaf/util/concurrent/Executors.h:24:\nIn file included from ./decaf/util/concurrent/ExecutorService.h:24:\nIn file included from ./decaf/util/ArrayList.h:30:\nIn file included from ./decaf/util/List.h:27:\n./decaf/util/AbstractCollection.h:318:33: warning: implicit conversion changes\n      signedness: 'int' to 'size_type' (aka 'unsigned long') [-Wsign-conversion]\n            valueArray.reserve( this->size() );\n            ~~~~~~~~~~          ^~~~~~~~~~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractCollection<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n5 warnings and 1 error generated.\n\n\n\n\nVersion 3.1.2 of the library compiles, but throws an exception (out of range) on in createConnection in AMQConnectionFactory.\n\nI wasn't sure how to classify this issue and whether it should be classified as enhancement request.  Is there any plan to support clang in the future?", "comments": [], "text": "Compiling with clang++\n\nDescription:\nWe're trying to get our entire software stack running under clang.  One of the third party packages we use is ActiveMQCPP.  We're using an older version of the library, which builds, but results in an error when we try to use it (see the last part of this message).\n\n\nThe ActiveMQCPP 3.4.3 package fails to compile under clang 3.0, first giving many warnings in other files, and then the error in ExecutorService.cpp:\n\nlibtool: compile:  clang++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.lo -MD -MP -MF decaf/util/concurrent/.deps/libactivemq_cpp_la-ExecutorService.Tpo -c decaf/util/concurrent/ExecutorService.cpp -o decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.o >/dev/null 2>&1\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\nIn file included from ./decaf/util/AbstractQueue.h:28:\n./decaf/util/Queue.h:101:19: warning: 'decaf::util::Queue<decaf::lang::Runnable\n      *>::remove' hides overloaded virtual function [-Woverloaded-virtual]\n        virtual E remove() = 0;\n                  ^\n./decaf/util/AbstractQueue.h:47:34: note: in instantiation of template class\n      'decaf::util::Queue<decaf::lang::Runnable *>' requested here\n    class AbstractQueue : public decaf::util::Queue<E>,\n                                 ^\n./decaf/util/concurrent/BlockingQueue.h:164:34: note: in instantiation of\n      template class 'decaf::util::AbstractQueue<decaf::lang::Runnable *>'\n      requested here\n    class BlockingQueue : public AbstractQueue<E> {\n                                 ^\n./decaf/util/concurrent/ThreadPoolExecutor.h:598:45: note: in instantiation of\n      template class\n      'decaf::util::concurrent::BlockingQueue<decaf::lang::Runnable *>'\n      requested here\n                        executer->getQueue()->poll(oldest);\n                                            ^\n./decaf/util/Collection.h:214:22: note: hidden overloaded virtual function\n      'decaf::util::Collection<decaf::lang::Runnable *>::remove' declared here\n        virtual bool remove( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:28:\n./decaf/util/concurrent/LinkedBlockingQueue.h:465:27: warning: implicit\n      conversion changes signedness: 'int' to 'size_type' (aka 'unsigned long')\n      [-Wsign-conversion]\n            array.reserve(size);\n            ~~~~~         ^~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function\n      'decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\n./decaf/util/AbstractQueue.h:63:17: error: use of undeclared identifier 'offer'\n            if( offer( value ) ) {\n                ^\n                this->\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractQueue<decaf::lang::Runnable *>::add'\n      requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n./decaf/util/Queue.h:76:22: note: must qualify identifier to find this\n      declaration in dependent base class\n        virtual bool offer( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:18:\nIn file included from decaf/util/concurrent/Executors.h:24:\nIn file included from ./decaf/util/concurrent/ExecutorService.h:24:\nIn file included from ./decaf/util/ArrayList.h:30:\nIn file included from ./decaf/util/List.h:27:\n./decaf/util/AbstractCollection.h:318:33: warning: implicit conversion changes\n      signedness: 'int' to 'size_type' (aka 'unsigned long') [-Wsign-conversion]\n            valueArray.reserve( this->size() );\n            ~~~~~~~~~~          ^~~~~~~~~~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractCollection<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n5 warnings and 1 error generated.\n\n\n\n\nVersion 3.1.2 of the library compiles, but throws an exception (out of range) on in createConnection in AMQConnectionFactory.\n\nI wasn't sure how to classify this issue and whether it should be classified as enhancement request.  Is there any plan to support clang in the future?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compiling with clang++\n\nDescription:\nWe're trying to get our entire software stack running under clang.  One of the third party packages we use is ActiveMQCPP.  We're using an older version of the library, which builds, but results in an error when we try to use it (see the last part of this message).\n\n\nThe ActiveMQCPP 3.4.3 package fails to compile under clang 3.0, first giving many warnings in other files, and then the error in ExecutorService.cpp:\n\nlibtool: compile:  clang++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -I/lsst/home/srp/clang/lsst_clang/Linux64/external/apr/1.3.3+1/include/apr-1 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.lo -MD -MP -MF decaf/util/concurrent/.deps/libactivemq_cpp_la-ExecutorService.Tpo -c decaf/util/concurrent/ExecutorService.cpp -o decaf/util/concurrent/libactivemq_cpp_la-ExecutorService.o >/dev/null 2>&1\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\nIn file included from ./decaf/util/AbstractQueue.h:28:\n./decaf/util/Queue.h:101:19: warning: 'decaf::util::Queue<decaf::lang::Runnable\n      *>::remove' hides overloaded virtual function [-Woverloaded-virtual]\n        virtual E remove() = 0;\n                  ^\n./decaf/util/AbstractQueue.h:47:34: note: in instantiation of template class\n      'decaf::util::Queue<decaf::lang::Runnable *>' requested here\n    class AbstractQueue : public decaf::util::Queue<E>,\n                                 ^\n./decaf/util/concurrent/BlockingQueue.h:164:34: note: in instantiation of\n      template class 'decaf::util::AbstractQueue<decaf::lang::Runnable *>'\n      requested here\n    class BlockingQueue : public AbstractQueue<E> {\n                                 ^\n./decaf/util/concurrent/ThreadPoolExecutor.h:598:45: note: in instantiation of\n      template class\n      'decaf::util::concurrent::BlockingQueue<decaf::lang::Runnable *>'\n      requested here\n                        executer->getQueue()->poll(oldest);\n                                            ^\n./decaf/util/Collection.h:214:22: note: hidden overloaded virtual function\n      'decaf::util::Collection<decaf::lang::Runnable *>::remove' declared here\n        virtual bool remove( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:28:\n./decaf/util/concurrent/LinkedBlockingQueue.h:465:27: warning: implicit\n      conversion changes signedness: 'int' to 'size_type' (aka 'unsigned long')\n      [-Wsign-conversion]\n            array.reserve(size);\n            ~~~~~         ^~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function\n      'decaf::util::concurrent::LinkedBlockingQueue<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\nIn file included from decaf/util/concurrent/Executors.cpp:25:\nIn file included from ./decaf/util/concurrent/ThreadPoolExecutor.h:23:\nIn file included from ./decaf/util/concurrent/BlockingQueue.h:22:\n./decaf/util/AbstractQueue.h:63:17: error: use of undeclared identifier 'offer'\n            if( offer( value ) ) {\n                ^\n                this->\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractQueue<decaf::lang::Runnable *>::add'\n      requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n./decaf/util/Queue.h:76:22: note: must qualify identifier to find this\n      declaration in dependent base class\n        virtual bool offer( const E& value ) = 0;\n                     ^\nIn file included from decaf/util/concurrent/Executors.cpp:18:\nIn file included from decaf/util/concurrent/Executors.h:24:\nIn file included from ./decaf/util/concurrent/ExecutorService.h:24:\nIn file included from ./decaf/util/ArrayList.h:30:\nIn file included from ./decaf/util/List.h:27:\n./decaf/util/AbstractCollection.h:318:33: warning: implicit conversion changes\n      signedness: 'int' to 'size_type' (aka 'unsigned long') [-Wsign-conversion]\n            valueArray.reserve( this->size() );\n            ~~~~~~~~~~          ^~~~~~~~~~~~\ndecaf/util/concurrent/Executors.cpp:112:28: note: in instantiation of member\n      function 'decaf::util::AbstractCollection<decaf::lang::Runnable\n      *>::toArray' requested here\n        backingQ.reset(new LinkedBlockingQueue<Runnable*>());\n                           ^\n5 warnings and 1 error generated.\n\n\n\n\nVersion 3.1.2 of the library compiles, but throws an exception (out of range) on in createConnection in AMQConnectionFactory.\n\nI wasn't sure how to classify this issue and whether it should be classified as enhancement request.  Is there any plan to support clang in the future?\n\nComments:\n", "classification": "Classify the issue 'Compiling with clang++' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-423?\nA: We're trying to get our entire software stack running under clang.  One of the third party packages we use is ActiveMQCPP.  We're using an older version of the library, which builds, but results in an error when we try to use it (see the last part of this message).\n\n\nThe ActiveMQCPP 3.4.3 package fails to compile under clang 3.0, first giving many warnings in other files, and then the error in Exe"}}
{"issue_key": "AMQCPP-422", "project": "AMQCPP", "title": "When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error.", "status": "Resolved", "reporter": "Mikhail Melamud", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-08-13T19:26:02.000+0000", "updated": "2013-02-27T19:26:22.000+0000", "description": "When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to do with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator", "comments": [], "text": "When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error.\n\nDescription:\nWhen we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to do with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error.\n\nDescription:\nWhen we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to do with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator\n\nComments:\n", "classification": "Classify the issue 'When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-422?\nA: When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is tryi"}}
{"issue_key": "AMQCPP-421", "project": "AMQCPP", "title": "cms crashing when SSL certificate's subject alternative name doesn't match the specified in failover URI", "status": "Closed", "reporter": "Mikhail Melamud", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-08-13T19:22:40.000+0000", "updated": "2012-08-13T21:07:07.000+0000", "description": "When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator", "comments": [], "text": "cms crashing when SSL certificate's subject alternative name doesn't match the specified in failover URI\n\nDescription:\nWhen we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: cms crashing when SSL certificate's subject alternative name doesn't match the specified in failover URI\n\nDescription:\nWhen we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is trying to fire an exception using listener pointer that is not instantiated properly in _void TransportFilter::fire( const decaf::lang::Exception& ex )_  method...  It is not happening all the time, so a simple unit test won't do...  I'm attaching a bit re-factored _HelloWorldProducer_ app and the certificate file that I used... There is possibility that it has something to with InactivityMonitor injected into transport filter chain... When I tried {color:blue}\"failover://(ssl://dev1467:61618?transport.useInactivityMonitor=false){color} instead of {color:blue}\"failover://(ssl://dev1467:61618)\"{color} it behaves much more stable, i.e. client app can be re-run many more times without a crash, still crashing though in OpenFormatNegotiator\n\nComments:\n", "classification": "Classify the issue 'cms crashing when SSL certificate's subject alternative name doesn't match the specified in failover URI' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-421?\nA: When we specify self-signed certificate in PEM-formatted file as value of the \"decaf.net.ssl.trustStore\" property and SAN that does't match any name in  failover URI, cms is crashing on \"R6025 Pure Virtual Function Call\" run-time error. I think, the issue can be attributed to multithreading... After ??Server Certificate Name doesn't match the URI Host Name value.?? exception is thrown, CMS is tryi"}}
{"issue_key": "AMQCPP-420", "project": "AMQCPP", "title": "The same fix should have been applied to SSLTransportFactory.cpp", "status": "Resolved", "reporter": "Mikhail Melamud", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2012-08-13T18:50:54.000+0000", "updated": "2012-08-13T21:02:38.000+0000", "description": "", "comments": [], "text": "The same fix should have been applied to SSLTransportFactory.cpp\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The same fix should have been applied to SSLTransportFactory.cpp\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'The same fix should have been applied to SSLTransportFactory.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-420?\nA: "}}
{"issue_key": "AMQCPP-419", "project": "AMQCPP", "title": "Missing dependency on apr/apr-util in pkg-config and config files", "status": "Closed", "reporter": "FrantiÅ¡ek DvoÅÃ¡k", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["build", "patch"], "created": "2012-08-07T12:38:42.000+0000", "updated": "2012-08-08T14:28:08.000+0000", "description": "Decaf header files depends on headers in apr and apr-util packages, which is not covered by activemq-cpp.pc and activemq-config files.\n\nI'm sending a patch which adds a necessary flags and includes.", "comments": [], "text": "Missing dependency on apr/apr-util in pkg-config and config files\n\nDescription:\nDecaf header files depends on headers in apr and apr-util packages, which is not covered by activemq-cpp.pc and activemq-config files.\n\nI'm sending a patch which adds a necessary flags and includes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Missing dependency on apr/apr-util in pkg-config and config files\n\nDescription:\nDecaf header files depends on headers in apr and apr-util packages, which is not covered by activemq-cpp.pc and activemq-config files.\n\nI'm sending a patch which adds a necessary flags and includes.\n\nComments:\n", "classification": "Classify the issue 'Missing dependency on apr/apr-util in pkg-config and config files' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-419?\nA: Decaf header files depends on headers in apr and apr-util packages, which is not covered by activemq-cpp.pc and activemq-config files.\n\nI'm sending a patch which adds a necessary flags and includes."}}
{"issue_key": "AMQCPP-418", "project": "AMQCPP", "title": "HPUX aCC compiler const char[] to initialize char*", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["HPUX", "compilation", "test"], "created": "2012-08-06T18:04:52.000+0000", "updated": "2012-08-06T22:34:57.000+0000", "description": "In file src/test/decaf/lang/ArrayPointerTest.cpp and PointerTest.cpp\nconstant strings are given as arguments to the function: \nstd::make_pair(pointer1,\"Bob\")\n\nThis was giving an error, \nI fixed it by including <string> and creating:\nstd::String name1=\"Bob\";\nand putting that variable in the function call and repeating for each of them in both files.\n\nThe error number was 2144 and can justification is can be seen here:\nhttp://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2708d7c682f02110d7c682f02110275d6e10RCRD", "comments": [], "text": "HPUX aCC compiler const char[] to initialize char*\n\nDescription:\nIn file src/test/decaf/lang/ArrayPointerTest.cpp and PointerTest.cpp\nconstant strings are given as arguments to the function: \nstd::make_pair(pointer1,\"Bob\")\n\nThis was giving an error, \nI fixed it by including <string> and creating:\nstd::String name1=\"Bob\";\nand putting that variable in the function call and repeating for each of them in both files.\n\nThe error number was 2144 and can justification is can be seen here:\nhttp://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2708d7c682f02110d7c682f02110275d6e10RCRD\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: HPUX aCC compiler const char[] to initialize char*\n\nDescription:\nIn file src/test/decaf/lang/ArrayPointerTest.cpp and PointerTest.cpp\nconstant strings are given as arguments to the function: \nstd::make_pair(pointer1,\"Bob\")\n\nThis was giving an error, \nI fixed it by including <string> and creating:\nstd::String name1=\"Bob\";\nand putting that variable in the function call and repeating for each of them in both files.\n\nThe error number was 2144 and can justification is can be seen here:\nhttp://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2708d7c682f02110d7c682f02110275d6e10RCRD\n\nComments:\n", "classification": "Classify the issue 'HPUX aCC compiler const char[] to initialize char*' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-418?\nA: In file src/test/decaf/lang/ArrayPointerTest.cpp and PointerTest.cpp\nconstant strings are given as arguments to the function: \nstd::make_pair(pointer1,\"Bob\")\n\nThis was giving an error, \nI fixed it by including <string> and creating:\nstd::String name1=\"Bob\";\nand putting that variable in the function call and repeating for each of them in both files.\n\nThe error number was 2144 and can justification "}}
{"issue_key": "AMQCPP-417", "project": "AMQCPP", "title": "decaf/lang/System.cpp error with HPUX aCC", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["HPUX", "fix", "system"], "created": "2012-08-06T17:53:50.000+0000", "updated": "2012-08-09T14:50:58.000+0000", "description": "in the file src/main/decaf/lang/System.cpp,\nit tries to get the number of CPUS, HPUX does not have the option for sysconf() that it uses.  I have a working addition:\n\nadd this include at the top:\n#if defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n\t#include <sys/mpctl.h>\n#endif\n\nand add this where it is getting the number of CPUs:\n#elif defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n     \tnumCpus = (int)mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\nhere are two sources for this information:\nhttp://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine\nhttp://h21007.www2.hp.com/portal/download/files/unprot/stk/solaris_stk/impacts/i190.html", "comments": [], "text": "decaf/lang/System.cpp error with HPUX aCC\n\nDescription:\nin the file src/main/decaf/lang/System.cpp,\nit tries to get the number of CPUS, HPUX does not have the option for sysconf() that it uses.  I have a working addition:\n\nadd this include at the top:\n#if defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n\t#include <sys/mpctl.h>\n#endif\n\nand add this where it is getting the number of CPUs:\n#elif defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n     \tnumCpus = (int)mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\nhere are two sources for this information:\nhttp://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine\nhttp://h21007.www2.hp.com/portal/download/files/unprot/stk/solaris_stk/impacts/i190.html\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf/lang/System.cpp error with HPUX aCC\n\nDescription:\nin the file src/main/decaf/lang/System.cpp,\nit tries to get the number of CPUS, HPUX does not have the option for sysconf() that it uses.  I have a working addition:\n\nadd this include at the top:\n#if defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n\t#include <sys/mpctl.h>\n#endif\n\nand add this where it is getting the number of CPUs:\n#elif defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n     \tnumCpus = (int)mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\nhere are two sources for this information:\nhttp://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine\nhttp://h21007.www2.hp.com/portal/download/files/unprot/stk/solaris_stk/impacts/i190.html\n\nComments:\n", "classification": "Classify the issue 'decaf/lang/System.cpp error with HPUX aCC' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-417?\nA: in the file src/main/decaf/lang/System.cpp,\nit tries to get the number of CPUS, HPUX does not have the option for sysconf() that it uses.  I have a working addition:\n\nadd this include at the top:\n#if defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n\t#include <sys/mpctl.h>\n#endif\n\nand add this where it is getting the number of CPUs:\n#elif defined( _HP_NAMESPACE_STD ) || !defined( _HPUX )\n     \tnum"}}
{"issue_key": "AMQCPP-416", "project": "AMQCPP", "title": "help wrong for configure", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["configuration", "help"], "created": "2012-08-06T17:47:23.000+0000", "updated": "2012-08-06T22:51:12.000+0000", "description": "when you do ./configure --help, \nit says an option is --with-cppunit\n\nTHe option in the code is actually --with-cppunit-prefix", "comments": [], "text": "help wrong for configure\n\nDescription:\nwhen you do ./configure --help, \nit says an option is --with-cppunit\n\nTHe option in the code is actually --with-cppunit-prefix\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: help wrong for configure\n\nDescription:\nwhen you do ./configure --help, \nit says an option is --with-cppunit\n\nTHe option in the code is actually --with-cppunit-prefix\n\nComments:\n", "classification": "Classify the issue 'help wrong for configure' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-416?\nA: when you do ./configure --help, \nit says an option is --with-cppunit\n\nTHe option in the code is actually --with-cppunit-prefix"}}
{"issue_key": "AMQCPP-415", "project": "AMQCPP", "title": "compiler flags with HPUX 11_31 aCC A.06.26", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["HPUX", "compiler", "configuration", "installer"], "created": "2012-08-06T17:44:22.000+0000", "updated": "2012-08-09T14:39:39.000+0000", "description": "The configure script places -PIC for flags when compiling and linking, but -P in aCC is something very different than it is in gcc.\nIn aCC it Preprocess named C/C++ files and leave the result in corresponding files suffixed with .i.\nIn gcc it Inhibit generation of linemarkers in the output from the preprocessor.  This might be useful when running the pre-processor on something that is not C code, and will be sent to a program which might be confused by the linemark-ers.\n\nThis flag overwrote the -o option and caused no .o files to be created and make would fail when it got that far.", "comments": [], "text": "compiler flags with HPUX 11_31 aCC A.06.26\n\nDescription:\nThe configure script places -PIC for flags when compiling and linking, but -P in aCC is something very different than it is in gcc.\nIn aCC it Preprocess named C/C++ files and leave the result in corresponding files suffixed with .i.\nIn gcc it Inhibit generation of linemarkers in the output from the preprocessor.  This might be useful when running the pre-processor on something that is not C code, and will be sent to a program which might be confused by the linemark-ers.\n\nThis flag overwrote the -o option and caused no .o files to be created and make would fail when it got that far.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: compiler flags with HPUX 11_31 aCC A.06.26\n\nDescription:\nThe configure script places -PIC for flags when compiling and linking, but -P in aCC is something very different than it is in gcc.\nIn aCC it Preprocess named C/C++ files and leave the result in corresponding files suffixed with .i.\nIn gcc it Inhibit generation of linemarkers in the output from the preprocessor.  This might be useful when running the pre-processor on something that is not C code, and will be sent to a program which might be confused by the linemark-ers.\n\nThis flag overwrote the -o option and caused no .o files to be created and make would fail when it got that far.\n\nComments:\n", "classification": "Classify the issue 'compiler flags with HPUX 11_31 aCC A.06.26' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-415?\nA: The configure script places -PIC for flags when compiling and linking, but -P in aCC is something very different than it is in gcc.\nIn aCC it Preprocess named C/C++ files and leave the result in corresponding files suffixed with .i.\nIn gcc it Inhibit generation of linemarkers in the output from the preprocessor.  This might be useful when running the pre-processor on something that is not C code, "}}
{"issue_key": "AMQCPP-760", "project": "AMQCPP", "title": "ActiveMQ-CPP 3.9.5 Failover Timeout Issue with Advisory Topic in PROD", "status": "Open", "reporter": "Oren", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2025-06-30T14:35:01.000+0000", "updated": "2025-06-30T15:27:00.000+0000", "description": "h2. Summary\r\n\r\nWe are experiencing a timeout issue in our PROD environment when using the ActiveMQ-CPP 3.9.5 client with aÂ {{failover:}}Â URI, specifically when subscribing to the advisory topicÂ {{{}ActiveMQ.Advisory.Consumer.Queue.101{}}}. The issue persists despite upgrading from 3.9.3 (whereÂ AMQCPP-610Â was suspected) and correcting a typo in theÂ {{{}AMQ_URL{}}}. The same code works in non-PROD environments (TEST/BETA) and in PROD with a directÂ {{tcp://}}Â URI.\r\nh2. Issue Description\r\n\r\nThe demo times out in PROD when using theÂ failover:Â protocol to receive advisory messages forÂ Queue.101. Key observations:\r\n * Works in TEST/BETA with identical broker settings andÂ failover:Â URI (maxReconnectAttempts=10).\r\n{noformat}\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-betappqua01.icc.corp:20801])\"\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ demo_sys_amq_modules.exe 101\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-betappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory^{noformat}\r\n * Works in PROD with directÂ [tcp://cca-prdappqua01.icc.corp:20801].\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"[tcp://cca-prdappqua01.icc.corp:20801]\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to [tcp://cca-prdappqua01.icc.corp:20801]\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory{noformat}\r\n * Fails in PROD withÂ failover:Â even after upgrading to 3.9.5 (fixing [AMQCPP-610]) and correcting a typo in the originalÂ AMQ_URLÂ (maxReconnectAttemps=0, which defaulted toÂ maxReconnectAttempts=-1).\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-prdappqua01.icc.corp:20801])\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-prdappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nNo advisory message received (timeout).{noformat}\r\n * Java-based clients work reliably in PROD withÂ failover:.\r\n\r\nh2. Relevant Broker Log Entries\r\n\r\nFromÂ activemq.logÂ onÂ cca-prdappqua01Â (ActiveMQ 5.17.3) activemq.log file attached:\r\n{noformat}\r\n2025-05-19 21:21:23,839 | WARNÂ  | TopicSubscription: consumer=ID:cca-prdappbta07.icc.corp-14259-1747678799256-0:0:-1:1, ... dispatched=1000, delivered=0, matched=1001, ... has twice its prefetch limit pending, without an ack; it appears to be slow: [tcp://10.222.12.83:31247]\r\n\r\n2025-05-19 17:31:22,146 | WARNÂ  | Transport Connection to: [tcp://10.222.12.74:25787] failed: Broken pipe (Write failed)\r\n\r\n2025-05-24 20:25:15,567 | WARNÂ  | Transport Connection to: [tcp://10.222.12.84:33681] failed: Cannot send, channel has already failed{noformat}\r\n * Slow topic consumers onÂ cca-prdappbta07,Â cca-prdappbta02,Â cca-prdappbta08Â suggest broker resource contention.\r\n * Failed connections indicate potential network instability affecting failover clients.\r\n\r\nh2. Suspected Causes\r\n # {*}Broker Overload{*}: Slow consumers may delay advisory message delivery, impacting failover clients.\r\n # {*}Network Issues{*}: Failed connections suggest network instability, disrupting failover retries or subscriptions.\r\n # {*}Advisory Message Absence{*}: Possible lack of consumer activity onÂ Queue.101Â in PROD.\r\n # {*}Residual Effects{*}: Earlier 3.9.3 clients withÂ maxReconnectAttemps=0Â (defaulting toÂ -1) may have stressed the broker, affecting current 3.9.5 clients.\r\n # {*}Failover Transport{*}: Possible edge case in 3.9.5 failover handling for advisory topics.\r\n\r\nh2. Steps Taken\r\n * Upgraded from ActiveMQ-CPP 3.9.3 to 3.9.5 to addressÂ AMQCPP-610.\r\n * CorrectedÂ {{AMQ_URL}}Â typo (maxReconnectAttempsÂ toÂ maxReconnectAttempts=10).\r\n * Tested with directÂ {{tcp://}}Â URI (works) andÂ {{failover:}}Â (times out).\r\n * Verified broker connectivity viaÂ telnetÂ (successful).\r\n * Added consumer forÂ {{Queue.101}}Â to trigger advisory messages (no success yet).\r\n * Enabled debug logging in the demo (logs pending).\r\n\r\nh2. Request for Assistance\r\n * Is there a known issue in ActiveMQ-CPP 3.9.5 with failover and advisory topic subscriptions under high broker load or network instability?\r\n * Could slow consumers (as seen in the log) affect failover client subscriptions? Any recommended configurations to mitigate this?\r\n * Are there additional failover parameters or patches in 3.9.5 to improve stability for advisory topics?\r\n * Suggestions for diagnosing broker-side issues (e.g., clearing stale connections without restart)?\r\n\r\nh2. Additional Information\r\n * {*}Broker Config{*}:Â advisorySupportÂ isÂ trueÂ (default for 5.17.3 see attached activemq.xml).\r\n * {*}Compile Command{*}:\r\n{noformat}\r\ng++ -O2 -finline-functions -D_XOPEN_SOURCE=600 -m64 -fPIC -Wall \\-L/usr/lib64 -lactivemq-cpp \\-isystem /usr/include/activemq-cpp-3.9.5 \\-std=c++11 \\src/demo_sys_amq_modules.cpp -o target/bin/demo_sys_amq_modules.exe{noformat}\r\n * {*}Next Steps Planned{*}: Test with non-advisory topic, increaseÂ receiveÂ timeout to 60s, checkÂ activemq.xmlÂ for advisory settings, and consider upgrading to 3.10.0.\r\n\r\nPlease advise on next steps or known issues. Thank you for your support!", "comments": [], "text": "ActiveMQ-CPP 3.9.5 Failover Timeout Issue with Advisory Topic in PROD\n\nDescription:\nh2. Summary\r\n\r\nWe are experiencing a timeout issue in our PROD environment when using the ActiveMQ-CPP 3.9.5 client with aÂ {{failover:}}Â URI, specifically when subscribing to the advisory topicÂ {{{}ActiveMQ.Advisory.Consumer.Queue.101{}}}. The issue persists despite upgrading from 3.9.3 (whereÂ AMQCPP-610Â was suspected) and correcting a typo in theÂ {{{}AMQ_URL{}}}. The same code works in non-PROD environments (TEST/BETA) and in PROD with a directÂ {{tcp://}}Â URI.\r\nh2. Issue Description\r\n\r\nThe demo times out in PROD when using theÂ failover:Â protocol to receive advisory messages forÂ Queue.101. Key observations:\r\n * Works in TEST/BETA with identical broker settings andÂ failover:Â URI (maxReconnectAttempts=10).\r\n{noformat}\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-betappqua01.icc.corp:20801])\"\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ demo_sys_amq_modules.exe 101\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-betappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory^{noformat}\r\n * Works in PROD with directÂ [tcp://cca-prdappqua01.icc.corp:20801].\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"[tcp://cca-prdappqua01.icc.corp:20801]\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to [tcp://cca-prdappqua01.icc.corp:20801]\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory{noformat}\r\n * Fails in PROD withÂ failover:Â even after upgrading to 3.9.5 (fixing [AMQCPP-610]) and correcting a typo in the originalÂ AMQ_URLÂ (maxReconnectAttemps=0, which defaulted toÂ maxReconnectAttempts=-1).\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-prdappqua01.icc.corp:20801])\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-prdappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nNo advisory message received (timeout).{noformat}\r\n * Java-based clients work reliably in PROD withÂ failover:.\r\n\r\nh2. Relevant Broker Log Entries\r\n\r\nFromÂ activemq.logÂ onÂ cca-prdappqua01Â (ActiveMQ 5.17.3) activemq.log file attached:\r\n{noformat}\r\n2025-05-19 21:21:23,839 | WARNÂ  | TopicSubscription: consumer=ID:cca-prdappbta07.icc.corp-14259-1747678799256-0:0:-1:1, ... dispatched=1000, delivered=0, matched=1001, ... has twice its prefetch limit pending, without an ack; it appears to be slow: [tcp://10.222.12.83:31247]\r\n\r\n2025-05-19 17:31:22,146 | WARNÂ  | Transport Connection to: [tcp://10.222.12.74:25787] failed: Broken pipe (Write failed)\r\n\r\n2025-05-24 20:25:15,567 | WARNÂ  | Transport Connection to: [tcp://10.222.12.84:33681] failed: Cannot send, channel has already failed{noformat}\r\n * Slow topic consumers onÂ cca-prdappbta07,Â cca-prdappbta02,Â cca-prdappbta08Â suggest broker resource contention.\r\n * Failed connections indicate potential network instability affecting failover clients.\r\n\r\nh2. Suspected Causes\r\n # {*}Broker Overload{*}: Slow consumers may delay advisory message delivery, impacting failover clients.\r\n # {*}Network Issues{*}: Failed connections suggest network instability, disrupting failover retries or subscriptions.\r\n # {*}Advisory Message Absence{*}: Possible lack of consumer activity onÂ Queue.101Â in PROD.\r\n # {*}Residual Effects{*}: Earlier 3.9.3 clients withÂ maxReconnectAttemps=0Â (defaulting toÂ -1) may have stressed the broker, affecting current 3.9.5 clients.\r\n # {*}Failover Transport{*}: Possible edge case in 3.9.5 failover handling for advisory topics.\r\n\r\nh2. Steps Taken\r\n * Upgraded from ActiveMQ-CPP 3.9.3 to 3.9.5 to addressÂ AMQCPP-610.\r\n * CorrectedÂ {{AMQ_URL}}Â typo (maxReconnectAttempsÂ toÂ maxReconnectAttempts=10).\r\n * Tested with directÂ {{tcp://}}Â URI (works) andÂ {{failover:}}Â (times out).\r\n * Verified broker connectivity viaÂ telnetÂ (successful).\r\n * Added consumer forÂ {{Queue.101}}Â to trigger advisory messages (no success yet).\r\n * Enabled debug logging in the demo (logs pending).\r\n\r\nh2. Request for Assistance\r\n * Is there a known issue in ActiveMQ-CPP 3.9.5 with failover and advisory topic subscriptions under high broker load or network instability?\r\n * Could slow consumers (as seen in the log) affect failover client subscriptions? Any recommended configurations to mitigate this?\r\n * Are there additional failover parameters or patches in 3.9.5 to improve stability for advisory topics?\r\n * Suggestions for diagnosing broker-side issues (e.g., clearing stale connections without restart)?\r\n\r\nh2. Additional Information\r\n * {*}Broker Config{*}:Â advisorySupportÂ isÂ trueÂ (default for 5.17.3 see attached activemq.xml).\r\n * {*}Compile Command{*}:\r\n{noformat}\r\ng++ -O2 -finline-functions -D_XOPEN_SOURCE=600 -m64 -fPIC -Wall \\-L/usr/lib64 -lactivemq-cpp \\-isystem /usr/include/activemq-cpp-3.9.5 \\-std=c++11 \\src/demo_sys_amq_modules.cpp -o target/bin/demo_sys_amq_modules.exe{noformat}\r\n * {*}Next Steps Planned{*}: Test with non-advisory topic, increaseÂ receiveÂ timeout to 60s, checkÂ activemq.xmlÂ for advisory settings, and consider upgrading to 3.10.0.\r\n\r\nPlease advise on next steps or known issues. Thank you for your support!\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ-CPP 3.9.5 Failover Timeout Issue with Advisory Topic in PROD\n\nDescription:\nh2. Summary\r\n\r\nWe are experiencing a timeout issue in our PROD environment when using the ActiveMQ-CPP 3.9.5 client with aÂ {{failover:}}Â URI, specifically when subscribing to the advisory topicÂ {{{}ActiveMQ.Advisory.Consumer.Queue.101{}}}. The issue persists despite upgrading from 3.9.3 (whereÂ AMQCPP-610Â was suspected) and correcting a typo in theÂ {{{}AMQ_URL{}}}. The same code works in non-PROD environments (TEST/BETA) and in PROD with a directÂ {{tcp://}}Â URI.\r\nh2. Issue Description\r\n\r\nThe demo times out in PROD when using theÂ failover:Â protocol to receive advisory messages forÂ Queue.101. Key observations:\r\n * Works in TEST/BETA with identical broker settings andÂ failover:Â URI (maxReconnectAttempts=10).\r\n{noformat}\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-betappqua01.icc.corp:20801])\"\r\n[BETA l_onissa@cca-betappbta01 cca_domain]$ demo_sys_amq_modules.exe 101\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-betappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory^{noformat}\r\n * Works in PROD with directÂ [tcp://cca-prdappqua01.icc.corp:20801].\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"[tcp://cca-prdappqua01.icc.corp:20801]\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to [tcp://cca-prdappqua01.icc.corp:20801]\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nReceived advisory message of type: Advisory{noformat}\r\n * Fails in PROD withÂ failover:Â even after upgrading to 3.9.5 (fixing [AMQCPP-610]) and correcting a typo in the originalÂ AMQ_URLÂ (maxReconnectAttemps=0, which defaulted toÂ maxReconnectAttempts=-1).\r\n{noformat}\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ AMQ_URL=\"failover:([tcp://cca-prdappqua01.icc.corp:20801])\"*\r\n*[PROD l_onissa@cca-prdappbta05 cca_domain]$ demo_sys_amq_modules.exe 101*\r\nActiveMQ-CPP initialized. Connecting to failover:([tcp://cca-prdappqua01.icc.corp:20801])\r\nWaiting for advisory messages on: ActiveMQ.Advisory.Consumer.Queue.101 ...\r\nNo advisory message received (timeout).{noformat}\r\n * Java-based clients work reliably in PROD withÂ failover:.\r\n\r\nh2. Relevant Broker Log Entries\r\n\r\nFromÂ activemq.logÂ onÂ cca-prdappqua01Â (ActiveMQ 5.17.3) activemq.log file attached:\r\n{noformat}\r\n2025-05-19 21:21:23,839 | WARNÂ  | TopicSubscription: consumer=ID:cca-prdappbta07.icc.corp-14259-1747678799256-0:0:-1:1, ... dispatched=1000, delivered=0, matched=1001, ... has twice its prefetch limit pending, without an ack; it appears to be slow: [tcp://10.222.12.83:31247]\r\n\r\n2025-05-19 17:31:22,146 | WARNÂ  | Transport Connection to: [tcp://10.222.12.74:25787] failed: Broken pipe (Write failed)\r\n\r\n2025-05-24 20:25:15,567 | WARNÂ  | Transport Connection to: [tcp://10.222.12.84:33681] failed: Cannot send, channel has already failed{noformat}\r\n * Slow topic consumers onÂ cca-prdappbta07,Â cca-prdappbta02,Â cca-prdappbta08Â suggest broker resource contention.\r\n * Failed connections indicate potential network instability affecting failover clients.\r\n\r\nh2. Suspected Causes\r\n # {*}Broker Overload{*}: Slow consumers may delay advisory message delivery, impacting failover clients.\r\n # {*}Network Issues{*}: Failed connections suggest network instability, disrupting failover retries or subscriptions.\r\n # {*}Advisory Message Absence{*}: Possible lack of consumer activity onÂ Queue.101Â in PROD.\r\n # {*}Residual Effects{*}: Earlier 3.9.3 clients withÂ maxReconnectAttemps=0Â (defaulting toÂ -1) may have stressed the broker, affecting current 3.9.5 clients.\r\n # {*}Failover Transport{*}: Possible edge case in 3.9.5 failover handling for advisory topics.\r\n\r\nh2. Steps Taken\r\n * Upgraded from ActiveMQ-CPP 3.9.3 to 3.9.5 to addressÂ AMQCPP-610.\r\n * CorrectedÂ {{AMQ_URL}}Â typo (maxReconnectAttempsÂ toÂ maxReconnectAttempts=10).\r\n * Tested with directÂ {{tcp://}}Â URI (works) andÂ {{failover:}}Â (times out).\r\n * Verified broker connectivity viaÂ telnetÂ (successful).\r\n * Added consumer forÂ {{Queue.101}}Â to trigger advisory messages (no success yet).\r\n * Enabled debug logging in the demo (logs pending).\r\n\r\nh2. Request for Assistance\r\n * Is there a known issue in ActiveMQ-CPP 3.9.5 with failover and advisory topic subscriptions under high broker load or network instability?\r\n * Could slow consumers (as seen in the log) affect failover client subscriptions? Any recommended configurations to mitigate this?\r\n * Are there additional failover parameters or patches in 3.9.5 to improve stability for advisory topics?\r\n * Suggestions for diagnosing broker-side issues (e.g., clearing stale connections without restart)?\r\n\r\nh2. Additional Information\r\n * {*}Broker Config{*}:Â advisorySupportÂ isÂ trueÂ (default for 5.17.3 see attached activemq.xml).\r\n * {*}Compile Command{*}:\r\n{noformat}\r\ng++ -O2 -finline-functions -D_XOPEN_SOURCE=600 -m64 -fPIC -Wall \\-L/usr/lib64 -lactivemq-cpp \\-isystem /usr/include/activemq-cpp-3.9.5 \\-std=c++11 \\src/demo_sys_amq_modules.cpp -o target/bin/demo_sys_amq_modules.exe{noformat}\r\n * {*}Next Steps Planned{*}: Test with non-advisory topic, increaseÂ receiveÂ timeout to 60s, checkÂ activemq.xmlÂ for advisory settings, and consider upgrading to 3.10.0.\r\n\r\nPlease advise on next steps or known issues. Thank you for your support!\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ-CPP 3.9.5 Failover Timeout Issue with Advisory Topic in PROD' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-760?\nA: h2. Summary\r\n\r\nWe are experiencing a timeout issue in our PROD environment when using the ActiveMQ-CPP 3.9.5 client with aÂ {{failover:}}Â URI, specifically when subscribing to the advisory topicÂ {{{}ActiveMQ.Advisory.Consumer.Queue.101{}}}. The issue persists despite upgrading from 3.9.3 (whereÂ AMQCPP-610Â was suspected) and correcting a typo in theÂ {{{}AMQ_URL{}}}. The same code works in non-PROD e"}}
{"issue_key": "AMQCPP-759", "project": "AMQCPP", "title": "src/main/decaf/lang/Long.cpp does not detect overflow properly", "status": "Open", "reporter": "Arjun Ray", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2025-03-06T03:09:37.000+0000", "updated": "2025-03-06T03:20:44.000+0000", "description": "The code has a defective test for overflow (at line 221)\r\n{color:#cccccc}Â  Â  Â  Â  {color}{color:#c586c0}if{color}{color:#cccccc} ({color}{color:#9cdcfe}max{color}{color:#cccccc} {color}{color:#d4d4d4}>{color}{color:#cccccc} {color}{color:#9cdcfe}result{color}{color:#cccccc}) {{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  {color}{color:#c586c0}throw{color}{color:#cccccc} {color}{color:#4ec9b0}exceptions{color}{color:#cccccc}::{color}{color:#4ec9b0}NumberFormatException{color}{color:#cccccc}({color}{color:#569cd6}{_}{{_}}FILE{{_}}{_}{color}{color:#cccccc}, {color}{color:#569cd6}{_}{{_}}LINE{{_}}{_}{color}{color:#cccccc},{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  Â  Â  {color}{color:#ce9178}\"Long::parseLong - Parsed value greater than max for radix.\"{color}{color:#cccccc});{color}\r\n{color:#cccccc}Â  Â  Â  Â  }{color}\r\nThe bug shows up when the code base is compiled with optimization turned on (typically, with -O2).Â  With that the compiler (gcc) assumes that overflow will not occur and therefore does not even check for it.Â  As a result, an exception is not thrown, which causes a unit test (which was expecting the exception for invalid input) to fail.Â  Without optimization, the overflow causes undefined behavior (according to the C++ standards), which in this particular case results in the unit test passing accidentally.\r\n\r\nThis bug occurs only with unusual inputs, but in theory should not be present at all with a correct implementation of overflow detection. Â This issue has been discussed in some depth at\r\n[https://stackoverflow.com/questions/3944505/detecting-signed-overflow-in-c-c]", "comments": [], "text": "src/main/decaf/lang/Long.cpp does not detect overflow properly\n\nDescription:\nThe code has a defective test for overflow (at line 221)\r\n{color:#cccccc}Â  Â  Â  Â  {color}{color:#c586c0}if{color}{color:#cccccc} ({color}{color:#9cdcfe}max{color}{color:#cccccc} {color}{color:#d4d4d4}>{color}{color:#cccccc} {color}{color:#9cdcfe}result{color}{color:#cccccc}) {{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  {color}{color:#c586c0}throw{color}{color:#cccccc} {color}{color:#4ec9b0}exceptions{color}{color:#cccccc}::{color}{color:#4ec9b0}NumberFormatException{color}{color:#cccccc}({color}{color:#569cd6}{_}{{_}}FILE{{_}}{_}{color}{color:#cccccc}, {color}{color:#569cd6}{_}{{_}}LINE{{_}}{_}{color}{color:#cccccc},{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  Â  Â  {color}{color:#ce9178}\"Long::parseLong - Parsed value greater than max for radix.\"{color}{color:#cccccc});{color}\r\n{color:#cccccc}Â  Â  Â  Â  }{color}\r\nThe bug shows up when the code base is compiled with optimization turned on (typically, with -O2).Â  With that the compiler (gcc) assumes that overflow will not occur and therefore does not even check for it.Â  As a result, an exception is not thrown, which causes a unit test (which was expecting the exception for invalid input) to fail.Â  Without optimization, the overflow causes undefined behavior (according to the C++ standards), which in this particular case results in the unit test passing accidentally.\r\n\r\nThis bug occurs only with unusual inputs, but in theory should not be present at all with a correct implementation of overflow detection. Â This issue has been discussed in some depth at\r\n[https://stackoverflow.com/questions/3944505/detecting-signed-overflow-in-c-c]\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: src/main/decaf/lang/Long.cpp does not detect overflow properly\n\nDescription:\nThe code has a defective test for overflow (at line 221)\r\n{color:#cccccc}Â  Â  Â  Â  {color}{color:#c586c0}if{color}{color:#cccccc} ({color}{color:#9cdcfe}max{color}{color:#cccccc} {color}{color:#d4d4d4}>{color}{color:#cccccc} {color}{color:#9cdcfe}result{color}{color:#cccccc}) {{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  {color}{color:#c586c0}throw{color}{color:#cccccc} {color}{color:#4ec9b0}exceptions{color}{color:#cccccc}::{color}{color:#4ec9b0}NumberFormatException{color}{color:#cccccc}({color}{color:#569cd6}{_}{{_}}FILE{{_}}{_}{color}{color:#cccccc}, {color}{color:#569cd6}{_}{{_}}LINE{{_}}{_}{color}{color:#cccccc},{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  Â  Â  {color}{color:#ce9178}\"Long::parseLong - Parsed value greater than max for radix.\"{color}{color:#cccccc});{color}\r\n{color:#cccccc}Â  Â  Â  Â  }{color}\r\nThe bug shows up when the code base is compiled with optimization turned on (typically, with -O2).Â  With that the compiler (gcc) assumes that overflow will not occur and therefore does not even check for it.Â  As a result, an exception is not thrown, which causes a unit test (which was expecting the exception for invalid input) to fail.Â  Without optimization, the overflow causes undefined behavior (according to the C++ standards), which in this particular case results in the unit test passing accidentally.\r\n\r\nThis bug occurs only with unusual inputs, but in theory should not be present at all with a correct implementation of overflow detection. Â This issue has been discussed in some depth at\r\n[https://stackoverflow.com/questions/3944505/detecting-signed-overflow-in-c-c]\n\nComments:\n", "classification": "Classify the issue 'src/main/decaf/lang/Long.cpp does not detect overflow properly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-759?\nA: The code has a defective test for overflow (at line 221)\r\n{color:#cccccc}Â  Â  Â  Â  {color}{color:#c586c0}if{color}{color:#cccccc} ({color}{color:#9cdcfe}max{color}{color:#cccccc} {color}{color:#d4d4d4}>{color}{color:#cccccc} {color}{color:#9cdcfe}result{color}{color:#cccccc}) {{color}\r\n{color:#cccccc}Â  Â  Â  Â  Â  Â  {color}{color:#c586c0}throw{color}{color:#cccccc} {color}{color:#4ec9b0}exceptions{color"}}
{"issue_key": "AMQCPP-758", "project": "AMQCPP", "title": "Consolidate README.txt files", "status": "Open", "reporter": "Arjun Ray", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2025-03-06T02:52:24.000+0000", "updated": "2025-06-05T11:33:29.000+0000", "description": "There are two README.txt files in the distribution package.Â  One of them is quite out of date, and could be a source of confusion.Â  The other is missing relevant information as well.\r\n\r\nThe two should be consolidated into a single file, preferably in the MD format,", "comments": [], "text": "Consolidate README.txt files\n\nDescription:\nThere are two README.txt files in the distribution package.Â  One of them is quite out of date, and could be a source of confusion.Â  The other is missing relevant information as well.\r\n\r\nThe two should be consolidated into a single file, preferably in the MD format,\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consolidate README.txt files\n\nDescription:\nThere are two README.txt files in the distribution package.Â  One of them is quite out of date, and could be a source of confusion.Â  The other is missing relevant information as well.\r\n\r\nThe two should be consolidated into a single file, preferably in the MD format,\n\nComments:\n", "classification": "Classify the issue 'Consolidate README.txt files' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-758?\nA: There are two README.txt files in the distribution package.Â  One of them is quite out of date, and could be a source of confusion.Â  The other is missing relevant information as well.\r\n\r\nThe two should be consolidated into a single file, preferably in the MD format,"}}
{"issue_key": "AMQCPP-757", "project": "AMQCPP", "title": "cppunit-config program is obsolete and dropped", "status": "Open", "reporter": "Arjun Ray", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2025-03-03T23:20:08.000+0000", "updated": "2025-06-05T11:33:14.000+0000", "description": "The cppunit-config program has been obsolete since 2016, and is no longer in the package. Our configure script's m4 macros rely on it to build the test suite.Â  The m4 macros should be updated to use pkg-config as well before giving up.", "comments": [], "text": "cppunit-config program is obsolete and dropped\n\nDescription:\nThe cppunit-config program has been obsolete since 2016, and is no longer in the package. Our configure script's m4 macros rely on it to build the test suite.Â  The m4 macros should be updated to use pkg-config as well before giving up.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: cppunit-config program is obsolete and dropped\n\nDescription:\nThe cppunit-config program has been obsolete since 2016, and is no longer in the package. Our configure script's m4 macros rely on it to build the test suite.Â  The m4 macros should be updated to use pkg-config as well before giving up.\n\nComments:\n", "classification": "Classify the issue 'cppunit-config program is obsolete and dropped' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-757?\nA: The cppunit-config program has been obsolete since 2016, and is no longer in the package. Our configure script's m4 macros rely on it to build the test suite.Â  The m4 macros should be updated to use pkg-config as well before giving up."}}
{"issue_key": "AMQCPP-756", "project": "AMQCPP", "title": "Upgrade for C++17 compliance", "status": "Resolved", "reporter": "Arjun Ray", "assignee": "Arthur Naseef", "priority": "Major", "labels": [], "created": "2025-02-19T07:08:02.000+0000", "updated": "2025-10-14T12:17:21.000+0000", "description": "Changes covered:\r\n # Global replacement of std::auto_ptr with std::unique_ptr.\r\n # 6 fixups for this change (5 initializers, 1 missing include file).\r\n # Compiling with GCC 11.4.0 yields\r\n ## 1 error from 'make' and 5 errors from 'make check'\r\n ## 197 warnings from 'make' and 35 from 'make check'.\r\n # 6 + 38 files modified to eliminate these issues.Â  No change in user-facing APIs.\r\n # All tests pass (2070 regular, 133 integration).\r\n\r\nOdds and ends:\r\n # Temporary script added to make up for missing cppunit-config (obsolete and removed from distributions).\r\n # More generally, the m4 macros used to configure the build are badly out of date and need to be upgraded (at which point the script above can be removed).\r\n # Global replacement of 'throw()' with 'noexcept' is advisable, as the 'throw()' alias has been removed in C++20.\r\n # OpenSSL version >= 1.1.0\r\n\r\nThis Jira is to label the set of changes properly in a pull request to be submitted in Github. Files will also be available in a 'forked' version on Github at [https://github.com/arayq2/activemq-cpp.]\r\n\r\nÂ \r\n\r\n4 attachments;\r\n # Patch for eliminating redundant initializers (fixinits.diff).\r\n # Patch for global replacement of auto_ptr (fixautoptr.diff).\r\n # Patch for fixing errors from C++17 compilation (fixerrs.diff).\r\n # Patch for fixing warnings from C++17 compilation (fixwarns.diff)", "comments": [], "text": "Upgrade for C++17 compliance\n\nDescription:\nChanges covered:\r\n # Global replacement of std::auto_ptr with std::unique_ptr.\r\n # 6 fixups for this change (5 initializers, 1 missing include file).\r\n # Compiling with GCC 11.4.0 yields\r\n ## 1 error from 'make' and 5 errors from 'make check'\r\n ## 197 warnings from 'make' and 35 from 'make check'.\r\n # 6 + 38 files modified to eliminate these issues.Â  No change in user-facing APIs.\r\n # All tests pass (2070 regular, 133 integration).\r\n\r\nOdds and ends:\r\n # Temporary script added to make up for missing cppunit-config (obsolete and removed from distributions).\r\n # More generally, the m4 macros used to configure the build are badly out of date and need to be upgraded (at which point the script above can be removed).\r\n # Global replacement of 'throw()' with 'noexcept' is advisable, as the 'throw()' alias has been removed in C++20.\r\n # OpenSSL version >= 1.1.0\r\n\r\nThis Jira is to label the set of changes properly in a pull request to be submitted in Github. Files will also be available in a 'forked' version on Github at [https://github.com/arayq2/activemq-cpp.]\r\n\r\nÂ \r\n\r\n4 attachments;\r\n # Patch for eliminating redundant initializers (fixinits.diff).\r\n # Patch for global replacement of auto_ptr (fixautoptr.diff).\r\n # Patch for fixing errors from C++17 compilation (fixerrs.diff).\r\n # Patch for fixing warnings from C++17 compilation (fixwarns.diff)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Upgrade for C++17 compliance\n\nDescription:\nChanges covered:\r\n # Global replacement of std::auto_ptr with std::unique_ptr.\r\n # 6 fixups for this change (5 initializers, 1 missing include file).\r\n # Compiling with GCC 11.4.0 yields\r\n ## 1 error from 'make' and 5 errors from 'make check'\r\n ## 197 warnings from 'make' and 35 from 'make check'.\r\n # 6 + 38 files modified to eliminate these issues.Â  No change in user-facing APIs.\r\n # All tests pass (2070 regular, 133 integration).\r\n\r\nOdds and ends:\r\n # Temporary script added to make up for missing cppunit-config (obsolete and removed from distributions).\r\n # More generally, the m4 macros used to configure the build are badly out of date and need to be upgraded (at which point the script above can be removed).\r\n # Global replacement of 'throw()' with 'noexcept' is advisable, as the 'throw()' alias has been removed in C++20.\r\n # OpenSSL version >= 1.1.0\r\n\r\nThis Jira is to label the set of changes properly in a pull request to be submitted in Github. Files will also be available in a 'forked' version on Github at [https://github.com/arayq2/activemq-cpp.]\r\n\r\nÂ \r\n\r\n4 attachments;\r\n # Patch for eliminating redundant initializers (fixinits.diff).\r\n # Patch for global replacement of auto_ptr (fixautoptr.diff).\r\n # Patch for fixing errors from C++17 compilation (fixerrs.diff).\r\n # Patch for fixing warnings from C++17 compilation (fixwarns.diff)\n\nComments:\n", "classification": "Classify the issue 'Upgrade for C++17 compliance' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-756?\nA: Changes covered:\r\n # Global replacement of std::auto_ptr with std::unique_ptr.\r\n # 6 fixups for this change (5 initializers, 1 missing include file).\r\n # Compiling with GCC 11.4.0 yields\r\n ## 1 error from 'make' and 5 errors from 'make check'\r\n ## 197 warnings from 'make' and 35 from 'make check'.\r\n # 6 + 38 files modified to eliminate these issues.Â  No change in user-facing APIs.\r\n # All tests pa"}}
{"issue_key": "AMQCPP-755", "project": "AMQCPP", "title": "Deadlock in FailoverTransport handleTransportFailure and oneway", "status": "Open", "reporter": "Evan Ward", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2024-09-04T14:48:08.000+0000", "updated": "2024-09-04T14:50:59.000+0000", "description": "# the library in FailoverTransport::handleTransportFailure takes a lock (FailoverTransfor.reconnectMutex)\r\n # then calls application code to notify the disconnection (transportInterrupted())\r\n # then the called application code attempts to send message with the notification\r\n # then in FailoverTransport::oneway line 458 the library waits on the lock it already owns (FailoverTransfor.reconnectMutex)\r\n\r\nThe result is the library will never send message and never attempt to reconnect.\r\n\r\nExpected behavior is that the activemq-cpp library reconnects, then sends the message.\r\n\r\nOne way to fix would be to ensure all locks are released before calling application code. Another possible fix would be to use re-entrant aware waiting.", "comments": [], "text": "Deadlock in FailoverTransport handleTransportFailure and oneway\n\nDescription:\n# the library in FailoverTransport::handleTransportFailure takes a lock (FailoverTransfor.reconnectMutex)\r\n # then calls application code to notify the disconnection (transportInterrupted())\r\n # then the called application code attempts to send message with the notification\r\n # then in FailoverTransport::oneway line 458 the library waits on the lock it already owns (FailoverTransfor.reconnectMutex)\r\n\r\nThe result is the library will never send message and never attempt to reconnect.\r\n\r\nExpected behavior is that the activemq-cpp library reconnects, then sends the message.\r\n\r\nOne way to fix would be to ensure all locks are released before calling application code. Another possible fix would be to use re-entrant aware waiting.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock in FailoverTransport handleTransportFailure and oneway\n\nDescription:\n# the library in FailoverTransport::handleTransportFailure takes a lock (FailoverTransfor.reconnectMutex)\r\n # then calls application code to notify the disconnection (transportInterrupted())\r\n # then the called application code attempts to send message with the notification\r\n # then in FailoverTransport::oneway line 458 the library waits on the lock it already owns (FailoverTransfor.reconnectMutex)\r\n\r\nThe result is the library will never send message and never attempt to reconnect.\r\n\r\nExpected behavior is that the activemq-cpp library reconnects, then sends the message.\r\n\r\nOne way to fix would be to ensure all locks are released before calling application code. Another possible fix would be to use re-entrant aware waiting.\n\nComments:\n", "classification": "Classify the issue 'Deadlock in FailoverTransport handleTransportFailure and oneway' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-755?\nA: # the library in FailoverTransport::handleTransportFailure takes a lock (FailoverTransfor.reconnectMutex)\r\n # then calls application code to notify the disconnection (transportInterrupted())\r\n # then the called application code attempts to send message with the notification\r\n # then in FailoverTransport::oneway line 458 the library waits on the lock it already owns (FailoverTransfor.reconnectMutex"}}
{"issue_key": "AMQCPP-754", "project": "AMQCPP", "title": "[Artemis Broker] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format.", "status": "Closed", "reporter": "Liviu Citu", "assignee": "Unassigned", "priority": "Critical", "labels": [], "created": "2024-06-20T06:25:33.000+0000", "updated": "2024-07-01T06:25:48.000+0000", "description": "We are currently in process of migrating our JMS Broker from Classic 5.x to Artemis.\r\n\r\nWe are currently using CMS C++ client for connecting to JMS Broker. Everything works fine when using non-SSL setup (on both Windows and Linux) but we have some issues when using SSL on Linux (SSL on Windows is OK).\r\n\r\nThe initial problem started with the following exceptions on the client side:\r\n\r\n*_024-02-22 09:54:37.377Â [ERROR]Â [activemq_connection.cc:336]Â CMS exception: Channel was inactive for too long:_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nwhile on the JMS Broker side we had:\r\n\r\n*_2024-03-20 12:29:08,700 ERROR [org.apache.activemq.artemis.core.server] AMQ224088: Timeout (10 seconds) on acceptor \"netty-ssl-acceptor\" during protocol handshake with /10.21.70.53:33053 has occurred._*\r\n\r\nTo bypass these we have added the following setting to the *broker.xml* *netty-ssl-acceptor* acceptor: *handshake-timeout=0*\r\n\r\nHowever now the exceptions we are receiving are:\r\n\r\n*_2024-05-22 09:26:40.842 [ERROR] [activemq_connection.cc:348] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format._*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nThe problem replicates with the following:\r\n * SSL on Linux. Problem does not replicate if non-SSL configuration is used. Also does not replicate on Windows (regardless if SSL or non-SSL is used)\r\n * two Artemis JMS Broker instances running on the same Linux host (problem does not replicate if there is only one Artemis JMS Broker instance running)\r\n * problem also replicates if there is one Artemis Broker and one Classic Broker instance running on the same host\r\n * *problem does not replicate with two instances of Classic Brokers. So it is specific to Artemis broker*\r\n * when testing with both Classic Broker and Artemis Broker, the client connections using the Classic Broker were fine. Only those using Artemis Broker were failing\r\n * CMS C++ client is also on Linux running on the same host. Basically both client and server are running on the same host\r\n * there are many connections done in the same time to the broker (50+). If there are only few then the problem does not happen\r\n * example of JMS Broker URL used by the client (the other instance just uses a different port)\r\n*ssl://linux_host:61617?soKeepAlive=true&wireFormat.MaxInactivityDuration=0*\r\n * JMS Broker configuration file attached (just mangled the SSL stuff and name of the host). The other one is similar (different ports)\r\n\r\nÂ \r\n\r\nMy first intention was to increase the OpenWire format negotiation timeout which is currently hardcoded in CMS CPP client to {*}15 seconds{*}.\r\n\r\nHowever when monitoring the successful connections I found out that they took less than 0.5 seconds. I was unable to find any successful connection that took more than this.\r\n\r\nThose that failed were unable to get the response from the Broker after 15 seconds. This means that the timeout value is not the issue here, It is something else.\r\n\r\nLooking to the JMS Broker logs we are unable to find any relevant message when the connection fails.", "comments": [], "text": "[Artemis Broker] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format.\n\nDescription:\nWe are currently in process of migrating our JMS Broker from Classic 5.x to Artemis.\r\n\r\nWe are currently using CMS C++ client for connecting to JMS Broker. Everything works fine when using non-SSL setup (on both Windows and Linux) but we have some issues when using SSL on Linux (SSL on Windows is OK).\r\n\r\nThe initial problem started with the following exceptions on the client side:\r\n\r\n*_024-02-22 09:54:37.377Â [ERROR]Â [activemq_connection.cc:336]Â CMS exception: Channel was inactive for too long:_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nwhile on the JMS Broker side we had:\r\n\r\n*_2024-03-20 12:29:08,700 ERROR [org.apache.activemq.artemis.core.server] AMQ224088: Timeout (10 seconds) on acceptor \"netty-ssl-acceptor\" during protocol handshake with /10.21.70.53:33053 has occurred._*\r\n\r\nTo bypass these we have added the following setting to the *broker.xml* *netty-ssl-acceptor* acceptor: *handshake-timeout=0*\r\n\r\nHowever now the exceptions we are receiving are:\r\n\r\n*_2024-05-22 09:26:40.842 [ERROR] [activemq_connection.cc:348] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format._*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nThe problem replicates with the following:\r\n * SSL on Linux. Problem does not replicate if non-SSL configuration is used. Also does not replicate on Windows (regardless if SSL or non-SSL is used)\r\n * two Artemis JMS Broker instances running on the same Linux host (problem does not replicate if there is only one Artemis JMS Broker instance running)\r\n * problem also replicates if there is one Artemis Broker and one Classic Broker instance running on the same host\r\n * *problem does not replicate with two instances of Classic Brokers. So it is specific to Artemis broker*\r\n * when testing with both Classic Broker and Artemis Broker, the client connections using the Classic Broker were fine. Only those using Artemis Broker were failing\r\n * CMS C++ client is also on Linux running on the same host. Basically both client and server are running on the same host\r\n * there are many connections done in the same time to the broker (50+). If there are only few then the problem does not happen\r\n * example of JMS Broker URL used by the client (the other instance just uses a different port)\r\n*ssl://linux_host:61617?soKeepAlive=true&wireFormat.MaxInactivityDuration=0*\r\n * JMS Broker configuration file attached (just mangled the SSL stuff and name of the host). The other one is similar (different ports)\r\n\r\nÂ \r\n\r\nMy first intention was to increase the OpenWire format negotiation timeout which is currently hardcoded in CMS CPP client to {*}15 seconds{*}.\r\n\r\nHowever when monitoring the successful connections I found out that they took less than 0.5 seconds. I was unable to find any successful connection that took more than this.\r\n\r\nThose that failed were unable to get the response from the Broker after 15 seconds. This means that the timeout value is not the issue here, It is something else.\r\n\r\nLooking to the JMS Broker logs we are unable to find any relevant message when the connection fails.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: [Artemis Broker] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format.\n\nDescription:\nWe are currently in process of migrating our JMS Broker from Classic 5.x to Artemis.\r\n\r\nWe are currently using CMS C++ client for connecting to JMS Broker. Everything works fine when using non-SSL setup (on both Windows and Linux) but we have some issues when using SSL on Linux (SSL on Windows is OK).\r\n\r\nThe initial problem started with the following exceptions on the client side:\r\n\r\n*_024-02-22 09:54:37.377Â [ERROR]Â [activemq_connection.cc:336]Â CMS exception: Channel was inactive for too long:_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\n\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nwhile on the JMS Broker side we had:\r\n\r\n*_2024-03-20 12:29:08,700 ERROR [org.apache.activemq.artemis.core.server] AMQ224088: Timeout (10 seconds) on acceptor \"netty-ssl-acceptor\" during protocol handshake with /10.21.70.53:33053 has occurred._*\r\n\r\nTo bypass these we have added the following setting to the *broker.xml* *netty-ssl-acceptor* acceptor: *handshake-timeout=0*\r\n\r\nHowever now the exceptions we are receiving are:\r\n\r\n*_2024-05-22 09:26:40.842 [ERROR] [activemq_connection.cc:348] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format._*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1293_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 1371_*\r\nÂ Â Â Â Â Â Â  *_FILE: activemq/core/ActiveMQConnection.cpp, LINE: 573_*\r\n\r\nThe problem replicates with the following:\r\n * SSL on Linux. Problem does not replicate if non-SSL configuration is used. Also does not replicate on Windows (regardless if SSL or non-SSL is used)\r\n * two Artemis JMS Broker instances running on the same Linux host (problem does not replicate if there is only one Artemis JMS Broker instance running)\r\n * problem also replicates if there is one Artemis Broker and one Classic Broker instance running on the same host\r\n * *problem does not replicate with two instances of Classic Brokers. So it is specific to Artemis broker*\r\n * when testing with both Classic Broker and Artemis Broker, the client connections using the Classic Broker were fine. Only those using Artemis Broker were failing\r\n * CMS C++ client is also on Linux running on the same host. Basically both client and server are running on the same host\r\n * there are many connections done in the same time to the broker (50+). If there are only few then the problem does not happen\r\n * example of JMS Broker URL used by the client (the other instance just uses a different port)\r\n*ssl://linux_host:61617?soKeepAlive=true&wireFormat.MaxInactivityDuration=0*\r\n * JMS Broker configuration file attached (just mangled the SSL stuff and name of the host). The other one is similar (different ports)\r\n\r\nÂ \r\n\r\nMy first intention was to increase the OpenWire format negotiation timeout which is currently hardcoded in CMS CPP client to {*}15 seconds{*}.\r\n\r\nHowever when monitoring the successful connections I found out that they took less than 0.5 seconds. I was unable to find any successful connection that took more than this.\r\n\r\nThose that failed were unable to get the response from the Broker after 15 seconds. This means that the timeout value is not the issue here, It is something else.\r\n\r\nLooking to the JMS Broker logs we are unable to find any relevant message when the connection fails.\n\nComments:\n", "classification": "Classify the issue '[Artemis Broker] CMS exception: OpenWireFormatNegotiator::onewayWire format negotiation timeout: peer did not send his wire format.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-754?\nA: We are currently in process of migrating our JMS Broker from Classic 5.x to Artemis.\r\n\r\nWe are currently using CMS C++ client for connecting to JMS Broker. Everything works fine when using non-SSL setup (on both Windows and Linux) but we have some issues when using SSL on Linux (SSL on Windows is OK).\r\n\r\nThe initial problem started with the following exceptions on the client side:\r\n\r\n*_024-02-22 0"}}
{"issue_key": "AMQCPP-753", "project": "AMQCPP", "title": "Deadlock when ActiveMQConection fails before ActiveMQSessionKernel can deliver message acknowledgement", "status": "Open", "reporter": "Katherine Pully", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2024-02-03T21:49:32.000+0000", "updated": "2024-02-03T22:04:43.000+0000", "description": "When an ActiveMQConnection fails before an ActiveMQSessionKernel can deliver a message acknowledgement to the broker, only decaf-type exceptions are caught. However, ActiveMQSessionKernel::acknowledge can indirectly throw a CMS-type exception, which means that the consumer read lock may not get released. This will result in a deadlock when the session tries to acquire the consumer write lock (for example, when cleaning up the ActiveMQConnection).\r\n\r\nI have attached a stack trace from such a deadlock, which occurs when the ActiveMQConnection gets cleaned up. The relevant portion (edited for brevity and clarity, though the attached is the original stack), is:\r\n{code:java}\r\n0  decaf::util::concurrent::ExecutorKernel::Worker::run() ThreadPoolExecutor.cpp:184\r\n1  decaf::util::concurrent::ExecutorKernel::runWorker (decaf::util::concurrent::ExecutorKernel::Worker*) ThreadPoolExecutor.cpp:738\r\n2  activemq::core::OnExceptionRunnable::run() ActiveMQConnection.cpp:439\r\n3  activemq::core::ActiveMQConnection::cleanup() ActiveMQConnection.cpp:839\r\n4  activemq::core::kernels::ActiveMQSessionKernel::dispose() ActiveMQSessionKernel.cpp:371\r\n5  decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquire(int) AbstractQueuedSynchronizer.cpp:1565\r\n6  decaf::util::concurrent::locks::SynchronizerState::acquireQueued((anonymous namespace)::Node*, int) AbstractQueuedSynchronizer.cpp:711\r\n7  decaf::util::concurrent::locks::LockSupport::park() LockSupport.cpp:54\r\n8  decaf::internal::util::concurrent::Threading::park(decaf::lang::Thread*) Threading.cpp:1345\r\n9  decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_opaque_pthread_cond_t*, _opaque_pthread_mutex_t*, decaf::internal::util::concurrent::CompletionCondition&) PlatformThread.cpp:210\r\n10 _pthread_cond_wait\r\n11 __psynch_cvwait{code}\r\nThis issue can be reproduced by using a client-acknowledge strategy and adding a substantial (10+ seconds) call to sleep before acknowledging the message. If the connection fails during that sleep, a CMS exception will be thrown when the thread handling onMessage wakes up and tries to acknowledge the message.\r\n\r\nThe exception is originally thrown by [ActiveMQConnection::checkClosedOrFailed|#L1329].] These exceptions become ActiveMQ exceptions [here|#L1257],] and then CMS Exceptions [here|#L1426].] The only exceptions caught in [ActiveMQSessionKernel::acknowledge|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L508] are [decaf exceptions|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L518]; when a CMS exception is thrown, the [consumer read lock|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L510] is not released.\r\n\r\nThis issue can be fixed by catching CMS exceptions in ActiveMQSessionKernel::acknowledge.", "comments": [], "text": "Deadlock when ActiveMQConection fails before ActiveMQSessionKernel can deliver message acknowledgement\n\nDescription:\nWhen an ActiveMQConnection fails before an ActiveMQSessionKernel can deliver a message acknowledgement to the broker, only decaf-type exceptions are caught. However, ActiveMQSessionKernel::acknowledge can indirectly throw a CMS-type exception, which means that the consumer read lock may not get released. This will result in a deadlock when the session tries to acquire the consumer write lock (for example, when cleaning up the ActiveMQConnection).\r\n\r\nI have attached a stack trace from such a deadlock, which occurs when the ActiveMQConnection gets cleaned up. The relevant portion (edited for brevity and clarity, though the attached is the original stack), is:\r\n{code:java}\r\n0  decaf::util::concurrent::ExecutorKernel::Worker::run() ThreadPoolExecutor.cpp:184\r\n1  decaf::util::concurrent::ExecutorKernel::runWorker (decaf::util::concurrent::ExecutorKernel::Worker*) ThreadPoolExecutor.cpp:738\r\n2  activemq::core::OnExceptionRunnable::run() ActiveMQConnection.cpp:439\r\n3  activemq::core::ActiveMQConnection::cleanup() ActiveMQConnection.cpp:839\r\n4  activemq::core::kernels::ActiveMQSessionKernel::dispose() ActiveMQSessionKernel.cpp:371\r\n5  decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquire(int) AbstractQueuedSynchronizer.cpp:1565\r\n6  decaf::util::concurrent::locks::SynchronizerState::acquireQueued((anonymous namespace)::Node*, int) AbstractQueuedSynchronizer.cpp:711\r\n7  decaf::util::concurrent::locks::LockSupport::park() LockSupport.cpp:54\r\n8  decaf::internal::util::concurrent::Threading::park(decaf::lang::Thread*) Threading.cpp:1345\r\n9  decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_opaque_pthread_cond_t*, _opaque_pthread_mutex_t*, decaf::internal::util::concurrent::CompletionCondition&) PlatformThread.cpp:210\r\n10 _pthread_cond_wait\r\n11 __psynch_cvwait{code}\r\nThis issue can be reproduced by using a client-acknowledge strategy and adding a substantial (10+ seconds) call to sleep before acknowledging the message. If the connection fails during that sleep, a CMS exception will be thrown when the thread handling onMessage wakes up and tries to acknowledge the message.\r\n\r\nThe exception is originally thrown by [ActiveMQConnection::checkClosedOrFailed|#L1329].] These exceptions become ActiveMQ exceptions [here|#L1257],] and then CMS Exceptions [here|#L1426].] The only exceptions caught in [ActiveMQSessionKernel::acknowledge|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L508] are [decaf exceptions|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L518]; when a CMS exception is thrown, the [consumer read lock|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L510] is not released.\r\n\r\nThis issue can be fixed by catching CMS exceptions in ActiveMQSessionKernel::acknowledge.\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock when ActiveMQConection fails before ActiveMQSessionKernel can deliver message acknowledgement\n\nDescription:\nWhen an ActiveMQConnection fails before an ActiveMQSessionKernel can deliver a message acknowledgement to the broker, only decaf-type exceptions are caught. However, ActiveMQSessionKernel::acknowledge can indirectly throw a CMS-type exception, which means that the consumer read lock may not get released. This will result in a deadlock when the session tries to acquire the consumer write lock (for example, when cleaning up the ActiveMQConnection).\r\n\r\nI have attached a stack trace from such a deadlock, which occurs when the ActiveMQConnection gets cleaned up. The relevant portion (edited for brevity and clarity, though the attached is the original stack), is:\r\n{code:java}\r\n0  decaf::util::concurrent::ExecutorKernel::Worker::run() ThreadPoolExecutor.cpp:184\r\n1  decaf::util::concurrent::ExecutorKernel::runWorker (decaf::util::concurrent::ExecutorKernel::Worker*) ThreadPoolExecutor.cpp:738\r\n2  activemq::core::OnExceptionRunnable::run() ActiveMQConnection.cpp:439\r\n3  activemq::core::ActiveMQConnection::cleanup() ActiveMQConnection.cpp:839\r\n4  activemq::core::kernels::ActiveMQSessionKernel::dispose() ActiveMQSessionKernel.cpp:371\r\n5  decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquire(int) AbstractQueuedSynchronizer.cpp:1565\r\n6  decaf::util::concurrent::locks::SynchronizerState::acquireQueued((anonymous namespace)::Node*, int) AbstractQueuedSynchronizer.cpp:711\r\n7  decaf::util::concurrent::locks::LockSupport::park() LockSupport.cpp:54\r\n8  decaf::internal::util::concurrent::Threading::park(decaf::lang::Thread*) Threading.cpp:1345\r\n9  decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_opaque_pthread_cond_t*, _opaque_pthread_mutex_t*, decaf::internal::util::concurrent::CompletionCondition&) PlatformThread.cpp:210\r\n10 _pthread_cond_wait\r\n11 __psynch_cvwait{code}\r\nThis issue can be reproduced by using a client-acknowledge strategy and adding a substantial (10+ seconds) call to sleep before acknowledging the message. If the connection fails during that sleep, a CMS exception will be thrown when the thread handling onMessage wakes up and tries to acknowledge the message.\r\n\r\nThe exception is originally thrown by [ActiveMQConnection::checkClosedOrFailed|#L1329].] These exceptions become ActiveMQ exceptions [here|#L1257],] and then CMS Exceptions [here|#L1426].] The only exceptions caught in [ActiveMQSessionKernel::acknowledge|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L508] are [decaf exceptions|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L518]; when a CMS exception is thrown, the [consumer read lock|https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/core/kernels/ActiveMQSessionKernel.cpp#L510] is not released.\r\n\r\nThis issue can be fixed by catching CMS exceptions in ActiveMQSessionKernel::acknowledge.\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Deadlock when ActiveMQConection fails before ActiveMQSessionKernel can deliver message acknowledgement' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-753?\nA: When an ActiveMQConnection fails before an ActiveMQSessionKernel can deliver a message acknowledgement to the broker, only decaf-type exceptions are caught. However, ActiveMQSessionKernel::acknowledge can indirectly throw a CMS-type exception, which means that the consumer read lock may not get released. This will result in a deadlock when the session tries to acquire the consumer write lock (for "}}
{"issue_key": "AMQCPP-752", "project": "AMQCPP", "title": "CMS API compatibility with 6.x brokers", "status": "Open", "reporter": "Liviu Citu", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2023-11-21T08:54:42.000+0000", "updated": "2023-11-21T08:54:42.000+0000", "description": "Hello,\r\n\r\nThe latest version of CMS API contains the following node:\r\n\r\n*NOTE:* Compatible with ActiveMQ Broker versions in the 4.X and 5.X family\r\n\r\n[https://activemq.apache.org/components/cms/download/395-release]\r\n\r\nAs we have now 6.X brokers, is this API compatible with them? If so can you please update the documentation to reflect that?\r\n\r\nThank you", "comments": [], "text": "CMS API compatibility with 6.x brokers\n\nDescription:\nHello,\r\n\r\nThe latest version of CMS API contains the following node:\r\n\r\n*NOTE:* Compatible with ActiveMQ Broker versions in the 4.X and 5.X family\r\n\r\n[https://activemq.apache.org/components/cms/download/395-release]\r\n\r\nAs we have now 6.X brokers, is this API compatible with them? If so can you please update the documentation to reflect that?\r\n\r\nThank you\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS API compatibility with 6.x brokers\n\nDescription:\nHello,\r\n\r\nThe latest version of CMS API contains the following node:\r\n\r\n*NOTE:* Compatible with ActiveMQ Broker versions in the 4.X and 5.X family\r\n\r\n[https://activemq.apache.org/components/cms/download/395-release]\r\n\r\nAs we have now 6.X brokers, is this API compatible with them? If so can you please update the documentation to reflect that?\r\n\r\nThank you\n\nComments:\n", "classification": "Classify the issue 'CMS API compatibility with 6.x brokers' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-752?\nA: Hello,\r\n\r\nThe latest version of CMS API contains the following node:\r\n\r\n*NOTE:* Compatible with ActiveMQ Broker versions in the 4.X and 5.X family\r\n\r\n[https://activemq.apache.org/components/cms/download/395-release]\r\n\r\nAs we have now 6.X brokers, is this API compatible with them? If so can you please update the documentation to reflect that?\r\n\r\nThank you"}}
{"issue_key": "AMQCPP-751", "project": "AMQCPP", "title": "Non-UTF-8 messages containing special characters are not supported", "status": "Reopened", "reporter": "Liviu Citu", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2023-10-18T06:14:53.000+0000", "updated": "2024-06-20T07:05:28.000+0000", "description": "When a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from ActiveMQ CPP client to Artemis, an exception \"java.io.UTFDataFormatException\" is seen in Artemis server log.\r\n\r\nAlthough the exception is thrown as a warning, the message gets rejected by the server.\r\n\r\nBelow the Artemis server log:\r\n\r\nÂ \r\n{noformat}\r\n2023-09-29 11:34:32,736 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\nÂ \r\njava.io.UTFDataFormatException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.convertUTF8WithBuf(MarshallingSupport.java:386) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.readUTF8(MarshallingSupport.java:358) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.writeTextType(OpenWireMessageConverter.java:233) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.inbound(OpenWireMessageConverter.java:128) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession.send(AMQSession.java:376) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1671) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,753 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\norg.apache.activemq.artemis.api.core.ActiveMQException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1674) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â  Â Â Â Â at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,755 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\njava.io.UTFDataFormatException: null\r\nÂ \r\n{noformat}\r\nÂ \r\n\r\nJust create a small test program using ActiveMQ CPP and send a message to Artemis containing a french or german specific character.\r\n\r\nÂ \r\n\r\nI have found an old discussion from ActiveMQ Community but it was focused on ActiveMQ CPPÂ  rather on Artemis.\r\n\r\n[https://lists.apache.org/thread/vywv1gk32mkhvj7sghnvlf7ng5zb1obp]\r\n\r\nÂ \r\n\r\nThis is a regression compared with ActiveMQ Classic which does not have this issue.\r\n\r\nDoes Artemis support non-UTF-8 encoding? Do we need now to encode all messages to UTF-8 before sending them to the server? Similarly to decode them upon receiving?\r\n\r\nThis will cause some problems on our end because:\r\n * we have many clients already using the ActiveMQ classic and migrating them to Artemis will cause issues when migrating KahaDB to Artemis because all the messages have to be encoded to UTF-8 otherwise they will not work in Artemis\r\n * encoding/decoding every message will impact the overall performance. We have applications handling thousands of messages every day and conversion of these messages will increase the time spent during communication with JMS broker", "comments": [], "text": "Non-UTF-8 messages containing special characters are not supported\n\nDescription:\nWhen a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from ActiveMQ CPP client to Artemis, an exception \"java.io.UTFDataFormatException\" is seen in Artemis server log.\r\n\r\nAlthough the exception is thrown as a warning, the message gets rejected by the server.\r\n\r\nBelow the Artemis server log:\r\n\r\nÂ \r\n{noformat}\r\n2023-09-29 11:34:32,736 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\nÂ \r\njava.io.UTFDataFormatException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.convertUTF8WithBuf(MarshallingSupport.java:386) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.readUTF8(MarshallingSupport.java:358) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.writeTextType(OpenWireMessageConverter.java:233) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.inbound(OpenWireMessageConverter.java:128) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession.send(AMQSession.java:376) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1671) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,753 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\norg.apache.activemq.artemis.api.core.ActiveMQException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1674) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â  Â Â Â Â at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,755 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\njava.io.UTFDataFormatException: null\r\nÂ \r\n{noformat}\r\nÂ \r\n\r\nJust create a small test program using ActiveMQ CPP and send a message to Artemis containing a french or german specific character.\r\n\r\nÂ \r\n\r\nI have found an old discussion from ActiveMQ Community but it was focused on ActiveMQ CPPÂ  rather on Artemis.\r\n\r\n[https://lists.apache.org/thread/vywv1gk32mkhvj7sghnvlf7ng5zb1obp]\r\n\r\nÂ \r\n\r\nThis is a regression compared with ActiveMQ Classic which does not have this issue.\r\n\r\nDoes Artemis support non-UTF-8 encoding? Do we need now to encode all messages to UTF-8 before sending them to the server? Similarly to decode them upon receiving?\r\n\r\nThis will cause some problems on our end because:\r\n * we have many clients already using the ActiveMQ classic and migrating them to Artemis will cause issues when migrating KahaDB to Artemis because all the messages have to be encoded to UTF-8 otherwise they will not work in Artemis\r\n * encoding/decoding every message will impact the overall performance. We have applications handling thousands of messages every day and conversion of these messages will increase the time spent during communication with JMS broker\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Non-UTF-8 messages containing special characters are not supported\n\nDescription:\nWhen a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from ActiveMQ CPP client to Artemis, an exception \"java.io.UTFDataFormatException\" is seen in Artemis server log.\r\n\r\nAlthough the exception is thrown as a warning, the message gets rejected by the server.\r\n\r\nBelow the Artemis server log:\r\n\r\nÂ \r\n{noformat}\r\n2023-09-29 11:34:32,736 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\nÂ \r\njava.io.UTFDataFormatException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.convertUTF8WithBuf(MarshallingSupport.java:386) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.util.MarshallingSupport.readUTF8(MarshallingSupport.java:358) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.writeTextType(OpenWireMessageConverter.java:233) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter.inbound(OpenWireMessageConverter.java:128) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession.send(AMQSession.java:376) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1671) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,753 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\norg.apache.activemq.artemis.api.core.ActiveMQException: null\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection$CommandProcessor.processMessage(OpenWireConnection.java:1674) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â  Â Â Â Â at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:769) ~[activemq-client-5.17.2.jar:5.17.2]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection.act(OpenWireConnection.java:369) ~[artemis-openwire-protocol-2.30.0.jar:2.30.0]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ThresholdActor.doTask(ThresholdActor.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:57) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.OrderedExecutor.doTask(OrderedExecutor.java:32) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.actors.ProcessorBase.executePendingTasks(ProcessorBase.java:68) ~[artemis-commons-2.30.0.jar:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) [?:?]\r\nÂ Â Â Â Â Â Â  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) [?:?]\r\nÂ Â Â Â Â Â Â  at org.apache.activemq.artemis.utils.ActiveMQThreadFactory$1.run(ActiveMQThreadFactory.java:118) [artemis-commons-2.30.0.jar:?]\r\n2023-09-29 11:34:32,755 WARNÂ  [org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection] Errors occurred during the buffering operation\r\njava.io.UTFDataFormatException: null\r\nÂ \r\n{noformat}\r\nÂ \r\n\r\nJust create a small test program using ActiveMQ CPP and send a message to Artemis containing a french or german specific character.\r\n\r\nÂ \r\n\r\nI have found an old discussion from ActiveMQ Community but it was focused on ActiveMQ CPPÂ  rather on Artemis.\r\n\r\n[https://lists.apache.org/thread/vywv1gk32mkhvj7sghnvlf7ng5zb1obp]\r\n\r\nÂ \r\n\r\nThis is a regression compared with ActiveMQ Classic which does not have this issue.\r\n\r\nDoes Artemis support non-UTF-8 encoding? Do we need now to encode all messages to UTF-8 before sending them to the server? Similarly to decode them upon receiving?\r\n\r\nThis will cause some problems on our end because:\r\n * we have many clients already using the ActiveMQ classic and migrating them to Artemis will cause issues when migrating KahaDB to Artemis because all the messages have to be encoded to UTF-8 otherwise they will not work in Artemis\r\n * encoding/decoding every message will impact the overall performance. We have applications handling thousands of messages every day and conversion of these messages will increase the time spent during communication with JMS broker\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Non-UTF-8 messages containing special characters are not supported' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-751?\nA: When a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from ActiveMQ CPP client to Artemis, an exception \"java.io.UTFDataFormatException\" is seen in Artemis server log.\r\n\r\nAlthough the exception is thrown as a warning, the message gets rejected by the server.\r\n\r\nBelow the Artemis server log:\r\n\r\nÂ \r\n{noformat}\r\n2023-09-29 11:34:32,736 WARNÂ  [org.apache.activemq.artemis.cor"}}
{"issue_key": "AMQCPP-744", "project": "AMQCPP", "title": "i can not use c++ dashboard properly ", "status": "Closed", "reporter": "Nasrin Bano Shaikh", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2022-09-26T05:27:29.000+0000", "updated": "2022-09-26T14:12:10.000+0000", "description": "i am trying to use c++ dashboard but i can use it because its show some error", "comments": [], "text": "i can not use c++ dashboard properly \n\nDescription:\ni am trying to use c++ dashboard but i can use it because its show some errorÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: i can not use c++ dashboard properly \n\nDescription:\ni am trying to use c++ dashboard but i can use it because its show some errorÂ \n\nComments:\n", "classification": "Classify the issue 'i can not use c++ dashboard properly ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-744?\nA: i am trying to use c++ dashboard but i can use it because its show some errorÂ "}}
{"issue_key": "AMQCPP-739", "project": "AMQCPP", "title": "activemq-cpp-library-3.9.5 is receving multiple response from activemq-all-5.17.0 server", "status": "Open", "reporter": "RANJITHKUMAR", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2022-09-05T11:38:02.000+0000", "updated": "2022-09-05T11:38:02.000+0000", "description": "Hi Team,\r\n\r\nÂ \r\n\r\nactivemq-cpp-library-3.9.5 is receiving multiple response from activemq-all-5.17.0 server for single request.\r\n\r\nÂ \r\n\r\nThanks,\r\n\r\nRanjith", "comments": [], "text": "activemq-cpp-library-3.9.5 is receving multiple response from activemq-all-5.17.0 server\n\nDescription:\nHi Team,\r\n\r\nÂ \r\n\r\nactivemq-cpp-library-3.9.5 is receiving multiple response from activemq-all-5.17.0 server for single request.\r\n\r\nÂ \r\n\r\nThanks,\r\n\r\nRanjith\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cpp-library-3.9.5 is receving multiple response from activemq-all-5.17.0 server\n\nDescription:\nHi Team,\r\n\r\nÂ \r\n\r\nactivemq-cpp-library-3.9.5 is receiving multiple response from activemq-all-5.17.0 server for single request.\r\n\r\nÂ \r\n\r\nThanks,\r\n\r\nRanjith\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'activemq-cpp-library-3.9.5 is receving multiple response from activemq-all-5.17.0 server' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-739?\nA: Hi Team,\r\n\r\nÂ \r\n\r\nactivemq-cpp-library-3.9.5 is receiving multiple response from activemq-all-5.17.0 server for single request.\r\n\r\nÂ \r\n\r\nThanks,\r\n\r\nRanjith\r\n\r\nÂ "}}
{"issue_key": "AMQCPP-718", "project": "AMQCPP", "title": "Compilation failing for C++17 standard", "status": "Open", "reporter": "Minhaajuddin Ahmad Khan", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2022-06-08T04:30:04.000+0000", "updated": "2025-03-06T18:37:44.000+0000", "description": "Hello,\r\n\r\nCMS fails to compile for C++17 standard, error below :\r\n\r\nÂ \r\n\r\n/home/minhaaj/bisrte-temp/build/vcpkg_installed/x64-linux/include/activemq/commands/ActiveMQMapMessage.h:70:34: error: ISO C++17 does not allow dynamic exception specifications\r\nÂ  Â 70 | Â  Â  Â  Â  virtual void clearBody() throw (cms::CMSException);\r\nÂ  Â  Â  | Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ^~~~~\r\n\r\nÂ \r\n\r\nCould you please make changes for the new standard.\r\n\r\nÂ \r\n\r\nRegards\r\n\r\nMinhaaj", "comments": [], "text": "Compilation failing for C++17 standard\n\nDescription:\nHello,\r\n\r\nCMS fails to compile for C++17 standard, error below :\r\n\r\nÂ \r\n\r\n/home/minhaaj/bisrte-temp/build/vcpkg_installed/x64-linux/include/activemq/commands/ActiveMQMapMessage.h:70:34: error: ISO C++17 does not allow dynamic exception specifications\r\nÂ  Â 70 | Â  Â  Â  Â  virtual void clearBody() throw (cms::CMSException);\r\nÂ  Â  Â  | Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ^~~~~\r\n\r\nÂ \r\n\r\nCould you please make changes for the new standard.\r\n\r\nÂ \r\n\r\nRegards\r\n\r\nMinhaaj\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation failing for C++17 standard\n\nDescription:\nHello,\r\n\r\nCMS fails to compile for C++17 standard, error below :\r\n\r\nÂ \r\n\r\n/home/minhaaj/bisrte-temp/build/vcpkg_installed/x64-linux/include/activemq/commands/ActiveMQMapMessage.h:70:34: error: ISO C++17 does not allow dynamic exception specifications\r\nÂ  Â 70 | Â  Â  Â  Â  virtual void clearBody() throw (cms::CMSException);\r\nÂ  Â  Â  | Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ^~~~~\r\n\r\nÂ \r\n\r\nCould you please make changes for the new standard.\r\n\r\nÂ \r\n\r\nRegards\r\n\r\nMinhaaj\n\nComments:\n", "classification": "Classify the issue 'Compilation failing for C++17 standard' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-718?\nA: Hello,\r\n\r\nCMS fails to compile for C++17 standard, error below :\r\n\r\nÂ \r\n\r\n/home/minhaaj/bisrte-temp/build/vcpkg_installed/x64-linux/include/activemq/commands/ActiveMQMapMessage.h:70:34: error: ISO C++17 does not allow dynamic exception specifications\r\nÂ  Â 70 | Â  Â  Â  Â  virtual void clearBody() throw (cms::CMSException);\r\nÂ  Â  Â  | Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ^~~~~\r\n\r\nÂ \r\n\r\nCould you please make cha"}}
{"issue_key": "AMQCPP-712", "project": "AMQCPP", "title": "ActiveMQConnection Start() hangs forever/not connecting with Broker", "status": "Open", "reporter": "Sthala Narasimhan", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2022-04-28T14:53:42.000+0000", "updated": "2022-05-13T14:27:42.000+0000", "description": "My Client application uses CMS Library 3.9.5 with failover protocol.. When I invoke Start() function to connect to broker it hangs/ not connecting, though broker is configured correctly\r\n\r\nstd::string brokerURI = \"failover:(tcp://host1:61400,tcp://host2:61400)&maxReconnectAttempts=1;\r\n\r\nÂ ActiveMQConnection* conn = 0;\r\nActiveMQConnectionFactory *amqfactory = new ActiveMQConnectionFactory(brokerURI);\r\n\r\nconn = amqfactory->createConnection();\r\ndelete amqfactory;\r\namqfactory = NULL;\r\n\r\n//Hangs here forever or timeout.Â  \r\n\r\nconn->start();", "comments": [], "text": "ActiveMQConnection Start() hangs forever/not connecting with Broker\n\nDescription:\nMy Client application uses CMS Library 3.9.5 with failover protocol.. When I invoke Start() function to connect to broker it hangs/ not connecting, though broker is configured correctly\r\n\r\nstd::string brokerURI = \"failover:(tcp://host1:61400,tcp://host2:61400)&maxReconnectAttempts=1;\r\n\r\nÂ ActiveMQConnection* conn = 0;\r\nActiveMQConnectionFactory *amqfactory = new ActiveMQConnectionFactory(brokerURI);\r\n\r\nconn = amqfactory->createConnection();\r\ndelete amqfactory;\r\namqfactory = NULL;\r\n\r\n//Hangs here forever or timeout.Â  \r\n\r\nconn->start();\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQConnection Start() hangs forever/not connecting with Broker\n\nDescription:\nMy Client application uses CMS Library 3.9.5 with failover protocol.. When I invoke Start() function to connect to broker it hangs/ not connecting, though broker is configured correctly\r\n\r\nstd::string brokerURI = \"failover:(tcp://host1:61400,tcp://host2:61400)&maxReconnectAttempts=1;\r\n\r\nÂ ActiveMQConnection* conn = 0;\r\nActiveMQConnectionFactory *amqfactory = new ActiveMQConnectionFactory(brokerURI);\r\n\r\nconn = amqfactory->createConnection();\r\ndelete amqfactory;\r\namqfactory = NULL;\r\n\r\n//Hangs here forever or timeout.Â  \r\n\r\nconn->start();\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'ActiveMQConnection Start() hangs forever/not connecting with Broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-712?\nA: My Client application uses CMS Library 3.9.5 with failover protocol.. When I invoke Start() function to connect to broker it hangs/ not connecting, though broker is configured correctly\r\n\r\nstd::string brokerURI = \"failover:(tcp://host1:61400,tcp://host2:61400)&maxReconnectAttempts=1;\r\n\r\nÂ ActiveMQConnection* conn = 0;\r\nActiveMQConnectionFactory *amqfactory = new ActiveMQConnectionFactory(brokerURI)"}}
{"issue_key": "AMQCPP-711", "project": "AMQCPP", "title": "set TLS cipher suits", "status": "Open", "reporter": "zhaojing", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2022-04-13T03:52:19.000+0000", "updated": "2022-04-20T14:33:43.000+0000", "description": "I found a comment at line:211 of src\\main\\decaf\\internal\\net\\ssl\\openssl\\OpenSSLContextSpi.cpp\r\n\r\nÂ \r\n// Sets the Default set of allowed Ciphers, this could be overridden by the system\r\n// property: decaf.net.ssl.CipherSuites\r\nif( SSL_CTX_set_cipher_list( this->data->openSSLContext, ContextData::defaultCipherList.c_str() ) != 1 ) {\r\nÂ  Â  Â  Â throw OpenSSLSocketException( __FILE__, __LINE__ );\r\nÂ }\r\nÂ \r\n\r\nThis comment seems to describe an unimplemented feature : set TLS cipher suits byÂ \r\nproperty: decaf.net.ssl.CipherSuitesï¼butÂ  I can't found the specific implementation in the code\r\nwill this feature be available in the future?", "comments": [], "text": "set TLS cipher suits\n\nDescription:\nI found a comment at line:211 of src\\main\\decaf\\internal\\net\\ssl\\openssl\\OpenSSLContextSpi.cpp\r\n\r\nÂ \r\n// Sets the Default set of allowed Ciphers, this could be overridden by the system\r\n// property: decaf.net.ssl.CipherSuites\r\nif( SSL_CTX_set_cipher_list( this->data->openSSLContext, ContextData::defaultCipherList.c_str() ) != 1 ) {\r\nÂ  Â  Â  Â throw OpenSSLSocketException( __FILE__, __LINE__ );\r\nÂ }\r\nÂ \r\n\r\nThis comment seems to describe an unimplemented feature : set TLS cipher suits byÂ \r\nproperty: decaf.net.ssl.CipherSuitesï¼butÂ  I can't found the specific implementation in the code\r\nwill this feature be available in the future?\r\nÂ \r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: set TLS cipher suits\n\nDescription:\nI found a comment at line:211 of src\\main\\decaf\\internal\\net\\ssl\\openssl\\OpenSSLContextSpi.cpp\r\n\r\nÂ \r\n// Sets the Default set of allowed Ciphers, this could be overridden by the system\r\n// property: decaf.net.ssl.CipherSuites\r\nif( SSL_CTX_set_cipher_list( this->data->openSSLContext, ContextData::defaultCipherList.c_str() ) != 1 ) {\r\nÂ  Â  Â  Â throw OpenSSLSocketException( __FILE__, __LINE__ );\r\nÂ }\r\nÂ \r\n\r\nThis comment seems to describe an unimplemented feature : set TLS cipher suits byÂ \r\nproperty: decaf.net.ssl.CipherSuitesï¼butÂ  I can't found the specific implementation in the code\r\nwill this feature be available in the future?\r\nÂ \r\nÂ \n\nComments:\n", "classification": "Classify the issue 'set TLS cipher suits' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-711?\nA: I found a comment at line:211 of src\\main\\decaf\\internal\\net\\ssl\\openssl\\OpenSSLContextSpi.cpp\r\n\r\nÂ \r\n// Sets the Default set of allowed Ciphers, this could be overridden by the system\r\n// property: decaf.net.ssl.CipherSuites\r\nif( SSL_CTX_set_cipher_list( this->data->openSSLContext, ContextData::defaultCipherList.c_str() ) != 1 ) {\r\nÂ  Â  Â  Â throw OpenSSLSocketException( __FILE__, __LINE__ );\r\nÂ }\r\nÂ \r"}}
{"issue_key": "AMQCPP-694", "project": "AMQCPP", "title": "Protocol Telnet Guacamole Issue Apache Client ", "status": "Open", "reporter": "Alfonso Franco", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2022-02-11T00:39:59.000+0000", "updated": "2022-02-11T00:39:59.000+0000", "description": "TheÂ  projectÂ  Guacamole Apache ServerÂ  C++Â  run fileÂ  protocol telnet guacomole issue apacheÂ  client.h\r\n\r\nguac_client_free_handlerÂ  guac_telnet_client_free_handler", "comments": [], "text": "Protocol Telnet Guacamole Issue Apache Client \n\nDescription:\nTheÂ  projectÂ  Guacamole Apache ServerÂ  C++Â  run fileÂ  protocol telnet guacomole issue apacheÂ  client.h\r\n\r\nguac_client_free_handlerÂ  guac_telnet_client_free_handlerÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Protocol Telnet Guacamole Issue Apache Client \n\nDescription:\nTheÂ  projectÂ  Guacamole Apache ServerÂ  C++Â  run fileÂ  protocol telnet guacomole issue apacheÂ  client.h\r\n\r\nguac_client_free_handlerÂ  guac_telnet_client_free_handlerÂ \n\nComments:\n", "classification": "Classify the issue 'Protocol Telnet Guacamole Issue Apache Client ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-694?\nA: TheÂ  projectÂ  Guacamole Apache ServerÂ  C++Â  run fileÂ  protocol telnet guacomole issue apacheÂ  client.h\r\n\r\nguac_client_free_handlerÂ  guac_telnet_client_free_handlerÂ "}}
{"issue_key": "AMQCPP-693", "project": "AMQCPP", "title": "Project Guacamole Apache Server C++ Client", "status": "Closed", "reporter": "Alfonso Franco", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2022-02-10T22:21:02.000+0000", "updated": "2022-02-11T03:14:20.000+0000", "description": "The project  guacomole apache  server  C++  runs file protocol  telnet guacomole issue apache  client \r\n\r\nguac_client_free_handler  guac_telnet_client_free_handler", "comments": [], "text": "Project Guacamole Apache Server C++ Client\n\nDescription:\nThe project  guacomole apache  server  C++  runs file protocol  telnet guacomole issue apache  client \r\n\r\nguac_client_free_handler  guac_telnet_client_free_handler  \r\n\r\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Project Guacamole Apache Server C++ Client\n\nDescription:\nThe project  guacomole apache  server  C++  runs file protocol  telnet guacomole issue apache  client \r\n\r\nguac_client_free_handler  guac_telnet_client_free_handler  \r\n\r\n\n\nComments:\n", "classification": "Classify the issue 'Project Guacamole Apache Server C++ Client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-693?\nA: The project  guacomole apache  server  C++  runs file protocol  telnet guacomole issue apache  client \r\n\r\nguac_client_free_handler  guac_telnet_client_free_handler  \r\n\r\n"}}
{"issue_key": "AMQCPP-692", "project": "AMQCPP", "title": "Sending text message non-UTF-8 containing special characters from OpenWire ", "status": "Open", "reporter": "Pierre-Henry Brasseur", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2021-12-02T13:14:29.000+0000", "updated": "2023-10-18T13:13:26.000+0000", "description": "When a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from OpenWire, this raised an exception :\"java.io.UTFDataFormatException\" which is not correctly handle and prevent the sending of the text message.\r\n\r\nSee email from ActiveMQ Community in attachment for more details.\r\n\r\n[^Re Question about charset supported by Artemis.msg]Â \r\n\r\nÂ \r\n\r\nThis was working with previous ActiveMQ version (v5.15.9).\r\n\r\nÂ \r\n\r\nIdentified during following test :\r\n\r\nText message sent from a C program using the Fuse ActiveMQ-Client C library to Artemis v2.16.", "comments": [], "text": "Sending text message non-UTF-8 containing special characters from OpenWire \n\nDescription:\nWhen a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from OpenWire, this raised an exception :\"java.io.UTFDataFormatException\" which is not correctly handle and prevent the sending of the text message.\r\n\r\nSee email from ActiveMQ Community in attachment for more details.\r\n\r\n[^Re Question about charset supported by Artemis.msg]Â \r\n\r\nÂ \r\n\r\nThis was working with previous ActiveMQ version (v5.15.9).\r\n\r\nÂ \r\n\r\nIdentified during following test :\r\n\r\nText message sent from a C program using the Fuse ActiveMQ-Client C library to Artemis v2.16.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Sending text message non-UTF-8 containing special characters from OpenWire \n\nDescription:\nWhen a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from OpenWire, this raised an exception :\"java.io.UTFDataFormatException\" which is not correctly handle and prevent the sending of the text message.\r\n\r\nSee email from ActiveMQ Community in attachment for more details.\r\n\r\n[^Re Question about charset supported by Artemis.msg]Â \r\n\r\nÂ \r\n\r\nThis was working with previous ActiveMQ version (v5.15.9).\r\n\r\nÂ \r\n\r\nIdentified during following test :\r\n\r\nText message sent from a C program using the Fuse ActiveMQ-Client C library to Artemis v2.16.\n\nComments:\n", "classification": "Classify the issue 'Sending text message non-UTF-8 containing special characters from OpenWire ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-692?\nA: When a text message non-UTF-8 (ISO-8859-15) containing special characters is sent from OpenWire, this raised an exception :\"java.io.UTFDataFormatException\" which is not correctly handle and prevent the sending of the text message.\r\n\r\nSee email from ActiveMQ Community in attachment for more details.\r\n\r\n[^Re Question about charset supported by Artemis.msg]Â \r\n\r\nÂ \r\n\r\nThis was working with previous Act"}}
{"issue_key": "AMQCPP-689", "project": "AMQCPP", "title": "Download page must use https for sigs and hashes", "status": "Open", "reporter": "Sebb", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2021-11-02T21:42:12.000+0000", "updated": "2021-11-02T21:42:12.000+0000", "description": "As the subject says.\r\n\r\nÂ \r\n\r\nhttps://activemq.apache.org/components/cms/download/395-release", "comments": [], "text": "Download page must use https for sigs and hashes\n\nDescription:\nAs the subject says.\r\n\r\nÂ \r\n\r\nhttps://activemq.apache.org/components/cms/download/395-release\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Download page must use https for sigs and hashes\n\nDescription:\nAs the subject says.\r\n\r\nÂ \r\n\r\nhttps://activemq.apache.org/components/cms/download/395-release\n\nComments:\n", "classification": "Classify the issue 'Download page must use https for sigs and hashes' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-689?\nA: As the subject says.\r\n\r\nÂ \r\n\r\nhttps://activemq.apache.org/components/cms/download/395-release"}}
{"issue_key": "AMQCPP-685", "project": "AMQCPP", "title": "Recurring Segfault bubbles up through ActiveMQProducer::send(); possibly related to FailoverTransport", "status": "Open", "reporter": "Chris A. Evans", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["RedHat"], "created": "2021-09-09T15:27:45.000+0000", "updated": "2021-09-09T15:35:12.000+0000", "description": "We have encountered a regularly occurring issue when using the activemq-cpp 3.9.4. Our application is acting as a producer to a message queue. We connect to an ActiveMQ 5.16.0 broker server using the failover transport.\r\n\r\nAll other potential configurations have not been exonerated of this issue because, while it occurs regularly, we have yet to determine the pattern to be able to reliably reproduce it.\r\n\r\nWe end up segfaulting because we're only catching CMSExecption, and the exception comes from decaf. We considered broadening our exception handling, but are aren't sure what the impact would be on future produced messages if we just caught this exception â and since we have yet to be able to reliably re-produce this on-demand, we haven't been able to test that behavior. So for now, we consider a crash the better outcome than potentially bad messages.\r\n\r\nI am a bit out of my element here, so let me know if any additional context or supporting material is needed here to assist.\r\n\r\nThe following internal code of ours is invoking {{activemq::core::ActiveMQProducer::send():}}\r\n{code:cpp}\r\nbool AMQueue::send(Message* message) {\r\n    try {\r\n        if(_producer) {\r\n            _producer->send(message);\r\n            return true;\r\n        }\r\n    } catch (CMSException& e) {\r\n        log4cxx::LoggerPtr logger = log4cxx::Logger::getLogger(\"ActiveMQ\");\r\n        LOG4CXX_ERROR(logger, e.getMessage());\r\n    }\r\n    return false;\r\n}\r\n{code}\r\nThe following stack trace is always present in the core dump:Â \r\n{code:java}\r\n#7  0xf7267679 in decaf::lang::Exception::buildMessage(char const*, char*&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#8  0xf72c21c5 in decaf::util::NoSuchElementException::NoSuchElementException(char const*, int, char const*, ...) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#9  0xf70d2512 in decaf::util::HashMap<unsigned int, decaf::lang::Pointer<activemq::transport::FutureResponse, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::util::HashCode<unsigned int> >::remove(unsigned int const&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#10 0xf70cfbc0 in (anonymous namespace)::ResponseFinalizer::~ResponseFinalizer() () from /usr/local/lib/libactivemq-cpp.so.19\r\n#11 0xf70d0d69 in activemq::transport::correlator::ResponseCorrelator::request(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#12 0xf6eb374e in activemq::core::ActiveMQConnection::syncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, unsigned int) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#13 0xf6eb3c8c in activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#14 0xf6ff2d7b in activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#15 0xf6fd733d in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#16 0xf6fcfe54 in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#17 0xf6f3c186 in activemq::core::ActiveMQProducer::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n{code}\r\nOur only theory at this time is that this may eventually occur after producing a very high number of messages, such as 8+ million produced messages. This type of crash has never happened early in the lifetime of the application run.\r\n\r\nThe title of this issue suggests a possible relation to theÂ FailoverTransport. I came to this conclusion because we haven't had this issue during the entire lifetime of our app â it is a recent-ish phenomenon, which loosely matches up with us switching from the tcp:// URI syntax to failover://.\r\n\r\nI also noticed that theÂ HashMap in theÂ {{ResponseFinalizer}}Â object is placed there from aÂ {{&this->impl->requestMap}}Â call inÂ {{ResponseCorrelator::request}}. A quick search of the repo leads to to notice that requestMap is only present in FailoverTransport.cpp (unless I missed it elsewhere, which is possible).\r\n\r\nThe NoSuchElementException exception is thrown once theÂ {{ResponseFinalizer}}Â deconstructor tries to callÂ {{map->remove(commandId);.}}", "comments": [], "text": "Recurring Segfault bubbles up through ActiveMQProducer::send(); possibly related to FailoverTransport\n\nDescription:\nWe have encountered a regularly occurring issue when using the activemq-cpp 3.9.4. Our application is acting as a producer to a message queue. We connect to an ActiveMQ 5.16.0 broker server using the failover transport.\r\n\r\nAll other potential configurations have not been exonerated of this issue because, while it occurs regularly, we have yet to determine the pattern to be able to reliably reproduce it.\r\n\r\nWe end up segfaulting because we're only catching CMSExecption, and the exception comes from decaf. We considered broadening our exception handling, but are aren't sure what the impact would be on future produced messages if we just caught this exception â and since we have yet to be able to reliably re-produce this on-demand, we haven't been able to test that behavior. So for now, we consider a crash the better outcome than potentially bad messages.\r\n\r\nI am a bit out of my element here, so let me know if any additional context or supporting material is needed here to assist.\r\n\r\nThe following internal code of ours is invoking {{activemq::core::ActiveMQProducer::send():}}\r\n{code:cpp}\r\nbool AMQueue::send(Message* message) {\r\n    try {\r\n        if(_producer) {\r\n            _producer->send(message);\r\n            return true;\r\n        }\r\n    } catch (CMSException& e) {\r\n        log4cxx::LoggerPtr logger = log4cxx::Logger::getLogger(\"ActiveMQ\");\r\n        LOG4CXX_ERROR(logger, e.getMessage());\r\n    }\r\n    return false;\r\n}\r\n{code}\r\nThe following stack trace is always present in the core dump:Â \r\n{code:java}\r\n#7  0xf7267679 in decaf::lang::Exception::buildMessage(char const*, char*&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#8  0xf72c21c5 in decaf::util::NoSuchElementException::NoSuchElementException(char const*, int, char const*, ...) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#9  0xf70d2512 in decaf::util::HashMap<unsigned int, decaf::lang::Pointer<activemq::transport::FutureResponse, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::util::HashCode<unsigned int> >::remove(unsigned int const&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#10 0xf70cfbc0 in (anonymous namespace)::ResponseFinalizer::~ResponseFinalizer() () from /usr/local/lib/libactivemq-cpp.so.19\r\n#11 0xf70d0d69 in activemq::transport::correlator::ResponseCorrelator::request(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#12 0xf6eb374e in activemq::core::ActiveMQConnection::syncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, unsigned int) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#13 0xf6eb3c8c in activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#14 0xf6ff2d7b in activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#15 0xf6fd733d in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#16 0xf6fcfe54 in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#17 0xf6f3c186 in activemq::core::ActiveMQProducer::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n{code}\r\nOur only theory at this time is that this may eventually occur after producing a very high number of messages, such as 8+ million produced messages. This type of crash has never happened early in the lifetime of the application run.\r\n\r\nThe title of this issue suggests a possible relation to theÂ FailoverTransport. I came to this conclusion because we haven't had this issue during the entire lifetime of our app â it is a recent-ish phenomenon, which loosely matches up with us switching from the tcp:// URI syntax to failover://.\r\n\r\nI also noticed that theÂ HashMap in theÂ {{ResponseFinalizer}}Â object is placed there from aÂ {{&this->impl->requestMap}}Â call inÂ {{ResponseCorrelator::request}}. A quick search of the repo leads to to notice that requestMap is only present in FailoverTransport.cpp (unless I missed it elsewhere, which is possible).\r\n\r\nThe NoSuchElementException exception is thrown once theÂ {{ResponseFinalizer}}Â deconstructor tries to callÂ {{map->remove(commandId);.}}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Recurring Segfault bubbles up through ActiveMQProducer::send(); possibly related to FailoverTransport\n\nDescription:\nWe have encountered a regularly occurring issue when using the activemq-cpp 3.9.4. Our application is acting as a producer to a message queue. We connect to an ActiveMQ 5.16.0 broker server using the failover transport.\r\n\r\nAll other potential configurations have not been exonerated of this issue because, while it occurs regularly, we have yet to determine the pattern to be able to reliably reproduce it.\r\n\r\nWe end up segfaulting because we're only catching CMSExecption, and the exception comes from decaf. We considered broadening our exception handling, but are aren't sure what the impact would be on future produced messages if we just caught this exception â and since we have yet to be able to reliably re-produce this on-demand, we haven't been able to test that behavior. So for now, we consider a crash the better outcome than potentially bad messages.\r\n\r\nI am a bit out of my element here, so let me know if any additional context or supporting material is needed here to assist.\r\n\r\nThe following internal code of ours is invoking {{activemq::core::ActiveMQProducer::send():}}\r\n{code:cpp}\r\nbool AMQueue::send(Message* message) {\r\n    try {\r\n        if(_producer) {\r\n            _producer->send(message);\r\n            return true;\r\n        }\r\n    } catch (CMSException& e) {\r\n        log4cxx::LoggerPtr logger = log4cxx::Logger::getLogger(\"ActiveMQ\");\r\n        LOG4CXX_ERROR(logger, e.getMessage());\r\n    }\r\n    return false;\r\n}\r\n{code}\r\nThe following stack trace is always present in the core dump:Â \r\n{code:java}\r\n#7  0xf7267679 in decaf::lang::Exception::buildMessage(char const*, char*&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#8  0xf72c21c5 in decaf::util::NoSuchElementException::NoSuchElementException(char const*, int, char const*, ...) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#9  0xf70d2512 in decaf::util::HashMap<unsigned int, decaf::lang::Pointer<activemq::transport::FutureResponse, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::util::HashCode<unsigned int> >::remove(unsigned int const&) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#10 0xf70cfbc0 in (anonymous namespace)::ResponseFinalizer::~ResponseFinalizer() () from /usr/local/lib/libactivemq-cpp.so.19\r\n#11 0xf70d0d69 in activemq::transport::correlator::ResponseCorrelator::request(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#12 0xf6eb374e in activemq::core::ActiveMQConnection::syncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, unsigned int) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#13 0xf6eb3c8c in activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#14 0xf6ff2d7b in activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#15 0xf6fd733d in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#16 0xf6fcfe54 in activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n#17 0xf6f3c186 in activemq::core::ActiveMQProducer::send(cms::Message*) () from /usr/local/lib/libactivemq-cpp.so.19\r\n{code}\r\nOur only theory at this time is that this may eventually occur after producing a very high number of messages, such as 8+ million produced messages. This type of crash has never happened early in the lifetime of the application run.\r\n\r\nThe title of this issue suggests a possible relation to theÂ FailoverTransport. I came to this conclusion because we haven't had this issue during the entire lifetime of our app â it is a recent-ish phenomenon, which loosely matches up with us switching from the tcp:// URI syntax to failover://.\r\n\r\nI also noticed that theÂ HashMap in theÂ {{ResponseFinalizer}}Â object is placed there from aÂ {{&this->impl->requestMap}}Â call inÂ {{ResponseCorrelator::request}}. A quick search of the repo leads to to notice that requestMap is only present in FailoverTransport.cpp (unless I missed it elsewhere, which is possible).\r\n\r\nThe NoSuchElementException exception is thrown once theÂ {{ResponseFinalizer}}Â deconstructor tries to callÂ {{map->remove(commandId);.}}\n\nComments:\n", "classification": "Classify the issue 'Recurring Segfault bubbles up through ActiveMQProducer::send(); possibly related to FailoverTransport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-685?\nA: We have encountered a regularly occurring issue when using the activemq-cpp 3.9.4. Our application is acting as a producer to a message queue. We connect to an ActiveMQ 5.16.0 broker server using the failover transport.\r\n\r\nAll other potential configurations have not been exonerated of this issue because, while it occurs regularly, we have yet to determine the pattern to be able to reliably reprodu"}}
{"issue_key": "AMQCPP-684", "project": "AMQCPP", "title": "Allow supplying of PKG_CONFIG_PATH", "status": "Open", "reporter": "Antonio L", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2021-07-20T01:40:45.000+0000", "updated": "2021-07-20T01:50:40.000+0000", "description": "I am having a hard time coercing ActiveMQ to reuse the OpenSSL installation from .pc files.\r\n\r\nPKG_CONFIG executable is in a different path, for this reason I am passing it as an ENV VAR to the configure script. However I find that on my local installation that complains about PKG_CONFIG_PATH not being set so I was wondering if there was any way to pass that to ActiveMQ-cpp configure script?\r\n\r\nI look at the build32/Makefile and I see that all the OpenSSL related variables are empty, despite that the configure script reports OpenSSL as being \"found\".\r\n\r\nI also tried passing manually the LIBS environment var (-lssl -lcrypto) but despite that when I try building against that I get lot of missing SLL related symbols despite being able to create the ActiveMQ-CPP static library. But that is a separate problem.\r\n I find this is solved by patching manually the generated .pc file:\r\n *Libs: -L${libdir} -lactivemq-cpp -lpthread -ldl -luuid -lssl -lcrypto*\r\n\r\nAlso another problem: at my company we tend to have 2 binaries for apr-1-config with the bitness suffix: apr-1-config-32 apr-1-config-64. ActiveMQ has a hard time parsing the --with-apr flag as it creates the corresponding .pc file with the full path of apr-1-config instead of \"apr-1\" dependency name which is the name of the corresponding .pc file.\r\n\r\nCan you advise on those ./configure glitches I found?\r\n\r\nWould like to remind that I need to build the static library not the dynamic one.", "comments": [], "text": "Allow supplying of PKG_CONFIG_PATH\n\nDescription:\nI am having a hard time coercing ActiveMQ to reuse the OpenSSL installation from .pc files.\r\n\r\nPKG_CONFIG executable is in a different path, for this reason I am passing it as an ENV VAR to the configure script. However I find that on my local installation that complains about PKG_CONFIG_PATH not being set so I was wondering if there was any way to pass that to ActiveMQ-cpp configure script?\r\n\r\nI look at the build32/Makefile and I see that all the OpenSSL related variables are empty, despite that the configure script reports OpenSSL as being \"found\".\r\n\r\nI also tried passing manually the LIBS environment var (-lssl -lcrypto) but despite that when I try building against that I get lot of missing SLL related symbols despite being able to create the ActiveMQ-CPP static library. But that is a separate problem.\r\n I find this is solved by patching manually the generated .pc file:\r\n *Libs: -L${libdir} -lactivemq-cpp -lpthread -ldl -luuid -lssl -lcrypto*\r\n\r\nAlso another problem: at my company we tend to have 2 binaries for apr-1-config with the bitness suffix: apr-1-config-32 apr-1-config-64. ActiveMQ has a hard time parsing the --with-apr flag as it creates the corresponding .pc file with the full path of apr-1-config instead of \"apr-1\" dependency name which is the name of the corresponding .pc file.\r\n\r\nCan you advise on those ./configure glitches I found?\r\n\r\nWould like to remind that I need to build the static library not the dynamic one.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Allow supplying of PKG_CONFIG_PATH\n\nDescription:\nI am having a hard time coercing ActiveMQ to reuse the OpenSSL installation from .pc files.\r\n\r\nPKG_CONFIG executable is in a different path, for this reason I am passing it as an ENV VAR to the configure script. However I find that on my local installation that complains about PKG_CONFIG_PATH not being set so I was wondering if there was any way to pass that to ActiveMQ-cpp configure script?\r\n\r\nI look at the build32/Makefile and I see that all the OpenSSL related variables are empty, despite that the configure script reports OpenSSL as being \"found\".\r\n\r\nI also tried passing manually the LIBS environment var (-lssl -lcrypto) but despite that when I try building against that I get lot of missing SLL related symbols despite being able to create the ActiveMQ-CPP static library. But that is a separate problem.\r\n I find this is solved by patching manually the generated .pc file:\r\n *Libs: -L${libdir} -lactivemq-cpp -lpthread -ldl -luuid -lssl -lcrypto*\r\n\r\nAlso another problem: at my company we tend to have 2 binaries for apr-1-config with the bitness suffix: apr-1-config-32 apr-1-config-64. ActiveMQ has a hard time parsing the --with-apr flag as it creates the corresponding .pc file with the full path of apr-1-config instead of \"apr-1\" dependency name which is the name of the corresponding .pc file.\r\n\r\nCan you advise on those ./configure glitches I found?\r\n\r\nWould like to remind that I need to build the static library not the dynamic one.\n\nComments:\n", "classification": "Classify the issue 'Allow supplying of PKG_CONFIG_PATH' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-684?\nA: I am having a hard time coercing ActiveMQ to reuse the OpenSSL installation from .pc files.\r\n\r\nPKG_CONFIG executable is in a different path, for this reason I am passing it as an ENV VAR to the configure script. However I find that on my local installation that complains about PKG_CONFIG_PATH not being set so I was wondering if there was any way to pass that to ActiveMQ-cpp configure script?\r\n\r\nI "}}
{"issue_key": "AMQCPP-675", "project": "AMQCPP", "title": "Consumer performance issues with many topics", "status": "Open", "reporter": "Rob Ambalu", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2021-04-22T01:24:01.000+0000", "updated": "2021-04-23T03:24:57.000+0000", "description": "activemq-cpp has a performance issue when subscribing to many topics.Â  When I try to subscribe to market data by ticker, with 1 topic per ticker, it starts to bog down as I add more Consumers.Â  Digging into it, I see the issue is in how consumers are managed in ActiveMQSessionKernel.cpp.Â  It maintains all consumers in a linked list, and then for *every message* that is received, it does a linear O(n) scan to find the matching consumer to call back into.\r\n\r\nMy application has close to 10k topics subscribed, every message does up to 10k scan.Â  This is completely unusable.\r\n\r\nThe fix is simple, maintain consumers by HashMap not a LinkedList.Â  I dont have access to create a pull-request in github, but I already have the diffs and will attach it to this PR.\r\n\r\nÂ \r\n\r\nSome notes:\r\n * adding an identical consumer will silently fail, but this is the same behavior as it is today ( duplicates will add to the LinkedList of consumers, but upon lookup only the first one will be returned... )\r\n * Added slight optim to ConsumerId::getHashCode() because it was too unnecessarily inefficient to bare\r\n * I removed the ActiveMQSessionKernel::deliverAcks() because its not used anywhere, and it does a full iteration so I want to make sure it never gets used\r\n * I tested this on my use case and my application can easily keep up without issue now", "comments": [], "text": "Consumer performance issues with many topics\n\nDescription:\nactivemq-cpp has a performance issue when subscribing to many topics.Â  When I try to subscribe to market data by ticker, with 1 topic per ticker, it starts to bog down as I add more Consumers.Â  Digging into it, I see the issue is in how consumers are managed in ActiveMQSessionKernel.cpp.Â  It maintains all consumers in a linked list, and then for *every message* that is received, it does a linear O(n) scan to find the matching consumer to call back into.\r\n\r\nMy application has close to 10k topics subscribed, every message does up to 10k scan.Â  This is completely unusable.\r\n\r\nThe fix is simple, maintain consumers by HashMap not a LinkedList.Â  I dont have access to create a pull-request in github, but I already have the diffs and will attach it to this PR.\r\n\r\nÂ \r\n\r\nSome notes:\r\n * adding an identical consumer will silently fail, but this is the same behavior as it is today ( duplicates will add to the LinkedList of consumers, but upon lookup only the first one will be returned... )\r\n * Added slight optim to ConsumerId::getHashCode() because it was too unnecessarily inefficient to bare\r\n * I removed the ActiveMQSessionKernel::deliverAcks() because its not used anywhere, and it does a full iteration so I want to make sure it never gets used\r\n * I tested this on my use case and my application can easily keep up without issue now\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consumer performance issues with many topics\n\nDescription:\nactivemq-cpp has a performance issue when subscribing to many topics.Â  When I try to subscribe to market data by ticker, with 1 topic per ticker, it starts to bog down as I add more Consumers.Â  Digging into it, I see the issue is in how consumers are managed in ActiveMQSessionKernel.cpp.Â  It maintains all consumers in a linked list, and then for *every message* that is received, it does a linear O(n) scan to find the matching consumer to call back into.\r\n\r\nMy application has close to 10k topics subscribed, every message does up to 10k scan.Â  This is completely unusable.\r\n\r\nThe fix is simple, maintain consumers by HashMap not a LinkedList.Â  I dont have access to create a pull-request in github, but I already have the diffs and will attach it to this PR.\r\n\r\nÂ \r\n\r\nSome notes:\r\n * adding an identical consumer will silently fail, but this is the same behavior as it is today ( duplicates will add to the LinkedList of consumers, but upon lookup only the first one will be returned... )\r\n * Added slight optim to ConsumerId::getHashCode() because it was too unnecessarily inefficient to bare\r\n * I removed the ActiveMQSessionKernel::deliverAcks() because its not used anywhere, and it does a full iteration so I want to make sure it never gets used\r\n * I tested this on my use case and my application can easily keep up without issue now\n\nComments:\n", "classification": "Classify the issue 'Consumer performance issues with many topics' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-675?\nA: activemq-cpp has a performance issue when subscribing to many topics.Â  When I try to subscribe to market data by ticker, with 1 topic per ticker, it starts to bog down as I add more Consumers.Â  Digging into it, I see the issue is in how consumers are managed in ActiveMQSessionKernel.cpp.Â  It maintains all consumers in a linked list, and then for *every message* that is received, it does a linear O"}}
{"issue_key": "AMQCPP-664", "project": "AMQCPP", "title": "Replace std::auto_ptr with std::unique_ptr", "status": "Open", "reporter": "Arjun Ray", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2021-04-14T18:37:07.000+0000", "updated": "2025-03-06T18:37:44.000+0000", "description": "The C\\+\\+17 standard has eliminated std::auto_ptr, which was deprecated as of C\\+\\+11 a decade ago.Â  The code-base will therefore not even compile with modern compilers.\r\n\r\nReplacing std::auto_ptr with std::unique_ptr requires only 6 fix-ups, 5 of which are trivial and actually advisable for the existing code-base anyway, and 1 (in the tests) which exposes a flaw in the existing interfaces yet can be worked around relatively simply.\r\n\r\n[https://mail-archives.apache.org/mod_mbox/activemq-dev/202010.mbox/%3Ctblsoft4dbhg61h2c4cgsian0mevub7567%404ax.com%3E]\r\n\r\nÂ \r\n\r\nThe three patches attached are\r\n\r\nÂ Â Â  1. libfix.diff - 3 edits for the library build, while retaining std:;auto_ptr\r\n\r\nÂ Â Â  2. checkfix.diff - 3 edits for the tests build, while retaining std::auto_ptr\r\n\r\nÂ Â Â  3. combo.diff - everything, including the global search and replace.", "comments": [], "text": "Replace std::auto_ptr with std::unique_ptr\n\nDescription:\nThe C\\+\\+17 standard has eliminated std::auto_ptr, which was deprecated as of C\\+\\+11 a decade ago.Â  The code-base will therefore not even compile with modern compilers.\r\n\r\nReplacing std::auto_ptr with std::unique_ptr requires only 6 fix-ups, 5 of which are trivial and actually advisable for the existing code-base anyway, and 1 (in the tests) which exposes a flaw in the existing interfaces yet can be worked around relatively simply.\r\n\r\n[https://mail-archives.apache.org/mod_mbox/activemq-dev/202010.mbox/%3Ctblsoft4dbhg61h2c4cgsian0mevub7567%404ax.com%3E]\r\n\r\nÂ \r\n\r\nThe three patches attached are\r\n\r\nÂ Â Â  1. libfix.diff - 3 edits for the library build, while retaining std:;auto_ptr\r\n\r\nÂ Â Â  2. checkfix.diff - 3 edits for the tests build, while retaining std::auto_ptr\r\n\r\nÂ Â Â  3. combo.diff - everything, including the global search and replace.\r\n\r\nÂ \r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Replace std::auto_ptr with std::unique_ptr\n\nDescription:\nThe C\\+\\+17 standard has eliminated std::auto_ptr, which was deprecated as of C\\+\\+11 a decade ago.Â  The code-base will therefore not even compile with modern compilers.\r\n\r\nReplacing std::auto_ptr with std::unique_ptr requires only 6 fix-ups, 5 of which are trivial and actually advisable for the existing code-base anyway, and 1 (in the tests) which exposes a flaw in the existing interfaces yet can be worked around relatively simply.\r\n\r\n[https://mail-archives.apache.org/mod_mbox/activemq-dev/202010.mbox/%3Ctblsoft4dbhg61h2c4cgsian0mevub7567%404ax.com%3E]\r\n\r\nÂ \r\n\r\nThe three patches attached are\r\n\r\nÂ Â Â  1. libfix.diff - 3 edits for the library build, while retaining std:;auto_ptr\r\n\r\nÂ Â Â  2. checkfix.diff - 3 edits for the tests build, while retaining std::auto_ptr\r\n\r\nÂ Â Â  3. combo.diff - everything, including the global search and replace.\r\n\r\nÂ \r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Replace std::auto_ptr with std::unique_ptr' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-664?\nA: The C\\+\\+17 standard has eliminated std::auto_ptr, which was deprecated as of C\\+\\+11 a decade ago.Â  The code-base will therefore not even compile with modern compilers.\r\n\r\nReplacing std::auto_ptr with std::unique_ptr requires only 6 fix-ups, 5 of which are trivial and actually advisable for the existing code-base anyway, and 1 (in the tests) which exposes a flaw in the existing interfaces yet can"}}
{"issue_key": "AMQCPP-658", "project": "AMQCPP", "title": "Add set/getConnectionId() methods to ActiveMQConnectionFactory", "status": "Open", "reporter": "John Kostaras", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["ActiveMQConnectionFactory", "ConnectionId,"], "created": "2021-02-01T15:21:19.000+0000", "updated": "2025-06-05T11:32:49.000+0000", "description": "While one can get/setConnectionId() in ActiveMQConnection class (via ConnectionId class), this is not possible in ActiveMQConnectionFactory. This could be implemented inside\r\n{code:java}\r\nActiveMQConnectionFactory::configureConnection(ActiveMQConnection* connection){code}\r\nfor example. Or simply add a getConnectionId() in ActiveMQConnectionFactory. This would be very useful when migrating to CMS from other frameworks that get/set the connection id at the ActiveMQConnectionFactory level.", "comments": [], "text": "Add set/getConnectionId() methods to ActiveMQConnectionFactory\n\nDescription:\nWhile one can get/setConnectionId() in ActiveMQConnection class (via ConnectionId class), this is not possible in ActiveMQConnectionFactory. This could be implemented inside\r\n{code:java}\r\nActiveMQConnectionFactory::configureConnection(ActiveMQConnection* connection){code}\r\nfor example. Or simply add a getConnectionId() in ActiveMQConnectionFactory. This would be very useful when migrating to CMS from other frameworks that get/set the connection id at the ActiveMQConnectionFactory level.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add set/getConnectionId() methods to ActiveMQConnectionFactory\n\nDescription:\nWhile one can get/setConnectionId() in ActiveMQConnection class (via ConnectionId class), this is not possible in ActiveMQConnectionFactory. This could be implemented inside\r\n{code:java}\r\nActiveMQConnectionFactory::configureConnection(ActiveMQConnection* connection){code}\r\nfor example. Or simply add a getConnectionId() in ActiveMQConnectionFactory. This would be very useful when migrating to CMS from other frameworks that get/set the connection id at the ActiveMQConnectionFactory level.\n\nComments:\n", "classification": "Classify the issue 'Add set/getConnectionId() methods to ActiveMQConnectionFactory' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-658?\nA: While one can get/setConnectionId() in ActiveMQConnection class (via ConnectionId class), this is not possible in ActiveMQConnectionFactory. This could be implemented inside\r\n{code:java}\r\nActiveMQConnectionFactory::configureConnection(ActiveMQConnection* connection){code}\r\nfor example. Or simply add a getConnectionId() in ActiveMQConnectionFactory. This would be very useful when migrating to CMS f"}}
{"issue_key": "AMQCPP-654", "project": "AMQCPP", "title": "memory leak", "status": "Open", "reporter": "lx", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": ["artemis", "cms", "memory-leak"], "created": "2020-11-10T02:50:48.000+0000", "updated": "2025-02-19T14:24:47.000+0000", "description": "I use cms to receive and send messages to artemis, and the consumer has a memory leak. My code like this\r\n{code:c++}\r\nvoid MyConsumer::WorkThread() {\r\n    try {\r\n            {\r\n                std::lock_guard<std::mutex> lock(mtx_);\r\n                if (inited_) {\r\n                    LOG<<\"inted\\n\";\r\n                    return;\r\n                }\r\n                if (SetMqClientId() != 0) {\r\n                    throw std::runtime_error(\"init mq client id failed\");\r\n                }\r\n                std::shared_ptr<cms::ConnectionFactory> connectionFactory(new ActiveMQConnectionFactory(conf_.broker_uri));\r\n                if (!connectionFactory) {\r\n                    throw std::runtime_error(\"connectionFactory is nullptr\");\r\n                }\r\n                connection = connectionFactory->createConnection(conf_.user_name, conf_.password, mq_client_id_);\r\n                if (!connection) {\r\n                    throw std::runtime_error(\"connection is nullptr\");\r\n                }\r\n\r\n                if (conf_.auto_ack) {\r\n                    session = connection->createSession(Session::AUTO_ACKNOWLEDGE);\r\n                } else {\r\n                    session = connection->createSession(Session::CLIENT_ACKNOWLEDGE);\r\n                }\r\n                if (!session) {\r\n                    throw std::runtime_error(\"session is nullptr\");\r\n                }\r\n\r\n                if (conf_.use_topic) {\r\n                    destination = session->createTopic(conf_.dest_uri);\r\n                } else {\r\n                    throw std::invalid_argument(\"error\");\r\n                }\r\n                if (!destination) {\r\n                    throw std::runtime_error(\"destination is nullptr\");\r\n                }\r\n\r\n                consumer = session->createConsumer(destination);\r\n                if (!consumer) {\r\n                    throw std::runtime_error(\"consumer is nullptr\");\r\n                }\r\n                producer_ = new MyProducer(response_uri_, connection, conf_);\r\n                producer_->Init();\r\n\r\n                connection->start();\r\n                inited_ = true;\r\n            }\r\n            \r\n            while (thread_running_) {\r\n                Message* mq_message = consumer->receive(check_message_interval_);\r\n                if (mq_message && thread_running_) {\r\n                    onMessage(mq_message);\r\n                }\r\n                if (mq_message) {\r\n                    delete mq_message;\r\n                    mq_message = nullptr;\r\n                }\r\n            }\r\n    }\r\n    catch (const decaf::lang::Exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const cms::CMSException& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const std::exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    LOG<<\"stopped\\n\";\r\n    if (thread_running_) {\r\n        sleep(restart_interval_);\r\n        std::thread tmp(&MyConsumer::Start, this);\r\n        tmp.detach();\r\n    }\r\n}\r\n{code}\r\nThe memory leak occurred even if I remove the consumer->receive method(the while loop does nothing)", "comments": [], "text": "memory leak\n\nDescription:\nI use cms to receive and send messages to artemis, and the consumer has a memory leak. My code like this\r\n{code:c++}\r\nvoid MyConsumer::WorkThread() {\r\n    try {\r\n            {\r\n                std::lock_guard<std::mutex> lock(mtx_);\r\n                if (inited_) {\r\n                    LOG<<\"inted\\n\";\r\n                    return;\r\n                }\r\n                if (SetMqClientId() != 0) {\r\n                    throw std::runtime_error(\"init mq client id failed\");\r\n                }\r\n                std::shared_ptr<cms::ConnectionFactory> connectionFactory(new ActiveMQConnectionFactory(conf_.broker_uri));\r\n                if (!connectionFactory) {\r\n                    throw std::runtime_error(\"connectionFactory is nullptr\");\r\n                }\r\n                connection = connectionFactory->createConnection(conf_.user_name, conf_.password, mq_client_id_);\r\n                if (!connection) {\r\n                    throw std::runtime_error(\"connection is nullptr\");\r\n                }\r\n\r\n                if (conf_.auto_ack) {\r\n                    session = connection->createSession(Session::AUTO_ACKNOWLEDGE);\r\n                } else {\r\n                    session = connection->createSession(Session::CLIENT_ACKNOWLEDGE);\r\n                }\r\n                if (!session) {\r\n                    throw std::runtime_error(\"session is nullptr\");\r\n                }\r\n\r\n                if (conf_.use_topic) {\r\n                    destination = session->createTopic(conf_.dest_uri);\r\n                } else {\r\n                    throw std::invalid_argument(\"error\");\r\n                }\r\n                if (!destination) {\r\n                    throw std::runtime_error(\"destination is nullptr\");\r\n                }\r\n\r\n                consumer = session->createConsumer(destination);\r\n                if (!consumer) {\r\n                    throw std::runtime_error(\"consumer is nullptr\");\r\n                }\r\n                producer_ = new MyProducer(response_uri_, connection, conf_);\r\n                producer_->Init();\r\n\r\n                connection->start();\r\n                inited_ = true;\r\n            }\r\n            \r\n            while (thread_running_) {\r\n                Message* mq_message = consumer->receive(check_message_interval_);\r\n                if (mq_message && thread_running_) {\r\n                    onMessage(mq_message);\r\n                }\r\n                if (mq_message) {\r\n                    delete mq_message;\r\n                    mq_message = nullptr;\r\n                }\r\n            }\r\n    }\r\n    catch (const decaf::lang::Exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const cms::CMSException& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const std::exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    LOG<<\"stopped\\n\";\r\n    if (thread_running_) {\r\n        sleep(restart_interval_);\r\n        std::thread tmp(&MyConsumer::Start, this);\r\n        tmp.detach();\r\n    }\r\n}\r\n{code}\r\nThe memory leak occurred even if I remove the consumer->receive method(the while loop does nothing)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: memory leak\n\nDescription:\nI use cms to receive and send messages to artemis, and the consumer has a memory leak. My code like this\r\n{code:c++}\r\nvoid MyConsumer::WorkThread() {\r\n    try {\r\n            {\r\n                std::lock_guard<std::mutex> lock(mtx_);\r\n                if (inited_) {\r\n                    LOG<<\"inted\\n\";\r\n                    return;\r\n                }\r\n                if (SetMqClientId() != 0) {\r\n                    throw std::runtime_error(\"init mq client id failed\");\r\n                }\r\n                std::shared_ptr<cms::ConnectionFactory> connectionFactory(new ActiveMQConnectionFactory(conf_.broker_uri));\r\n                if (!connectionFactory) {\r\n                    throw std::runtime_error(\"connectionFactory is nullptr\");\r\n                }\r\n                connection = connectionFactory->createConnection(conf_.user_name, conf_.password, mq_client_id_);\r\n                if (!connection) {\r\n                    throw std::runtime_error(\"connection is nullptr\");\r\n                }\r\n\r\n                if (conf_.auto_ack) {\r\n                    session = connection->createSession(Session::AUTO_ACKNOWLEDGE);\r\n                } else {\r\n                    session = connection->createSession(Session::CLIENT_ACKNOWLEDGE);\r\n                }\r\n                if (!session) {\r\n                    throw std::runtime_error(\"session is nullptr\");\r\n                }\r\n\r\n                if (conf_.use_topic) {\r\n                    destination = session->createTopic(conf_.dest_uri);\r\n                } else {\r\n                    throw std::invalid_argument(\"error\");\r\n                }\r\n                if (!destination) {\r\n                    throw std::runtime_error(\"destination is nullptr\");\r\n                }\r\n\r\n                consumer = session->createConsumer(destination);\r\n                if (!consumer) {\r\n                    throw std::runtime_error(\"consumer is nullptr\");\r\n                }\r\n                producer_ = new MyProducer(response_uri_, connection, conf_);\r\n                producer_->Init();\r\n\r\n                connection->start();\r\n                inited_ = true;\r\n            }\r\n            \r\n            while (thread_running_) {\r\n                Message* mq_message = consumer->receive(check_message_interval_);\r\n                if (mq_message && thread_running_) {\r\n                    onMessage(mq_message);\r\n                }\r\n                if (mq_message) {\r\n                    delete mq_message;\r\n                    mq_message = nullptr;\r\n                }\r\n            }\r\n    }\r\n    catch (const decaf::lang::Exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const cms::CMSException& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    catch (const std::exception& e) {\r\n        LOG<<\"error:\"<<e.what()<<\"\\n\";\r\n    }\r\n    LOG<<\"stopped\\n\";\r\n    if (thread_running_) {\r\n        sleep(restart_interval_);\r\n        std::thread tmp(&MyConsumer::Start, this);\r\n        tmp.detach();\r\n    }\r\n}\r\n{code}\r\nThe memory leak occurred even if I remove the consumer->receive method(the while loop does nothing)\n\nComments:\n", "classification": "Classify the issue 'memory leak' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-654?\nA: I use cms to receive and send messages to artemis, and the consumer has a memory leak. My code like this\r\n{code:c++}\r\nvoid MyConsumer::WorkThread() {\r\n    try {\r\n            {\r\n                std::lock_guard<std::mutex> lock(mtx_);\r\n                if (inited_) {\r\n                    LOG<<\"inted\\n\";\r\n                    return;\r\n                }\r\n                if (SetMqClientId() != 0) {\r\n    "}}
{"issue_key": "AMQCPP-653", "project": "AMQCPP", "title": "ActiveMQ C++ 3.9.3 Client returning Exception having message \"Pointer operator& - Pointee is NULL.\"", "status": "Open", "reporter": "Srikrishna Erra", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2020-10-02T14:52:08.000+0000", "updated": "2020-10-12T15:08:14.000+0000", "description": "We have a C++ Application usingÂ ActiveMQ C++ 3.9.3 Library to interact ActiveMQ Server.\r\n\r\nWe are testing failover and failback functionality with Master and Slave ActiveMQ Borkers.\r\n\r\n#1. Starting with,Â  Master Broker Up and Slave Borker Down, we could scuccessfully establish connection and send/receive messages.\r\n\r\n#2. Tested Failover (switch to Slave Broker) with Master Broker Down and Slave Broker Up. We could successully establish connection and send/revceive messages\r\n\r\n#3. Tested Failback (switch back to Master Broker) with Master Broker Up and MakingSlave Broker Down again.Â  We could successully establish connection and send/revceive messages\r\n\r\n#4. Our C++ application being running, Master Broker being Up and Slave being down, the setup was intact for fewÂ  days with no activity.\r\n\r\nÂ \r\n\r\nAfter few days, we have just stoped and started our application with still Master Broker being Up and Slave being down.Â  Our application's stop and start was clean.\r\n\r\nÂ \r\n\r\nBut we just got Expception now. Here are the Details.\r\n\r\n==========================================================\r\n\r\nProcess ID: 14606\r\n\r\nThreads ID:Â  14612 ==>Â  Â Connecting with Master Broker which is Up. So, no issues.\r\n\r\nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  14613Â  ==>Â  Connecting with Slave Broker which is Down. Got an Exception.\r\n\r\n==========================================================\r\n\r\nÂ \r\n\r\nHere are the Logs:\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdd5rcdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n[ 0:_*14606*_:*14613*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdt5wsdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker Connection started\r\n[ 0:_*14606*_:*14613*] ERROR JMSSessionFactory - JMSSessionFactory could not be created, verify ActiveMQ server is configured correctly and running.Message from CMS is: Connection refused\r\n[ 0:_*14606*_:*14613*] ERROR JMSHandler - JMSHandler caught exception: Pointer operator& - Pointee is NULL.\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\nÂ \r\n\r\nWe got 2 Exceptions here on the thread that is interacting with Slave Broker which is Down.\r\n\r\nÂ  Â #1.Â  Connection refused. But there was a re-try attemepted.\r\n\r\nÂ  Â #2.Â  NULL Pointer Exception -->Â Pointer operator& - Pointee is NULL.\r\n\r\nÂ \r\n\r\nCould you verify this and assist us on next actions.", "comments": [], "text": "ActiveMQ C++ 3.9.3 Client returning Exception having message \"Pointer operator& - Pointee is NULL.\"\n\nDescription:\nWe have a C++ Application usingÂ ActiveMQ C++ 3.9.3 Library to interact ActiveMQ Server.\r\n\r\nWe are testing failover and failback functionality with Master and Slave ActiveMQ Borkers.\r\n\r\n#1. Starting with,Â  Master Broker Up and Slave Borker Down, we could scuccessfully establish connection and send/receive messages.\r\n\r\n#2. Tested Failover (switch to Slave Broker) with Master Broker Down and Slave Broker Up. We could successully establish connection and send/revceive messages\r\n\r\n#3. Tested Failback (switch back to Master Broker) with Master Broker Up and MakingSlave Broker Down again.Â  We could successully establish connection and send/revceive messages\r\n\r\n#4. Our C++ application being running, Master Broker being Up and Slave being down, the setup was intact for fewÂ  days with no activity.\r\n\r\nÂ \r\n\r\nAfter few days, we have just stoped and started our application with still Master Broker being Up and Slave being down.Â  Our application's stop and start was clean.\r\n\r\nÂ \r\n\r\nBut we just got Expception now. Here are the Details.\r\n\r\n==========================================================\r\n\r\nProcess ID: 14606\r\n\r\nThreads ID:Â  14612 ==>Â  Â Connecting with Master Broker which is Up. So, no issues.\r\n\r\nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  14613Â  ==>Â  Connecting with Slave Broker which is Down. Got an Exception.\r\n\r\n==========================================================\r\n\r\nÂ \r\n\r\nHere are the Logs:\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdd5rcdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n[ 0:_*14606*_:*14613*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdt5wsdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker Connection started\r\n[ 0:_*14606*_:*14613*] ERROR JMSSessionFactory - JMSSessionFactory could not be created, verify ActiveMQ server is configured correctly and running.Message from CMS is: Connection refused\r\n[ 0:_*14606*_:*14613*] ERROR JMSHandler - JMSHandler caught exception: Pointer operator& - Pointee is NULL.\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\nÂ \r\n\r\nWe got 2 Exceptions here on the thread that is interacting with Slave Broker which is Down.\r\n\r\nÂ  Â #1.Â  Connection refused. But there was a re-try attemepted.\r\n\r\nÂ  Â #2.Â  NULL Pointer Exception -->Â Pointer operator& - Pointee is NULL.\r\n\r\nÂ \r\n\r\nCould you verify this and assist us on next actions.\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ C++ 3.9.3 Client returning Exception having message \"Pointer operator& - Pointee is NULL.\"\n\nDescription:\nWe have a C++ Application usingÂ ActiveMQ C++ 3.9.3 Library to interact ActiveMQ Server.\r\n\r\nWe are testing failover and failback functionality with Master and Slave ActiveMQ Borkers.\r\n\r\n#1. Starting with,Â  Master Broker Up and Slave Borker Down, we could scuccessfully establish connection and send/receive messages.\r\n\r\n#2. Tested Failover (switch to Slave Broker) with Master Broker Down and Slave Broker Up. We could successully establish connection and send/revceive messages\r\n\r\n#3. Tested Failback (switch back to Master Broker) with Master Broker Up and MakingSlave Broker Down again.Â  We could successully establish connection and send/revceive messages\r\n\r\n#4. Our C++ application being running, Master Broker being Up and Slave being down, the setup was intact for fewÂ  days with no activity.\r\n\r\nÂ \r\n\r\nAfter few days, we have just stoped and started our application with still Master Broker being Up and Slave being down.Â  Our application's stop and start was clean.\r\n\r\nÂ \r\n\r\nBut we just got Expception now. Here are the Details.\r\n\r\n==========================================================\r\n\r\nProcess ID: 14606\r\n\r\nThreads ID:Â  14612 ==>Â  Â Connecting with Master Broker which is Up. So, no issues.\r\n\r\nÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  14613Â  ==>Â  Connecting with Slave Broker which is Down. Got an Exception.\r\n\r\n==========================================================\r\n\r\nÂ \r\n\r\nHere are the Logs:\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdd5rcdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n[ 0:_*14606*_:*14613*] DEBUG JMSSessionFactory - Broker URL:failover://(tcp://tdt5wsdam01:61616?jms.watchTopicAdvisories=false)?startupMaxReconnectAttempts=6&initialReconnectDelay=500&maxReconnectAttempts=-1&maxReconnectDelay=30000\r\n\r\n[ 0:_*14606*_:*14612*] DEBUG JMSSessionFactory - Broker Connection started\r\n[ 0:_*14606*_:*14613*] ERROR JMSSessionFactory - JMSSessionFactory could not be created, verify ActiveMQ server is configured correctly and running.Message from CMS is: Connection refused\r\n[ 0:_*14606*_:*14613*] ERROR JMSHandler - JMSHandler caught exception: Pointer operator& - Pointee is NULL.\r\n\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\nÂ \r\n\r\nWe got 2 Exceptions here on the thread that is interacting with Slave Broker which is Down.\r\n\r\nÂ  Â #1.Â  Connection refused. But there was a re-try attemepted.\r\n\r\nÂ  Â #2.Â  NULL Pointer Exception -->Â Pointer operator& - Pointee is NULL.\r\n\r\nÂ \r\n\r\nCould you verify this and assist us on next actions.\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'ActiveMQ C++ 3.9.3 Client returning Exception having message \"Pointer operator& - Pointee is NULL.\"' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-653?\nA: We have a C++ Application usingÂ ActiveMQ C++ 3.9.3 Library to interact ActiveMQ Server.\r\n\r\nWe are testing failover and failback functionality with Master and Slave ActiveMQ Borkers.\r\n\r\n#1. Starting with,Â  Master Broker Up and Slave Borker Down, we could scuccessfully establish connection and send/receive messages.\r\n\r\n#2. Tested Failover (switch to Slave Broker) with Master Broker Down and Slave Br"}}
{"issue_key": "AMQCPP-652", "project": "AMQCPP", "title": "AMQCPP client sometimes hangs forever in failover reconnect attempt", "status": "Open", "reporter": "Srdjan Stamenkovic", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2020-05-06T12:07:24.000+0000", "updated": "2020-05-07T12:21:15.000+0000", "description": "After successful reconnect attempts to server (transport interruptions), it happens that some reconnect attempt may block forever, probably in deadlock, where thread trying to close the transport waits infinitely for anther thread to send message on the transport being closed (only advisory messages were sent from the server to the client at the time).Â  Attached the stack at the moment of deadlock.", "comments": [], "text": "AMQCPP client sometimes hangs forever in failover reconnect attempt\n\nDescription:\nAfter successful reconnect attempts to server (transport interruptions), it happens that some reconnect attempt may block forever, probably in deadlock, where thread trying to close the transport waits infinitely for anther thread to send message on the transport being closed (only advisory messages were sent from the server to the client at the time).Â  Attached the stack at the moment of deadlock.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AMQCPP client sometimes hangs forever in failover reconnect attempt\n\nDescription:\nAfter successful reconnect attempts to server (transport interruptions), it happens that some reconnect attempt may block forever, probably in deadlock, where thread trying to close the transport waits infinitely for anther thread to send message on the transport being closed (only advisory messages were sent from the server to the client at the time).Â  Attached the stack at the moment of deadlock.\n\nComments:\n", "classification": "Classify the issue 'AMQCPP client sometimes hangs forever in failover reconnect attempt' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-652?\nA: After successful reconnect attempts to server (transport interruptions), it happens that some reconnect attempt may block forever, probably in deadlock, where thread trying to close the transport waits infinitely for anther thread to send message on the transport being closed (only advisory messages were sent from the server to the client at the time).Â  Attached the stack at the moment of deadlock"}}
{"issue_key": "AMQCPP-649", "project": "AMQCPP", "title": "cms::MessageConsumer with pending messages cannot be closed ", "status": "Open", "reporter": "Antal IspÃ¡novity", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2020-04-08T07:48:32.000+0000", "updated": "2020-04-08T15:42:53.000+0000", "description": "Dear Support,\r\n\r\nÂ \r\n\r\nI found an issue that cms::MessageConsumer cannot be deleted and therefore the cms::Session and cms::Connection cannot be closed while there are still incoming messages.\r\n\r\nI can reproduce the problem with a slightly modified version of the example code posted here:\r\n\r\n[https://activemq.apache.org/components/cms/example]\r\n\r\nÂ \r\n\r\nHere is the required modification:\r\n\r\nClose the 'connection' in the onMessage(const Message* message)Â  function like this:\r\n\r\n*original:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\n{code}\r\nÂ \r\n\r\nÂ \r\n\r\n*modified:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\nif (connection)\r\n{\r\nÂ  Â  connection->close();\r\nÂ  Â  delete connection;\r\nÂ  Â  connection = nullptr;\r\n}\r\nelse\r\n{\r\n    return;\r\n}{code}\r\nThis is not the exact code that I used in our production environment, but unfortunately I cannot share that code with you.\r\n\r\nÂ \r\n\r\nWhat happens:\r\n\r\ntheÂ \r\n{code:java}\r\nconnection->close();{code}\r\nhangs. Here is the stacktrace from the modified example application:\r\n\r\nÂ  [External Code] Â  [External Code] Â  activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex, decaf::internal::util::concurrent::CompletionCondition & complete) Line 282 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread, __int64 mills, int nanos) Line 1147 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::destroyThread(decaf::internal::util::concurrent::ThreadHandle * thread) Line 946 C++Â  activemq-cppd.dll!decaf::lang::Thread::~Thread() Line 131 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Thread * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::~DedicatedTaskRunner() Line 46 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::threads::TaskRunner * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop() Line 153 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQSessionKernel::stop() Line 1121 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConnection::stop() Line 898 C++> activemq-cppd.dll!activemq::core::ActiveMQConnection::close() Line 695 C++Â  consumer_producer.exe!HelloWorldConsumer::onMessage(const cms::Message * message) Line 281 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 1646 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 166 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::iterate() Line 192 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::run() Line 141 C++Â  activemq-cppd.dll!decaf::lang::Thread::run() Line 143 C++Â  activemq-cppd.dll!`anonymous namespace'::runCallback(void * arg) Line 268 C++Â  activemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg) Line 258 C++Â  [External Code]\r\n\r\nÂ \r\n\r\nIn our production environment the Connection is closed outside of the onMessage function and in that case the following is the stacktrace on the blocked thread:\r\n\r\nÂ  [External Code] Â  [External Code] > activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::waitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex) Line 254 C++Â  activemq-cppd.dll!`anonymous namespace'::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle * monitor, decaf::internal::util::concurrent::ThreadHandle * thread) Line 664 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor) Line 1541 C++Â  activemq-cppd.dll!decaf::util::concurrent::Mutex::lock() Line 130 C++Â  activemq-cppd.dll!decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> >::lock() Line 346 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::lock() Line 55 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object, const bool intiallyLocked) Line 32 C++Â  activemq-cppd.dll!activemq::core::FifoMessageDispatchChannel::close() Line 131 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispose() Line 972 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::doClose() Line 894 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::close() Line 875 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConsumer::~ActiveMQConsumer() Line 74 C++Â  [External Code]\r\n\r\n...\r\n\r\nÂ \r\n\r\nThe execution is waiting at this line:Â \r\n\r\n::WaitForSingleObject(condition, INFINITE);\r\n\r\ncondition's value is:Â 0x0000000000000484\r\n\r\nmutex'x value is:\r\n\r\n- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- DebugInfo 0xffffffffffffffff \\{Type=??? CreatorBackTraceIndex=??? CriticalSection=??? ...} _RTL_CRITICAL_SECTION_DEBUG * Type <Unable to read memory> CreatorBackTraceIndex <Unable to read memory> CriticalSection <Unable to read memory> + ProcessLocksList \\{Flink=??? Blink=??? } _LIST_ENTRY EntryCount <Unable to read memory> ContentionCount <Unable to read memory> Flags <Unable to read memory> CreatorBackTraceIndexHigh <Unable to read memory> SpareWORD <Unable to read memory> LockCount -1 long RecursionCount 0 long OwningThread 0x0000000000000000 void * LockSemaphore 0x0000000000000000 void * SpinCount 33556432 unsigned __int64", "comments": [], "text": "cms::MessageConsumer with pending messages cannot be closed \n\nDescription:\nDear Support,\r\n\r\nÂ \r\n\r\nI found an issue that cms::MessageConsumer cannot be deleted and therefore the cms::Session and cms::Connection cannot be closed while there are still incoming messages.\r\n\r\nI can reproduce the problem with a slightly modified version of the example code posted here:\r\n\r\n[https://activemq.apache.org/components/cms/example]\r\n\r\nÂ \r\n\r\nHere is the required modification:\r\n\r\nClose the 'connection' in the onMessage(const Message* message)Â  function like this:\r\n\r\n*original:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\n{code}\r\nÂ \r\n\r\nÂ \r\n\r\n*modified:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\nif (connection)\r\n{\r\nÂ  Â  connection->close();\r\nÂ  Â  delete connection;\r\nÂ  Â  connection = nullptr;\r\n}\r\nelse\r\n{\r\n    return;\r\n}{code}\r\nThis is not the exact code that I used in our production environment, but unfortunately I cannot share that code with you.\r\n\r\nÂ \r\n\r\nWhat happens:\r\n\r\ntheÂ \r\n{code:java}\r\nconnection->close();{code}\r\nhangs. Here is the stacktrace from the modified example application:\r\n\r\nÂ  [External Code] Â  [External Code] Â  activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex, decaf::internal::util::concurrent::CompletionCondition & complete) Line 282 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread, __int64 mills, int nanos) Line 1147 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::destroyThread(decaf::internal::util::concurrent::ThreadHandle * thread) Line 946 C++Â  activemq-cppd.dll!decaf::lang::Thread::~Thread() Line 131 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Thread * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::~DedicatedTaskRunner() Line 46 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::threads::TaskRunner * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop() Line 153 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQSessionKernel::stop() Line 1121 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConnection::stop() Line 898 C++> activemq-cppd.dll!activemq::core::ActiveMQConnection::close() Line 695 C++Â  consumer_producer.exe!HelloWorldConsumer::onMessage(const cms::Message * message) Line 281 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 1646 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 166 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::iterate() Line 192 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::run() Line 141 C++Â  activemq-cppd.dll!decaf::lang::Thread::run() Line 143 C++Â  activemq-cppd.dll!`anonymous namespace'::runCallback(void * arg) Line 268 C++Â  activemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg) Line 258 C++Â  [External Code]\r\n\r\nÂ \r\n\r\nIn our production environment the Connection is closed outside of the onMessage function and in that case the following is the stacktrace on the blocked thread:\r\n\r\nÂ  [External Code] Â  [External Code] > activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::waitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex) Line 254 C++Â  activemq-cppd.dll!`anonymous namespace'::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle * monitor, decaf::internal::util::concurrent::ThreadHandle * thread) Line 664 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor) Line 1541 C++Â  activemq-cppd.dll!decaf::util::concurrent::Mutex::lock() Line 130 C++Â  activemq-cppd.dll!decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> >::lock() Line 346 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::lock() Line 55 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object, const bool intiallyLocked) Line 32 C++Â  activemq-cppd.dll!activemq::core::FifoMessageDispatchChannel::close() Line 131 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispose() Line 972 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::doClose() Line 894 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::close() Line 875 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConsumer::~ActiveMQConsumer() Line 74 C++Â  [External Code]\r\n\r\n...\r\n\r\nÂ \r\n\r\nThe execution is waiting at this line:Â \r\n\r\n::WaitForSingleObject(condition, INFINITE);\r\n\r\ncondition's value is:Â 0x0000000000000484\r\n\r\nmutex'x value is:\r\n\r\n- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- DebugInfo 0xffffffffffffffff \\{Type=??? CreatorBackTraceIndex=??? CriticalSection=??? ...} _RTL_CRITICAL_SECTION_DEBUG * Type <Unable to read memory> CreatorBackTraceIndex <Unable to read memory> CriticalSection <Unable to read memory> + ProcessLocksList \\{Flink=??? Blink=??? } _LIST_ENTRY EntryCount <Unable to read memory> ContentionCount <Unable to read memory> Flags <Unable to read memory> CreatorBackTraceIndexHigh <Unable to read memory> SpareWORD <Unable to read memory> LockCount -1 long RecursionCount 0 long OwningThread 0x0000000000000000 void * LockSemaphore 0x0000000000000000 void * SpinCount 33556432 unsigned __int64\r\n\r\nÂ \r\n\r\nÂ \r\n\r\nÂ \r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: cms::MessageConsumer with pending messages cannot be closed \n\nDescription:\nDear Support,\r\n\r\nÂ \r\n\r\nI found an issue that cms::MessageConsumer cannot be deleted and therefore the cms::Session and cms::Connection cannot be closed while there are still incoming messages.\r\n\r\nI can reproduce the problem with a slightly modified version of the example code posted here:\r\n\r\n[https://activemq.apache.org/components/cms/example]\r\n\r\nÂ \r\n\r\nHere is the required modification:\r\n\r\nClose the 'connection' in the onMessage(const Message* message)Â  function like this:\r\n\r\n*original:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\n{code}\r\nÂ \r\n\r\nÂ \r\n\r\n*modified:*\r\n\r\nÂ \r\n{code:java}\r\ncount++;\r\nif (connection)\r\n{\r\nÂ  Â  connection->close();\r\nÂ  Â  delete connection;\r\nÂ  Â  connection = nullptr;\r\n}\r\nelse\r\n{\r\n    return;\r\n}{code}\r\nThis is not the exact code that I used in our production environment, but unfortunately I cannot share that code with you.\r\n\r\nÂ \r\n\r\nWhat happens:\r\n\r\ntheÂ \r\n{code:java}\r\nconnection->close();{code}\r\nhangs. Here is the stacktrace from the modified example application:\r\n\r\nÂ  [External Code] Â  [External Code] Â  activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex, decaf::internal::util::concurrent::CompletionCondition & complete) Line 282 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread, __int64 mills, int nanos) Line 1147 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::destroyThread(decaf::internal::util::concurrent::ThreadHandle * thread) Line 946 C++Â  activemq-cppd.dll!decaf::lang::Thread::~Thread() Line 131 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::lang::Thread * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::lang::Thread,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::~DedicatedTaskRunner() Line 46 C++Â  [External Code] Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::threads::TaskRunner * value) Line 317 C++Â  activemq-cppd.dll!decaf::lang::Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::threads::TaskRunner,decaf::util::concurrent::atomic::AtomicRefCounter>() Line 148 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop() Line 153 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQSessionKernel::stop() Line 1121 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConnection::stop() Line 898 C++> activemq-cppd.dll!activemq::core::ActiveMQConnection::close() Line 695 C++Â  consumer_producer.exe!HelloWorldConsumer::onMessage(const cms::Message * message) Line 281 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 1646 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & dispatch) Line 166 C++Â  activemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::iterate() Line 192 C++Â  activemq-cppd.dll!activemq::threads::DedicatedTaskRunner::run() Line 141 C++Â  activemq-cppd.dll!decaf::lang::Thread::run() Line 143 C++Â  activemq-cppd.dll!`anonymous namespace'::runCallback(void * arg) Line 268 C++Â  activemq-cppd.dll!`anonymous namespace'::threadEntryMethod(void * arg) Line 258 C++Â  [External Code]\r\n\r\nÂ \r\n\r\nIn our production environment the Connection is closed outside of the onMessage function and in that case the following is the stacktrace on the blocked thread:\r\n\r\nÂ  [External Code] Â  [External Code] > activemq-cppd.dll!decaf::internal::util::concurrent::PlatformThread::waitOnCondition(void * condition, _RTL_CRITICAL_SECTION * mutex) Line 254 C++Â  activemq-cppd.dll!`anonymous namespace'::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle * monitor, decaf::internal::util::concurrent::ThreadHandle * thread) Line 664 C++Â  activemq-cppd.dll!decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor) Line 1541 C++Â  activemq-cppd.dll!decaf::util::concurrent::Mutex::lock() Line 130 C++Â  activemq-cppd.dll!decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> >::lock() Line 346 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::lock() Line 55 C++Â  activemq-cppd.dll!decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable * object, const bool intiallyLocked) Line 32 C++Â  activemq-cppd.dll!activemq::core::FifoMessageDispatchChannel::close() Line 131 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::dispose() Line 972 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::doClose() Line 894 C++Â  activemq-cppd.dll!activemq::core::kernels::ActiveMQConsumerKernel::close() Line 875 C++Â  activemq-cppd.dll!activemq::core::ActiveMQConsumer::~ActiveMQConsumer() Line 74 C++Â  [External Code]\r\n\r\n...\r\n\r\nÂ \r\n\r\nThe execution is waiting at this line:Â \r\n\r\n::WaitForSingleObject(condition, INFINITE);\r\n\r\ncondition's value is:Â 0x0000000000000484\r\n\r\nmutex'x value is:\r\n\r\n- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- mutex 0x0000029337da8ff0 \\{DebugInfo=0xffffffffffffffff {Type=??? CreatorBackTraceIndex=??? CriticalSection=...} ...} _RTL_CRITICAL_SECTION *- DebugInfo 0xffffffffffffffff \\{Type=??? CreatorBackTraceIndex=??? CriticalSection=??? ...} _RTL_CRITICAL_SECTION_DEBUG * Type <Unable to read memory> CreatorBackTraceIndex <Unable to read memory> CriticalSection <Unable to read memory> + ProcessLocksList \\{Flink=??? Blink=??? } _LIST_ENTRY EntryCount <Unable to read memory> ContentionCount <Unable to read memory> Flags <Unable to read memory> CreatorBackTraceIndexHigh <Unable to read memory> SpareWORD <Unable to read memory> LockCount -1 long RecursionCount 0 long OwningThread 0x0000000000000000 void * LockSemaphore 0x0000000000000000 void * SpinCount 33556432 unsigned __int64\r\n\r\nÂ \r\n\r\nÂ \r\n\r\nÂ \r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'cms::MessageConsumer with pending messages cannot be closed ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-649?\nA: Dear Support,\r\n\r\nÂ \r\n\r\nI found an issue that cms::MessageConsumer cannot be deleted and therefore the cms::Session and cms::Connection cannot be closed while there are still incoming messages.\r\n\r\nI can reproduce the problem with a slightly modified version of the example code posted here:\r\n\r\n[https://activemq.apache.org/components/cms/example]\r\n\r\nÂ \r\n\r\nHere is the required modification:\r\n\r\nClose the"}}
{"issue_key": "AMQCPP-648", "project": "AMQCPP", "title": "Invalid cast in ConnectionState object in ConnectionStateTracker called from FailoverTransport::oneway() while initiating an XA transaction", "status": "Open", "reporter": "Sven Bovin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2020-02-03T07:44:45.000+0000", "updated": "2020-02-10T15:46:07.000+0000", "description": "From a C application we use the ActiveMQ-CPP libraries (version 3.9.5) to interact with ActiveMQ Classic 5.15.11.\r\n\r\nOur application connects to a broker using the failover transport.\r\n\r\nWhen starting an XA transaction, we first create an XID (an object of type XATransactionId) and use it to start the XA transaction with the XAResource::start method. Control then flows through several layers to arrive in the FailoverTransport::oneway method where a state tracker is called. The state tracker leads to aÂ ConnectionStateTracker::processBeginTransaction method that grabs our XID (an XATransactionId) and tries to cast it to aÂ LocalTransactionId. Both XATransactionId and LocalTransactionId inherit from TransactionId, but an XATransactionId is obviously not a LocalTransactionId and the cast fails. Our attempt to start an XA transaction therefore also fails.\r\n\r\nUsing tcp transport instead of failover allows our code to correctly start the XA transaction but is not a viable solution for production use.\r\n\r\nIs what we observed (impossible to start an XA transaction while using failover) the expected behaviour (and if so, what is the rationale for it) or is it a bug in the library?", "comments": [], "text": "Invalid cast in ConnectionState object in ConnectionStateTracker called from FailoverTransport::oneway() while initiating an XA transaction\n\nDescription:\nFrom a C application we use the ActiveMQ-CPP libraries (version 3.9.5) to interact with ActiveMQ Classic 5.15.11.\r\n\r\nOur application connects to a broker using the failover transport.\r\n\r\nWhen starting an XA transaction, we first create an XID (an object of type XATransactionId) and use it to start the XA transaction with the XAResource::start method. Control then flows through several layers to arrive in the FailoverTransport::oneway method where a state tracker is called. The state tracker leads to aÂ ConnectionStateTracker::processBeginTransaction method that grabs our XID (an XATransactionId) and tries to cast it to aÂ LocalTransactionId. Both XATransactionId and LocalTransactionId inherit from TransactionId, but an XATransactionId is obviously not a LocalTransactionId and the cast fails. Our attempt to start an XA transaction therefore also fails.\r\n\r\nUsing tcp transport instead of failover allows our code to correctly start the XA transaction but is not a viable solution for production use.\r\n\r\nIs what we observed (impossible to start an XA transaction while using failover) the expected behaviour (and if so, what is the rationale for it) or is it a bug in the library?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Invalid cast in ConnectionState object in ConnectionStateTracker called from FailoverTransport::oneway() while initiating an XA transaction\n\nDescription:\nFrom a C application we use the ActiveMQ-CPP libraries (version 3.9.5) to interact with ActiveMQ Classic 5.15.11.\r\n\r\nOur application connects to a broker using the failover transport.\r\n\r\nWhen starting an XA transaction, we first create an XID (an object of type XATransactionId) and use it to start the XA transaction with the XAResource::start method. Control then flows through several layers to arrive in the FailoverTransport::oneway method where a state tracker is called. The state tracker leads to aÂ ConnectionStateTracker::processBeginTransaction method that grabs our XID (an XATransactionId) and tries to cast it to aÂ LocalTransactionId. Both XATransactionId and LocalTransactionId inherit from TransactionId, but an XATransactionId is obviously not a LocalTransactionId and the cast fails. Our attempt to start an XA transaction therefore also fails.\r\n\r\nUsing tcp transport instead of failover allows our code to correctly start the XA transaction but is not a viable solution for production use.\r\n\r\nIs what we observed (impossible to start an XA transaction while using failover) the expected behaviour (and if so, what is the rationale for it) or is it a bug in the library?\n\nComments:\n", "classification": "Classify the issue 'Invalid cast in ConnectionState object in ConnectionStateTracker called from FailoverTransport::oneway() while initiating an XA transaction' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-648?\nA: From a C application we use the ActiveMQ-CPP libraries (version 3.9.5) to interact with ActiveMQ Classic 5.15.11.\r\n\r\nOur application connects to a broker using the failover transport.\r\n\r\nWhen starting an XA transaction, we first create an XID (an object of type XATransactionId) and use it to start the XA transaction with the XAResource::start method. Control then flows through several layers to ar"}}
{"issue_key": "AMQCPP-647", "project": "AMQCPP", "title": "failover transport can not rebalanced", "status": "Open", "reporter": "liguopeng", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2019-07-24T12:59:59.000+0000", "updated": "2019-07-24T12:59:59.000+0000", "description": "I used activemq-cpp c++ exampleÂ HelloWorldProducer with\r\n\r\nfailover://(tcp://10.14.69.125:61617).\r\n\r\nI tried a number of times but found that the new transport always connect toÂ 10.14.69.125:61616\r\n\r\nwhen the server responseÂ rebalance control command with severalÂ URIs.\r\n\r\nI put a fix into theÂ FailoverTransport::updateURIs method to replaceÂ StlSet<URI>Â with StlList<URI>\r\n\r\nÂ \r\n\r\nthen the client can successfully rebalanced", "comments": [], "text": "failover transport can not rebalanced\n\nDescription:\nI used activemq-cpp c++ exampleÂ HelloWorldProducer with\r\n\r\nfailover://(tcp://10.14.69.125:61617).\r\n\r\nI tried a number of times but found that the new transport always connect toÂ 10.14.69.125:61616\r\n\r\nwhen the server responseÂ rebalance control command with severalÂ URIs.\r\n\r\nI put a fix into theÂ FailoverTransport::updateURIs method to replaceÂ StlSet<URI>Â with StlList<URI>\r\n\r\nÂ \r\n\r\nthen the client can successfully rebalanced\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: failover transport can not rebalanced\n\nDescription:\nI used activemq-cpp c++ exampleÂ HelloWorldProducer with\r\n\r\nfailover://(tcp://10.14.69.125:61617).\r\n\r\nI tried a number of times but found that the new transport always connect toÂ 10.14.69.125:61616\r\n\r\nwhen the server responseÂ rebalance control command with severalÂ URIs.\r\n\r\nI put a fix into theÂ FailoverTransport::updateURIs method to replaceÂ StlSet<URI>Â with StlList<URI>\r\n\r\nÂ \r\n\r\nthen the client can successfully rebalanced\n\nComments:\n", "classification": "Classify the issue 'failover transport can not rebalanced' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-647?\nA: I used activemq-cpp c++ exampleÂ HelloWorldProducer with\r\n\r\nfailover://(tcp://10.14.69.125:61617).\r\n\r\nI tried a number of times but found that the new transport always connect toÂ 10.14.69.125:61616\r\n\r\nwhen the server responseÂ rebalance control command with severalÂ URIs.\r\n\r\nI put a fix into theÂ FailoverTransport::updateURIs method to replaceÂ StlSet<URI>Â with StlList<URI>\r\n\r\nÂ \r\n\r\nthen the client can "}}
{"issue_key": "AMQCPP-646", "project": "AMQCPP", "title": "Segmentation fault in TransportFilter & FailoverTransportListener", "status": "Open", "reporter": "Hassan Raza", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2019-05-15T15:11:26.000+0000", "updated": "2021-01-13T15:46:24.000+0000", "description": "26/11/2020 UPDATE:\r\n\r\nWe ran into segmentation faults even with our patched library, which looked like this:\r\n\r\n-|/.../libactivemq-cpp.so.19\r\n -|[18] : decaf::util::concurrent::Lock::lock()+0x1f\r\n -|[19] : decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool)+0x55\r\n -|[20] : activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x104\r\n -|[21] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[22] : activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xac\r\n -|[23] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x305\r\n -|[24] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[25] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6\r\n -|[26] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[27] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x300\r\n -|[28] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[29] : activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9a\r\n -|[30] : activemq::transport::IOTransport::run()+0xd0\r\n -|[31] : +0xb7fc12\r\n -|[32] : +0xb8042a\r\n\r\nÂ \r\n\r\nAfter comparing with the java equivalent of FailoverTransport, we noticed that there was a discrepancy in how the disposed listener works. It seems that the disposed listener is not initialized at all, which leads to the transport listener not putting this fallback in place, leaving dangling pointers to itself in other elements in the chain. We now ensure that there is always a valid disposed listener which will serve as the sink for any leftover calls. This new patch is attached.\r\n\r\nÂ \r\n\r\n26/11/2020 END OF UPDATE\r\n\r\n___________________________________________\r\n\r\nWe'reÂ gettingÂ the following segmentation faults on a productive system with 160 cores on a fairly regular basis:\r\n{quote}-|/export/..../lib/libactivemq-cpp.so.19\r\n\r\n{{-|[7] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x175}}\r\n {{ -|[8] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[9] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6}}\r\n {{ -|[10] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[11] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x292}}\r\n {{ -|[12] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[13] : activemq::transport::IOTransport::(fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9c}}\r\n {{ -|[14] : activemq::transport::IOTransport::run()+0xb1}}\r\n{quote}\r\nWe've narrowed the problem down to the call to Transport::setTransportListener(NULL) inÂ TransportFilter::close() - it seems to be the same race condition reported with:\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-534]\r\n\r\nand\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-583]\r\n\r\nÂ I'm guessing the fix will also be similar - a basic patch suggestion isÂ attached. You may want to put the static DefaultTransportListener in a common place.\r\n\r\nHowever, what is more worrying is that there appear to be several race conditions related toÂ FailoverTransport::getTransportListener(). It provides mutex based access to the current listener, but all subsequent access to the raw pointer is unprotected. We had a concrete case inÂ FailoverTransportListener::onCommand(). There are two calls toÂ parent->getTransportListener() - one for the null ptr check, the second to invoke the command. In our seg fault, we observed that the first call returned a valid ptr, but the second call didn't (or returned null). Our explanation is that since getting and setting the TransportListener is protected by a mutex, another thread was able to get a hold of the mutex between the two calls and set it to FailoverTransport::setTransportListener(NULL).\r\n\r\nPerhaps aÂ much better way of handling this situation would be to use shared_ptr instead of aÂ raw pointer for:\r\n\r\n{{FailoverTransportImpl::TransportListener* transportListener;}}\r\n\r\n{{std::shared_ptr<TransportListener> FailoverTransport::getTransportListener()}}\r\n\r\n{{FailoverTransport::setTransportListener(std::shared_ptr<TransportListener> listener)}}\r\n\r\nThis way, a thread could set a new listener, and any threads still referencing the old listener would gracefully fail. We looked into providing a patch for that, but realized that would be a much bigger change involving ActiveMQConnection deriving from std::enable_shared_from_this, which would also meanÂ replacingÂ decaf::lang::Pointer by std::shared_ptr...Â Without knowing why decaf::lang::Pointer exists in the first place, it would be difficult to proceed without additional clarifications.", "comments": [], "text": "Segmentation fault in TransportFilter & FailoverTransportListener\n\nDescription:\n26/11/2020 UPDATE:\r\n\r\nWe ran into segmentation faults even with our patched library, which looked like this:\r\n\r\n-|/.../libactivemq-cpp.so.19\r\n -|[18] : decaf::util::concurrent::Lock::lock()+0x1f\r\n -|[19] : decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool)+0x55\r\n -|[20] : activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x104\r\n -|[21] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[22] : activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xac\r\n -|[23] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x305\r\n -|[24] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[25] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6\r\n -|[26] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[27] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x300\r\n -|[28] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[29] : activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9a\r\n -|[30] : activemq::transport::IOTransport::run()+0xd0\r\n -|[31] : +0xb7fc12\r\n -|[32] : +0xb8042a\r\n\r\nÂ \r\n\r\nAfter comparing with the java equivalent of FailoverTransport, we noticed that there was a discrepancy in how the disposed listener works. It seems that the disposed listener is not initialized at all, which leads to the transport listener not putting this fallback in place, leaving dangling pointers to itself in other elements in the chain. We now ensure that there is always a valid disposed listener which will serve as the sink for any leftover calls. This new patch is attached.\r\n\r\nÂ \r\n\r\n26/11/2020 END OF UPDATE\r\n\r\n___________________________________________\r\n\r\nWe'reÂ gettingÂ the following segmentation faults on a productive system with 160 cores on a fairly regular basis:\r\n{quote}-|/export/..../lib/libactivemq-cpp.so.19\r\n\r\n{{-|[7] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x175}}\r\n {{ -|[8] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[9] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6}}\r\n {{ -|[10] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[11] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x292}}\r\n {{ -|[12] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[13] : activemq::transport::IOTransport::(fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9c}}\r\n {{ -|[14] : activemq::transport::IOTransport::run()+0xb1}}\r\n{quote}\r\nWe've narrowed the problem down to the call to Transport::setTransportListener(NULL) inÂ TransportFilter::close() - it seems to be the same race condition reported with:\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-534]\r\n\r\nand\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-583]\r\n\r\nÂ I'm guessing the fix will also be similar - a basic patch suggestion isÂ attached. You may want to put the static DefaultTransportListener in a common place.\r\n\r\nHowever, what is more worrying is that there appear to be several race conditions related toÂ FailoverTransport::getTransportListener(). It provides mutex based access to the current listener, but all subsequent access to the raw pointer is unprotected. We had a concrete case inÂ FailoverTransportListener::onCommand(). There are two calls toÂ parent->getTransportListener() - one for the null ptr check, the second to invoke the command. In our seg fault, we observed that the first call returned a valid ptr, but the second call didn't (or returned null). Our explanation is that since getting and setting the TransportListener is protected by a mutex, another thread was able to get a hold of the mutex between the two calls and set it to FailoverTransport::setTransportListener(NULL).\r\n\r\nPerhaps aÂ much better way of handling this situation would be to use shared_ptr instead of aÂ raw pointer for:\r\n\r\n{{FailoverTransportImpl::TransportListener* transportListener;}}\r\n\r\n{{std::shared_ptr<TransportListener> FailoverTransport::getTransportListener()}}\r\n\r\n{{FailoverTransport::setTransportListener(std::shared_ptr<TransportListener> listener)}}\r\n\r\nThis way, a thread could set a new listener, and any threads still referencing the old listener would gracefully fail. We looked into providing a patch for that, but realized that would be a much bigger change involving ActiveMQConnection deriving from std::enable_shared_from_this, which would also meanÂ replacingÂ decaf::lang::Pointer by std::shared_ptr...Â Without knowing why decaf::lang::Pointer exists in the first place, it would be difficult to proceed without additional clarifications.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation fault in TransportFilter & FailoverTransportListener\n\nDescription:\n26/11/2020 UPDATE:\r\n\r\nWe ran into segmentation faults even with our patched library, which looked like this:\r\n\r\n-|/.../libactivemq-cpp.so.19\r\n -|[18] : decaf::util::concurrent::Lock::lock()+0x1f\r\n -|[19] : decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool)+0x55\r\n -|[20] : activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x104\r\n -|[21] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[22] : activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xac\r\n -|[23] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x305\r\n -|[24] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[25] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6\r\n -|[26] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[27] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x300\r\n -|[28] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xb5\r\n -|[29] : activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9a\r\n -|[30] : activemq::transport::IOTransport::run()+0xd0\r\n -|[31] : +0xb7fc12\r\n -|[32] : +0xb8042a\r\n\r\nÂ \r\n\r\nAfter comparing with the java equivalent of FailoverTransport, we noticed that there was a discrepancy in how the disposed listener works. It seems that the disposed listener is not initialized at all, which leads to the transport listener not putting this fallback in place, leaving dangling pointers to itself in other elements in the chain. We now ensure that there is always a valid disposed listener which will serve as the sink for any leftover calls. This new patch is attached.\r\n\r\nÂ \r\n\r\n26/11/2020 END OF UPDATE\r\n\r\n___________________________________________\r\n\r\nWe'reÂ gettingÂ the following segmentation faults on a productive system with 160 cores on a fairly regular basis:\r\n{quote}-|/export/..../lib/libactivemq-cpp.so.19\r\n\r\n{{-|[7] : activemq::transport::failover::FailoverTransportListener::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x175}}\r\n {{ -|[8] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[9] : activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xe6}}\r\n {{ -|[10] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[11] : activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x292}}\r\n {{ -|[12] : activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0xc2}}\r\n {{ -|[13] : activemq::transport::IOTransport::(fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>)+0x9c}}\r\n {{ -|[14] : activemq::transport::IOTransport::run()+0xb1}}\r\n{quote}\r\nWe've narrowed the problem down to the call to Transport::setTransportListener(NULL) inÂ TransportFilter::close() - it seems to be the same race condition reported with:\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-534]\r\n\r\nand\r\n\r\n[https://jira.apache.org/jira/browse/AMQCPP-583]\r\n\r\nÂ I'm guessing the fix will also be similar - a basic patch suggestion isÂ attached. You may want to put the static DefaultTransportListener in a common place.\r\n\r\nHowever, what is more worrying is that there appear to be several race conditions related toÂ FailoverTransport::getTransportListener(). It provides mutex based access to the current listener, but all subsequent access to the raw pointer is unprotected. We had a concrete case inÂ FailoverTransportListener::onCommand(). There are two calls toÂ parent->getTransportListener() - one for the null ptr check, the second to invoke the command. In our seg fault, we observed that the first call returned a valid ptr, but the second call didn't (or returned null). Our explanation is that since getting and setting the TransportListener is protected by a mutex, another thread was able to get a hold of the mutex between the two calls and set it to FailoverTransport::setTransportListener(NULL).\r\n\r\nPerhaps aÂ much better way of handling this situation would be to use shared_ptr instead of aÂ raw pointer for:\r\n\r\n{{FailoverTransportImpl::TransportListener* transportListener;}}\r\n\r\n{{std::shared_ptr<TransportListener> FailoverTransport::getTransportListener()}}\r\n\r\n{{FailoverTransport::setTransportListener(std::shared_ptr<TransportListener> listener)}}\r\n\r\nThis way, a thread could set a new listener, and any threads still referencing the old listener would gracefully fail. We looked into providing a patch for that, but realized that would be a much bigger change involving ActiveMQConnection deriving from std::enable_shared_from_this, which would also meanÂ replacingÂ decaf::lang::Pointer by std::shared_ptr...Â Without knowing why decaf::lang::Pointer exists in the first place, it would be difficult to proceed without additional clarifications.\n\nComments:\n", "classification": "Classify the issue 'Segmentation fault in TransportFilter & FailoverTransportListener' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-646?\nA: 26/11/2020 UPDATE:\r\n\r\nWe ran into segmentation faults even with our patched library, which looked like this:\r\n\r\n-|/.../libactivemq-cpp.so.19\r\n -|[18] : decaf::util::concurrent::Lock::lock()+0x1f\r\n -|[19] : decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool)+0x55\r\n -|[20] : activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command"}}
{"issue_key": "AMQCPP-645", "project": "AMQCPP", "title": "Website seems to be broken, can not access the API docs", "status": "Closed", "reporter": "S A", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2019-04-25T15:48:30.000+0000", "updated": "2019-04-25T18:10:34.000+0000", "description": "Don't know where else to put this but the website:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\npresents a link to \"Read the Docs\".Â  When clicked you come to:\r\n\r\n[http://activemq.apache.org/components/cms/documentation]\r\n\r\nWhich presents a link to view the API under \"API Reference\", yet when you click on that link, it redirects you right back to the home page:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\nSO, it appears you can't get to the API.", "comments": [], "text": "Website seems to be broken, can not access the API docs\n\nDescription:\nDon't know where else to put this but the website:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\npresents a link to \"Read the Docs\".Â  When clicked you come to:\r\n\r\n[http://activemq.apache.org/components/cms/documentation]\r\n\r\nWhich presents a link to view the API under \"API Reference\", yet when you click on that link, it redirects you right back to the home page:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\nSO, it appears you can't get to the API.\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Website seems to be broken, can not access the API docs\n\nDescription:\nDon't know where else to put this but the website:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\npresents a link to \"Read the Docs\".Â  When clicked you come to:\r\n\r\n[http://activemq.apache.org/components/cms/documentation]\r\n\r\nWhich presents a link to view the API under \"API Reference\", yet when you click on that link, it redirects you right back to the home page:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\nSO, it appears you can't get to the API.\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Website seems to be broken, can not access the API docs' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-645?\nA: Don't know where else to put this but the website:\r\n\r\n[https://activemq.apache.org/components/cms/]\r\n\r\npresents a link to \"Read the Docs\".Â  When clicked you come to:\r\n\r\n[http://activemq.apache.org/components/cms/documentation]\r\n\r\nWhich presents a link to view the API under \"API Reference\", yet when you click on that link, it redirects you right back to the home page:\r\n\r\n[https://activemq.apache.or"}}
{"issue_key": "AMQCPP-644", "project": "AMQCPP", "title": "potential issue using compression", "status": "Open", "reporter": "Christoph Fetzer", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2019-01-30T12:17:01.000+0000", "updated": "2019-06-13T10:41:56.000+0000", "description": "I am not shure, what I observed, maybe it is not critical at all.\r\n\r\nLet me describe:\r\n\r\nwe are using the active mq C++ library to transfer measurement files (in xml format) compressed to an Active-MQ-server. We build the library ourselves with our own build system using MS Visual Studio compiler.\r\n\r\nWhat we use in release-build is:\r\n{code:java}\r\n/DDEBUG=0\r\n{code}\r\nDeep inside this library code there is a zlib that makes use of the DEBUG macro in that way:\r\n{code:java}\r\n#ifdef DEBUG\r\n\r\n\r\n...\r\n\r\n\r\n#else\r\n\r\n\r\n.....\r\n\r\n\r\n#endif\r\n{code}\r\nAs you see we accidentally delivered debug-code in release binaries.\r\n\r\nA customer told us about some files not being tansferred successfully to the queue. While we investigated the issue we found out, our process seems to be dissapearing whithout any exception, signal, whatever. We only see a message\r\n{code:java}\r\nniitt\"\">>invalid match\r\n{code}\r\nat the console. (which is part of our xml file: unit\">)\r\n\r\nInside zlib we found some check_match function that is active in case of DEBUG beingÂ  defined that emitts exactly that message and does\r\n{code:java}\r\nexit(1);\r\n{code}\r\nas next step (decaf/internal/util/zip/deflate.c, line 1284)\r\n\r\nWhen we changed to code to correctly handle our DEBUG macro, the file is transferred successfully.\r\n\r\nWhat is this? Ciritcal error inside the zlib? Incorrect use of the library?\r\n\r\nÂ \r\n\r\nAnother maybe interesting fact:\r\n\r\nwhen we insert a space in the first line (all characters moved by one), we don't have the issue.\r\n\r\nÂ \r\n\r\nAdditional information:\r\n\r\nour files are coded in UTF8 but maybe don't use the proper BOM and we transfer a lot of UTF-8 coded characters when we transfer the measurement unit m/sÂ². But as far as I understand, Active MQ handles the files as transparent binary messages.\r\n\r\nÂ \r\n\r\nPlease ask, if you need additional information. I am trying to find out if I am allowed to add an example file....", "comments": [], "text": "potential issue using compression\n\nDescription:\nI am not shure, what I observed, maybe it is not critical at all.\r\n\r\nLet me describe:\r\n\r\nwe are using the active mq C++ library to transfer measurement files (in xml format) compressed to an Active-MQ-server. We build the library ourselves with our own build system using MS Visual Studio compiler.\r\n\r\nWhat we use in release-build is:\r\n{code:java}\r\n/DDEBUG=0\r\n{code}\r\nDeep inside this library code there is a zlib that makes use of the DEBUG macro in that way:\r\n{code:java}\r\n#ifdef DEBUG\r\n\r\n\r\n...\r\n\r\n\r\n#else\r\n\r\n\r\n.....\r\n\r\n\r\n#endif\r\n{code}\r\nAs you see we accidentally delivered debug-code in release binaries.\r\n\r\nA customer told us about some files not being tansferred successfully to the queue. While we investigated the issue we found out, our process seems to be dissapearing whithout any exception, signal, whatever. We only see a message\r\n{code:java}\r\nniitt\"\">>invalid match\r\n{code}\r\nat the console. (which is part of our xml file: unit\">)\r\n\r\nInside zlib we found some check_match function that is active in case of DEBUG beingÂ  defined that emitts exactly that message and does\r\n{code:java}\r\nexit(1);\r\n{code}\r\nas next step (decaf/internal/util/zip/deflate.c, line 1284)\r\n\r\nWhen we changed to code to correctly handle our DEBUG macro, the file is transferred successfully.\r\n\r\nWhat is this? Ciritcal error inside the zlib? Incorrect use of the library?\r\n\r\nÂ \r\n\r\nAnother maybe interesting fact:\r\n\r\nwhen we insert a space in the first line (all characters moved by one), we don't have the issue.\r\n\r\nÂ \r\n\r\nAdditional information:\r\n\r\nour files are coded in UTF8 but maybe don't use the proper BOM and we transfer a lot of UTF-8 coded characters when we transfer the measurement unit m/sÂ². But as far as I understand, Active MQ handles the files as transparent binary messages.\r\n\r\nÂ \r\n\r\nPlease ask, if you need additional information. I am trying to find out if I am allowed to add an example file....\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: potential issue using compression\n\nDescription:\nI am not shure, what I observed, maybe it is not critical at all.\r\n\r\nLet me describe:\r\n\r\nwe are using the active mq C++ library to transfer measurement files (in xml format) compressed to an Active-MQ-server. We build the library ourselves with our own build system using MS Visual Studio compiler.\r\n\r\nWhat we use in release-build is:\r\n{code:java}\r\n/DDEBUG=0\r\n{code}\r\nDeep inside this library code there is a zlib that makes use of the DEBUG macro in that way:\r\n{code:java}\r\n#ifdef DEBUG\r\n\r\n\r\n...\r\n\r\n\r\n#else\r\n\r\n\r\n.....\r\n\r\n\r\n#endif\r\n{code}\r\nAs you see we accidentally delivered debug-code in release binaries.\r\n\r\nA customer told us about some files not being tansferred successfully to the queue. While we investigated the issue we found out, our process seems to be dissapearing whithout any exception, signal, whatever. We only see a message\r\n{code:java}\r\nniitt\"\">>invalid match\r\n{code}\r\nat the console. (which is part of our xml file: unit\">)\r\n\r\nInside zlib we found some check_match function that is active in case of DEBUG beingÂ  defined that emitts exactly that message and does\r\n{code:java}\r\nexit(1);\r\n{code}\r\nas next step (decaf/internal/util/zip/deflate.c, line 1284)\r\n\r\nWhen we changed to code to correctly handle our DEBUG macro, the file is transferred successfully.\r\n\r\nWhat is this? Ciritcal error inside the zlib? Incorrect use of the library?\r\n\r\nÂ \r\n\r\nAnother maybe interesting fact:\r\n\r\nwhen we insert a space in the first line (all characters moved by one), we don't have the issue.\r\n\r\nÂ \r\n\r\nAdditional information:\r\n\r\nour files are coded in UTF8 but maybe don't use the proper BOM and we transfer a lot of UTF-8 coded characters when we transfer the measurement unit m/sÂ². But as far as I understand, Active MQ handles the files as transparent binary messages.\r\n\r\nÂ \r\n\r\nPlease ask, if you need additional information. I am trying to find out if I am allowed to add an example file....\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'potential issue using compression' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-644?\nA: I am not shure, what I observed, maybe it is not critical at all.\r\n\r\nLet me describe:\r\n\r\nwe are using the active mq C++ library to transfer measurement files (in xml format) compressed to an Active-MQ-server. We build the library ourselves with our own build system using MS Visual Studio compiler.\r\n\r\nWhat we use in release-build is:\r\n{code:java}\r\n/DDEBUG=0\r\n{code}\r\nDeep inside this library code th"}}
{"issue_key": "AMQCPP-643", "project": "AMQCPP", "title": "Add an option to time out connection attempts when blocked in ensureConnectionInfoSent", "status": "Resolved", "reporter": "Roddie Kieley", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-12-11T16:47:46.000+0000", "updated": "2019-01-24T20:10:32.000+0000", "description": "In some rare cases client side stack traces show that the client can be stuck in ensureConnectionInfoSent waiting forever for a response from the broker.\r\n\r\nWe will add an optional timeout to allow this operation to fail which defaults to off via a default timeout of 0.", "comments": [], "text": "Add an option to time out connection attempts when blocked in ensureConnectionInfoSent\n\nDescription:\nIn some rare cases client side stack traces show that the client can be stuck in ensureConnectionInfoSent waiting forever for a response from the broker.\r\n\r\nWe will add an optional timeout to allow this operation to fail which defaults to off via a default timeout of 0.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add an option to time out connection attempts when blocked in ensureConnectionInfoSent\n\nDescription:\nIn some rare cases client side stack traces show that the client can be stuck in ensureConnectionInfoSent waiting forever for a response from the broker.\r\n\r\nWe will add an optional timeout to allow this operation to fail which defaults to off via a default timeout of 0.\n\nComments:\n", "classification": "Classify the issue 'Add an option to time out connection attempts when blocked in ensureConnectionInfoSent' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-643?\nA: In some rare cases client side stack traces show that the client can be stuck in ensureConnectionInfoSent waiting forever for a response from the broker.\r\n\r\nWe will add an optional timeout to allow this operation to fail which defaults to off via a default timeout of 0."}}
{"issue_key": "AMQCPP-642", "project": "AMQCPP", "title": "Create 3.10.x branch based upon 3.9.x code.", "status": "Resolved", "reporter": "Jamie Mark Goodyear", "assignee": "Jamie Mark Goodyear", "priority": "Major", "labels": [], "created": "2018-12-07T18:09:57.000+0000", "updated": "2018-12-07T18:21:25.000+0000", "description": "Create 3.10.x branch based upon 3.9.x code base.", "comments": [], "text": "Create 3.10.x branch based upon 3.9.x code.\n\nDescription:\nCreate 3.10.x branch based upon 3.9.x code base.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create 3.10.x branch based upon 3.9.x code.\n\nDescription:\nCreate 3.10.x branch based upon 3.9.x code base.\n\nComments:\n", "classification": "Classify the issue 'Create 3.10.x branch based upon 3.9.x code.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-642?\nA: Create 3.10.x branch based upon 3.9.x code base."}}
{"issue_key": "AMQCPP-641", "project": "AMQCPP", "title": "Getting core dump on activemq-cpp-library-3.7.0", "status": "Closed", "reporter": "Gaurav", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-11-15T09:38:43.000+0000", "updated": "2018-11-15T17:47:10.000+0000", "description": "Hello,\r\n\r\nWe are getting below core-dump sometime on our system running activemq-cpp-library-3.7.0.\r\n\r\nAny idea what can be done to resolve it?\r\n\r\nÂ \r\n\r\nThank you in advance.\r\n\r\nÂ \r\n\r\ncoredump backtrack:\r\n\r\n=============================================================\r\n\r\nÂ \r\n\r\n#0Â  0x00337ebd in __dynamic_cast () from /usr/lib/libstdc++.so.6\r\nNo symbol table info available.\r\n#1Â  0x016b0c8a in activemq::core::ActiveMQConnection::syncRequest (this=0xf4a10100, command=..., timeout=1) at activemq/core/ActiveMQConnection.cpp:1276\r\nÂ Â Â Â Â Â Â  response = \\{<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x1d449a8, counter = 0xf3e27678}, value = 0xf6c20128, onDelete = 0x16c0430 <decaf::lang::Pointer<activemq::commands::Response, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::Response*)>}\r\n#2Â  0x016bd6c8 in activemq::core::ActiveMQConnection::disconnect (this=0xf4a10100, lastDeliveredSequenceId=0) at activemq/core/ActiveMQConnection.cpp:925\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  e = \\{<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e276e8}, <No data fields>}\r\n#3Â  0x016be848 in activemq::core::ActiveMQConnection::close (this=0xf4a10100) at activemq/core/ActiveMQConnection.cpp:783\r\nÂ Â Â Â Â Â Â  ex = \\{<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e273a0}\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  lastDeliveredSequenceId = 0", "comments": [], "text": "Getting core dump on activemq-cpp-library-3.7.0\n\nDescription:\nHello,\r\n\r\nWe are getting below core-dump sometime on our system running activemq-cpp-library-3.7.0.\r\n\r\nAny idea what can be done to resolve it?\r\n\r\nÂ \r\n\r\nThank you in advance.\r\n\r\nÂ \r\n\r\ncoredump backtrack:\r\n\r\n=============================================================\r\n\r\nÂ \r\n\r\n#0Â  0x00337ebd in __dynamic_cast () from /usr/lib/libstdc++.so.6\r\nNo symbol table info available.\r\n#1Â  0x016b0c8a in activemq::core::ActiveMQConnection::syncRequest (this=0xf4a10100, command=..., timeout=1) at activemq/core/ActiveMQConnection.cpp:1276\r\nÂ Â Â Â Â Â Â  response = \\{<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x1d449a8, counter = 0xf3e27678}, value = 0xf6c20128, onDelete = 0x16c0430 <decaf::lang::Pointer<activemq::commands::Response, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::Response*)>}\r\n#2Â  0x016bd6c8 in activemq::core::ActiveMQConnection::disconnect (this=0xf4a10100, lastDeliveredSequenceId=0) at activemq/core/ActiveMQConnection.cpp:925\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  e = \\{<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e276e8}, <No data fields>}\r\n#3Â  0x016be848 in activemq::core::ActiveMQConnection::close (this=0xf4a10100) at activemq/core/ActiveMQConnection.cpp:783\r\nÂ Â Â Â Â Â Â  ex = \\{<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e273a0}\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  lastDeliveredSequenceId = 0\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Getting core dump on activemq-cpp-library-3.7.0\n\nDescription:\nHello,\r\n\r\nWe are getting below core-dump sometime on our system running activemq-cpp-library-3.7.0.\r\n\r\nAny idea what can be done to resolve it?\r\n\r\nÂ \r\n\r\nThank you in advance.\r\n\r\nÂ \r\n\r\ncoredump backtrack:\r\n\r\n=============================================================\r\n\r\nÂ \r\n\r\n#0Â  0x00337ebd in __dynamic_cast () from /usr/lib/libstdc++.so.6\r\nNo symbol table info available.\r\n#1Â  0x016b0c8a in activemq::core::ActiveMQConnection::syncRequest (this=0xf4a10100, command=..., timeout=1) at activemq/core/ActiveMQConnection.cpp:1276\r\nÂ Â Â Â Â Â Â  response = \\{<decaf::util::concurrent::atomic::AtomicRefCounter> = {_vptr.AtomicRefCounter = 0x1d449a8, counter = 0xf3e27678}, value = 0xf6c20128, onDelete = 0x16c0430 <decaf::lang::Pointer<activemq::commands::Response, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::commands::Response*)>}\r\n#2Â  0x016bd6c8 in activemq::core::ActiveMQConnection::disconnect (this=0xf4a10100, lastDeliveredSequenceId=0) at activemq/core/ActiveMQConnection.cpp:925\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  e = \\{<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e276e8}, <No data fields>}\r\n#3Â  0x016be848 in activemq::core::ActiveMQConnection::close (this=0xf4a10100) at activemq/core/ActiveMQConnection.cpp:783\r\nÂ Â Â Â Â Â Â  ex = \\{<decaf::lang::Throwable> = {<std::exception> = {<No data fields>}, <No data fields>}, data = 0xf3e273a0}\r\nÂ Â Â Â Â Â Â  hasException = false\r\nÂ Â Â Â Â Â Â  lastDeliveredSequenceId = 0\n\nComments:\n", "classification": "Classify the issue 'Getting core dump on activemq-cpp-library-3.7.0' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-641?\nA: Hello,\r\n\r\nWe are getting below core-dump sometime on our system running activemq-cpp-library-3.7.0.\r\n\r\nAny idea what can be done to resolve it?\r\n\r\nÂ \r\n\r\nThank you in advance.\r\n\r\nÂ \r\n\r\ncoredump backtrack:\r\n\r\n=============================================================\r\n\r\nÂ \r\n\r\n#0Â  0x00337ebd in __dynamic_cast () from /usr/lib/libstdc++.so.6\r\nNo symbol table info available.\r\n#1Â  0x016b0c8a in activemq"}}
{"issue_key": "AMQCPP-640", "project": "AMQCPP", "title": "Connect operation can hang indefinitely", "status": "Open", "reporter": "Francois Godin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-10-17T17:45:49.000+0000", "updated": "2018-10-17T17:45:49.000+0000", "description": "SSL_connect can hang indefinitely if for any reason (network lost, server crash, ...) the server does not send a response.\r\n\r\nÂ \r\n\r\nThis can be reproduced with a VM (so that client and server are not on the same machine) and breakpoint in the server. Settings the breakpoint just before the server can negotiate with the client allow us to kill the network to the VM at that time. Thus, when resuming the server, the SSL exchange cannot continue. This cause ActiveMQ C++ to hang.\r\n\r\nÂ \r\n\r\n[https://stackoverflow.com/questions/11835203/openssl-ssl-connect-blocks-forever-how-to-set-timeout]", "comments": [], "text": "Connect operation can hang indefinitely\n\nDescription:\nSSL_connect can hang indefinitely if for any reason (network lost, server crash, ...) the server does not send a response.\r\n\r\nÂ \r\n\r\nThis can be reproduced with a VM (so that client and server are not on the same machine) and breakpoint in the server. Settings the breakpoint just before the server can negotiate with the client allow us to kill the network to the VM at that time. Thus, when resuming the server, the SSL exchange cannot continue. This cause ActiveMQ C++ to hang.\r\n\r\nÂ \r\n\r\n[https://stackoverflow.com/questions/11835203/openssl-ssl-connect-blocks-forever-how-to-set-timeout]\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Connect operation can hang indefinitely\n\nDescription:\nSSL_connect can hang indefinitely if for any reason (network lost, server crash, ...) the server does not send a response.\r\n\r\nÂ \r\n\r\nThis can be reproduced with a VM (so that client and server are not on the same machine) and breakpoint in the server. Settings the breakpoint just before the server can negotiate with the client allow us to kill the network to the VM at that time. Thus, when resuming the server, the SSL exchange cannot continue. This cause ActiveMQ C++ to hang.\r\n\r\nÂ \r\n\r\n[https://stackoverflow.com/questions/11835203/openssl-ssl-connect-blocks-forever-how-to-set-timeout]\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Connect operation can hang indefinitely' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-640?\nA: SSL_connect can hang indefinitely if for any reason (network lost, server crash, ...) the server does not send a response.\r\n\r\nÂ \r\n\r\nThis can be reproduced with a VM (so that client and server are not on the same machine) and breakpoint in the server. Settings the breakpoint just before the server can negotiate with the client allow us to kill the network to the VM at that time. Thus, when resuming "}}
{"issue_key": "AMQCPP-639", "project": "AMQCPP", "title": "license incompatibility", "status": "Open", "reporter": "oana kacso", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-10-17T14:15:03.000+0000", "updated": "2018-10-17T14:15:03.000+0000", "description": "My issue is regarding two files in the +*activemq-cpp-library-3.9.4-src.zip*+ package:\r\n * doxygen-include.am\r\n\r\nand\r\n * Makefile.in\r\n\r\nÂ \r\n\r\nIn these two files I found the reference:\r\n\r\nÂ \r\n\r\n_# Copyright (C) 2004 Oren Ben-Kiki_\r\n\r\n_# This file is distributed under the same terms as the Automake macro files._\r\n\r\nÂ __Â \r\n\r\n_# Generate automatic documentation using Doxygen. Goals and variables values_\r\n\r\n_# are controlled by the various DX_COND_??? conditionals set by autoconf._\r\n\r\nÂ \r\n\r\nAutomake is GPL v2 licensed.\r\n\r\nÂ \r\n\r\nMy question to you is:Â *are these two files licensed under Apache License 2.0,* based on some agreement between you and the copyright holder*?*\r\n\r\nÂ \r\n\r\nThank you in advance.", "comments": [], "text": "license incompatibility\n\nDescription:\nMy issue is regarding two files in the +*activemq-cpp-library-3.9.4-src.zip*+ package:\r\n * doxygen-include.am\r\n\r\nand\r\n * Makefile.in\r\n\r\nÂ \r\n\r\nIn these two files I found the reference:\r\n\r\nÂ \r\n\r\n_# Copyright (C) 2004 Oren Ben-Kiki_\r\n\r\n_# This file is distributed under the same terms as the Automake macro files._\r\n\r\nÂ __Â \r\n\r\n_# Generate automatic documentation using Doxygen. Goals and variables values_\r\n\r\n_# are controlled by the various DX_COND_??? conditionals set by autoconf._\r\n\r\nÂ \r\n\r\nAutomake is GPL v2 licensed.\r\n\r\nÂ \r\n\r\nMy question to you is:Â *are these two files licensed under Apache License 2.0,* based on some agreement between you and the copyright holder*?*\r\n\r\nÂ \r\n\r\nThank you in advance.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: license incompatibility\n\nDescription:\nMy issue is regarding two files in the +*activemq-cpp-library-3.9.4-src.zip*+ package:\r\n * doxygen-include.am\r\n\r\nand\r\n * Makefile.in\r\n\r\nÂ \r\n\r\nIn these two files I found the reference:\r\n\r\nÂ \r\n\r\n_# Copyright (C) 2004 Oren Ben-Kiki_\r\n\r\n_# This file is distributed under the same terms as the Automake macro files._\r\n\r\nÂ __Â \r\n\r\n_# Generate automatic documentation using Doxygen. Goals and variables values_\r\n\r\n_# are controlled by the various DX_COND_??? conditionals set by autoconf._\r\n\r\nÂ \r\n\r\nAutomake is GPL v2 licensed.\r\n\r\nÂ \r\n\r\nMy question to you is:Â *are these two files licensed under Apache License 2.0,* based on some agreement between you and the copyright holder*?*\r\n\r\nÂ \r\n\r\nThank you in advance.\n\nComments:\n", "classification": "Classify the issue 'license incompatibility' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-639?\nA: My issue is regarding two files in the +*activemq-cpp-library-3.9.4-src.zip*+ package:\r\n * doxygen-include.am\r\n\r\nand\r\n * Makefile.in\r\n\r\nÂ \r\n\r\nIn these two files I found the reference:\r\n\r\nÂ \r\n\r\n_# Copyright (C) 2004 Oren Ben-Kiki_\r\n\r\n_# This file is distributed under the same terms as the Automake macro files._\r\n\r\nÂ __Â \r\n\r\n_# Generate automatic documentation using Doxygen. Goals and variables values_\r"}}
{"issue_key": "AMQCPP-638", "project": "AMQCPP", "title": "Add Support for OpenSSL 1.1.1", "status": "Open", "reporter": "Jeff Gullett", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-10-01T23:02:35.000+0000", "updated": "2019-01-24T20:58:50.000+0000", "description": "Currently, compiling the OpenSSL-enabled versions of ActiveMQ-CPP with any version of OpenSSL newer than 1.0.2 results in compile-time errors.  OpenSSL is dropping support for 1.0.2 on 2019-12-31.  The next long-term support version of OpenSSL, 1.1.1, has been released.  Please update ActiveMQ-CPP so it can be built using OpenSSL 1.1.1.", "comments": [], "text": "Add Support for OpenSSL 1.1.1\n\nDescription:\nCurrently, compiling the OpenSSL-enabled versions of ActiveMQ-CPP with any version of OpenSSL newer than 1.0.2 results in compile-time errors.  OpenSSL is dropping support for 1.0.2 on 2019-12-31.  The next long-term support version of OpenSSL, 1.1.1, has been released.  Please update ActiveMQ-CPP so it can be built using OpenSSL 1.1.1.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add Support for OpenSSL 1.1.1\n\nDescription:\nCurrently, compiling the OpenSSL-enabled versions of ActiveMQ-CPP with any version of OpenSSL newer than 1.0.2 results in compile-time errors.  OpenSSL is dropping support for 1.0.2 on 2019-12-31.  The next long-term support version of OpenSSL, 1.1.1, has been released.  Please update ActiveMQ-CPP so it can be built using OpenSSL 1.1.1.\n\nComments:\n", "classification": "Classify the issue 'Add Support for OpenSSL 1.1.1' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-638?\nA: Currently, compiling the OpenSSL-enabled versions of ActiveMQ-CPP with any version of OpenSSL newer than 1.0.2 results in compile-time errors.  OpenSSL is dropping support for 1.0.2 on 2019-12-31.  The next long-term support version of OpenSSL, 1.1.1, has been released.  Please update ActiveMQ-CPP so it can be built using OpenSSL 1.1.1."}}
{"issue_key": "AMQCPP-637", "project": "AMQCPP", "title": "fix documentation for cms::Message::clearProperties", "status": "Open", "reporter": "Eladio Caritos", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["documentation"], "created": "2018-09-27T19:45:19.000+0000", "updated": "2018-09-27T19:45:19.000+0000", "description": "Incorrect documentation regarding the cms::Message::clearProperties().", "comments": [], "text": "fix documentation for cms::Message::clearProperties\n\nDescription:\nIncorrect documentation regarding the cms::Message::clearProperties().\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: fix documentation for cms::Message::clearProperties\n\nDescription:\nIncorrect documentation regarding the cms::Message::clearProperties().\n\nComments:\n", "classification": "Classify the issue 'fix documentation for cms::Message::clearProperties' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-637?\nA: Incorrect documentation regarding the cms::Message::clearProperties()."}}
{"issue_key": "AMQCPP-635", "project": "AMQCPP", "title": "HA Shared store docs are using wrong tag name 'failover-on-server-shutdown' instead of 'failover-on-shutdown'", "status": "Closed", "reporter": "Michal Toth", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-09-07T12:16:28.000+0000", "updated": "2018-09-07T12:18:37.000+0000", "description": "http://activemq.apache.org/artemis/docs/latest/ha.html describes wrong tag name failover-on-server-shutdown it should be failover-on-shutdown on both master/slave.\r\n\r\nSee artemis-configuration.xsd schema for details.\r\n\r\nThis is a very wrong project. I will try to move it to ARTEMIS.", "comments": [], "text": "HA Shared store docs are using wrong tag name 'failover-on-server-shutdown' instead of 'failover-on-shutdown'\n\nDescription:\nhttp://activemq.apache.org/artemis/docs/latest/ha.html describes wrong tag name failover-on-server-shutdown it should be failover-on-shutdown on both master/slave.\r\n\r\nSee artemis-configuration.xsd schema for details.\r\n\r\nThis is a very wrong project. I will try to move it to ARTEMIS.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: HA Shared store docs are using wrong tag name 'failover-on-server-shutdown' instead of 'failover-on-shutdown'\n\nDescription:\nhttp://activemq.apache.org/artemis/docs/latest/ha.html describes wrong tag name failover-on-server-shutdown it should be failover-on-shutdown on both master/slave.\r\n\r\nSee artemis-configuration.xsd schema for details.\r\n\r\nThis is a very wrong project. I will try to move it to ARTEMIS.\n\nComments:\n", "classification": "Classify the issue 'HA Shared store docs are using wrong tag name 'failover-on-server-shutdown' instead of 'failover-on-shutdown'' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-635?\nA: http://activemq.apache.org/artemis/docs/latest/ha.html describes wrong tag name failover-on-server-shutdown it should be failover-on-shutdown on both master/slave.\r\n\r\nSee artemis-configuration.xsd schema for details.\r\n\r\nThis is a very wrong project. I will try to move it to ARTEMIS."}}
{"issue_key": "AMQCPP-630", "project": "AMQCPP", "title": "microsoft", "status": "Closed", "reporter": "Heng Puthireach", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-04-30T13:27:20.000+0000", "updated": "2018-04-30T13:34:42.000+0000", "description": "", "comments": [], "text": "microsoft\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: microsoft\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'microsoft' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-630?\nA: "}}
{"issue_key": "AMQCPP-629", "project": "AMQCPP", "title": "Stack Trace is not avalable when connect fails ", "status": "Open", "reporter": "Danielle Gutfinger", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2018-03-22T23:48:28.000+0000", "updated": "2018-03-22T23:48:28.000+0000", "description": "the stack trace is missing when exception thrown becasue broker is not found at given addressÂ \r\n\r\nthe issue is inÂ  cms::CMSException ActiveMQException::convertToCMSException().\r\n\r\nadding the line highlighted in green seems to fix it.Â \r\n\r\nÂ \r\n\r\ncms::CMSException ActiveMQException::convertToCMSException() const {\r\n\r\nstd::exception* result = NULL;\r\n\r\nif (this->getCause() != NULL) {\r\n const Exception* ptrCause = dynamic_cast<const Exception*>(this->getCause());\r\n\r\nif (ptrCause == NULL) {\r\n result = new Exception(__FILE__, __LINE__, getCause()->what());\r\n } else {\r\n result = ptrCause->clone();\r\n {color:#14892c}return cms::CMSException(this->getMessage(), result, ptrCause->getStackTrace());{color}\r\n } \r\n }\r\n\r\nreturn cms::CMSException(this->getMessage(), result, this->getStackTrace());\r\n}", "comments": [], "text": "Stack Trace is not avalable when connect fails \n\nDescription:\nthe stack trace is missing when exception thrown becasue broker is not found at given addressÂ \r\n\r\nthe issue is inÂ  cms::CMSException ActiveMQException::convertToCMSException().\r\n\r\nadding the line highlighted in green seems to fix it.Â \r\n\r\nÂ \r\n\r\ncms::CMSException ActiveMQException::convertToCMSException() const {\r\n\r\nstd::exception* result = NULL;\r\n\r\nif (this->getCause() != NULL) {\r\n const Exception* ptrCause = dynamic_cast<const Exception*>(this->getCause());\r\n\r\nif (ptrCause == NULL) {\r\n result = new Exception(__FILE__, __LINE__, getCause()->what());\r\n } else {\r\n result = ptrCause->clone();\r\n {color:#14892c}return cms::CMSException(this->getMessage(), result, ptrCause->getStackTrace());{color}\r\n } \r\n }\r\n\r\nreturn cms::CMSException(this->getMessage(), result, this->getStackTrace());\r\n}\r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stack Trace is not avalable when connect fails \n\nDescription:\nthe stack trace is missing when exception thrown becasue broker is not found at given addressÂ \r\n\r\nthe issue is inÂ  cms::CMSException ActiveMQException::convertToCMSException().\r\n\r\nadding the line highlighted in green seems to fix it.Â \r\n\r\nÂ \r\n\r\ncms::CMSException ActiveMQException::convertToCMSException() const {\r\n\r\nstd::exception* result = NULL;\r\n\r\nif (this->getCause() != NULL) {\r\n const Exception* ptrCause = dynamic_cast<const Exception*>(this->getCause());\r\n\r\nif (ptrCause == NULL) {\r\n result = new Exception(__FILE__, __LINE__, getCause()->what());\r\n } else {\r\n result = ptrCause->clone();\r\n {color:#14892c}return cms::CMSException(this->getMessage(), result, ptrCause->getStackTrace());{color}\r\n } \r\n }\r\n\r\nreturn cms::CMSException(this->getMessage(), result, this->getStackTrace());\r\n}\r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Stack Trace is not avalable when connect fails ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-629?\nA: the stack trace is missing when exception thrown becasue broker is not found at given addressÂ \r\n\r\nthe issue is inÂ  cms::CMSException ActiveMQException::convertToCMSException().\r\n\r\nadding the line highlighted in green seems to fix it.Â \r\n\r\nÂ \r\n\r\ncms::CMSException ActiveMQException::convertToCMSException() const {\r\n\r\nstd::exception* result = NULL;\r\n\r\nif (this->getCause() != NULL) {\r\n const Exception* "}}
{"issue_key": "AMQCPP-628", "project": "AMQCPP", "title": "std::auto_ptr has been removed in C++17", "status": "Closed", "reporter": "Hermann Walth", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2018-03-19T08:36:43.000+0000", "updated": "2020-05-15T14:56:15.000+0000", "description": "Compiling ActiveMQ-cpp when the compiler flag to enable the C++ 17 standard is set will result in compiler errors because ActiveMQ-cpp uses auto_ptr, which has been removed in C++ 17.\r\n\r\nMore importantly, compiling any project that _uses_ ActiveMQ-cpp with a C++17-compliant compiler will fail because std::auto_ptr is used in the ActiveMQ headers.\r\n\r\nPlease replace all occurrences of std::auto_ptr with std::unique_ptr.", "comments": [], "text": "std::auto_ptr has been removed in C++17\n\nDescription:\nCompiling ActiveMQ-cpp when the compiler flag to enable the C++ 17 standard is set will result in compiler errors because ActiveMQ-cpp uses auto_ptr, which has been removed in C++ 17.\r\n\r\nMore importantly, compiling any project that _uses_ ActiveMQ-cpp with a C++17-compliant compiler will fail because std::auto_ptr is used in the ActiveMQ headers.\r\n\r\nPlease replace all occurrences of std::auto_ptr with std::unique_ptr.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: std::auto_ptr has been removed in C++17\n\nDescription:\nCompiling ActiveMQ-cpp when the compiler flag to enable the C++ 17 standard is set will result in compiler errors because ActiveMQ-cpp uses auto_ptr, which has been removed in C++ 17.\r\n\r\nMore importantly, compiling any project that _uses_ ActiveMQ-cpp with a C++17-compliant compiler will fail because std::auto_ptr is used in the ActiveMQ headers.\r\n\r\nPlease replace all occurrences of std::auto_ptr with std::unique_ptr.\n\nComments:\n", "classification": "Classify the issue 'std::auto_ptr has been removed in C++17' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-628?\nA: Compiling ActiveMQ-cpp when the compiler flag to enable the C++ 17 standard is set will result in compiler errors because ActiveMQ-cpp uses auto_ptr, which has been removed in C++ 17.\r\n\r\nMore importantly, compiling any project that _uses_ ActiveMQ-cpp with a C++17-compliant compiler will fail because std::auto_ptr is used in the ActiveMQ headers.\r\n\r\nPlease replace all occurrences of std::auto_ptr "}}
{"issue_key": "AMQCPP-627", "project": "AMQCPP", "title": "InactivityMonitor deadlock", "status": "Open", "reporter": "mephi42", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-03-14T16:21:53.000+0000", "updated": "2018-03-14T16:22:13.000+0000", "description": "Extremely rarely internal AMQCPP AsyncSignalReadErrorkTask task deadlocks while holding FailoverTransport::reconnectMutex, which makes it impossible to send anything anymore.\r\n\r\nÂ \r\n\r\nUnfortunately I do not have the complete core dump of process which exhibits this behavior, but I have the stacktrace (see attachments).", "comments": [], "text": "InactivityMonitor deadlock\n\nDescription:\nExtremely rarely internal AMQCPP AsyncSignalReadErrorkTask task deadlocks while holding FailoverTransport::reconnectMutex, which makes it impossible to send anything anymore.\r\n\r\nÂ \r\n\r\nUnfortunately I do not have the complete core dump of process which exhibits this behavior, but I have the stacktrace (see attachments).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: InactivityMonitor deadlock\n\nDescription:\nExtremely rarely internal AMQCPP AsyncSignalReadErrorkTask task deadlocks while holding FailoverTransport::reconnectMutex, which makes it impossible to send anything anymore.\r\n\r\nÂ \r\n\r\nUnfortunately I do not have the complete core dump of process which exhibits this behavior, but I have the stacktrace (see attachments).\n\nComments:\n", "classification": "Classify the issue 'InactivityMonitor deadlock' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-627?\nA: Extremely rarely internal AMQCPP AsyncSignalReadErrorkTask task deadlocks while holding FailoverTransport::reconnectMutex, which makes it impossible to send anything anymore.\r\n\r\nÂ \r\n\r\nUnfortunately I do not have the complete core dump of process which exhibits this behavior, but I have the stacktrace (see attachments)."}}
{"issue_key": "AMQCPP-626", "project": "AMQCPP", "title": "ActiveMQ C++ client crashes with `_purecall`", "status": "Open", "reporter": "Andrzej Lichnerowicz", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-03-12T15:17:58.000+0000", "updated": "2021-01-13T15:53:14.000+0000", "description": "Inactivty monitor, during failover, in high CPU load conditions can crash an application.\r\n\r\nÂ \r\n\r\n{{0:031> k}}\r\n{{Â  *** Stack trace for last set context - .thread/.cxr resets it}}\r\n{{Â # ChildEBP RetAddr Â }}\r\n{{00 1323f880 614b4f3b ucrtbase!abort+0x4b}}\r\n{{01 1323f888 5a16e846 VCRUNTIME140!_purecall+0x1b [f:\\dd\\vctools\\crt\\vcruntime\\src\\misc\\purevirt.cpp @ 29] }}\r\n{{WARNING: Stack unwind information not available. Following frames may be wrong.}}\r\n{{02 1323f8c8 5a0383d4 activemq_cpp!decaf::util::concurrent::Lock::~Lock+0x46}}\r\n{{03 1323f8f0 5a067077 activemq_cpp!activemq::threads::CompositeTaskRunner::wakeup+0x74}}\r\n{{04 1323f924 5a068188 activemq_cpp!activemq::transport::inactivity::InactivityMonitor::writeCheck+0x47}}\r\n{{05 1323f938 5a15cd24 activemq_cpp!activemq::transport::inactivity::WriteChecker::run+0x48}}\r\n{{06 1323fa20 5a0f25ac activemq_cpp!decaf::util::StringTokenizer::reset+0xa04}}\r\n{{07 1323fa74 5a0f254b activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x4cc}}\r\n{{08 1323faac 60c78824 activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x46b}}\r\n{{09 1323fae8 76a27c04 ucrtbase!_crt_atexit+0x104}}\r\n{{0a 1323fafc 777fad2f kernel32!BaseThreadInitThunk+0x24}}\r\n{{0b 1323fb44 777facfa ntdll!__RtlUserThreadStart+0x2f}}\r\n{{0c 1323fb54 00000000 ntdll!_RtlUserThreadStart+0x1b}}\r\n\r\nÂ \r\n\r\nIt seems to be introduced by a commit 69739ab64c4cd140a5d92f15a64725d3386f86ce from Nov 2009, so looks like since very introduction of Inactivity Monitor.", "comments": [], "text": "ActiveMQ C++ client crashes with `_purecall`\n\nDescription:\nInactivty monitor, during failover, in high CPU load conditions can crash an application.\r\n\r\nÂ \r\n\r\n{{0:031> k}}\r\n{{Â  *** Stack trace for last set context - .thread/.cxr resets it}}\r\n{{Â # ChildEBP RetAddr Â }}\r\n{{00 1323f880 614b4f3b ucrtbase!abort+0x4b}}\r\n{{01 1323f888 5a16e846 VCRUNTIME140!_purecall+0x1b [f:\\dd\\vctools\\crt\\vcruntime\\src\\misc\\purevirt.cpp @ 29] }}\r\n{{WARNING: Stack unwind information not available. Following frames may be wrong.}}\r\n{{02 1323f8c8 5a0383d4 activemq_cpp!decaf::util::concurrent::Lock::~Lock+0x46}}\r\n{{03 1323f8f0 5a067077 activemq_cpp!activemq::threads::CompositeTaskRunner::wakeup+0x74}}\r\n{{04 1323f924 5a068188 activemq_cpp!activemq::transport::inactivity::InactivityMonitor::writeCheck+0x47}}\r\n{{05 1323f938 5a15cd24 activemq_cpp!activemq::transport::inactivity::WriteChecker::run+0x48}}\r\n{{06 1323fa20 5a0f25ac activemq_cpp!decaf::util::StringTokenizer::reset+0xa04}}\r\n{{07 1323fa74 5a0f254b activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x4cc}}\r\n{{08 1323faac 60c78824 activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x46b}}\r\n{{09 1323fae8 76a27c04 ucrtbase!_crt_atexit+0x104}}\r\n{{0a 1323fafc 777fad2f kernel32!BaseThreadInitThunk+0x24}}\r\n{{0b 1323fb44 777facfa ntdll!__RtlUserThreadStart+0x2f}}\r\n{{0c 1323fb54 00000000 ntdll!_RtlUserThreadStart+0x1b}}\r\n\r\nÂ \r\n\r\nIt seems to be introduced by a commit 69739ab64c4cd140a5d92f15a64725d3386f86ce from Nov 2009, so looks like since very introduction of Inactivity Monitor.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ C++ client crashes with `_purecall`\n\nDescription:\nInactivty monitor, during failover, in high CPU load conditions can crash an application.\r\n\r\nÂ \r\n\r\n{{0:031> k}}\r\n{{Â  *** Stack trace for last set context - .thread/.cxr resets it}}\r\n{{Â # ChildEBP RetAddr Â }}\r\n{{00 1323f880 614b4f3b ucrtbase!abort+0x4b}}\r\n{{01 1323f888 5a16e846 VCRUNTIME140!_purecall+0x1b [f:\\dd\\vctools\\crt\\vcruntime\\src\\misc\\purevirt.cpp @ 29] }}\r\n{{WARNING: Stack unwind information not available. Following frames may be wrong.}}\r\n{{02 1323f8c8 5a0383d4 activemq_cpp!decaf::util::concurrent::Lock::~Lock+0x46}}\r\n{{03 1323f8f0 5a067077 activemq_cpp!activemq::threads::CompositeTaskRunner::wakeup+0x74}}\r\n{{04 1323f924 5a068188 activemq_cpp!activemq::transport::inactivity::InactivityMonitor::writeCheck+0x47}}\r\n{{05 1323f938 5a15cd24 activemq_cpp!activemq::transport::inactivity::WriteChecker::run+0x48}}\r\n{{06 1323fa20 5a0f25ac activemq_cpp!decaf::util::StringTokenizer::reset+0xa04}}\r\n{{07 1323fa74 5a0f254b activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x4cc}}\r\n{{08 1323faac 60c78824 activemq_cpp!decaf::internal::util::concurrent::SynchronizableImpl::~SynchronizableImpl+0x46b}}\r\n{{09 1323fae8 76a27c04 ucrtbase!_crt_atexit+0x104}}\r\n{{0a 1323fafc 777fad2f kernel32!BaseThreadInitThunk+0x24}}\r\n{{0b 1323fb44 777facfa ntdll!__RtlUserThreadStart+0x2f}}\r\n{{0c 1323fb54 00000000 ntdll!_RtlUserThreadStart+0x1b}}\r\n\r\nÂ \r\n\r\nIt seems to be introduced by a commit 69739ab64c4cd140a5d92f15a64725d3386f86ce from Nov 2009, so looks like since very introduction of Inactivity Monitor.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ C++ client crashes with `_purecall`' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-626?\nA: Inactivty monitor, during failover, in high CPU load conditions can crash an application.\r\n\r\nÂ \r\n\r\n{{0:031> k}}\r\n{{Â  *** Stack trace for last set context - .thread/.cxr resets it}}\r\n{{Â # ChildEBP RetAddr Â }}\r\n{{00 1323f880 614b4f3b ucrtbase!abort+0x4b}}\r\n{{01 1323f888 5a16e846 VCRUNTIME140!_purecall+0x1b [f:\\dd\\vctools\\crt\\vcruntime\\src\\misc\\purevirt.cpp @ 29] }}\r\n{{WARNING: Stack unwind informatio"}}
{"issue_key": "AMQCPP-625", "project": "AMQCPP", "title": "Inactivity mointor  core dump", "status": "Open", "reporter": "Satadip Dutta", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2018-02-27T10:02:38.000+0000", "updated": "2021-01-13T15:52:58.000+0000", "description": "Broker Configuration:\r\n\r\n----------------------------\r\n\r\n<transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600&transport.useInactivityMonitor=false\"/>\r\n\r\nClient configuration:Â \r\n\r\n---------------------------\r\n\r\nfailover://(tcp://192.168.114.105:61616,tcp://192.168.114.105:61616)?randomize=false&wireFormat=openwire&transport.useInactivityMonitor=false\r\n\r\nÂ \r\n\r\nApplication cores/crashes/segfaults and generates core file, even when in idle state.Â  Below is the backtrace - Not sure if this is related to inactivity monitor\r\n\r\n(gdb) bt\r\n #0 0x00007f2dd9bff989 in raise () from /lib64/libc.so.6\r\n #1 0x00007f2dd9c01098 in abort () from /lib64/libc.so.6\r\n #2 0x00007f2dda5039d5 in __gnu_cxx::__verbose_terminate_handler() () from /lib64/libstdc++.so.6\r\n #3 0x00007f2dda501946 in ?? () from /lib64/libstdc++.so.6\r\n #4 0x00007f2dda501973 in std::terminate() () from /lib64/libstdc++.so.6\r\n #5 0x00007f2dda5024df in __cxa_pure_virtual () from /lib64/libstdc++.so.6\r\n #6 0x00007f2ddc404baa in decaf::util::concurrent::Lock::~Lock (this=0x7f2d637fdbf0, __in_chrg=<optimized out>) at decaf/util/concurrent/Lock.cpp:46\r\n #7 0x00007f2ddc221e80 in activemq::threads::CompositeTaskRunner::wakeup (this=<optimized out>) at activemq/threads/CompositeTaskRunner.cpp:154\r\n #8 0x00007f2ddc282c95 in activemq::transport::inactivity::InactivityMonitor::readCheck (this=0x7f2d70003a50)\r\n at activemq/transport/inactivity/InactivityMonitor.cpp:400\r\n #9 0x00007f2ddc3ffe5d in decaf::util::TimerImpl::run (this=0x7f2d70002160) at decaf/util/Timer.cpp:156\r\n #10 0x00007f2ddc37b622 in (anonymous namespace)::runCallback (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:268\r\n #11 0x00007f2ddc37beec in (anonymous namespace)::threadEntryMethod (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:256\r\n #12 0x00007f2dda9b4df3 in start_thread () from /lib64/libpthread.so.0\r\n #13 0x00007f2dd9cc03dd in clone () from /lib64/libc.so.6", "comments": [], "text": "Inactivity mointor  core dump\n\nDescription:\nBroker Configuration:\r\n\r\n----------------------------\r\n\r\n<transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600&transport.useInactivityMonitor=false\"/>\r\n\r\nClient configuration:Â \r\n\r\n---------------------------\r\n\r\nfailover://(tcp://192.168.114.105:61616,tcp://192.168.114.105:61616)?randomize=false&wireFormat=openwire&transport.useInactivityMonitor=false\r\n\r\nÂ \r\n\r\nApplication cores/crashes/segfaults and generates core file, even when in idle state.Â  Below is the backtrace - Not sure if this is related to inactivity monitor\r\n\r\n(gdb) bt\r\n #0 0x00007f2dd9bff989 in raise () from /lib64/libc.so.6\r\n #1 0x00007f2dd9c01098 in abort () from /lib64/libc.so.6\r\n #2 0x00007f2dda5039d5 in __gnu_cxx::__verbose_terminate_handler() () from /lib64/libstdc++.so.6\r\n #3 0x00007f2dda501946 in ?? () from /lib64/libstdc++.so.6\r\n #4 0x00007f2dda501973 in std::terminate() () from /lib64/libstdc++.so.6\r\n #5 0x00007f2dda5024df in __cxa_pure_virtual () from /lib64/libstdc++.so.6\r\n #6 0x00007f2ddc404baa in decaf::util::concurrent::Lock::~Lock (this=0x7f2d637fdbf0, __in_chrg=<optimized out>) at decaf/util/concurrent/Lock.cpp:46\r\n #7 0x00007f2ddc221e80 in activemq::threads::CompositeTaskRunner::wakeup (this=<optimized out>) at activemq/threads/CompositeTaskRunner.cpp:154\r\n #8 0x00007f2ddc282c95 in activemq::transport::inactivity::InactivityMonitor::readCheck (this=0x7f2d70003a50)\r\n at activemq/transport/inactivity/InactivityMonitor.cpp:400\r\n #9 0x00007f2ddc3ffe5d in decaf::util::TimerImpl::run (this=0x7f2d70002160) at decaf/util/Timer.cpp:156\r\n #10 0x00007f2ddc37b622 in (anonymous namespace)::runCallback (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:268\r\n #11 0x00007f2ddc37beec in (anonymous namespace)::threadEntryMethod (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:256\r\n #12 0x00007f2dda9b4df3 in start_thread () from /lib64/libpthread.so.0\r\n #13 0x00007f2dd9cc03dd in clone () from /lib64/libc.so.6\r\n\r\nÂ \r\n\r\nÂ \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Inactivity mointor  core dump\n\nDescription:\nBroker Configuration:\r\n\r\n----------------------------\r\n\r\n<transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600&transport.useInactivityMonitor=false\"/>\r\n\r\nClient configuration:Â \r\n\r\n---------------------------\r\n\r\nfailover://(tcp://192.168.114.105:61616,tcp://192.168.114.105:61616)?randomize=false&wireFormat=openwire&transport.useInactivityMonitor=false\r\n\r\nÂ \r\n\r\nApplication cores/crashes/segfaults and generates core file, even when in idle state.Â  Below is the backtrace - Not sure if this is related to inactivity monitor\r\n\r\n(gdb) bt\r\n #0 0x00007f2dd9bff989 in raise () from /lib64/libc.so.6\r\n #1 0x00007f2dd9c01098 in abort () from /lib64/libc.so.6\r\n #2 0x00007f2dda5039d5 in __gnu_cxx::__verbose_terminate_handler() () from /lib64/libstdc++.so.6\r\n #3 0x00007f2dda501946 in ?? () from /lib64/libstdc++.so.6\r\n #4 0x00007f2dda501973 in std::terminate() () from /lib64/libstdc++.so.6\r\n #5 0x00007f2dda5024df in __cxa_pure_virtual () from /lib64/libstdc++.so.6\r\n #6 0x00007f2ddc404baa in decaf::util::concurrent::Lock::~Lock (this=0x7f2d637fdbf0, __in_chrg=<optimized out>) at decaf/util/concurrent/Lock.cpp:46\r\n #7 0x00007f2ddc221e80 in activemq::threads::CompositeTaskRunner::wakeup (this=<optimized out>) at activemq/threads/CompositeTaskRunner.cpp:154\r\n #8 0x00007f2ddc282c95 in activemq::transport::inactivity::InactivityMonitor::readCheck (this=0x7f2d70003a50)\r\n at activemq/transport/inactivity/InactivityMonitor.cpp:400\r\n #9 0x00007f2ddc3ffe5d in decaf::util::TimerImpl::run (this=0x7f2d70002160) at decaf/util/Timer.cpp:156\r\n #10 0x00007f2ddc37b622 in (anonymous namespace)::runCallback (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:268\r\n #11 0x00007f2ddc37beec in (anonymous namespace)::threadEntryMethod (arg=0x7f2d70002670) at decaf/internal/util/concurrent/Threading.cpp:256\r\n #12 0x00007f2dda9b4df3 in start_thread () from /lib64/libpthread.so.0\r\n #13 0x00007f2dd9cc03dd in clone () from /lib64/libc.so.6\r\n\r\nÂ \r\n\r\nÂ \n\nComments:\n", "classification": "Classify the issue 'Inactivity mointor  core dump' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-625?\nA: Broker Configuration:\r\n\r\n----------------------------\r\n\r\n<transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600&transport.useInactivityMonitor=false\"/>\r\n\r\nClient configuration:Â \r\n\r\n---------------------------\r\n\r\nfailover://(tcp://192.168.114.105:61616,tcp://192.168.114.105:61616)?randomize=false&wireFormat=openwire&transport.useInacti"}}
{"issue_key": "AMQCPP-624", "project": "AMQCPP", "title": "Random crash with ActiveMQ-CMS when running the system long term", "status": "Open", "reporter": "Karthik Kashyap", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-01-25T13:19:37.000+0000", "updated": "2018-01-25T13:23:04.000+0000", "description": "We use ActiveMQ-CPP for inter-component messaging within a voice recorder software. When doing some long term load tests for a few hours, we encountered a random crash which pointed to ActiveMQ-CPP with the below backtrace on GDB as listed below:\r\n\r\n[Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". Missing separate debuginfo for /root/mediarecorder_ext/target/linux/lib/libaudiofile.so.1 Try: yum --enablerepo='*debug*' install /usr/lib/debug/.build-id/3f/ab3a9b600e5d5156497eac8d35217947a324aa.debug Core was generated by `/root/amr/bin/tdaemon --daemon -f wav'. Program terminated with signal 6, Aborted. #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install apr-1.4.8-3.el7.x86_64 glibc-2.17-55.el7.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.11.3-49.el7.x86_64 libcom_err-1.42.9-4.el7.x86_64 libgcc-4.8.2-16.el7.x86_64 libselinux-2.2.2-6.el7.x86_64 libstdc++-4.8.2-16.el7.x86_64 libuuid-2.23.2-16.el7.x86_64 nss-softokn-freebl-3.15.4-2.el7.x86_64 openssl-libs-1.0.1e-34.el7.x86_64 pcre-8.32-12.el7.x86_64 xz-libs-5.1.2-8alpha.el7.x86_64 (gdb) bt full #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 No symbol table info available.+ \r\n\r\n+#1 0x00007f18f0e66098 in abort () from /lib64/libc.so.6 No symbol table info available.+\r\n\r\n +#2 0x00007f18f8fad305 in Poco::SignalHandler::handleSignal (sig=11) at /root/poco/latest/poco-1.6.1-all/Foundation/src/SignalHandler.cpp:96 jb = <optimized out>+ \r\n\r\n+#3 <signal handler called> No symbol table info available.+ \r\n\r\n+#4 0x00007f18f0f78886 in __memcpy_ssse3_back () from /lib64/libc.so.6 No symbol table info available._+ \r\n\r\n+_#5 0x00007f18f17c65b4 in std::string::append(std::string const&) () from /lib64/libstdc_+_+.so.6 No symbol table info available._ \r\n\r\n_#6 0x00007f18f3a47053 in decaf::util::concurrent::Mutex::Mutex (this=0x7f1859ffabc0) at decaf/util/concurrent/Mutex.cpp:50 idStr = \"10474\" this = 0x7f1888000be0_ \r\n\r\n_#7 0x00007f18f3a50340 in AbstractCollection (__vtt_parm=<optimized out>, this=0x7f1859ffabb8, __in_chrg=<optimized out>) at ./decaf/util/AbstractCollection.h:65 No locals._ \r\n\r\n_#8 AbstractList (__vtt_parm=<optimized out>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractList.h:341 No locals._ \r\n\r\n_#9 AbstractSequentialList (__vtt_parm=0x7f18f4069ce8 <VTT for decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>+8>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractSequentialList.h:59 No locals.\r\n\r\n#10 decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>::LinkedList (this=this@entry=0x7f1859ffabb0, __in_chrg=<optimized out>, __vtt_parm=<optimized out>) at ./decaf/util/LinkedList.h:91 No locals.\r\n\r\n#11 0x00007f18f3a5366f in decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x7f187c00aad0) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248 toDeleteList = warning: can't find linker symbol for virtual table for `decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' value warning: found `construction vtable for decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>-in-decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' instead {<decaf::util::AbstractSequentialList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::AbstractList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::List<decaf::util::concurrent::ExecutorKernel::Worker*>> =\r\n\r\n{<decaf::util::Collection<decaf::util::concurrent::ExecutorKernel::Worker*>> = <invalid address>, <No data fields>}\r\n\r\n, <decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>> = {mutex = {<decaf::util::concurrent::Synchronizable> =\r\n\r\n{ _vptr.Synchronizable = 0x7f18f4064db0 <vtable for decaf::util::concurrent::Mutex+16>}\r\n\r\n, properties = 0x0}}, modCount = 0}, <No data fields>}, <decaf::util::Deque<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::Queue<decaf::util::concurrent::ExecutorKernel::Worker*>---Type <return> to continue, or q <return> to quit--- > =\r\n\r\n{<No data fields>}\r\n\r\n, <No data fields>}, listSize = 147917545, head = \\{value = 0x7f1859ffaca0, prev = 0x7f187c009a80, next = 0x7f18f3a46840 <decaf::util::concurrent::Lock::~Lock()+160>}, tail = \\{value = 0x7f187c009aa8, prev = 0x7f1859ffac80, next = 0x7f1888014768}} #12 0x00007f18f3a41abd in decaf::util::TimerImpl::run (this=0x7f187c009a80) at decaf/util/Timer.cpp:156 task = {<decaf::util::concurrent::atomic::AtomicRefCounter> =\r\n\r\n{ _vptr.AtomicRefCounter = 0x7f18f40170d0 <vtable for decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>+16>, counter = 0x7f187c00ab40}\r\n\r\n, value = 0x7f187c00aad0, onDelete = 0x7f18f38c7fb0 <decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::TimerTask*)>} #13 0x00007f18f39bd3d2 in (anonymous namespace)::runCallback (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:268 thread = 0x7f187c009b40 #14 0x00007f18f39bdc0c in (anonymous namespace)::threadEntryMethod (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:256 thread = 0x7f187c009b40 #15 0x00007f18f5862df3 in start_thread () from /lib64/libpthread.so.0 No symbol table info available. #16 0x00007f18f0f253dd in clone () from /lib64/libc.so.6 No symbol table info available.", "comments": [], "text": "Random crash with ActiveMQ-CMS when running the system long term\n\nDescription:\nWe use ActiveMQ-CPP for inter-component messaging within a voice recorder software. When doing some long term load tests for a few hours, we encountered a random crash which pointed to ActiveMQ-CPP with the below backtrace on GDB as listed below:\r\n\r\n[Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". Missing separate debuginfo for /root/mediarecorder_ext/target/linux/lib/libaudiofile.so.1 Try: yum --enablerepo='*debug*' install /usr/lib/debug/.build-id/3f/ab3a9b600e5d5156497eac8d35217947a324aa.debug Core was generated by `/root/amr/bin/tdaemon --daemon -f wav'. Program terminated with signal 6, Aborted. #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install apr-1.4.8-3.el7.x86_64 glibc-2.17-55.el7.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.11.3-49.el7.x86_64 libcom_err-1.42.9-4.el7.x86_64 libgcc-4.8.2-16.el7.x86_64 libselinux-2.2.2-6.el7.x86_64 libstdc++-4.8.2-16.el7.x86_64 libuuid-2.23.2-16.el7.x86_64 nss-softokn-freebl-3.15.4-2.el7.x86_64 openssl-libs-1.0.1e-34.el7.x86_64 pcre-8.32-12.el7.x86_64 xz-libs-5.1.2-8alpha.el7.x86_64 (gdb) bt full #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 No symbol table info available.+ \r\n\r\n+#1 0x00007f18f0e66098 in abort () from /lib64/libc.so.6 No symbol table info available.+\r\n\r\n +#2 0x00007f18f8fad305 in Poco::SignalHandler::handleSignal (sig=11) at /root/poco/latest/poco-1.6.1-all/Foundation/src/SignalHandler.cpp:96 jb = <optimized out>+ \r\n\r\n+#3 <signal handler called> No symbol table info available.+ \r\n\r\n+#4 0x00007f18f0f78886 in __memcpy_ssse3_back () from /lib64/libc.so.6 No symbol table info available._+ \r\n\r\n+_#5 0x00007f18f17c65b4 in std::string::append(std::string const&) () from /lib64/libstdc_+_+.so.6 No symbol table info available._ \r\n\r\n_#6 0x00007f18f3a47053 in decaf::util::concurrent::Mutex::Mutex (this=0x7f1859ffabc0) at decaf/util/concurrent/Mutex.cpp:50 idStr = \"10474\" this = 0x7f1888000be0_ \r\n\r\n_#7 0x00007f18f3a50340 in AbstractCollection (__vtt_parm=<optimized out>, this=0x7f1859ffabb8, __in_chrg=<optimized out>) at ./decaf/util/AbstractCollection.h:65 No locals._ \r\n\r\n_#8 AbstractList (__vtt_parm=<optimized out>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractList.h:341 No locals._ \r\n\r\n_#9 AbstractSequentialList (__vtt_parm=0x7f18f4069ce8 <VTT for decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>+8>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractSequentialList.h:59 No locals.\r\n\r\n#10 decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>::LinkedList (this=this@entry=0x7f1859ffabb0, __in_chrg=<optimized out>, __vtt_parm=<optimized out>) at ./decaf/util/LinkedList.h:91 No locals.\r\n\r\n#11 0x00007f18f3a5366f in decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x7f187c00aad0) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248 toDeleteList = warning: can't find linker symbol for virtual table for `decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' value warning: found `construction vtable for decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>-in-decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' instead {<decaf::util::AbstractSequentialList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::AbstractList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::List<decaf::util::concurrent::ExecutorKernel::Worker*>> =\r\n\r\n{<decaf::util::Collection<decaf::util::concurrent::ExecutorKernel::Worker*>> = <invalid address>, <No data fields>}\r\n\r\n, <decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>> = {mutex = {<decaf::util::concurrent::Synchronizable> =\r\n\r\n{ _vptr.Synchronizable = 0x7f18f4064db0 <vtable for decaf::util::concurrent::Mutex+16>}\r\n\r\n, properties = 0x0}}, modCount = 0}, <No data fields>}, <decaf::util::Deque<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::Queue<decaf::util::concurrent::ExecutorKernel::Worker*>---Type <return> to continue, or q <return> to quit--- > =\r\n\r\n{<No data fields>}\r\n\r\n, <No data fields>}, listSize = 147917545, head = \\{value = 0x7f1859ffaca0, prev = 0x7f187c009a80, next = 0x7f18f3a46840 <decaf::util::concurrent::Lock::~Lock()+160>}, tail = \\{value = 0x7f187c009aa8, prev = 0x7f1859ffac80, next = 0x7f1888014768}} #12 0x00007f18f3a41abd in decaf::util::TimerImpl::run (this=0x7f187c009a80) at decaf/util/Timer.cpp:156 task = {<decaf::util::concurrent::atomic::AtomicRefCounter> =\r\n\r\n{ _vptr.AtomicRefCounter = 0x7f18f40170d0 <vtable for decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>+16>, counter = 0x7f187c00ab40}\r\n\r\n, value = 0x7f187c00aad0, onDelete = 0x7f18f38c7fb0 <decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::TimerTask*)>} #13 0x00007f18f39bd3d2 in (anonymous namespace)::runCallback (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:268 thread = 0x7f187c009b40 #14 0x00007f18f39bdc0c in (anonymous namespace)::threadEntryMethod (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:256 thread = 0x7f187c009b40 #15 0x00007f18f5862df3 in start_thread () from /lib64/libpthread.so.0 No symbol table info available. #16 0x00007f18f0f253dd in clone () from /lib64/libc.so.6 No symbol table info available.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Random crash with ActiveMQ-CMS when running the system long term\n\nDescription:\nWe use ActiveMQ-CPP for inter-component messaging within a voice recorder software. When doing some long term load tests for a few hours, we encountered a random crash which pointed to ActiveMQ-CPP with the below backtrace on GDB as listed below:\r\n\r\n[Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". Missing separate debuginfo for /root/mediarecorder_ext/target/linux/lib/libaudiofile.so.1 Try: yum --enablerepo='*debug*' install /usr/lib/debug/.build-id/3f/ab3a9b600e5d5156497eac8d35217947a324aa.debug Core was generated by `/root/amr/bin/tdaemon --daemon -f wav'. Program terminated with signal 6, Aborted. #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install apr-1.4.8-3.el7.x86_64 glibc-2.17-55.el7.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.11.3-49.el7.x86_64 libcom_err-1.42.9-4.el7.x86_64 libgcc-4.8.2-16.el7.x86_64 libselinux-2.2.2-6.el7.x86_64 libstdc++-4.8.2-16.el7.x86_64 libuuid-2.23.2-16.el7.x86_64 nss-softokn-freebl-3.15.4-2.el7.x86_64 openssl-libs-1.0.1e-34.el7.x86_64 pcre-8.32-12.el7.x86_64 xz-libs-5.1.2-8alpha.el7.x86_64 (gdb) bt full #0 0x00007f18f0e64989 in raise () from /lib64/libc.so.6 No symbol table info available.+ \r\n\r\n+#1 0x00007f18f0e66098 in abort () from /lib64/libc.so.6 No symbol table info available.+\r\n\r\n +#2 0x00007f18f8fad305 in Poco::SignalHandler::handleSignal (sig=11) at /root/poco/latest/poco-1.6.1-all/Foundation/src/SignalHandler.cpp:96 jb = <optimized out>+ \r\n\r\n+#3 <signal handler called> No symbol table info available.+ \r\n\r\n+#4 0x00007f18f0f78886 in __memcpy_ssse3_back () from /lib64/libc.so.6 No symbol table info available._+ \r\n\r\n+_#5 0x00007f18f17c65b4 in std::string::append(std::string const&) () from /lib64/libstdc_+_+.so.6 No symbol table info available._ \r\n\r\n_#6 0x00007f18f3a47053 in decaf::util::concurrent::Mutex::Mutex (this=0x7f1859ffabc0) at decaf/util/concurrent/Mutex.cpp:50 idStr = \"10474\" this = 0x7f1888000be0_ \r\n\r\n_#7 0x00007f18f3a50340 in AbstractCollection (__vtt_parm=<optimized out>, this=0x7f1859ffabb8, __in_chrg=<optimized out>) at ./decaf/util/AbstractCollection.h:65 No locals._ \r\n\r\n_#8 AbstractList (__vtt_parm=<optimized out>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractList.h:341 No locals._ \r\n\r\n_#9 AbstractSequentialList (__vtt_parm=0x7f18f4069ce8 <VTT for decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>+8>, this=0x7f1859ffabb0, __in_chrg=<optimized out>) at ./decaf/util/AbstractSequentialList.h:59 No locals.\r\n\r\n#10 decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>::LinkedList (this=this@entry=0x7f1859ffabb0, __in_chrg=<optimized out>, __vtt_parm=<optimized out>) at ./decaf/util/LinkedList.h:91 No locals.\r\n\r\n#11 0x00007f18f3a5366f in decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x7f187c00aad0) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248 toDeleteList = warning: can't find linker symbol for virtual table for `decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' value warning: found `construction vtable for decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>-in-decaf::util::LinkedList<decaf::util::concurrent::ExecutorKernel::Worker*>' instead {<decaf::util::AbstractSequentialList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::AbstractList<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::List<decaf::util::concurrent::ExecutorKernel::Worker*>> =\r\n\r\n{<decaf::util::Collection<decaf::util::concurrent::ExecutorKernel::Worker*>> = <invalid address>, <No data fields>}\r\n\r\n, <decaf::util::AbstractCollection<decaf::util::concurrent::ExecutorKernel::Worker*>> = {mutex = {<decaf::util::concurrent::Synchronizable> =\r\n\r\n{ _vptr.Synchronizable = 0x7f18f4064db0 <vtable for decaf::util::concurrent::Mutex+16>}\r\n\r\n, properties = 0x0}}, modCount = 0}, <No data fields>}, <decaf::util::Deque<decaf::util::concurrent::ExecutorKernel::Worker*>> = {<decaf::util::Queue<decaf::util::concurrent::ExecutorKernel::Worker*>---Type <return> to continue, or q <return> to quit--- > =\r\n\r\n{<No data fields>}\r\n\r\n, <No data fields>}, listSize = 147917545, head = \\{value = 0x7f1859ffaca0, prev = 0x7f187c009a80, next = 0x7f18f3a46840 <decaf::util::concurrent::Lock::~Lock()+160>}, tail = \\{value = 0x7f187c009aa8, prev = 0x7f1859ffac80, next = 0x7f1888014768}} #12 0x00007f18f3a41abd in decaf::util::TimerImpl::run (this=0x7f187c009a80) at decaf/util/Timer.cpp:156 task = {<decaf::util::concurrent::atomic::AtomicRefCounter> =\r\n\r\n{ _vptr.AtomicRefCounter = 0x7f18f40170d0 <vtable for decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>+16>, counter = 0x7f187c00ab40}\r\n\r\n, value = 0x7f187c00aad0, onDelete = 0x7f18f38c7fb0 <decaf::lang::Pointer<decaf::util::TimerTask, decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::TimerTask*)>} #13 0x00007f18f39bd3d2 in (anonymous namespace)::runCallback (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:268 thread = 0x7f187c009b40 #14 0x00007f18f39bdc0c in (anonymous namespace)::threadEntryMethod (arg=0x7f187c009b40) at decaf/internal/util/concurrent/Threading.cpp:256 thread = 0x7f187c009b40 #15 0x00007f18f5862df3 in start_thread () from /lib64/libpthread.so.0 No symbol table info available. #16 0x00007f18f0f253dd in clone () from /lib64/libc.so.6 No symbol table info available.\n\nComments:\n", "classification": "Classify the issue 'Random crash with ActiveMQ-CMS when running the system long term' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-624?\nA: We use ActiveMQ-CPP for inter-component messaging within a voice recorder software. When doing some long term load tests for a few hours, we encountered a random crash which pointed to ActiveMQ-CPP with the below backtrace on GDB as listed below:\r\n\r\n[Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". Missing separate debuginfo for /root/mediare"}}
{"issue_key": "AMQCPP-623", "project": "AMQCPP", "title": "Can't build on some newer OpenSSL versions", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2018-01-22T22:01:26.000+0000", "updated": "2018-10-01T17:17:18.000+0000", "description": "Some newer revisions of OpenSSL such as those on latest Fedora releases cause an error in compilation.", "comments": [], "text": "Can't build on some newer OpenSSL versions\n\nDescription:\nSome newer revisions of OpenSSL such as those on latest Fedora releases cause an error in compilation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't build on some newer OpenSSL versions\n\nDescription:\nSome newer revisions of OpenSSL such as those on latest Fedora releases cause an error in compilation.\n\nComments:\n", "classification": "Classify the issue 'Can't build on some newer OpenSSL versions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-623?\nA: Some newer revisions of OpenSSL such as those on latest Fedora releases cause an error in compilation."}}
{"issue_key": "AMQCPP-622", "project": "AMQCPP", "title": "Memory leaks in the handshake of a OpenSSL connection", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2017-12-19T09:02:32.000+0000", "updated": "2018-01-22T22:05:20.000+0000", "description": "ActiveMQ transport has two memory leaks in the handshake of a OpenSSL connection.\r\n\r\n{noformat}\r\n==15167== Memcheck, a memory error detector\r\n==15167== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\r\n==15167== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\r\n==15167== \r\n==15167== \r\n==15167== HEAP SUMMARY:\r\n==15167==     in use at exit: 4,682,917 bytes in 8,351 blocks\r\n==15167==   total heap usage: 108,257 allocs, 99,907 frees, 64,602,948 bytes allocated\r\n==15167== \r\n==15167== 207 (32 direct, 175 indirect) bytes in 1 blocks are definitely lost in loss record 2,149 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E93024: X509V3_add_value (v3_utl.c:93)\r\n==15167==    by 0x6E94BD8: i2v_GENERAL_NAME (v3_alt.c:142)\r\n==15167==    by 0x6E94D2A: i2v_GENERAL_NAMES (v3_alt.c:106)\r\n==15167==    by 0x19B5FF6E: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167==    by 0x19BB1255: decaf::io::OutputStream::write(unsigned char const*, int) (OutputStream.cpp:65)\r\n==15167== \r\n==15167== 228 (32 direct, 196 indirect) bytes in 1 blocks are definitely lost in loss record 2,153 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E6ED08: asn1_template_noexp_d2i (tasn_dec.c:634)\r\n==15167==    by 0x6E6EE34: asn1_template_ex_d2i (tasn_dec.c:584)\r\n==15167==    by 0x6E6E4A5: ASN1_item_ex_d2i (tasn_dec.c:206)\r\n==15167==    by 0x6E6E983: ASN1_item_d2i (tasn_dec.c:146)\r\n==15167==    by 0x19B5FF4C: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167== \r\n==15167== LEAK SUMMARY:\r\n==15167==    definitely lost: 64 bytes in 2 blocks\r\n==15167==    indirectly lost: 371 bytes in 20 blocks\r\n==15167==      possibly lost: 176,608 bytes in 28 blocks\r\n==15167==    still reachable: 2,705,672 bytes in 6,620 blocks\r\n==15167==         suppressed: 1,800,202 bytes in 1,681 blocks\r\n==15167== Reachable blocks (those to which a pointer was found) are not shown.\r\n==15167== To see them, rerun with: --leak-check=full --show-leak-kinds=all\r\n{noformat}", "comments": [], "text": "Memory leaks in the handshake of a OpenSSL connection\n\nDescription:\nActiveMQ transport has two memory leaks in the handshake of a OpenSSL connection.\r\n\r\n{noformat}\r\n==15167== Memcheck, a memory error detector\r\n==15167== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\r\n==15167== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\r\n==15167== \r\n==15167== \r\n==15167== HEAP SUMMARY:\r\n==15167==     in use at exit: 4,682,917 bytes in 8,351 blocks\r\n==15167==   total heap usage: 108,257 allocs, 99,907 frees, 64,602,948 bytes allocated\r\n==15167== \r\n==15167== 207 (32 direct, 175 indirect) bytes in 1 blocks are definitely lost in loss record 2,149 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E93024: X509V3_add_value (v3_utl.c:93)\r\n==15167==    by 0x6E94BD8: i2v_GENERAL_NAME (v3_alt.c:142)\r\n==15167==    by 0x6E94D2A: i2v_GENERAL_NAMES (v3_alt.c:106)\r\n==15167==    by 0x19B5FF6E: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167==    by 0x19BB1255: decaf::io::OutputStream::write(unsigned char const*, int) (OutputStream.cpp:65)\r\n==15167== \r\n==15167== 228 (32 direct, 196 indirect) bytes in 1 blocks are definitely lost in loss record 2,153 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E6ED08: asn1_template_noexp_d2i (tasn_dec.c:634)\r\n==15167==    by 0x6E6EE34: asn1_template_ex_d2i (tasn_dec.c:584)\r\n==15167==    by 0x6E6E4A5: ASN1_item_ex_d2i (tasn_dec.c:206)\r\n==15167==    by 0x6E6E983: ASN1_item_d2i (tasn_dec.c:146)\r\n==15167==    by 0x19B5FF4C: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167== \r\n==15167== LEAK SUMMARY:\r\n==15167==    definitely lost: 64 bytes in 2 blocks\r\n==15167==    indirectly lost: 371 bytes in 20 blocks\r\n==15167==      possibly lost: 176,608 bytes in 28 blocks\r\n==15167==    still reachable: 2,705,672 bytes in 6,620 blocks\r\n==15167==         suppressed: 1,800,202 bytes in 1,681 blocks\r\n==15167== Reachable blocks (those to which a pointer was found) are not shown.\r\n==15167== To see them, rerun with: --leak-check=full --show-leak-kinds=all\r\n{noformat}\r\n\r\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leaks in the handshake of a OpenSSL connection\n\nDescription:\nActiveMQ transport has two memory leaks in the handshake of a OpenSSL connection.\r\n\r\n{noformat}\r\n==15167== Memcheck, a memory error detector\r\n==15167== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\r\n==15167== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\r\n==15167== \r\n==15167== \r\n==15167== HEAP SUMMARY:\r\n==15167==     in use at exit: 4,682,917 bytes in 8,351 blocks\r\n==15167==   total heap usage: 108,257 allocs, 99,907 frees, 64,602,948 bytes allocated\r\n==15167== \r\n==15167== 207 (32 direct, 175 indirect) bytes in 1 blocks are definitely lost in loss record 2,149 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E93024: X509V3_add_value (v3_utl.c:93)\r\n==15167==    by 0x6E94BD8: i2v_GENERAL_NAME (v3_alt.c:142)\r\n==15167==    by 0x6E94D2A: i2v_GENERAL_NAMES (v3_alt.c:106)\r\n==15167==    by 0x19B5FF6E: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167==    by 0x19BB1255: decaf::io::OutputStream::write(unsigned char const*, int) (OutputStream.cpp:65)\r\n==15167== \r\n==15167== 228 (32 direct, 196 indirect) bytes in 1 blocks are definitely lost in loss record 2,153 of 2,859\r\n==15167==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==15167==    by 0x6D8DA67: CRYPTO_malloc (mem.c:346)\r\n==15167==    by 0x6E3FEBE: sk_new (stack.c:162)\r\n==15167==    by 0x6E6ED08: asn1_template_noexp_d2i (tasn_dec.c:634)\r\n==15167==    by 0x6E6EE34: asn1_template_ex_d2i (tasn_dec.c:584)\r\n==15167==    by 0x6E6E4A5: ASN1_item_ex_d2i (tasn_dec.c:206)\r\n==15167==    by 0x6E6E983: ASN1_item_d2i (tasn_dec.c:146)\r\n==15167==    by 0x19B5FF4C: decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert(std::string const&) (OpenSSLSocket.cpp:671)\r\n==15167==    by 0x19B61481: decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake() (OpenSSLSocket.cpp:379)\r\n==15167==    by 0x19B5FA95: decaf::internal::net::ssl::openssl::OpenSSLSocket::write(unsigned char const*, int, int, int) (OpenSSLSocket.cpp:566)\r\n==15167==    by 0x19B63520: decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded(unsigned char const*, int, int, int) (OpenSSLSocketOutputStream.cpp:91)\r\n==15167==    by 0x19BB14D1: decaf::io::OutputStream::doWriteArray(unsigned char const*, int) (OutputStream.cpp:89)\r\n==15167== \r\n==15167== LEAK SUMMARY:\r\n==15167==    definitely lost: 64 bytes in 2 blocks\r\n==15167==    indirectly lost: 371 bytes in 20 blocks\r\n==15167==      possibly lost: 176,608 bytes in 28 blocks\r\n==15167==    still reachable: 2,705,672 bytes in 6,620 blocks\r\n==15167==         suppressed: 1,800,202 bytes in 1,681 blocks\r\n==15167== Reachable blocks (those to which a pointer was found) are not shown.\r\n==15167== To see them, rerun with: --leak-check=full --show-leak-kinds=all\r\n{noformat}\r\n\r\n\n\nComments:\n", "classification": "Classify the issue 'Memory leaks in the handshake of a OpenSSL connection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-622?\nA: ActiveMQ transport has two memory leaks in the handshake of a OpenSSL connection.\r\n\r\n{noformat}\r\n==15167== Memcheck, a memory error detector\r\n==15167== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\r\n==15167== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\r\n==15167== \r\n==15167== \r\n==15167== HEAP SUMMARY:\r\n==15167==     in use at exit: 4,682,917 bytes in 8,3"}}
{"issue_key": "AMQCPP-565", "project": "AMQCPP", "title": "Stop consumming messages after lost comunication (ActiveMQ C++ CLIENT 3.8.2)", "status": "Closed", "reporter": "TomÃ¡s De Bla", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-02-21T18:22:00.000+0000", "updated": "2015-02-24T15:26:40.000+0000", "description": "Messages  enqueues  at    T_INICIALIZACION topic are not consumed by  the consumer included in the    (ActiveMQ C++ CLIENT 3.8.2) library  and  sometimes also the  brÃ³ker dont dispatch the messsages  to the tÃ³pic. \n\nIn the active mq manager whe have the next inforamtion: \n\n\nEnqueues  219 Dequeues  0 Dispatched 0\n\nProvider and consumer connections  are listed in connections List but not in the topic list.\n\nThe computer host where  the program is running its affected by network issues, frequent  micro -loss communications", "comments": [], "text": "Stop consumming messages after lost comunication (ActiveMQ C++ CLIENT 3.8.2)\n\nDescription:\nMessages  enqueues  at    T_INICIALIZACION topic are not consumed by  the consumer included in the    (ActiveMQ C++ CLIENT 3.8.2) library  and  sometimes also the  brÃ³ker dont dispatch the messsages  to the tÃ³pic. \n\nIn the active mq manager whe have the next inforamtion: \n\n\nEnqueues  219 Dequeues  0 Dispatched 0\n\nProvider and consumer connections  are listed in connections List but not in the topic list.\n\nThe computer host where  the program is running its affected by network issues, frequent  micro -loss communications \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stop consumming messages after lost comunication (ActiveMQ C++ CLIENT 3.8.2)\n\nDescription:\nMessages  enqueues  at    T_INICIALIZACION topic are not consumed by  the consumer included in the    (ActiveMQ C++ CLIENT 3.8.2) library  and  sometimes also the  brÃ³ker dont dispatch the messsages  to the tÃ³pic. \n\nIn the active mq manager whe have the next inforamtion: \n\n\nEnqueues  219 Dequeues  0 Dispatched 0\n\nProvider and consumer connections  are listed in connections List but not in the topic list.\n\nThe computer host where  the program is running its affected by network issues, frequent  micro -loss communications \n\n\nComments:\n", "classification": "Classify the issue 'Stop consumming messages after lost comunication (ActiveMQ C++ CLIENT 3.8.2)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-565?\nA: Messages  enqueues  at    T_INICIALIZACION topic are not consumed by  the consumer included in the    (ActiveMQ C++ CLIENT 3.8.2) library  and  sometimes also the  brÃ³ker dont dispatch the messsages  to the tÃ³pic. \n\nIn the active mq manager whe have the next inforamtion: \n\n\nEnqueues  219 Dequeues  0 Dispatched 0\n\nProvider and consumer connections  are listed in connections List but not in the topi"}}
{"issue_key": "AMQCPP-564", "project": "AMQCPP", "title": "OS thread handles are kept forever", "status": "Resolved", "reporter": "Dusan Kutnik", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-02-13T14:27:20.000+0000", "updated": "2021-08-24T15:27:21.000+0000", "description": "The method decaf::internal::util::concurrent::Threading::attachToCurrentThread() creates a proxy thread object for a new OS thread and keeps it in a vector:\n\n////////////////////////////////////////////////////////////////////////////////\nThreadHandle* Threading::attachToCurrentThread() {\n\n    Pointer<ThreadHandle> thread(initThreadHandle(new ThreadHandle()));\n\n    thread->handle = PlatformThread::getCurrentThread();\n    thread->state = Thread::RUNNABLE;\n    thread->stackSize = PlatformThread::getStackSize(thread->handle);\n    thread->name = ::strdup(\n        std::string(std::string(\"OS-Thread\") + Integer::toString(library->osThreadId.getAndIncrement())).c_str());\n    thread->threadId = PlatformThread::getCurrentThreadId();\n\n    // An OS Thread doesn't have a running thread, this is only a proxy to only one ref.\n    thread->references = 1;\n\n    // Now create a Decaf Thread as a proxy to the OS thread.\n    Pointer<Thread> osThread(new Thread(thread.get()));\n    thread->parent = osThread.get();\n    thread->osThread = true;\n\n    PlatformThread::setTlsValue(library->threadKey, osThread.get());\n    PlatformThread::setTlsValue(library->selfKey, thread.get());\n\n    // Store the Thread that wraps this OS thread for later deletion since\n    // no other owners exist.\n    PlatformThread::lockMutex(library->globalLock);\n    library->osThreads.push_back(osThread.release());\n    PlatformThread::unlockMutex(library->globalLock);\n\n    return thread.release();\n}\n\nThis method is part of the mutex machinery in the AMQ CPP. The only way how to free this memory is to invoke the method decaf::internal::util::concurrent::Threading::shutdown(). In our scenario we create continuously new worker threads that communicate with ActiveMQ broker. This leads to the situation that new OS thread handles are still being created and never freed. The consumed RAM is rapidly growing since the size of the thread object is on our platform (Win 64bit) 1632 Bytes. We would need to have possibility to explicitly free this OS thread object before it terminates, for instance something like:\n\nvoid decaf::internal::util::concurrent::Threading::detachFromCurrentThread()\n\nIs there a reasonable workaround or another way how to free this OS thread?", "comments": [], "text": "OS thread handles are kept forever\n\nDescription:\nThe method decaf::internal::util::concurrent::Threading::attachToCurrentThread() creates a proxy thread object for a new OS thread and keeps it in a vector:\n\n////////////////////////////////////////////////////////////////////////////////\nThreadHandle* Threading::attachToCurrentThread() {\n\n    Pointer<ThreadHandle> thread(initThreadHandle(new ThreadHandle()));\n\n    thread->handle = PlatformThread::getCurrentThread();\n    thread->state = Thread::RUNNABLE;\n    thread->stackSize = PlatformThread::getStackSize(thread->handle);\n    thread->name = ::strdup(\n        std::string(std::string(\"OS-Thread\") + Integer::toString(library->osThreadId.getAndIncrement())).c_str());\n    thread->threadId = PlatformThread::getCurrentThreadId();\n\n    // An OS Thread doesn't have a running thread, this is only a proxy to only one ref.\n    thread->references = 1;\n\n    // Now create a Decaf Thread as a proxy to the OS thread.\n    Pointer<Thread> osThread(new Thread(thread.get()));\n    thread->parent = osThread.get();\n    thread->osThread = true;\n\n    PlatformThread::setTlsValue(library->threadKey, osThread.get());\n    PlatformThread::setTlsValue(library->selfKey, thread.get());\n\n    // Store the Thread that wraps this OS thread for later deletion since\n    // no other owners exist.\n    PlatformThread::lockMutex(library->globalLock);\n    library->osThreads.push_back(osThread.release());\n    PlatformThread::unlockMutex(library->globalLock);\n\n    return thread.release();\n}\n\nThis method is part of the mutex machinery in the AMQ CPP. The only way how to free this memory is to invoke the method decaf::internal::util::concurrent::Threading::shutdown(). In our scenario we create continuously new worker threads that communicate with ActiveMQ broker. This leads to the situation that new OS thread handles are still being created and never freed. The consumed RAM is rapidly growing since the size of the thread object is on our platform (Win 64bit) 1632 Bytes. We would need to have possibility to explicitly free this OS thread object before it terminates, for instance something like:\n\nvoid decaf::internal::util::concurrent::Threading::detachFromCurrentThread()\n\nIs there a reasonable workaround or another way how to free this OS thread?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: OS thread handles are kept forever\n\nDescription:\nThe method decaf::internal::util::concurrent::Threading::attachToCurrentThread() creates a proxy thread object for a new OS thread and keeps it in a vector:\n\n////////////////////////////////////////////////////////////////////////////////\nThreadHandle* Threading::attachToCurrentThread() {\n\n    Pointer<ThreadHandle> thread(initThreadHandle(new ThreadHandle()));\n\n    thread->handle = PlatformThread::getCurrentThread();\n    thread->state = Thread::RUNNABLE;\n    thread->stackSize = PlatformThread::getStackSize(thread->handle);\n    thread->name = ::strdup(\n        std::string(std::string(\"OS-Thread\") + Integer::toString(library->osThreadId.getAndIncrement())).c_str());\n    thread->threadId = PlatformThread::getCurrentThreadId();\n\n    // An OS Thread doesn't have a running thread, this is only a proxy to only one ref.\n    thread->references = 1;\n\n    // Now create a Decaf Thread as a proxy to the OS thread.\n    Pointer<Thread> osThread(new Thread(thread.get()));\n    thread->parent = osThread.get();\n    thread->osThread = true;\n\n    PlatformThread::setTlsValue(library->threadKey, osThread.get());\n    PlatformThread::setTlsValue(library->selfKey, thread.get());\n\n    // Store the Thread that wraps this OS thread for later deletion since\n    // no other owners exist.\n    PlatformThread::lockMutex(library->globalLock);\n    library->osThreads.push_back(osThread.release());\n    PlatformThread::unlockMutex(library->globalLock);\n\n    return thread.release();\n}\n\nThis method is part of the mutex machinery in the AMQ CPP. The only way how to free this memory is to invoke the method decaf::internal::util::concurrent::Threading::shutdown(). In our scenario we create continuously new worker threads that communicate with ActiveMQ broker. This leads to the situation that new OS thread handles are still being created and never freed. The consumed RAM is rapidly growing since the size of the thread object is on our platform (Win 64bit) 1632 Bytes. We would need to have possibility to explicitly free this OS thread object before it terminates, for instance something like:\n\nvoid decaf::internal::util::concurrent::Threading::detachFromCurrentThread()\n\nIs there a reasonable workaround or another way how to free this OS thread?\n\nComments:\n", "classification": "Classify the issue 'OS thread handles are kept forever' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-564?\nA: The method decaf::internal::util::concurrent::Threading::attachToCurrentThread() creates a proxy thread object for a new OS thread and keeps it in a vector:\n\n////////////////////////////////////////////////////////////////////////////////\nThreadHandle* Threading::attachToCurrentThread() {\n\n    Pointer<ThreadHandle> thread(initThreadHandle(new ThreadHandle()));\n\n    thread->handle = PlatformThread:"}}
{"issue_key": "AMQCPP-563", "project": "AMQCPP", "title": "Process is dead with seg fault when queue has heavy load.", "status": "Closed", "reporter": "Kyung Soo Lee", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-02-11T22:27:47.000+0000", "updated": "2015-07-13T20:49:08.000+0000", "description": "We are using activemq cms to communicate with Java application and broker is running over Java side. I got the seg fault (shown on the below) when we send a lot of packets over the activemq.\n\n  [1] poller_x() [0x496f08]\n  [2] /lib/x86_64-linux-gnu/libc.so.6(+0x32220) [0x7f0b6796b220]\n  [3] /libactivemq-cpp.so.18(_ZN8activemq4core18ActiveMQConnection9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0x676) [0x7f0b68e7e226]\n  [4] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [5] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10correlator18ResponseCorrelator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x81) [0x7f0b690241f1]\n  [6] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport8failover25FailoverTransportListener9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x146) [0x7f0b69064af6]\n  [7] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [8] /lib/libactivemq-cpp.so.18(_ZN8activemq10wireformat8openwire24OpenWireFormatNegotiator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0xe7) [0x7f0b690b51b7]\n  [9] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [10] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10inactivity17InactivityMonitor9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x26a) [0x7f0b690697aa]", "comments": [], "text": "Process is dead with seg fault when queue has heavy load.\n\nDescription:\nWe are using activemq cms to communicate with Java application and broker is running over Java side. I got the seg fault (shown on the below) when we send a lot of packets over the activemq.\n\n  [1] poller_x() [0x496f08]\n  [2] /lib/x86_64-linux-gnu/libc.so.6(+0x32220) [0x7f0b6796b220]\n  [3] /libactivemq-cpp.so.18(_ZN8activemq4core18ActiveMQConnection9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0x676) [0x7f0b68e7e226]\n  [4] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [5] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10correlator18ResponseCorrelator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x81) [0x7f0b690241f1]\n  [6] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport8failover25FailoverTransportListener9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x146) [0x7f0b69064af6]\n  [7] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [8] /lib/libactivemq-cpp.so.18(_ZN8activemq10wireformat8openwire24OpenWireFormatNegotiator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0xe7) [0x7f0b690b51b7]\n  [9] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [10] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10inactivity17InactivityMonitor9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x26a) [0x7f0b690697aa]\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Process is dead with seg fault when queue has heavy load.\n\nDescription:\nWe are using activemq cms to communicate with Java application and broker is running over Java side. I got the seg fault (shown on the below) when we send a lot of packets over the activemq.\n\n  [1] poller_x() [0x496f08]\n  [2] /lib/x86_64-linux-gnu/libc.so.6(+0x32220) [0x7f0b6796b220]\n  [3] /libactivemq-cpp.so.18(_ZN8activemq4core18ActiveMQConnection9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0x676) [0x7f0b68e7e226]\n  [4] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [5] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10correlator18ResponseCorrelator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x81) [0x7f0b690241f1]\n  [6] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport8failover25FailoverTransportListener9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x146) [0x7f0b69064af6]\n  [7] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [8] /lib/libactivemq-cpp.so.18(_ZN8activemq10wireformat8openwire24OpenWireFormatNegotiator9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0xe7) [0x7f0b690b51b7]\n  [9] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport15TransportFilter9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS2_4util10concurrent6atomic16AtomicRefCounterEEE+0xbf) [0x7f0b6901801f]\n  [10] /lib/libactivemq-cpp.so.18(_ZN8activemq9transport10inactivity17InactivityMonitor9onCommandEN5decaf4lang7PointerINS_8commands7CommandENS3_4util10concurrent6atomic16AtomicRefCounterEEE+0x26a) [0x7f0b690697aa]\n\nComments:\n", "classification": "Classify the issue 'Process is dead with seg fault when queue has heavy load.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-563?\nA: We are using activemq cms to communicate with Java application and broker is running over Java side. I got the seg fault (shown on the below) when we send a lot of packets over the activemq.\n\n  [1] poller_x() [0x496f08]\n  [2] /lib/x86_64-linux-gnu/libc.so.6(+0x32220) [0x7f0b6796b220]\n  [3] /libactivemq-cpp.so.18(_ZN8activemq4core18ActiveMQConnection9onCommandEN5decaf4lang7PointerINS_8commands7Comm"}}
{"issue_key": "AMQCPP-562", "project": "AMQCPP", "title": "Reduce memory delete and allocation in ArrayList", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-01-29T08:07:31.000+0000", "updated": "2015-01-29T15:18:50.000+0000", "description": "", "comments": [], "text": "Reduce memory delete and allocation in ArrayList\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Reduce memory delete and allocation in ArrayList\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Reduce memory delete and allocation in ArrayList' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-562?\nA: "}}
{"issue_key": "AMQCPP-561", "project": "AMQCPP", "title": "Memory Leak in ActiveMQConsumerKernel while calling deliverAcks", "status": "Closed", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-01-29T02:30:52.000+0000", "updated": "2015-01-29T02:35:50.000+0000", "description": "", "comments": [], "text": "Memory Leak in ActiveMQConsumerKernel while calling deliverAcks\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory Leak in ActiveMQConsumerKernel while calling deliverAcks\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Memory Leak in ActiveMQConsumerKernel while calling deliverAcks' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-561?\nA: "}}
{"issue_key": "AMQCPP-560", "project": "AMQCPP", "title": "Memory used by thread is not freed when thread end", "status": "Closed", "reporter": "Francois Godin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-01-23T21:32:32.000+0000", "updated": "2017-11-09T19:47:39.000+0000", "description": "A program have one connection and may create many threads. Each of those thread can then use that connection to generate a session. The problem happen when the session is destroyed. The memory consumption do not go back to what it was before.\n\nIn addition, it seems that 3.8.3 on Windows (not tested on Linux with that version) is prone to crash in that situation.\n\nI've tried valgrind and dr memory and they did not find memory leak. This should means that the memory is still reachable. The implication is then that when using ActiveMQ C++ on one thread, some memory is allocated for that thread. That memory would then be kept accessible even when the thread die/session closed/connection closed.\n\nI've managed to build a C++11 example program. It should be noted that this program create only one session at a time (by using join() to wait). Also, if the session is created on the current thread (by not defining THREAD), then the memory stay stable.\n\nIt seems to also happen if we use new thread to open Connection but as creating those is slower, it is not as easy to see.", "comments": [], "text": "Memory used by thread is not freed when thread end\n\nDescription:\nA program have one connection and may create many threads. Each of those thread can then use that connection to generate a session. The problem happen when the session is destroyed. The memory consumption do not go back to what it was before.\n\nIn addition, it seems that 3.8.3 on Windows (not tested on Linux with that version) is prone to crash in that situation.\n\nI've tried valgrind and dr memory and they did not find memory leak. This should means that the memory is still reachable. The implication is then that when using ActiveMQ C++ on one thread, some memory is allocated for that thread. That memory would then be kept accessible even when the thread die/session closed/connection closed.\n\nI've managed to build a C++11 example program. It should be noted that this program create only one session at a time (by using join() to wait). Also, if the session is created on the current thread (by not defining THREAD), then the memory stay stable.\n\nIt seems to also happen if we use new thread to open Connection but as creating those is slower, it is not as easy to see.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory used by thread is not freed when thread end\n\nDescription:\nA program have one connection and may create many threads. Each of those thread can then use that connection to generate a session. The problem happen when the session is destroyed. The memory consumption do not go back to what it was before.\n\nIn addition, it seems that 3.8.3 on Windows (not tested on Linux with that version) is prone to crash in that situation.\n\nI've tried valgrind and dr memory and they did not find memory leak. This should means that the memory is still reachable. The implication is then that when using ActiveMQ C++ on one thread, some memory is allocated for that thread. That memory would then be kept accessible even when the thread die/session closed/connection closed.\n\nI've managed to build a C++11 example program. It should be noted that this program create only one session at a time (by using join() to wait). Also, if the session is created on the current thread (by not defining THREAD), then the memory stay stable.\n\nIt seems to also happen if we use new thread to open Connection but as creating those is slower, it is not as easy to see.\n\n\nComments:\n", "classification": "Classify the issue 'Memory used by thread is not freed when thread end' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-560?\nA: A program have one connection and may create many threads. Each of those thread can then use that connection to generate a session. The problem happen when the session is destroyed. The memory consumption do not go back to what it was before.\n\nIn addition, it seems that 3.8.3 on Windows (not tested on Linux with that version) is prone to crash in that situation.\n\nI've tried valgrind and dr memory "}}
{"issue_key": "AMQCPP-559", "project": "AMQCPP", "title": "Deadlock in concurrent condition", "status": "Open", "reporter": "eagle518", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-01-23T01:45:59.000+0000", "updated": "2015-01-23T21:35:42.000+0000", "description": "run a moment and deadlock at await().\n\ncode:\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <decaf/lang/Runtime.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/util/ArrayList.h>\n#include <decaf/lang/String.h>\n#include <decaf/lang/System.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/exceptions/RuntimeException.h>\n#include <decaf/util/concurrent/locks/Lock.h>\n#include <decaf/util/concurrent/locks/Condition.h>\n#include <decaf/util/concurrent/locks/ReentrantLock.h>\n#include <decaf/util/LinkedList.h>\n\nusing namespace std;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::lang::exceptions;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace decaf::util::concurrent::locks;\n\nclass LockConditionTest {\npublic:\n\tLockConditionTest();\n\tvirtual ~LockConditionTest();\n\n\tvoid put();\n\n\tString* take();\n\nprivate:\n\tCondition* fullCondition;\n\tCondition* emptyCondition;\n\tdecaf::util::concurrent::locks::Lock* lock;\n\tint maxSize;\n\n\tLinkedList<String*> *bag;\n};\n\nclass Producer: public Runnable {\npublic:\n\tProducer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Producer() {\n\n\t}\n\tvoid run() {\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tm_parent->put();\n\t\t\t} while (1);\n\t\t} catch (Exception& e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nclass Customer: public Runnable {\npublic:\n\tCustomer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Customer() {\n\n\t}\n\tvoid run() {\n\t\tdo {\n\t\t\tString* s = m_parent->take();\n\t\t\tdelete s;\n\t\t} while (1);\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nLockConditionTest::LockConditionTest() {\n\tlock = new ReentrantLock();\n\tfullCondition = lock->newCondition();\n\temptyCondition = lock->newCondition();\n\tmaxSize = 10;\n\tbag = new LinkedList<String*>();\n}\nLockConditionTest::~LockConditionTest() {\n\tdelete bag;\n\tdelete fullCondition;\n\tdelete emptyCondition;\n\tdelete lock;\n}\n\nvoid LockConditionTest::put() {\n\tint n = 0;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() >= maxSize)\n\t\t\tfullCondition->await();\n\t\tbag->push(new String(Integer::toString(n++)));\n\t\tprintf(\"push: %d\\n\", bag->size());\n\t\temptyCondition->signal();\n\t} catch (Exception& ex) {\n\t\tex.printStackTrace();\n\t}\n\tlock->unlock();\n}\n\nString* LockConditionTest::take() {\n\tString* result = NULL;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() == 0)\n\t\t\temptyCondition->await();\n\t\tresult = dynamic_cast<String*>(bag->pop());\n\t\tprintf(\"pop: %d\\n\", bag->size());\n\t\tfullCondition->signal();\n\t} catch (Exception& e) {\n\t\te.printStackTrace();\n\t}\n\tlock->unlock();\n\treturn result;\n}\n\nstatic void test_condition()\n{\n\n\tArrayList<Thread*> arr;\n\tArrayList<Runnable*> arr1;\n\n\tLockConditionTest *tct = new LockConditionTest();\n\tRunnable *r1 = new Producer(tct);\n\tThread *t1 = new Thread(r1);\n\tt1->start();\n\tarr.add(t1);\n\tarr1.add(r1);\n\n\tRunnable *c1 = new Customer(tct);\n\tThread *t2 = new Thread(c1);\n\tt2->start();\n\tarr.add(t2);\n\tarr1.add(c1);\n\n\tRunnable *r2 = new Producer(tct);\n\tThread *t3 = new Thread(r2);\n\tt3->start();\n\tarr.add(t3);\n\tarr1.add(r2);\n\n\tRunnable *c2 = new Customer(tct);\n\tThread *t4 = new Thread(c2);\n\tt4->start();\n\tarr.add(t4);\n\tarr1.add(c2);\n\n\tRunnable *r3 = new Producer(tct);\n\tThread *t5 = new Thread(r3);\n\tt5->start();\n\tarr.add(t5);\n\tarr1.add(r3);\n\n\tRunnable *c3 = new Customer(tct);\n\tThread *t6 = new Thread(c3);\n\tt6->start();\n\tarr.add(t1);\n\tarr1.add(c3);\n\n\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tarr.get(i)->join();\n\t}\n\tdelete tct;\n\n\tprintf(\"end of test_condition.\\n\");\n}\n\nint main(int argc, const char** argv)\n{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\n\ttest_condition();\n\n\treturn 0;\n}", "comments": [], "text": "Deadlock in concurrent condition\n\nDescription:\nrun a moment and deadlock at await().\n\ncode:\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <decaf/lang/Runtime.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/util/ArrayList.h>\n#include <decaf/lang/String.h>\n#include <decaf/lang/System.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/exceptions/RuntimeException.h>\n#include <decaf/util/concurrent/locks/Lock.h>\n#include <decaf/util/concurrent/locks/Condition.h>\n#include <decaf/util/concurrent/locks/ReentrantLock.h>\n#include <decaf/util/LinkedList.h>\n\nusing namespace std;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::lang::exceptions;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace decaf::util::concurrent::locks;\n\nclass LockConditionTest {\npublic:\n\tLockConditionTest();\n\tvirtual ~LockConditionTest();\n\n\tvoid put();\n\n\tString* take();\n\nprivate:\n\tCondition* fullCondition;\n\tCondition* emptyCondition;\n\tdecaf::util::concurrent::locks::Lock* lock;\n\tint maxSize;\n\n\tLinkedList<String*> *bag;\n};\n\nclass Producer: public Runnable {\npublic:\n\tProducer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Producer() {\n\n\t}\n\tvoid run() {\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tm_parent->put();\n\t\t\t} while (1);\n\t\t} catch (Exception& e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nclass Customer: public Runnable {\npublic:\n\tCustomer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Customer() {\n\n\t}\n\tvoid run() {\n\t\tdo {\n\t\t\tString* s = m_parent->take();\n\t\t\tdelete s;\n\t\t} while (1);\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nLockConditionTest::LockConditionTest() {\n\tlock = new ReentrantLock();\n\tfullCondition = lock->newCondition();\n\temptyCondition = lock->newCondition();\n\tmaxSize = 10;\n\tbag = new LinkedList<String*>();\n}\nLockConditionTest::~LockConditionTest() {\n\tdelete bag;\n\tdelete fullCondition;\n\tdelete emptyCondition;\n\tdelete lock;\n}\n\nvoid LockConditionTest::put() {\n\tint n = 0;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() >= maxSize)\n\t\t\tfullCondition->await();\n\t\tbag->push(new String(Integer::toString(n++)));\n\t\tprintf(\"push: %d\\n\", bag->size());\n\t\temptyCondition->signal();\n\t} catch (Exception& ex) {\n\t\tex.printStackTrace();\n\t}\n\tlock->unlock();\n}\n\nString* LockConditionTest::take() {\n\tString* result = NULL;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() == 0)\n\t\t\temptyCondition->await();\n\t\tresult = dynamic_cast<String*>(bag->pop());\n\t\tprintf(\"pop: %d\\n\", bag->size());\n\t\tfullCondition->signal();\n\t} catch (Exception& e) {\n\t\te.printStackTrace();\n\t}\n\tlock->unlock();\n\treturn result;\n}\n\nstatic void test_condition()\n{\n\n\tArrayList<Thread*> arr;\n\tArrayList<Runnable*> arr1;\n\n\tLockConditionTest *tct = new LockConditionTest();\n\tRunnable *r1 = new Producer(tct);\n\tThread *t1 = new Thread(r1);\n\tt1->start();\n\tarr.add(t1);\n\tarr1.add(r1);\n\n\tRunnable *c1 = new Customer(tct);\n\tThread *t2 = new Thread(c1);\n\tt2->start();\n\tarr.add(t2);\n\tarr1.add(c1);\n\n\tRunnable *r2 = new Producer(tct);\n\tThread *t3 = new Thread(r2);\n\tt3->start();\n\tarr.add(t3);\n\tarr1.add(r2);\n\n\tRunnable *c2 = new Customer(tct);\n\tThread *t4 = new Thread(c2);\n\tt4->start();\n\tarr.add(t4);\n\tarr1.add(c2);\n\n\tRunnable *r3 = new Producer(tct);\n\tThread *t5 = new Thread(r3);\n\tt5->start();\n\tarr.add(t5);\n\tarr1.add(r3);\n\n\tRunnable *c3 = new Customer(tct);\n\tThread *t6 = new Thread(c3);\n\tt6->start();\n\tarr.add(t1);\n\tarr1.add(c3);\n\n\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tarr.get(i)->join();\n\t}\n\tdelete tct;\n\n\tprintf(\"end of test_condition.\\n\");\n}\n\nint main(int argc, const char** argv)\n{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\n\ttest_condition();\n\n\treturn 0;\n}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock in concurrent condition\n\nDescription:\nrun a moment and deadlock at await().\n\ncode:\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <decaf/lang/Runtime.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/util/ArrayList.h>\n#include <decaf/lang/String.h>\n#include <decaf/lang/System.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/exceptions/RuntimeException.h>\n#include <decaf/util/concurrent/locks/Lock.h>\n#include <decaf/util/concurrent/locks/Condition.h>\n#include <decaf/util/concurrent/locks/ReentrantLock.h>\n#include <decaf/util/LinkedList.h>\n\nusing namespace std;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::lang::exceptions;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace decaf::util::concurrent::locks;\n\nclass LockConditionTest {\npublic:\n\tLockConditionTest();\n\tvirtual ~LockConditionTest();\n\n\tvoid put();\n\n\tString* take();\n\nprivate:\n\tCondition* fullCondition;\n\tCondition* emptyCondition;\n\tdecaf::util::concurrent::locks::Lock* lock;\n\tint maxSize;\n\n\tLinkedList<String*> *bag;\n};\n\nclass Producer: public Runnable {\npublic:\n\tProducer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Producer() {\n\n\t}\n\tvoid run() {\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tm_parent->put();\n\t\t\t} while (1);\n\t\t} catch (Exception& e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nclass Customer: public Runnable {\npublic:\n\tCustomer(LockConditionTest *test) {\n\t\tm_parent = test;\n\t}\n\tvirtual ~Customer() {\n\n\t}\n\tvoid run() {\n\t\tdo {\n\t\t\tString* s = m_parent->take();\n\t\t\tdelete s;\n\t\t} while (1);\n\t}\nprivate:\n\tLockConditionTest *m_parent;\n};\n\nLockConditionTest::LockConditionTest() {\n\tlock = new ReentrantLock();\n\tfullCondition = lock->newCondition();\n\temptyCondition = lock->newCondition();\n\tmaxSize = 10;\n\tbag = new LinkedList<String*>();\n}\nLockConditionTest::~LockConditionTest() {\n\tdelete bag;\n\tdelete fullCondition;\n\tdelete emptyCondition;\n\tdelete lock;\n}\n\nvoid LockConditionTest::put() {\n\tint n = 0;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() >= maxSize)\n\t\t\tfullCondition->await();\n\t\tbag->push(new String(Integer::toString(n++)));\n\t\tprintf(\"push: %d\\n\", bag->size());\n\t\temptyCondition->signal();\n\t} catch (Exception& ex) {\n\t\tex.printStackTrace();\n\t}\n\tlock->unlock();\n}\n\nString* LockConditionTest::take() {\n\tString* result = NULL;\n\tlock->lock();\n\ttry {\n\t\twhile (bag->size() == 0)\n\t\t\temptyCondition->await();\n\t\tresult = dynamic_cast<String*>(bag->pop());\n\t\tprintf(\"pop: %d\\n\", bag->size());\n\t\tfullCondition->signal();\n\t} catch (Exception& e) {\n\t\te.printStackTrace();\n\t}\n\tlock->unlock();\n\treturn result;\n}\n\nstatic void test_condition()\n{\n\n\tArrayList<Thread*> arr;\n\tArrayList<Runnable*> arr1;\n\n\tLockConditionTest *tct = new LockConditionTest();\n\tRunnable *r1 = new Producer(tct);\n\tThread *t1 = new Thread(r1);\n\tt1->start();\n\tarr.add(t1);\n\tarr1.add(r1);\n\n\tRunnable *c1 = new Customer(tct);\n\tThread *t2 = new Thread(c1);\n\tt2->start();\n\tarr.add(t2);\n\tarr1.add(c1);\n\n\tRunnable *r2 = new Producer(tct);\n\tThread *t3 = new Thread(r2);\n\tt3->start();\n\tarr.add(t3);\n\tarr1.add(r2);\n\n\tRunnable *c2 = new Customer(tct);\n\tThread *t4 = new Thread(c2);\n\tt4->start();\n\tarr.add(t4);\n\tarr1.add(c2);\n\n\tRunnable *r3 = new Producer(tct);\n\tThread *t5 = new Thread(r3);\n\tt5->start();\n\tarr.add(t5);\n\tarr1.add(r3);\n\n\tRunnable *c3 = new Customer(tct);\n\tThread *t6 = new Thread(c3);\n\tt6->start();\n\tarr.add(t1);\n\tarr1.add(c3);\n\n\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tarr.get(i)->join();\n\t}\n\tdelete tct;\n\n\tprintf(\"end of test_condition.\\n\");\n}\n\nint main(int argc, const char** argv)\n{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\n\ttest_condition();\n\n\treturn 0;\n}\n\n\nComments:\n", "classification": "Classify the issue 'Deadlock in concurrent condition' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-559?\nA: run a moment and deadlock at await().\n\ncode:\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <decaf/lang/Runtime.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/util/ArrayList.h>\n#include <decaf/lang/String.h>\n#include <decaf/lang/System.h>\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/except"}}
{"issue_key": "AMQCPP-558", "project": "AMQCPP", "title": "Port fix for AMQ-5513", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-01-09T14:38:21.000+0000", "updated": "2015-01-09T14:41:30.000+0000", "description": "Port fix from AMQ-5513", "comments": [], "text": "Port fix for AMQ-5513\n\nDescription:\nPort fix from AMQ-5513\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Port fix for AMQ-5513\n\nDescription:\nPort fix from AMQ-5513\n\nComments:\n", "classification": "Classify the issue 'Port fix for AMQ-5513' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-558?\nA: Port fix from AMQ-5513"}}
{"issue_key": "AMQCPP-557", "project": "AMQCPP", "title": "ActiveMQ C++ library leaks threads", "status": "Closed", "reporter": "pfid", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-12-12T08:11:19.000+0000", "updated": "2015-07-10T20:22:06.000+0000", "description": "Steps to reproduce:\n\n1) open connection\n2) attach to the process and note the number of threads (info thr)\n3) shutdown the broker\n4) your programm should try to automatically reconnect\n5) start the broker\n6) repeat 2) to see that the number of threads has increased\n\nWe had a bigger outage because of this recently, when the library would refuse to reconnect to the (multiple times) restarted broker, because the maximum number of threads was reached on OS level.\n\nAttached a very minimal example which will reproduce the problem.", "comments": [], "text": "ActiveMQ C++ library leaks threads\n\nDescription:\nSteps to reproduce:\n\n1) open connection\n2) attach to the process and note the number of threads (info thr)\n3) shutdown the broker\n4) your programm should try to automatically reconnect\n5) start the broker\n6) repeat 2) to see that the number of threads has increased\n\nWe had a bigger outage because of this recently, when the library would refuse to reconnect to the (multiple times) restarted broker, because the maximum number of threads was reached on OS level.\n\nAttached a very minimal example which will reproduce the problem.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ C++ library leaks threads\n\nDescription:\nSteps to reproduce:\n\n1) open connection\n2) attach to the process and note the number of threads (info thr)\n3) shutdown the broker\n4) your programm should try to automatically reconnect\n5) start the broker\n6) repeat 2) to see that the number of threads has increased\n\nWe had a bigger outage because of this recently, when the library would refuse to reconnect to the (multiple times) restarted broker, because the maximum number of threads was reached on OS level.\n\nAttached a very minimal example which will reproduce the problem.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ C++ library leaks threads' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-557?\nA: Steps to reproduce:\n\n1) open connection\n2) attach to the process and note the number of threads (info thr)\n3) shutdown the broker\n4) your programm should try to automatically reconnect\n5) start the broker\n6) repeat 2) to see that the number of threads has increased\n\nWe had a bigger outage because of this recently, when the library would refuse to reconnect to the (multiple times) restarted broker,"}}
{"issue_key": "AMQCPP-556", "project": "AMQCPP", "title": "setMessageListener on active session may leads to deadlock", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-12-01T06:09:01.000+0000", "updated": "2014-12-01T20:27:50.000+0000", "description": "When we create a new *MessageConsumer* with a *MessageListener* from a session, the session will be stopped before the updates of the message listener and restarted afterward if the session already started.\nHowever, if there have more than one consumers already started; calling *ActiveMQSessionKernel::stop()* may goes into a deadlock if there have many messages coming in.\n\n{panel:title=Stack Trace when the sample program run into deadlock}\n26989:  ./SimpleAsyncConsumer\n-----------------  lwp# 1 / thread# 1  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (8078ef0, 808bc28, 0) + 5e\n fdb2403f _cond_wait (8078ef0, 808bc28) + 64\n fdb24081 cond_wait (8078ef0, 808bc28) + 21\n fdb240ba pthread_cond_wait (8078ef0, 808bc28) + 1b\n fe7217b6 void decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,decaf::internal::util::concurrent::CompletionCondition&) (8078ef0, 808bc28, 8046e14) + 36\n fe71f400 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (808f8d0, 0, 0, 0, fe758acd) + 160\n fe758aeb void decaf::lang::Thread::join() (808ea18) + 2b\n fe56b727 void activemq::threads::DedicatedTaskRunner::shutdown() (808f788) + f7\n fe3f417a void activemq::core::ActiveMQSessionExecutor::stop() (808cb30) + 2da\n fe48af48 void activemq::core::kernels::ActiveMQSessionKernel::stop() (808c240) + 18\n fe44362a void activemq::core::kernels::ActiveMQConsumerKernel::setMessageListener(cms::MessageListener*) (80917d8, 8047384) + f2\n fe3aa8c3 void activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener*) (808f4e8, 8047384) + 73{color}\n 08055170 void SimpleAsyncConsumer::runConsumer() (8047380) + 610\n 080530d3 main     (1, 80474b8, 80474c0) + 2a3\n 08052d5a _start   (1, 8047618, 0, 804762e, 804763a, 8047674) + 7a\n-----------------  lwp# 10 / thread# 10  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f188, 808bc48, 0) + 5e\n fdb2403f _cond_wait (808f188, 808bc48) + 64\n fdb24081 cond_wait (808f188, 808bc48) + 21\n fdb240ba pthread_cond_wait (808f188, 808bc48) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f188, 808bc48) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c740, 808f8d0) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c740) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (808ec34) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd71fb84) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd71fb84, 808ec34, 1) + 43\n fe44b7a4 void activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808ebb8, fd71feb0) + 49c\n fe3f4371 void activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808cb30, fd71feb0) + 11d\n fe3f45be bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + a2\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (808f788) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (808ea18) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (808f8d0) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (808f8d0) + ee\n fdb28ffb _thr_setup (fd814200) + 4e\n fdb29300 _lwp_start (fd814200, 0, 0, fd71fff8, fdb29300, fd814200)\n-----------------  lwp# 11 / thread# 11  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f5d8, 808bbc8, 0) + 5e\n fdb2403f _cond_wait (808f5d8, 808bbc8) + 64\n fdb24081 cond_wait (808f5d8, 808bbc8) + 21\n fdb240ba pthread_cond_wait (808f5d8, 808bbc8) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f5d8, 808bbc8) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c7a0, 8093c18) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c7a0) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (80798b0) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd73fda4) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd73fda4, 80798b0, 1) + 43\n fe434d3d decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait() (fd73fdf0, 80798a8) + 31\n fe44e1cb bool activemq::core::kernels::ActiveMQConsumerKernel::iterate() (808ebb8) + bb\n fe48de0e bool activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers() (808c240) + 1b6\n fe3f4545 bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + 29\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (8091160) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (8092a88) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (8093c18) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (8093c18) + ee\n fdb28ffb _thr_setup (fd813a00) + 4e\n fdb29300 _lwp_start (fd813a00, 0, 0, fd73fff8, fdb29300, fd813a00)\n{panel}", "comments": [], "text": "setMessageListener on active session may leads to deadlock\n\nDescription:\nWhen we create a new *MessageConsumer* with a *MessageListener* from a session, the session will be stopped before the updates of the message listener and restarted afterward if the session already started.\nHowever, if there have more than one consumers already started; calling *ActiveMQSessionKernel::stop()* may goes into a deadlock if there have many messages coming in.\n\n{panel:title=Stack Trace when the sample program run into deadlock}\n26989:  ./SimpleAsyncConsumer\n-----------------  lwp# 1 / thread# 1  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (8078ef0, 808bc28, 0) + 5e\n fdb2403f _cond_wait (8078ef0, 808bc28) + 64\n fdb24081 cond_wait (8078ef0, 808bc28) + 21\n fdb240ba pthread_cond_wait (8078ef0, 808bc28) + 1b\n fe7217b6 void decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,decaf::internal::util::concurrent::CompletionCondition&) (8078ef0, 808bc28, 8046e14) + 36\n fe71f400 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (808f8d0, 0, 0, 0, fe758acd) + 160\n fe758aeb void decaf::lang::Thread::join() (808ea18) + 2b\n fe56b727 void activemq::threads::DedicatedTaskRunner::shutdown() (808f788) + f7\n fe3f417a void activemq::core::ActiveMQSessionExecutor::stop() (808cb30) + 2da\n fe48af48 void activemq::core::kernels::ActiveMQSessionKernel::stop() (808c240) + 18\n fe44362a void activemq::core::kernels::ActiveMQConsumerKernel::setMessageListener(cms::MessageListener*) (80917d8, 8047384) + f2\n fe3aa8c3 void activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener*) (808f4e8, 8047384) + 73{color}\n 08055170 void SimpleAsyncConsumer::runConsumer() (8047380) + 610\n 080530d3 main     (1, 80474b8, 80474c0) + 2a3\n 08052d5a _start   (1, 8047618, 0, 804762e, 804763a, 8047674) + 7a\n-----------------  lwp# 10 / thread# 10  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f188, 808bc48, 0) + 5e\n fdb2403f _cond_wait (808f188, 808bc48) + 64\n fdb24081 cond_wait (808f188, 808bc48) + 21\n fdb240ba pthread_cond_wait (808f188, 808bc48) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f188, 808bc48) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c740, 808f8d0) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c740) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (808ec34) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd71fb84) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd71fb84, 808ec34, 1) + 43\n fe44b7a4 void activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808ebb8, fd71feb0) + 49c\n fe3f4371 void activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808cb30, fd71feb0) + 11d\n fe3f45be bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + a2\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (808f788) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (808ea18) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (808f8d0) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (808f8d0) + ee\n fdb28ffb _thr_setup (fd814200) + 4e\n fdb29300 _lwp_start (fd814200, 0, 0, fd71fff8, fdb29300, fd814200)\n-----------------  lwp# 11 / thread# 11  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f5d8, 808bbc8, 0) + 5e\n fdb2403f _cond_wait (808f5d8, 808bbc8) + 64\n fdb24081 cond_wait (808f5d8, 808bbc8) + 21\n fdb240ba pthread_cond_wait (808f5d8, 808bbc8) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f5d8, 808bbc8) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c7a0, 8093c18) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c7a0) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (80798b0) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd73fda4) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd73fda4, 80798b0, 1) + 43\n fe434d3d decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait() (fd73fdf0, 80798a8) + 31\n fe44e1cb bool activemq::core::kernels::ActiveMQConsumerKernel::iterate() (808ebb8) + bb\n fe48de0e bool activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers() (808c240) + 1b6\n fe3f4545 bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + 29\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (8091160) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (8092a88) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (8093c18) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (8093c18) + ee\n fdb28ffb _thr_setup (fd813a00) + 4e\n fdb29300 _lwp_start (fd813a00, 0, 0, fd73fff8, fdb29300, fd813a00)\n{panel}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: setMessageListener on active session may leads to deadlock\n\nDescription:\nWhen we create a new *MessageConsumer* with a *MessageListener* from a session, the session will be stopped before the updates of the message listener and restarted afterward if the session already started.\nHowever, if there have more than one consumers already started; calling *ActiveMQSessionKernel::stop()* may goes into a deadlock if there have many messages coming in.\n\n{panel:title=Stack Trace when the sample program run into deadlock}\n26989:  ./SimpleAsyncConsumer\n-----------------  lwp# 1 / thread# 1  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (8078ef0, 808bc28, 0) + 5e\n fdb2403f _cond_wait (8078ef0, 808bc28) + 64\n fdb24081 cond_wait (8078ef0, 808bc28) + 21\n fdb240ba pthread_cond_wait (8078ef0, 808bc28) + 1b\n fe7217b6 void decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,decaf::internal::util::concurrent::CompletionCondition&) (8078ef0, 808bc28, 8046e14) + 36\n fe71f400 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (808f8d0, 0, 0, 0, fe758acd) + 160\n fe758aeb void decaf::lang::Thread::join() (808ea18) + 2b\n fe56b727 void activemq::threads::DedicatedTaskRunner::shutdown() (808f788) + f7\n fe3f417a void activemq::core::ActiveMQSessionExecutor::stop() (808cb30) + 2da\n fe48af48 void activemq::core::kernels::ActiveMQSessionKernel::stop() (808c240) + 18\n fe44362a void activemq::core::kernels::ActiveMQConsumerKernel::setMessageListener(cms::MessageListener*) (80917d8, 8047384) + f2\n fe3aa8c3 void activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener*) (808f4e8, 8047384) + 73{color}\n 08055170 void SimpleAsyncConsumer::runConsumer() (8047380) + 610\n 080530d3 main     (1, 80474b8, 80474c0) + 2a3\n 08052d5a _start   (1, 8047618, 0, 804762e, 804763a, 8047674) + 7a\n-----------------  lwp# 10 / thread# 10  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f188, 808bc48, 0) + 5e\n fdb2403f _cond_wait (808f188, 808bc48) + 64\n fdb24081 cond_wait (808f188, 808bc48) + 21\n fdb240ba pthread_cond_wait (808f188, 808bc48) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f188, 808bc48) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c740, 808f8d0) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c740) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (808ec34) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd71fb84) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd71fb84, 808ec34, 1) + 43\n fe44b7a4 void activemq::core::kernels::ActiveMQConsumerKernel::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808ebb8, fd71feb0) + 49c\n fe3f4371 void activemq::core::ActiveMQSessionExecutor::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>&) (808cb30, fd71feb0) + 11d\n fe3f45be bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + a2\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (808f788) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (808ea18) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (808f8d0) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (808f8d0) + ee\n fdb28ffb _thr_setup (fd814200) + 4e\n fdb29300 _lwp_start (fd814200, 0, 0, fd71fff8, fdb29300, fd814200)\n-----------------  lwp# 11 / thread# 11  --------------------\n{color:red} fdb29379 lwp_park (0, 0, 0)\n fdb23b6b cond_wait_queue (808f5d8, 808bbc8, 0) + 5e\n fdb2403f _cond_wait (808f5d8, 808bbc8) + 64\n fdb24081 cond_wait (808f5d8, 808bbc8) + 21\n fdb240ba pthread_cond_wait (808f5d8, 808bbc8) + 1b\n fe721666 void decaf::internal::util::concurrent::PlatformThread::waitOnCondition(_pthread_cond*,_pthread_mutex*) (808f5d8, 808bbc8) + 1e\n fe71dab3 void __unnamed_syh4PZ6vdUWCx::doMonitorEnter(decaf::internal::util::concurrent::MonitorHandle*,decaf::internal::util::concurrent::ThreadHandle*) (806c7a0, 8093c18) + 8f\n fe71fd0b void decaf::internal::util::concurrent::Threading::enterMonitor(decaf::internal::util::concurrent::MonitorHandle*) (806c7a0) + 27\n fe7aaa78 void decaf::util::concurrent::Mutex::lock() (80798b0) + 4c\n fe7aa2d4 void decaf::util::concurrent::Lock::lock() (fd73fda4) + 2c\n fe7aa023 decaf::util::concurrent::Lock::Lock #Nvariant 1(decaf::util::concurrent::Synchronizable*,const bool) (fd73fda4, 80798b0, 1) + 43\n fe434d3d decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter>activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait() (fd73fdf0, 80798a8) + 31\n fe44e1cb bool activemq::core::kernels::ActiveMQConsumerKernel::iterate() (808ebb8) + bb\n fe48de0e bool activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers() (808c240) + 1b6\n fe3f4545 bool activemq::core::ActiveMQSessionExecutor::iterate() (808cb30) + 29\n fe56b88a void activemq::threads::DedicatedTaskRunner::run() (8091160) + 8e{color}\n fe75889e void decaf::lang::Thread::run() (8092a88) + 1a\n fe71cfbb void __unnamed_syh4PZ6vdUWCx::runCallback(void*) (8093c18) + 2b\n fe71cf52 void*__unnamed_syh4PZ6vdUWCx::threadEntryMethod(void*) (8093c18) + ee\n fdb28ffb _thr_setup (fd813a00) + 4e\n fdb29300 _lwp_start (fd813a00, 0, 0, fd73fff8, fdb29300, fd813a00)\n{panel}\n\nComments:\n", "classification": "Classify the issue 'setMessageListener on active session may leads to deadlock' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-556?\nA: When we create a new *MessageConsumer* with a *MessageListener* from a session, the session will be stopped before the updates of the message listener and restarted afterward if the session already started.\nHowever, if there have more than one consumers already started; calling *ActiveMQSessionKernel::stop()* may goes into a deadlock if there have many messages coming in.\n\n{panel:title=Stack Trace"}}
{"issue_key": "AMQCPP-555", "project": "AMQCPP", "title": "AcE427", "status": "Closed", "reporter": "hossein mirzaeei", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2014-11-20T17:03:01.000+0000", "updated": "2014-11-24T17:40:06.000+0000", "description": "", "comments": [], "text": "AcE427\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AcE427\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'AcE427' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-555?\nA: "}}
{"issue_key": "AMQCPP-554", "project": "AMQCPP", "title": "Consumer close with INDIVIDUAL_ACKNOWLEDGE and dispatched messages doesn't rollback", "status": "Resolved", "reporter": "Kevin Urciolo", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-10-13T15:17:13.000+0000", "updated": "2015-07-17T14:17:13.000+0000", "description": "Messages are lost when the following is done:\n1.  Send message to queue ABC\n1.  Subscribe to queue ABC with INDIVIDUAL_ACKNOWLEDGE\n2.  Unsubscribe to queue ABC\n3.  Subscribe to queue ABC\n\nThe unsubscribe doesn't remove the message from the audit, so the resubscribe causes CMS to think the message is a duplicate, so it just acknowledges it without it ever getting delivered to a consumer.", "comments": [], "text": "Consumer close with INDIVIDUAL_ACKNOWLEDGE and dispatched messages doesn't rollback\n\nDescription:\nMessages are lost when the following is done:\n1.  Send message to queue ABC\n1.  Subscribe to queue ABC with INDIVIDUAL_ACKNOWLEDGE\n2.  Unsubscribe to queue ABC\n3.  Subscribe to queue ABC\n\nThe unsubscribe doesn't remove the message from the audit, so the resubscribe causes CMS to think the message is a duplicate, so it just acknowledges it without it ever getting delivered to a consumer.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consumer close with INDIVIDUAL_ACKNOWLEDGE and dispatched messages doesn't rollback\n\nDescription:\nMessages are lost when the following is done:\n1.  Send message to queue ABC\n1.  Subscribe to queue ABC with INDIVIDUAL_ACKNOWLEDGE\n2.  Unsubscribe to queue ABC\n3.  Subscribe to queue ABC\n\nThe unsubscribe doesn't remove the message from the audit, so the resubscribe causes CMS to think the message is a duplicate, so it just acknowledges it without it ever getting delivered to a consumer.\n\nComments:\n", "classification": "Classify the issue 'Consumer close with INDIVIDUAL_ACKNOWLEDGE and dispatched messages doesn't rollback' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-554?\nA: Messages are lost when the following is done:\n1.  Send message to queue ABC\n1.  Subscribe to queue ABC with INDIVIDUAL_ACKNOWLEDGE\n2.  Unsubscribe to queue ABC\n3.  Subscribe to queue ABC\n\nThe unsubscribe doesn't remove the message from the audit, so the resubscribe causes CMS to think the message is a duplicate, so it just acknowledges it without it ever getting delivered to a consumer."}}
{"issue_key": "AMQCPP-553", "project": "AMQCPP", "title": "Deadlock and memory leak under stress", "status": "Resolved", "reporter": "mephi42", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-10-09T17:48:02.000+0000", "updated": "2015-07-14T22:37:18.000+0000", "description": "Please have a look at the attached stress test. It consists of 12 reader threads, that create and destroy cms::MessageConsumers in a loop, and 4 writer threads, that send cms::TextMessages in a loop. Reader threads deadlock in less than 1 minute on my machine. To run it, simply issue\n\n{quote}\nmake test\n{quote}\n\nI traced the issue down to inconsistent mutex acquisition order by the following two threads:\n\n{quote}\nthread 7 (Thread 0x7fa691fce700 (LWP 28088))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa668007ff0, thread=0x7fa64c0071d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fcd6b0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc4da38 in activemq::core::kernels::ActiveMQConsumerKernel::dispatch (this=0x7fa680010a20, dispatch=...) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1527\n    #5  0x00007fa68fc06584 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x7fa65c005300, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:156\n    #6  0x00007fa68fc06f15 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:181\n    #7  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa64c004ab0) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for internal->listenerMutex, that is held by thread 6\n    Acquisition order:\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n        ActiveMQConsumerKernel::internal->listenerMutex\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $9 = 0x7fa691fbd700\n\n\n\nthread 6 (Thread 0x7fa691fbd700 (LWP 28091))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa6680071e0, thread=0x7fa6246a13d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fbc6f0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc3c21a in activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait (this=0x7fa68000eee0) at activemq/core/SimplePriorityMessageDispatchChannel.cpp:95\n    #5  0x00007fa68fc40f3c in activemq::core::kernels::ActiveMQConsumerKernel::iterate (this=0x7fa680010a20) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1701\n    #6  0x00007fa68fc8ab23 in activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers (this=0x7fa65c003960) at activemq/core/kernels/ActiveMQSessionKernel.cpp:1370\n    #7  0x00007fa68fc06eb9 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:173\n    #8  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa624603e00) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for mutex, that is held by thread 7\n    Acquisition order:\n        ActiveMQSessionKernel::config->consumerLock\n        ActiveMQConsumerKernel::internal->listenerMutex\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $10 = 0x7fa691fce700\n{quote}\n\nWith the attached patch, the stress test no longer deadlocks. However, it starts consuming memory in BitSet::ensureCapacity() via ActiveMQConnection::isDuplicate(). See attached massif output for details.", "comments": [], "text": "Deadlock and memory leak under stress\n\nDescription:\nPlease have a look at the attached stress test. It consists of 12 reader threads, that create and destroy cms::MessageConsumers in a loop, and 4 writer threads, that send cms::TextMessages in a loop. Reader threads deadlock in less than 1 minute on my machine. To run it, simply issue\n\n{quote}\nmake test\n{quote}\n\nI traced the issue down to inconsistent mutex acquisition order by the following two threads:\n\n{quote}\nthread 7 (Thread 0x7fa691fce700 (LWP 28088))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa668007ff0, thread=0x7fa64c0071d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fcd6b0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc4da38 in activemq::core::kernels::ActiveMQConsumerKernel::dispatch (this=0x7fa680010a20, dispatch=...) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1527\n    #5  0x00007fa68fc06584 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x7fa65c005300, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:156\n    #6  0x00007fa68fc06f15 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:181\n    #7  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa64c004ab0) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for internal->listenerMutex, that is held by thread 6\n    Acquisition order:\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n        ActiveMQConsumerKernel::internal->listenerMutex\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $9 = 0x7fa691fbd700\n\n\n\nthread 6 (Thread 0x7fa691fbd700 (LWP 28091))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa6680071e0, thread=0x7fa6246a13d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fbc6f0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc3c21a in activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait (this=0x7fa68000eee0) at activemq/core/SimplePriorityMessageDispatchChannel.cpp:95\n    #5  0x00007fa68fc40f3c in activemq::core::kernels::ActiveMQConsumerKernel::iterate (this=0x7fa680010a20) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1701\n    #6  0x00007fa68fc8ab23 in activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers (this=0x7fa65c003960) at activemq/core/kernels/ActiveMQSessionKernel.cpp:1370\n    #7  0x00007fa68fc06eb9 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:173\n    #8  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa624603e00) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for mutex, that is held by thread 7\n    Acquisition order:\n        ActiveMQSessionKernel::config->consumerLock\n        ActiveMQConsumerKernel::internal->listenerMutex\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $10 = 0x7fa691fce700\n{quote}\n\nWith the attached patch, the stress test no longer deadlocks. However, it starts consuming memory in BitSet::ensureCapacity() via ActiveMQConnection::isDuplicate(). See attached massif output for details.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock and memory leak under stress\n\nDescription:\nPlease have a look at the attached stress test. It consists of 12 reader threads, that create and destroy cms::MessageConsumers in a loop, and 4 writer threads, that send cms::TextMessages in a loop. Reader threads deadlock in less than 1 minute on my machine. To run it, simply issue\n\n{quote}\nmake test\n{quote}\n\nI traced the issue down to inconsistent mutex acquisition order by the following two threads:\n\n{quote}\nthread 7 (Thread 0x7fa691fce700 (LWP 28088))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa668007ff0, thread=0x7fa64c0071d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fcd6b0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc4da38 in activemq::core::kernels::ActiveMQConsumerKernel::dispatch (this=0x7fa680010a20, dispatch=...) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1527\n    #5  0x00007fa68fc06584 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x7fa65c005300, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:156\n    #6  0x00007fa68fc06f15 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:181\n    #7  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa64c004ab0) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for internal->listenerMutex, that is held by thread 6\n    Acquisition order:\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n        ActiveMQConsumerKernel::internal->listenerMutex\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $9 = 0x7fa691fbd700\n\n\n\nthread 6 (Thread 0x7fa691fbd700 (LWP 28091))\n\n    (gdb) bt\n    #0  0x00007fa68eb405bc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n    #1  0x00007fa68fea1c06 in (anonymous namespace)::doMonitorEnter (monitor=0x7fa6680071e0, thread=0x7fa6246a13d0) at decaf/internal/util/concurrent/Threading.cpp:664\n    #2  0x00007fa68ff15dcb in decaf::util::concurrent::Lock::lock (this=0x7fa691fbc6f0) at decaf/util/concurrent/Lock.cpp:54\n    #3  0x00007fa68ff15ee5 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>, intiallyLocked=<value optimized out>)\n        at decaf/util/concurrent/Lock.cpp:32\n    #4  0x00007fa68fc3c21a in activemq::core::SimplePriorityMessageDispatchChannel::dequeueNoWait (this=0x7fa68000eee0) at activemq/core/SimplePriorityMessageDispatchChannel.cpp:95\n    #5  0x00007fa68fc40f3c in activemq::core::kernels::ActiveMQConsumerKernel::iterate (this=0x7fa680010a20) at activemq/core/kernels/ActiveMQConsumerKernel.cpp:1701\n    #6  0x00007fa68fc8ab23 in activemq::core::kernels::ActiveMQSessionKernel::iterateConsumers (this=0x7fa65c003960) at activemq/core/kernels/ActiveMQSessionKernel.cpp:1370\n    #7  0x00007fa68fc06eb9 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x7fa65c005300) at activemq/core/ActiveMQSessionExecutor.cpp:173\n    #8  0x00007fa68fd3fdf5 in activemq::threads::DedicatedTaskRunner::run (this=0x7fa624603e00) at activemq/threads/DedicatedTaskRunner.cpp:141\n\n    Waiting for mutex, that is held by thread 7\n    Acquisition order:\n        ActiveMQSessionKernel::config->consumerLock\n        ActiveMQConsumerKernel::internal->listenerMutex\n        ActiveMQConsumerKernel::internal->unconsumedMessages\n\n    (gdb) frame 1\n    (gdb) p/x monitor->owner->handle\n    $10 = 0x7fa691fce700\n{quote}\n\nWith the attached patch, the stress test no longer deadlocks. However, it starts consuming memory in BitSet::ensureCapacity() via ActiveMQConnection::isDuplicate(). See attached massif output for details.\n\nComments:\n", "classification": "Classify the issue 'Deadlock and memory leak under stress' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-553?\nA: Please have a look at the attached stress test. It consists of 12 reader threads, that create and destroy cms::MessageConsumers in a loop, and 4 writer threads, that send cms::TextMessages in a loop. Reader threads deadlock in less than 1 minute on my machine. To run it, simply issue\n\n{quote}\nmake test\n{quote}\n\nI traced the issue down to inconsistent mutex acquisition order by the following two th"}}
{"issue_key": "AMQCPP-552", "project": "AMQCPP", "title": "Honor RedeliveryPolicy for message redelivered by the Broker.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-08-22T20:10:21.000+0000", "updated": "2015-07-28T21:16:55.000+0000", "description": "Port changes from AMQ-5146 which respects the redelivery maximum for messages that are dispatched to a consumer from the Broker.\n\n{noformat}\n\n\n    A consumer with a transacted session that dies after receive or in onMessage (due to some of the message content for example), but before the a transaction can complete will continue to receive the message.\n    The connection will die, the transaction will rollback, the broker will increment the redeliveryCounter and redispatch the message.\n    However the redeliveryPolicy, which is only checked on rollback (client side) will never kick in.\n    the result is infinite redelivery with an ever incrementing redeliveryCounter.\n    It is a reasonable expectation that this message would eventually find its way into the dlq.\n    The broker redelivery plugin does not help because it is triggered by the client side poison ack.\n\n    Either the broker redelivery plugin can get involved before dispatch, or a client can do a predispatch check.\n{noformat}", "comments": [], "text": "Honor RedeliveryPolicy for message redelivered by the Broker.\n\nDescription:\nPort changes from AMQ-5146 which respects the redelivery maximum for messages that are dispatched to a consumer from the Broker.\n\n{noformat}\n\n\n    A consumer with a transacted session that dies after receive or in onMessage (due to some of the message content for example), but before the a transaction can complete will continue to receive the message.\n    The connection will die, the transaction will rollback, the broker will increment the redeliveryCounter and redispatch the message.\n    However the redeliveryPolicy, which is only checked on rollback (client side) will never kick in.\n    the result is infinite redelivery with an ever incrementing redeliveryCounter.\n    It is a reasonable expectation that this message would eventually find its way into the dlq.\n    The broker redelivery plugin does not help because it is triggered by the client side poison ack.\n\n    Either the broker redelivery plugin can get involved before dispatch, or a client can do a predispatch check.\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Honor RedeliveryPolicy for message redelivered by the Broker.\n\nDescription:\nPort changes from AMQ-5146 which respects the redelivery maximum for messages that are dispatched to a consumer from the Broker.\n\n{noformat}\n\n\n    A consumer with a transacted session that dies after receive or in onMessage (due to some of the message content for example), but before the a transaction can complete will continue to receive the message.\n    The connection will die, the transaction will rollback, the broker will increment the redeliveryCounter and redispatch the message.\n    However the redeliveryPolicy, which is only checked on rollback (client side) will never kick in.\n    the result is infinite redelivery with an ever incrementing redeliveryCounter.\n    It is a reasonable expectation that this message would eventually find its way into the dlq.\n    The broker redelivery plugin does not help because it is triggered by the client side poison ack.\n\n    Either the broker redelivery plugin can get involved before dispatch, or a client can do a predispatch check.\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'Honor RedeliveryPolicy for message redelivered by the Broker.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-552?\nA: Port changes from AMQ-5146 which respects the redelivery maximum for messages that are dispatched to a consumer from the Broker.\n\n{noformat}\n\n\n    A consumer with a transacted session that dies after receive or in onMessage (due to some of the message content for example), but before the a transaction can complete will continue to receive the message.\n    The connection will die, the transaction w"}}
{"issue_key": "AMQCPP-551", "project": "AMQCPP", "title": "EOFException when sending char in MapMessage between Java and C++", "status": "Resolved", "reporter": "Pawel Remiszewski", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2014-08-21T10:49:49.000+0000", "updated": "2014-08-21T17:32:24.000+0000", "description": "Char values in MapMessage cause EOFException when sending message between Java and C++ (both ways).\nWhen sending messages with char values between Java <=> Java and c++ <=> c++ it works without errors.\n\nDon't know if the issue is in Java or c++ part, so I create 2 issues (one for Java ActiveMQ and one for C++)\n\nActiveMQ version used: 5.10.0\nActiveMQ-CPP version used: 3.8.3\n\nAlso tried with older (3.7.0) and the newest (master from GIT) version of ActiveMQ-CPP and the same error is thrown.\n\nScenario 1 (send message from Java to c++):\n1. when MapMessage contains only one char value, no exception is thrown on c++ side, but value is always equals to 0.\n2. when MapMessage contains char value and some additional values (no matter what type) EOF exception is thrown on c++ side.\n\nScenario 2 (send message from c++ to Java):\n1. when MapMessage contains at lease one char value, EOF exception is thrown on Java side.\n\nJava stacktrace:\n{noformat}\njavax.jms.JMSException: java.io.EOFException\n\tat org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:62)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:178)\n\tat org.apache.activemq.command.ActiveMQMapMessage.initializeReading(ActiveMQMapMessage.java:795)\n\tat org.apache.activemq.command.ActiveMQMapMessage.getMapNames(ActiveMQMapMessage.java:537)\n\tat activemq.test.TestConsumer.onMessage(TestConsumer.java:59)\n\tat activemq.test.TestConsumer.<init>(TestConsumer.java:39)\n\tat activemq.test.App.main(App.java:12)\nCaused by: java.io.EOFException\n\tat java.io.DataInputStream.readChar(DataInputStream.java:365)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitive(MarshallingSupport.java:175)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:98)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:78)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:70)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:174)\n\t... 5 more\n{noformat}", "comments": [], "text": "EOFException when sending char in MapMessage between Java and C++\n\nDescription:\nChar values in MapMessage cause EOFException when sending message between Java and C++ (both ways).\nWhen sending messages with char values between Java <=> Java and c++ <=> c++ it works without errors.\n\nDon't know if the issue is in Java or c++ part, so I create 2 issues (one for Java ActiveMQ and one for C++)\n\nActiveMQ version used: 5.10.0\nActiveMQ-CPP version used: 3.8.3\n\nAlso tried with older (3.7.0) and the newest (master from GIT) version of ActiveMQ-CPP and the same error is thrown.\n\nScenario 1 (send message from Java to c++):\n1. when MapMessage contains only one char value, no exception is thrown on c++ side, but value is always equals to 0.\n2. when MapMessage contains char value and some additional values (no matter what type) EOF exception is thrown on c++ side.\n\nScenario 2 (send message from c++ to Java):\n1. when MapMessage contains at lease one char value, EOF exception is thrown on Java side.\n\nJava stacktrace:\n{noformat}\njavax.jms.JMSException: java.io.EOFException\n\tat org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:62)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:178)\n\tat org.apache.activemq.command.ActiveMQMapMessage.initializeReading(ActiveMQMapMessage.java:795)\n\tat org.apache.activemq.command.ActiveMQMapMessage.getMapNames(ActiveMQMapMessage.java:537)\n\tat activemq.test.TestConsumer.onMessage(TestConsumer.java:59)\n\tat activemq.test.TestConsumer.<init>(TestConsumer.java:39)\n\tat activemq.test.App.main(App.java:12)\nCaused by: java.io.EOFException\n\tat java.io.DataInputStream.readChar(DataInputStream.java:365)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitive(MarshallingSupport.java:175)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:98)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:78)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:70)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:174)\n\t... 5 more\n{noformat}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: EOFException when sending char in MapMessage between Java and C++\n\nDescription:\nChar values in MapMessage cause EOFException when sending message between Java and C++ (both ways).\nWhen sending messages with char values between Java <=> Java and c++ <=> c++ it works without errors.\n\nDon't know if the issue is in Java or c++ part, so I create 2 issues (one for Java ActiveMQ and one for C++)\n\nActiveMQ version used: 5.10.0\nActiveMQ-CPP version used: 3.8.3\n\nAlso tried with older (3.7.0) and the newest (master from GIT) version of ActiveMQ-CPP and the same error is thrown.\n\nScenario 1 (send message from Java to c++):\n1. when MapMessage contains only one char value, no exception is thrown on c++ side, but value is always equals to 0.\n2. when MapMessage contains char value and some additional values (no matter what type) EOF exception is thrown on c++ side.\n\nScenario 2 (send message from c++ to Java):\n1. when MapMessage contains at lease one char value, EOF exception is thrown on Java side.\n\nJava stacktrace:\n{noformat}\njavax.jms.JMSException: java.io.EOFException\n\tat org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:62)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:178)\n\tat org.apache.activemq.command.ActiveMQMapMessage.initializeReading(ActiveMQMapMessage.java:795)\n\tat org.apache.activemq.command.ActiveMQMapMessage.getMapNames(ActiveMQMapMessage.java:537)\n\tat activemq.test.TestConsumer.onMessage(TestConsumer.java:59)\n\tat activemq.test.TestConsumer.<init>(TestConsumer.java:39)\n\tat activemq.test.App.main(App.java:12)\nCaused by: java.io.EOFException\n\tat java.io.DataInputStream.readChar(DataInputStream.java:365)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitive(MarshallingSupport.java:175)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:98)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:78)\n\tat org.apache.activemq.util.MarshallingSupport.unmarshalPrimitiveMap(MarshallingSupport.java:70)\n\tat org.apache.activemq.command.ActiveMQMapMessage.loadContent(ActiveMQMapMessage.java:174)\n\t... 5 more\n{noformat}\n\nComments:\n", "classification": "Classify the issue 'EOFException when sending char in MapMessage between Java and C++' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-551?\nA: Char values in MapMessage cause EOFException when sending message between Java and C++ (both ways).\nWhen sending messages with char values between Java <=> Java and c++ <=> c++ it works without errors.\n\nDon't know if the issue is in Java or c++ part, so I create 2 issues (one for Java ActiveMQ and one for C++)\n\nActiveMQ version used: 5.10.0\nActiveMQ-CPP version used: 3.8.3\n\nAlso tried with older ("}}
{"issue_key": "AMQCPP-550", "project": "AMQCPP", "title": "CMS (C++ client) crashed if getLocalHost failed", "status": "Resolved", "reporter": "Huan Bui", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2014-08-20T18:39:42.000+0000", "updated": "2014-08-20T20:31:05.000+0000", "description": "CMS (C++ client) crashed when calling ActiveMQ::initializeLibrary().  Here is the backtrace from gdb\n\n#0 decaf::net::InetAddress::getLocalHost () at decaf/net/InetAddress.cpp:174\n#1 0x00007f071766247b in IdGeneratorKernel (this=0x31de9d0) at activemq/util/IdGenerator.cpp:60\n#2 activemq::util::IdGenerator::initialize () at activemq/util/IdGenerator.cpp:169\n#3 0x000000000043fe30 in main ()\napr_sockaddr_info_get returned APR_SUCCESS but address is NULL causing the segfault at InetAddress.cpp line 174.", "comments": [], "text": "CMS (C++ client) crashed if getLocalHost failed\n\nDescription:\nCMS (C++ client) crashed when calling ActiveMQ::initializeLibrary().  Here is the backtrace from gdb\n\n#0 decaf::net::InetAddress::getLocalHost () at decaf/net/InetAddress.cpp:174\n#1 0x00007f071766247b in IdGeneratorKernel (this=0x31de9d0) at activemq/util/IdGenerator.cpp:60\n#2 activemq::util::IdGenerator::initialize () at activemq/util/IdGenerator.cpp:169\n#3 0x000000000043fe30 in main ()\napr_sockaddr_info_get returned APR_SUCCESS but address is NULL causing the segfault at InetAddress.cpp line 174.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS (C++ client) crashed if getLocalHost failed\n\nDescription:\nCMS (C++ client) crashed when calling ActiveMQ::initializeLibrary().  Here is the backtrace from gdb\n\n#0 decaf::net::InetAddress::getLocalHost () at decaf/net/InetAddress.cpp:174\n#1 0x00007f071766247b in IdGeneratorKernel (this=0x31de9d0) at activemq/util/IdGenerator.cpp:60\n#2 activemq::util::IdGenerator::initialize () at activemq/util/IdGenerator.cpp:169\n#3 0x000000000043fe30 in main ()\napr_sockaddr_info_get returned APR_SUCCESS but address is NULL causing the segfault at InetAddress.cpp line 174.\n\nComments:\n", "classification": "Classify the issue 'CMS (C++ client) crashed if getLocalHost failed' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-550?\nA: CMS (C++ client) crashed when calling ActiveMQ::initializeLibrary().  Here is the backtrace from gdb\n\n#0 decaf::net::InetAddress::getLocalHost () at decaf/net/InetAddress.cpp:174\n#1 0x00007f071766247b in IdGeneratorKernel (this=0x31de9d0) at activemq/util/IdGenerator.cpp:60\n#2 activemq::util::IdGenerator::initialize () at activemq/util/IdGenerator.cpp:169\n#3 0x000000000043fe30 in main ()\napr_socka"}}
{"issue_key": "AMQCPP-549", "project": "AMQCPP", "title": "Potential memory leak in consumer when delivering delayed ack.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-08-14T16:47:08.000+0000", "updated": "2015-01-29T02:35:50.000+0000", "description": "Leak reported on User list:\n\n{quote}\n==7369== 2,604 (48 direct, 2,556 indirect) bytes in 1 blocks are definitely\nlost in loss record 1,819 of 2,022\n==7369==    at 0x4A084CC: operator new(unsigned long)\n(vg_replace_malloc.c:298)\n==7369==    by 0xF9CD8A1: decaf::util::concurrent::Future<bool>*\ndecaf::util::concurrent::ExecutorService::submit<bool>(decaf::lang::Runnable*,\nbool const&, bool) (FutureTask.h:408)\n==7369==    by 0xF9B9CBB:\nactivemq::core::kernels::ActiveMQConsumerKernel::deliverAcks()\n(ActiveMQConsumerKernel.cpp:1257)\n==7369==    by 0xF9BAB04:\nactivemq::core::kernels::ActiveMQConsumerKernel::dispose()\n(ActiveMQConsumerKernel.cpp:845)\n==7369==    by 0xF9EFC53:\nactivemq::core::kernels::ActiveMQSessionKernel::dispose()\n(ActiveMQSessionKernel.cpp:379)\n==7369==    by 0xF9F09A8:\nactivemq::core::kernels::ActiveMQSessionKernel::doClose()\n(ActiveMQSessionKernel.cpp:306)\n==7369==    by 0xF9F103F:\nactivemq::core::kernels::ActiveMQSessionKernel::close()\n(ActiveMQSessionKernel.cpp:296)\n==7369==    by 0xF962466: activemq::core::ActiveMQSession::close()\n(ActiveMQSession.cpp:62)\n{quote}", "comments": [], "text": "Potential memory leak in consumer when delivering delayed ack.\n\nDescription:\nLeak reported on User list:\n\n{quote}\n==7369== 2,604 (48 direct, 2,556 indirect) bytes in 1 blocks are definitely\nlost in loss record 1,819 of 2,022\n==7369==    at 0x4A084CC: operator new(unsigned long)\n(vg_replace_malloc.c:298)\n==7369==    by 0xF9CD8A1: decaf::util::concurrent::Future<bool>*\ndecaf::util::concurrent::ExecutorService::submit<bool>(decaf::lang::Runnable*,\nbool const&, bool) (FutureTask.h:408)\n==7369==    by 0xF9B9CBB:\nactivemq::core::kernels::ActiveMQConsumerKernel::deliverAcks()\n(ActiveMQConsumerKernel.cpp:1257)\n==7369==    by 0xF9BAB04:\nactivemq::core::kernels::ActiveMQConsumerKernel::dispose()\n(ActiveMQConsumerKernel.cpp:845)\n==7369==    by 0xF9EFC53:\nactivemq::core::kernels::ActiveMQSessionKernel::dispose()\n(ActiveMQSessionKernel.cpp:379)\n==7369==    by 0xF9F09A8:\nactivemq::core::kernels::ActiveMQSessionKernel::doClose()\n(ActiveMQSessionKernel.cpp:306)\n==7369==    by 0xF9F103F:\nactivemq::core::kernels::ActiveMQSessionKernel::close()\n(ActiveMQSessionKernel.cpp:296)\n==7369==    by 0xF962466: activemq::core::ActiveMQSession::close()\n(ActiveMQSession.cpp:62)\n{quote}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Potential memory leak in consumer when delivering delayed ack.\n\nDescription:\nLeak reported on User list:\n\n{quote}\n==7369== 2,604 (48 direct, 2,556 indirect) bytes in 1 blocks are definitely\nlost in loss record 1,819 of 2,022\n==7369==    at 0x4A084CC: operator new(unsigned long)\n(vg_replace_malloc.c:298)\n==7369==    by 0xF9CD8A1: decaf::util::concurrent::Future<bool>*\ndecaf::util::concurrent::ExecutorService::submit<bool>(decaf::lang::Runnable*,\nbool const&, bool) (FutureTask.h:408)\n==7369==    by 0xF9B9CBB:\nactivemq::core::kernels::ActiveMQConsumerKernel::deliverAcks()\n(ActiveMQConsumerKernel.cpp:1257)\n==7369==    by 0xF9BAB04:\nactivemq::core::kernels::ActiveMQConsumerKernel::dispose()\n(ActiveMQConsumerKernel.cpp:845)\n==7369==    by 0xF9EFC53:\nactivemq::core::kernels::ActiveMQSessionKernel::dispose()\n(ActiveMQSessionKernel.cpp:379)\n==7369==    by 0xF9F09A8:\nactivemq::core::kernels::ActiveMQSessionKernel::doClose()\n(ActiveMQSessionKernel.cpp:306)\n==7369==    by 0xF9F103F:\nactivemq::core::kernels::ActiveMQSessionKernel::close()\n(ActiveMQSessionKernel.cpp:296)\n==7369==    by 0xF962466: activemq::core::ActiveMQSession::close()\n(ActiveMQSession.cpp:62)\n{quote}\n\n\nComments:\n", "classification": "Classify the issue 'Potential memory leak in consumer when delivering delayed ack.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-549?\nA: Leak reported on User list:\n\n{quote}\n==7369== 2,604 (48 direct, 2,556 indirect) bytes in 1 blocks are definitely\nlost in loss record 1,819 of 2,022\n==7369==    at 0x4A084CC: operator new(unsigned long)\n(vg_replace_malloc.c:298)\n==7369==    by 0xF9CD8A1: decaf::util::concurrent::Future<bool>*\ndecaf::util::concurrent::ExecutorService::submit<bool>(decaf::lang::Runnable*,\nbool const&, bool) (FutureTa"}}
{"issue_key": "AMQCPP-548", "project": "AMQCPP", "title": "Too many  temporary std::string in Mutex and decaf::lang::Integer::toString(int)", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-07-18T02:35:09.000+0000", "updated": "2014-08-06T22:34:06.000+0000", "description": "Every Mutex will associated with a MutexProperties and the name of the Mutex is actually generated by the DEFAULT_NAME_PREFIX plus a call to Integer::toString( ++id ).\n\nFrom the profiling of our application (highly multi-threaded), we found that many times are spent in the std::basic_string allocation and deallocation inside the functions decaf::lang::Integer::toString(int) and decaf::lang::Integer::toString(int, int).", "comments": [], "text": "Too many  temporary std::string in Mutex and decaf::lang::Integer::toString(int)\n\nDescription:\nEvery Mutex will associated with a MutexProperties and the name of the Mutex is actually generated by the DEFAULT_NAME_PREFIX plus a call to Integer::toString( ++id ).\n\nFrom the profiling of our application (highly multi-threaded), we found that many times are spent in the std::basic_string allocation and deallocation inside the functions decaf::lang::Integer::toString(int) and decaf::lang::Integer::toString(int, int).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Too many  temporary std::string in Mutex and decaf::lang::Integer::toString(int)\n\nDescription:\nEvery Mutex will associated with a MutexProperties and the name of the Mutex is actually generated by the DEFAULT_NAME_PREFIX plus a call to Integer::toString( ++id ).\n\nFrom the profiling of our application (highly multi-threaded), we found that many times are spent in the std::basic_string allocation and deallocation inside the functions decaf::lang::Integer::toString(int) and decaf::lang::Integer::toString(int, int).\n\nComments:\n", "classification": "Classify the issue 'Too many  temporary std::string in Mutex and decaf::lang::Integer::toString(int)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-548?\nA: Every Mutex will associated with a MutexProperties and the name of the Mutex is actually generated by the DEFAULT_NAME_PREFIX plus a call to Integer::toString( ++id ).\n\nFrom the profiling of our application (highly multi-threaded), we found that many times are spent in the std::basic_string allocation and deallocation inside the functions decaf::lang::Integer::toString(int) and decaf::lang::Intege"}}
{"issue_key": "AMQCPP-547", "project": "AMQCPP", "title": "activemq::core::ConnectionAudit::isDuplicate is not thread safe", "status": "Closed", "reporter": "Lyubov Romachuk", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2014-07-09T12:18:55.000+0000", "updated": "2014-07-09T12:56:17.000+0000", "description": "We use ActiveMQ C++ 3.8.2 client in a multi-threaded application. \nThe application crashed because activemq::core::ConnectionAudit::isDuplicate doesn't synchronize access to the activemq::core::ConnectionAuditImpl::destinations and activemq::core::ConnectionAuditImpl::dispatchers which are shared and destinations,dispatchers itself are not thread-safe.", "comments": [], "text": "activemq::core::ConnectionAudit::isDuplicate is not thread safe\n\nDescription:\nWe use ActiveMQ C++ 3.8.2 client in a multi-threaded application. \nThe application crashed because activemq::core::ConnectionAudit::isDuplicate doesn't synchronize access to the activemq::core::ConnectionAuditImpl::destinations and activemq::core::ConnectionAuditImpl::dispatchers which are shared and destinations,dispatchers itself are not thread-safe. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq::core::ConnectionAudit::isDuplicate is not thread safe\n\nDescription:\nWe use ActiveMQ C++ 3.8.2 client in a multi-threaded application. \nThe application crashed because activemq::core::ConnectionAudit::isDuplicate doesn't synchronize access to the activemq::core::ConnectionAuditImpl::destinations and activemq::core::ConnectionAuditImpl::dispatchers which are shared and destinations,dispatchers itself are not thread-safe. \n\nComments:\n", "classification": "Classify the issue 'activemq::core::ConnectionAudit::isDuplicate is not thread safe' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-547?\nA: We use ActiveMQ C++ 3.8.2 client in a multi-threaded application. \nThe application crashed because activemq::core::ConnectionAudit::isDuplicate doesn't synchronize access to the activemq::core::ConnectionAuditImpl::destinations and activemq::core::ConnectionAuditImpl::dispatchers which are shared and destinations,dispatchers itself are not thread-safe. "}}
{"issue_key": "AMQCPP-546", "project": "AMQCPP", "title": "ConnetionAudit should be thread safe", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-07-08T20:54:02.000+0000", "updated": "2014-07-09T12:56:17.000+0000", "description": "The duplicate detection methods in ConnectionAudit.cpp lack synchronized blocks to protect mutable state.", "comments": [], "text": "ConnetionAudit should be thread safe\n\nDescription:\nThe duplicate detection methods in ConnectionAudit.cpp lack synchronized blocks to protect mutable state.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ConnetionAudit should be thread safe\n\nDescription:\nThe duplicate detection methods in ConnectionAudit.cpp lack synchronized blocks to protect mutable state.  \n\nComments:\n", "classification": "Classify the issue 'ConnetionAudit should be thread safe' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-546?\nA: The duplicate detection methods in ConnectionAudit.cpp lack synchronized blocks to protect mutable state.  "}}
{"issue_key": "AMQCPP-545", "project": "AMQCPP", "title": "Failover transport timeout options should only operate on Message sends.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2014-06-18T18:13:15.000+0000", "updated": "2014-06-18T18:36:59.000+0000", "description": "To prevent connection attempts from failing the Failover transport should only apply the timeout option to sends of Message types as the over commands are governed by other configuration options.  \n\nCurrently a timeout set on failover can override the behaviour given by maxReconnectAttempts which is quite confusing.", "comments": [], "text": "Failover transport timeout options should only operate on Message sends.\n\nDescription:\nTo prevent connection attempts from failing the Failover transport should only apply the timeout option to sends of Message types as the over commands are governed by other configuration options.  \n\nCurrently a timeout set on failover can override the behaviour given by maxReconnectAttempts which is quite confusing.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover transport timeout options should only operate on Message sends.\n\nDescription:\nTo prevent connection attempts from failing the Failover transport should only apply the timeout option to sends of Message types as the over commands are governed by other configuration options.  \n\nCurrently a timeout set on failover can override the behaviour given by maxReconnectAttempts which is quite confusing.  \n\nComments:\n", "classification": "Classify the issue 'Failover transport timeout options should only operate on Message sends.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-545?\nA: To prevent connection attempts from failing the Failover transport should only apply the timeout option to sends of Message types as the over commands are governed by other configuration options.  \n\nCurrently a timeout set on failover can override the behaviour given by maxReconnectAttempts which is quite confusing.  "}}
{"issue_key": "AMQCPP-544", "project": "AMQCPP", "title": "decaf Lock::lock() triggering ABRT within destructors", "status": "Closed", "reporter": "Geoff Simmons", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-05-20T16:03:07.000+0000", "updated": "2015-07-16T17:22:15.000+0000", "description": "We are experiencing SIGABRTs during attempts to disconnect a client from the broker by calling the destructor of ActiveMQConnection.\n\nHere's the portion of the stack trace that includes activemq-cpp code:\n\n{noformat}\n(gdb) bt\n#3  <signal handler called>\n#4  0x00007f98ce2fe925 in raise () from /lib64/libc.so.6\n#5  0x00007f98ce300105 in abort () from /lib64/libc.so.6\n#6  0x00007f98cafd1a5d in __gnu_cxx::__verbose_terminate_handler() ()\n   from /usr/lib64/libstdc++.so.6\n#7  0x00007f98cafcfbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#8  0x00007f98cafcfc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#9  0x00007f98cafd053f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#10 0x00007f98cd891e8b in decaf::util::concurrent::Lock::lock() ()\n   from /usr/lib64/libactivemq-cpp.so.18\n#11 0x00007f98cd891fa5 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) () from /usr/lib64/libactivemq-cpp.so.18\n#12 0x00007f98cd538d0d in activemq::core::ConnectionConfig::~ConnectionConfig()\n    () from /usr/lib64/libactivemq-cpp.so.18\n#13 0x00007f98cd4f39c2 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n#14 0x00007f98cd4f3b69 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n{noformat}\n\nThe call to {{__cxa_pure_virtual()}} in frame 9 indicates that {{decaf::util::concurrent::Lock::lock()}} is calling a pure virtual function. Since this is happening within destructor calls (of both ActiveMQConnection and ConnectionConfig), it has evidently triggered std::terminate from libstdc++, and hence the abort.", "comments": [], "text": "decaf Lock::lock() triggering ABRT within destructors\n\nDescription:\nWe are experiencing SIGABRTs during attempts to disconnect a client from the broker by calling the destructor of ActiveMQConnection.\n\nHere's the portion of the stack trace that includes activemq-cpp code:\n\n{noformat}\n(gdb) bt\n#3  <signal handler called>\n#4  0x00007f98ce2fe925 in raise () from /lib64/libc.so.6\n#5  0x00007f98ce300105 in abort () from /lib64/libc.so.6\n#6  0x00007f98cafd1a5d in __gnu_cxx::__verbose_terminate_handler() ()\n   from /usr/lib64/libstdc++.so.6\n#7  0x00007f98cafcfbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#8  0x00007f98cafcfc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#9  0x00007f98cafd053f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#10 0x00007f98cd891e8b in decaf::util::concurrent::Lock::lock() ()\n   from /usr/lib64/libactivemq-cpp.so.18\n#11 0x00007f98cd891fa5 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) () from /usr/lib64/libactivemq-cpp.so.18\n#12 0x00007f98cd538d0d in activemq::core::ConnectionConfig::~ConnectionConfig()\n    () from /usr/lib64/libactivemq-cpp.so.18\n#13 0x00007f98cd4f39c2 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n#14 0x00007f98cd4f3b69 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n{noformat}\n\nThe call to {{__cxa_pure_virtual()}} in frame 9 indicates that {{decaf::util::concurrent::Lock::lock()}} is calling a pure virtual function. Since this is happening within destructor calls (of both ActiveMQConnection and ConnectionConfig), it has evidently triggered std::terminate from libstdc++, and hence the abort.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf Lock::lock() triggering ABRT within destructors\n\nDescription:\nWe are experiencing SIGABRTs during attempts to disconnect a client from the broker by calling the destructor of ActiveMQConnection.\n\nHere's the portion of the stack trace that includes activemq-cpp code:\n\n{noformat}\n(gdb) bt\n#3  <signal handler called>\n#4  0x00007f98ce2fe925 in raise () from /lib64/libc.so.6\n#5  0x00007f98ce300105 in abort () from /lib64/libc.so.6\n#6  0x00007f98cafd1a5d in __gnu_cxx::__verbose_terminate_handler() ()\n   from /usr/lib64/libstdc++.so.6\n#7  0x00007f98cafcfbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#8  0x00007f98cafcfc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#9  0x00007f98cafd053f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#10 0x00007f98cd891e8b in decaf::util::concurrent::Lock::lock() ()\n   from /usr/lib64/libactivemq-cpp.so.18\n#11 0x00007f98cd891fa5 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) () from /usr/lib64/libactivemq-cpp.so.18\n#12 0x00007f98cd538d0d in activemq::core::ConnectionConfig::~ConnectionConfig()\n    () from /usr/lib64/libactivemq-cpp.so.18\n#13 0x00007f98cd4f39c2 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n#14 0x00007f98cd4f3b69 in activemq::core::ActiveMQConnection::~ActiveMQConnection() () from /usr/lib64/libactivemq-cpp.so.18\n{noformat}\n\nThe call to {{__cxa_pure_virtual()}} in frame 9 indicates that {{decaf::util::concurrent::Lock::lock()}} is calling a pure virtual function. Since this is happening within destructor calls (of both ActiveMQConnection and ConnectionConfig), it has evidently triggered std::terminate from libstdc++, and hence the abort.\n\nComments:\n", "classification": "Classify the issue 'decaf Lock::lock() triggering ABRT within destructors' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-544?\nA: We are experiencing SIGABRTs during attempts to disconnect a client from the broker by calling the destructor of ActiveMQConnection.\n\nHere's the portion of the stack trace that includes activemq-cpp code:\n\n{noformat}\n(gdb) bt\n#3  <signal handler called>\n#4  0x00007f98ce2fe925 in raise () from /lib64/libc.so.6\n#5  0x00007f98ce300105 in abort () from /lib64/libc.so.6\n#6  0x00007f98cafd1a5d in __gnu_"}}
{"issue_key": "AMQCPP-543", "project": "AMQCPP", "title": "message producer send never blocking when using producer flow control", "status": "Resolved", "reporter": "Christian Mamen", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2014-05-14T16:31:06.000+0000", "updated": "2014-08-14T22:12:12.000+0000", "description": "For testing, \nmessage producer is set to non-persisted mode, with the connection producer window size to 1MB. (the broker enables the producer flow control and set the memory limit to ~10MB with vm only storage)\n\nI notice that when i don't have any message consumer, the broker notify me that the memory limit is reached, that the producer will be throttled (as i would expect), however the producer never blocks on a send, as if the window size has no effect.\n\nwhile digging into ActiveMQProducerKernel.cpp,\nI notice the private member memoryUsage (auto_ptr) is never initialized. and there's a TODO in the code ?\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n}\n{code}\n\nI tried initializing the memoryUsage, and producer seem to block as expected on a send, when the limit is reached.\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n\n    if (session->getConnection()->getProducerWindowSize()) { \n            this->memoryUsage.reset( new MemoryUsage(session->getConnection()->getProducerWindowSize()) );\n    }\n}\n{code}\n\nI'm not sure what is the proper fix,", "comments": [], "text": "message producer send never blocking when using producer flow control\n\nDescription:\nFor testing, \nmessage producer is set to non-persisted mode, with the connection producer window size to 1MB. (the broker enables the producer flow control and set the memory limit to ~10MB with vm only storage)\n\nI notice that when i don't have any message consumer, the broker notify me that the memory limit is reached, that the producer will be throttled (as i would expect), however the producer never blocks on a send, as if the window size has no effect.\n\nwhile digging into ActiveMQProducerKernel.cpp,\nI notice the private member memoryUsage (auto_ptr) is never initialized. and there's a TODO in the code ?\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n}\n{code}\n\nI tried initializing the memoryUsage, and producer seem to block as expected on a send, when the limit is reached.\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n\n    if (session->getConnection()->getProducerWindowSize()) { \n            this->memoryUsage.reset( new MemoryUsage(session->getConnection()->getProducerWindowSize()) );\n    }\n}\n{code}\n\nI'm not sure what is the proper fix,\n\n\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: message producer send never blocking when using producer flow control\n\nDescription:\nFor testing, \nmessage producer is set to non-persisted mode, with the connection producer window size to 1MB. (the broker enables the producer flow control and set the memory limit to ~10MB with vm only storage)\n\nI notice that when i don't have any message consumer, the broker notify me that the memory limit is reached, that the producer will be throttled (as i would expect), however the producer never blocks on a send, as if the window size has no effect.\n\nwhile digging into ActiveMQProducerKernel.cpp,\nI notice the private member memoryUsage (auto_ptr) is never initialized. and there's a TODO in the code ?\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n}\n{code}\n\nI tried initializing the memoryUsage, and producer seem to block as expected on a send, when the limit is reached.\n{code}\nActiveMQProducerKernel::ActiveMQProducerKernel(\n\n[...]\n\n    // TODO - Check for need of MemoryUsage if there's a producer Windows size\n    //        and the Protocol version is greater than 3.\n\n    if (session->getConnection()->getProducerWindowSize()) { \n            this->memoryUsage.reset( new MemoryUsage(session->getConnection()->getProducerWindowSize()) );\n    }\n}\n{code}\n\nI'm not sure what is the proper fix,\n\n\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'message producer send never blocking when using producer flow control' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-543?\nA: For testing, \nmessage producer is set to non-persisted mode, with the connection producer window size to 1MB. (the broker enables the producer flow control and set the memory limit to ~10MB with vm only storage)\n\nI notice that when i don't have any message consumer, the broker notify me that the memory limit is reached, that the producer will be throttled (as i would expect), however the producer "}}
{"issue_key": "AMQCPP-542", "project": "AMQCPP", "title": "pre-processor defs are off for windows visual studio compilation with SSL", "status": "Closed", "reporter": "Eyal Zaidman", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-05-07T15:11:01.000+0000", "updated": "2014-08-11T14:31:34.000+0000", "description": "Trying to build some of the DLL versions (SSL enabled) fails to create an import library due to faulty pre-processor defs. Here is the current list:\n\nDebug\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nDebug SSL\t\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\nDebug DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nDebug DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nRelease\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nRelease SSL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC;HAVE_OPENSSL\nRelease DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nRelease DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nDebug SSL, Debug DLL SSL and Release DLL SSL try to use \"PreprocessorDefinitions\" but should in fact contain a full option line like Release SSL", "comments": [], "text": "pre-processor defs are off for windows visual studio compilation with SSL\n\nDescription:\nTrying to build some of the DLL versions (SSL enabled) fails to create an import library due to faulty pre-processor defs. Here is the current list:\n\nDebug\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nDebug SSL\t\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\nDebug DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nDebug DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nRelease\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nRelease SSL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC;HAVE_OPENSSL\nRelease DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nRelease DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nDebug SSL, Debug DLL SSL and Release DLL SSL try to use \"PreprocessorDefinitions\" but should in fact contain a full option line like Release SSL\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: pre-processor defs are off for windows visual studio compilation with SSL\n\nDescription:\nTrying to build some of the DLL versions (SSL enabled) fails to create an import library due to faulty pre-processor defs. Here is the current list:\n\nDebug\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nDebug SSL\t\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\nDebug DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nDebug DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nRelease\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nRelease SSL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC;HAVE_OPENSSL\nRelease DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_WINDOWS;_USRDLL;CMS_DLL;CMS_EXPORTS;AMQCPP_DLL;AMQCPP_EXPORTS;DECAF_DLL;DECAF_EXPORTS\nRelease DLL SSL\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\n\nDebug SSL, Debug DLL SSL and Release DLL SSL try to use \"PreprocessorDefinitions\" but should in fact contain a full option line like Release SSL\n\nComments:\n", "classification": "Classify the issue 'pre-processor defs are off for windows visual studio compilation with SSL' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-542?\nA: Trying to build some of the DLL versions (SSL enabled) fails to create an import library due to faulty pre-processor defs. Here is the current list:\n\nDebug\t\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;APR_DECLARE_STATIC;APU_DECLARE_STATIC;API_DECLARE_STATIC\nDebug SSL\t\t- HAVE_OPENSSL;%(PreprocessorDefinitions)\nDebug DLL\t\t- WIN32;NDEBUG;_LIB;WIN32_LEAN_AND_MEAN;_CRT_SE"}}
{"issue_key": "AMQCPP-541", "project": "AMQCPP", "title": "Crash found when closing ActiveMQConnection", "status": "Closed", "reporter": "Shirley Lee", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2014-05-05T08:20:48.000+0000", "updated": "2014-05-05T10:10:25.000+0000", "description": "We encounter a crash with activemq-cpp-library 3.4.5 when we are closing the ActiveMQ connection. It seems that an un-expected exception is thrown when LinkedList object's destructor is called. We are wondering what the root cause might be and if it is fixed in the new version of activemq-cpp-library.\n\n======== crash report ===============\nCrashed Thread:  0  Dispatch queue: com.apple.main-thread\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\n\nApplication Specific Information:\nabort() called\nterminate called throwing an exception\nobjc[59690]: garbage collection is OFF\n\nThread 0 Crashed:: Dispatch queue: com.apple.main-thread\n0   libsystem_kernel.dylib        \t0x933e19c6 __pthread_kill + 10\n1   libsystem_c.dylib             \t0x96153f78 pthread_kill + 106\n2   libsystem_c.dylib             \t0x96144bdd abort + 167\n3   libc++abi.dylib               \t0x90401921 abort_message + 94\n4   libc++abi.dylib               \t0x903ff1bc default_terminate() + 36\n5   libc++abi.dylib               \t0x903ff1fe safe_handler_caller(void ( * )()) + 15\n6   libc++abi.dylib               \t0x903ff1e1 unexpected_defaults_to_terminate() + 23\n7   libc++abi.dylib               \t0x903ff246 __cxxabiv1::__unexpected(void ( * )()) + 16\n8   libc++abi.dylib               \t0x90400071 __cxa_call_unexpected + 58\n9   libAMQCPipe.dylib             \t0x011d4aae decaf::util::LinkedList<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::~LinkedList() + 1086\n10  libAMQCPipe.dylib             \t0x011ca0d8 activemq::transport::failover::CloseTransportsTask::~CloseTransportsTask() + 40\n11  libAMQCPipe.dylib             \t0x011bbce9 activemq::transport::failover::BackupTransportPool::~BackupTransportPool() + 249\n12  libAMQCPipe.dylib             \t0x011da6d9 activemq::transport::failover::FailoverTransport::~FailoverTransport() + 729\n13  libAMQCPipe.dylib             \t0x011b359f activemq::transport::TransportFilter::~TransportFilter() + 95\n14  libAMQCPipe.dylib             \t0x011b89ae activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator() + 110\n15  libAMQCPipe.dylib             \t0x010dcd79 activemq::core::ActiveMQConnection::disconnect(long long) + 905\n16  libAMQCPipe.dylib             \t0x010e11dd activemq::core::ActiveMQConnection::close() + 365", "comments": [], "text": "Crash found when closing ActiveMQConnection\n\nDescription:\nWe encounter a crash with activemq-cpp-library 3.4.5 when we are closing the ActiveMQ connection. It seems that an un-expected exception is thrown when LinkedList object's destructor is called. We are wondering what the root cause might be and if it is fixed in the new version of activemq-cpp-library.\n\n======== crash report ===============\nCrashed Thread:  0  Dispatch queue: com.apple.main-thread\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\n\nApplication Specific Information:\nabort() called\nterminate called throwing an exception\nobjc[59690]: garbage collection is OFF\n\nThread 0 Crashed:: Dispatch queue: com.apple.main-thread\n0   libsystem_kernel.dylib        \t0x933e19c6 __pthread_kill + 10\n1   libsystem_c.dylib             \t0x96153f78 pthread_kill + 106\n2   libsystem_c.dylib             \t0x96144bdd abort + 167\n3   libc++abi.dylib               \t0x90401921 abort_message + 94\n4   libc++abi.dylib               \t0x903ff1bc default_terminate() + 36\n5   libc++abi.dylib               \t0x903ff1fe safe_handler_caller(void ( * )()) + 15\n6   libc++abi.dylib               \t0x903ff1e1 unexpected_defaults_to_terminate() + 23\n7   libc++abi.dylib               \t0x903ff246 __cxxabiv1::__unexpected(void ( * )()) + 16\n8   libc++abi.dylib               \t0x90400071 __cxa_call_unexpected + 58\n9   libAMQCPipe.dylib             \t0x011d4aae decaf::util::LinkedList<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::~LinkedList() + 1086\n10  libAMQCPipe.dylib             \t0x011ca0d8 activemq::transport::failover::CloseTransportsTask::~CloseTransportsTask() + 40\n11  libAMQCPipe.dylib             \t0x011bbce9 activemq::transport::failover::BackupTransportPool::~BackupTransportPool() + 249\n12  libAMQCPipe.dylib             \t0x011da6d9 activemq::transport::failover::FailoverTransport::~FailoverTransport() + 729\n13  libAMQCPipe.dylib             \t0x011b359f activemq::transport::TransportFilter::~TransportFilter() + 95\n14  libAMQCPipe.dylib             \t0x011b89ae activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator() + 110\n15  libAMQCPipe.dylib             \t0x010dcd79 activemq::core::ActiveMQConnection::disconnect(long long) + 905\n16  libAMQCPipe.dylib             \t0x010e11dd activemq::core::ActiveMQConnection::close() + 365\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash found when closing ActiveMQConnection\n\nDescription:\nWe encounter a crash with activemq-cpp-library 3.4.5 when we are closing the ActiveMQ connection. It seems that an un-expected exception is thrown when LinkedList object's destructor is called. We are wondering what the root cause might be and if it is fixed in the new version of activemq-cpp-library.\n\n======== crash report ===============\nCrashed Thread:  0  Dispatch queue: com.apple.main-thread\n\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\n\nApplication Specific Information:\nabort() called\nterminate called throwing an exception\nobjc[59690]: garbage collection is OFF\n\nThread 0 Crashed:: Dispatch queue: com.apple.main-thread\n0   libsystem_kernel.dylib        \t0x933e19c6 __pthread_kill + 10\n1   libsystem_c.dylib             \t0x96153f78 pthread_kill + 106\n2   libsystem_c.dylib             \t0x96144bdd abort + 167\n3   libc++abi.dylib               \t0x90401921 abort_message + 94\n4   libc++abi.dylib               \t0x903ff1bc default_terminate() + 36\n5   libc++abi.dylib               \t0x903ff1fe safe_handler_caller(void ( * )()) + 15\n6   libc++abi.dylib               \t0x903ff1e1 unexpected_defaults_to_terminate() + 23\n7   libc++abi.dylib               \t0x903ff246 __cxxabiv1::__unexpected(void ( * )()) + 16\n8   libc++abi.dylib               \t0x90400071 __cxa_call_unexpected + 58\n9   libAMQCPipe.dylib             \t0x011d4aae decaf::util::LinkedList<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::~LinkedList() + 1086\n10  libAMQCPipe.dylib             \t0x011ca0d8 activemq::transport::failover::CloseTransportsTask::~CloseTransportsTask() + 40\n11  libAMQCPipe.dylib             \t0x011bbce9 activemq::transport::failover::BackupTransportPool::~BackupTransportPool() + 249\n12  libAMQCPipe.dylib             \t0x011da6d9 activemq::transport::failover::FailoverTransport::~FailoverTransport() + 729\n13  libAMQCPipe.dylib             \t0x011b359f activemq::transport::TransportFilter::~TransportFilter() + 95\n14  libAMQCPipe.dylib             \t0x011b89ae activemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator() + 110\n15  libAMQCPipe.dylib             \t0x010dcd79 activemq::core::ActiveMQConnection::disconnect(long long) + 905\n16  libAMQCPipe.dylib             \t0x010e11dd activemq::core::ActiveMQConnection::close() + 365\n\n\nComments:\n", "classification": "Classify the issue 'Crash found when closing ActiveMQConnection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-541?\nA: We encounter a crash with activemq-cpp-library 3.4.5 when we are closing the ActiveMQ connection. It seems that an un-expected exception is thrown when LinkedList object's destructor is called. We are wondering what the root cause might be and if it is fixed in the new version of activemq-cpp-library.\n\n======== crash report ===============\nCrashed Thread:  0  Dispatch queue: com.apple.main-thread\n"}}
{"issue_key": "AMQCPP-540", "project": "AMQCPP", "title": "Ambiguous usage of Math::min in AbstractDiscoveryAgent.cpp", "status": "Resolved", "reporter": "Valeriy V. Argunov", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-04-25T11:42:33.000+0000", "updated": "2014-04-28T14:50:33.000+0000", "description": "Here is a patch.", "comments": [], "text": "Ambiguous usage of Math::min in AbstractDiscoveryAgent.cpp\n\nDescription:\nHere is a patch.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Ambiguous usage of Math::min in AbstractDiscoveryAgent.cpp\n\nDescription:\nHere is a patch.\n\nComments:\n", "classification": "Classify the issue 'Ambiguous usage of Math::min in AbstractDiscoveryAgent.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-540?\nA: Here is a patch."}}
{"issue_key": "AMQCPP-539", "project": "AMQCPP", "title": "Can't build GIT master on MSVC", "status": "Resolved", "reporter": "Valeriy V. Argunov", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-04-25T11:09:09.000+0000", "updated": "2014-04-28T14:50:49.000+0000", "description": "PlatformDefs.h for Windows defines only PLATFORM_DEFAULT_STACK_SIZE, but PlatformThread.cpp tries to use PLATFORM_MIN_STACK_SIZE.\nHere is a patch.", "comments": [], "text": "Can't build GIT master on MSVC\n\nDescription:\nPlatformDefs.h for Windows defines only PLATFORM_DEFAULT_STACK_SIZE, but PlatformThread.cpp tries to use PLATFORM_MIN_STACK_SIZE.\nHere is a patch.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't build GIT master on MSVC\n\nDescription:\nPlatformDefs.h for Windows defines only PLATFORM_DEFAULT_STACK_SIZE, but PlatformThread.cpp tries to use PLATFORM_MIN_STACK_SIZE.\nHere is a patch.\n\nComments:\n", "classification": "Classify the issue 'Can't build GIT master on MSVC' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-539?\nA: PlatformDefs.h for Windows defines only PLATFORM_DEFAULT_STACK_SIZE, but PlatformThread.cpp tries to use PLATFORM_MIN_STACK_SIZE.\nHere is a patch."}}
{"issue_key": "AMQCPP-538", "project": "AMQCPP", "title": "Catch exception by value in FailoverTransport", "status": "Resolved", "reporter": "Carl Sung", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2014-04-16T05:39:02.000+0000", "updated": "2014-04-16T10:19:11.000+0000", "description": "In line 753 of FailoverTransport.cpp, it catches Exception by value, where I think is meant to catch by reference", "comments": [], "text": "Catch exception by value in FailoverTransport\n\nDescription:\nIn line 753 of FailoverTransport.cpp, it catches Exception by value, where I think is meant to catch by reference\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Catch exception by value in FailoverTransport\n\nDescription:\nIn line 753 of FailoverTransport.cpp, it catches Exception by value, where I think is meant to catch by reference\n\nComments:\n", "classification": "Classify the issue 'Catch exception by value in FailoverTransport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-538?\nA: In line 753 of FailoverTransport.cpp, it catches Exception by value, where I think is meant to catch by reference"}}
{"issue_key": "AMQCPP-537", "project": "AMQCPP", "title": "CLONE - verify the admin login functionality using login credentials", "status": "Closed", "reporter": "ram", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["easytest", "features"], "created": "2014-04-01T09:40:50.000+0000", "updated": "2014-06-18T18:08:50.000+0000", "description": "verify that adminstrator login functionality  successfully", "comments": [], "text": "CLONE - verify the admin login functionality using login credentials\n\nDescription:\nverify that adminstrator login functionality  successfully\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CLONE - verify the admin login functionality using login credentials\n\nDescription:\nverify that adminstrator login functionality  successfully\n\n\nComments:\n", "classification": "Classify the issue 'CLONE - verify the admin login functionality using login credentials' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-537?\nA: verify that adminstrator login functionality  successfully\n"}}
{"issue_key": "AMQCPP-536", "project": "AMQCPP", "title": "verify the admin login functionality using login credentials", "status": "Closed", "reporter": "ram", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["easytest", "features"], "created": "2014-04-01T09:32:31.000+0000", "updated": "2014-07-08T16:11:54.000+0000", "description": "verify that adminstrator login functionality  successfully", "comments": [], "text": "verify the admin login functionality using login credentials\n\nDescription:\nverify that adminstrator login functionality  successfully\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: verify the admin login functionality using login credentials\n\nDescription:\nverify that adminstrator login functionality  successfully\n\n\nComments:\n", "classification": "Classify the issue 'verify the admin login functionality using login credentials' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-536?\nA: verify that adminstrator login functionality  successfully\n"}}
{"issue_key": "AMQCPP-535", "project": "AMQCPP", "title": "Activemq session commit, not working as expected.", "status": "Closed", "reporter": "D V Gangadhar Rao", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-02-25T14:09:56.000+0000", "updated": "2014-02-28T04:34:57.000+0000", "description": "Tested with AMQ CMS CPP 3.8.2 client \n\nProducer has opened the session in SESSION_TRANSACTED mode.\nIt has sent a set of messages to the destination activemq broker.\nThe producer did a commit on the session, which resulted in only committing only a subset of messages in the destination queue and remaining messages are not commited in case of a scenario where there was a queue full exception. \n\nExpected behavior:\nActually we were expecting that session commit call should either commit the whole batch of messages or rollback the entire batch of messages if the queue is FULL on the destination broker queue, but it should not commit few messages and rollback the other messages.", "comments": [], "text": "Activemq session commit, not working as expected.\n\nDescription:\nTested with AMQ CMS CPP 3.8.2 client \n\nProducer has opened the session in SESSION_TRANSACTED mode.\nIt has sent a set of messages to the destination activemq broker.\nThe producer did a commit on the session, which resulted in only committing only a subset of messages in the destination queue and remaining messages are not commited in case of a scenario where there was a queue full exception. \n\nExpected behavior:\nActually we were expecting that session commit call should either commit the whole batch of messages or rollback the entire batch of messages if the queue is FULL on the destination broker queue, but it should not commit few messages and rollback the other messages. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Activemq session commit, not working as expected.\n\nDescription:\nTested with AMQ CMS CPP 3.8.2 client \n\nProducer has opened the session in SESSION_TRANSACTED mode.\nIt has sent a set of messages to the destination activemq broker.\nThe producer did a commit on the session, which resulted in only committing only a subset of messages in the destination queue and remaining messages are not commited in case of a scenario where there was a queue full exception. \n\nExpected behavior:\nActually we were expecting that session commit call should either commit the whole batch of messages or rollback the entire batch of messages if the queue is FULL on the destination broker queue, but it should not commit few messages and rollback the other messages. \n\nComments:\n", "classification": "Classify the issue 'Activemq session commit, not working as expected.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-535?\nA: Tested with AMQ CMS CPP 3.8.2 client \n\nProducer has opened the session in SESSION_TRANSACTED mode.\nIt has sent a set of messages to the destination activemq broker.\nThe producer did a commit on the session, which resulted in only committing only a subset of messages in the destination queue and remaining messages are not commited in case of a scenario where there was a queue full exception. \n\nExpe"}}
{"issue_key": "AMQCPP-534", "project": "AMQCPP", "title": "Closing connection with setTransportListener to NULL may cause core dump", "status": "Resolved", "reporter": "Jeremy Leung", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-02-20T01:31:54.000+0000", "updated": "2015-02-16T02:50:29.000+0000", "description": "This happen in random; and will cause core dump under Solaris 10.\n\n{panel:title=Core dump happened on thread #22 which is a thread for IO for activemq|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\nt@22 (l@22) terminated by signal SEGV (no mapping at the fault address)\n0xfcbef02c: onCommand+0x0370:   movl     (%edi),%eax\n(dbx) where -h\ncurrent thread: t@22\n=>[1] activemq::transport::failover::FailoverTransportListener::onCommand(0x1c20d280, 0xfa567ce0), at 0xfcbef02c\n  [2] activemq::transport::TransportFilter::onCommand(0x116c3700, 0xfa567d20), at 0xfcb7ae15\n  [3] activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(0x116c3700, 0xfa567d70), at 0xfcc5ff05\n  [4] activemq::transport::TransportFilter::onCommand(0x10bdaaa0, 0xfa567de0), at 0xfcb7ae15\n  [5] activemq::transport::inactivity::InactivityMonitor::onCommand(0x10bdaaa0, 0xfa567e40), at 0xfcbf69f7\n  [6] activemq::transport::TransportFilter::onCommand(0x1027cbc0, 0xfa567e90), at 0xfcb7ae15\n  [7] activemq::transport::IOTransport::fire(0x1bbc4ab8, 0xfa567ef0), at 0xfcb78a49\n  [8] activemq::transport::IOTransport::run(0x1bbc4ab8), at 0xfcb79827\n  [9] decaf::lang::Thread::run(0x1c2080a0), at 0xfcd58512\n  [10] __unnamed_syh4P47F8S2uD::runCallback(0x1c21c138), at 0xfcd1cc2f\n  [11] __unnamed_syh4P47F8S2uD::threadEntryMethod(0x1c21c138), at 0xfcd1cbc6\n  [12] _thr_setup(0xfac2a200), at 0xfc0771c0\n  [13] _lwp_start(), at 0xfc0774b0\n{noformat}\n{panel}\n\n{panel:title=Stack trace for the main thread|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\n-----------------  lwp# 1 / thread# 1  --------------------\n fc07750b __lwp_park (163995d8, 1bbc1e10, 8046358) + b\n fc071d07 cond_wait_queue (163995d8, 1bbc1e10, 8046358) + 5e\n fc072084 cond_wait_common (163995d8, 1bbc1e10, 8046358) + 1db\n fc0722b6 _cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 51\n fc072321 cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 24\n fc07235d pthread_cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 1e\n fcd21550 bool decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,long long,int,decaf::internal::util::concurrent::CompletionCondition&) (163995d8, 1bbc1e10, 493e0, 0, 0, 8046434) + 110\n fcd1f051 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (1bbe5660, 493e0, 0, 0, fcd5877a) + 13d\n fcd587a0 void decaf::lang::Thread::join(long long) (1c20d270, 493e0, 0) + 38\n fcb61945 void activemq::threads::CompositeTaskRunner::shutdown(long long) (f3b1730, 493e0, 0) + e5\n fcbd26d3 void activemq::transport::failover::FailoverTransport::close() (efde3f8) + 327\n fcb7b799 void activemq::transport::TransportFilter::close() (118b49e0) + 191\n fc940003 void activemq::core::ActiveMQConnection::disconnect(long long) (eef0fb8, 0, 0) + 52f\n fc93c3f3 void activemq::core::ActiveMQConnection::close() (eef0fb8) + b47\n 0888e6ec main     (7, 80475dc, 80475fc) + 149\n 0888dd6a _start   (7, 9e7dafc, 804775d, 8047760, 8047769, 804777f) + 7a\n{noformat}\n{panel}\n\nThis is happen only during the disconnect. So, what i suspected is that there have an concurrent issue between the ActiveMQConnection, TransportFilter, FailoverTransportListener.\n\nAs i dig into the code, i see during the disconnection, the transport listener will being set to NULL at the very first stage. However, the another thread may have access to the pointer of the null transport listener as the NULL check is not thread safe.\n\n{noformat}\nvoid ActiveMQConnection::disconnect(long long lastDeliveredSequenceId) {\n\n    try {\n\n        // Clear the listener, we don't care about async errors at this point.\n        this->config->transport->setTransportListener(NULL);\n\n        [...]\n{noformat}\n\n{noformat}\nvoid FailoverTransportListener::onCommand(const Pointer<Command> command) {\n\n    if (command == NULL) {\n        return;\n    }\n\n    if (command->isResponse()) {\n        Pointer<Response> response = command.dynamicCast<Response>();\n        parent->processResponse(response);\n    }\n\n    if (!parent->isInitialized()) {\n        parent->setInitialized(true);\n    }\n\n    if (command->isConnectionControl()) {\n        parent->handleConnectionControl(command);\n    }\n\n    if (parent->getTransportListener() != NULL) {\n        parent->getTransportListener()->onCommand(command);\n    }\n}\n{noformat}\n\n{noformat}\nvoid TransportFilter::onCommand(const Pointer<Command> command) {\n\n    if (!this->impl->started.get() || this->impl->closed.get()) {\n        return;\n    }\n\n    try {\n        if (this->listener != NULL) {\n            this->listener->onCommand(command);\n        }\n    } catch (...) {\n    }\n}\n{noformat}", "comments": [], "text": "Closing connection with setTransportListener to NULL may cause core dump\n\nDescription:\nThis happen in random; and will cause core dump under Solaris 10.\n\n{panel:title=Core dump happened on thread #22 which is a thread for IO for activemq|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\nt@22 (l@22) terminated by signal SEGV (no mapping at the fault address)\n0xfcbef02c: onCommand+0x0370:   movl     (%edi),%eax\n(dbx) where -h\ncurrent thread: t@22\n=>[1] activemq::transport::failover::FailoverTransportListener::onCommand(0x1c20d280, 0xfa567ce0), at 0xfcbef02c\n  [2] activemq::transport::TransportFilter::onCommand(0x116c3700, 0xfa567d20), at 0xfcb7ae15\n  [3] activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(0x116c3700, 0xfa567d70), at 0xfcc5ff05\n  [4] activemq::transport::TransportFilter::onCommand(0x10bdaaa0, 0xfa567de0), at 0xfcb7ae15\n  [5] activemq::transport::inactivity::InactivityMonitor::onCommand(0x10bdaaa0, 0xfa567e40), at 0xfcbf69f7\n  [6] activemq::transport::TransportFilter::onCommand(0x1027cbc0, 0xfa567e90), at 0xfcb7ae15\n  [7] activemq::transport::IOTransport::fire(0x1bbc4ab8, 0xfa567ef0), at 0xfcb78a49\n  [8] activemq::transport::IOTransport::run(0x1bbc4ab8), at 0xfcb79827\n  [9] decaf::lang::Thread::run(0x1c2080a0), at 0xfcd58512\n  [10] __unnamed_syh4P47F8S2uD::runCallback(0x1c21c138), at 0xfcd1cc2f\n  [11] __unnamed_syh4P47F8S2uD::threadEntryMethod(0x1c21c138), at 0xfcd1cbc6\n  [12] _thr_setup(0xfac2a200), at 0xfc0771c0\n  [13] _lwp_start(), at 0xfc0774b0\n{noformat}\n{panel}\n\n{panel:title=Stack trace for the main thread|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\n-----------------  lwp# 1 / thread# 1  --------------------\n fc07750b __lwp_park (163995d8, 1bbc1e10, 8046358) + b\n fc071d07 cond_wait_queue (163995d8, 1bbc1e10, 8046358) + 5e\n fc072084 cond_wait_common (163995d8, 1bbc1e10, 8046358) + 1db\n fc0722b6 _cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 51\n fc072321 cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 24\n fc07235d pthread_cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 1e\n fcd21550 bool decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,long long,int,decaf::internal::util::concurrent::CompletionCondition&) (163995d8, 1bbc1e10, 493e0, 0, 0, 8046434) + 110\n fcd1f051 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (1bbe5660, 493e0, 0, 0, fcd5877a) + 13d\n fcd587a0 void decaf::lang::Thread::join(long long) (1c20d270, 493e0, 0) + 38\n fcb61945 void activemq::threads::CompositeTaskRunner::shutdown(long long) (f3b1730, 493e0, 0) + e5\n fcbd26d3 void activemq::transport::failover::FailoverTransport::close() (efde3f8) + 327\n fcb7b799 void activemq::transport::TransportFilter::close() (118b49e0) + 191\n fc940003 void activemq::core::ActiveMQConnection::disconnect(long long) (eef0fb8, 0, 0) + 52f\n fc93c3f3 void activemq::core::ActiveMQConnection::close() (eef0fb8) + b47\n 0888e6ec main     (7, 80475dc, 80475fc) + 149\n 0888dd6a _start   (7, 9e7dafc, 804775d, 8047760, 8047769, 804777f) + 7a\n{noformat}\n{panel}\n\nThis is happen only during the disconnect. So, what i suspected is that there have an concurrent issue between the ActiveMQConnection, TransportFilter, FailoverTransportListener.\n\nAs i dig into the code, i see during the disconnection, the transport listener will being set to NULL at the very first stage. However, the another thread may have access to the pointer of the null transport listener as the NULL check is not thread safe.\n\n{noformat}\nvoid ActiveMQConnection::disconnect(long long lastDeliveredSequenceId) {\n\n    try {\n\n        // Clear the listener, we don't care about async errors at this point.\n        this->config->transport->setTransportListener(NULL);\n\n        [...]\n{noformat}\n\n{noformat}\nvoid FailoverTransportListener::onCommand(const Pointer<Command> command) {\n\n    if (command == NULL) {\n        return;\n    }\n\n    if (command->isResponse()) {\n        Pointer<Response> response = command.dynamicCast<Response>();\n        parent->processResponse(response);\n    }\n\n    if (!parent->isInitialized()) {\n        parent->setInitialized(true);\n    }\n\n    if (command->isConnectionControl()) {\n        parent->handleConnectionControl(command);\n    }\n\n    if (parent->getTransportListener() != NULL) {\n        parent->getTransportListener()->onCommand(command);\n    }\n}\n{noformat}\n\n{noformat}\nvoid TransportFilter::onCommand(const Pointer<Command> command) {\n\n    if (!this->impl->started.get() || this->impl->closed.get()) {\n        return;\n    }\n\n    try {\n        if (this->listener != NULL) {\n            this->listener->onCommand(command);\n        }\n    } catch (...) {\n    }\n}\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Closing connection with setTransportListener to NULL may cause core dump\n\nDescription:\nThis happen in random; and will cause core dump under Solaris 10.\n\n{panel:title=Core dump happened on thread #22 which is a thread for IO for activemq|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\nt@22 (l@22) terminated by signal SEGV (no mapping at the fault address)\n0xfcbef02c: onCommand+0x0370:   movl     (%edi),%eax\n(dbx) where -h\ncurrent thread: t@22\n=>[1] activemq::transport::failover::FailoverTransportListener::onCommand(0x1c20d280, 0xfa567ce0), at 0xfcbef02c\n  [2] activemq::transport::TransportFilter::onCommand(0x116c3700, 0xfa567d20), at 0xfcb7ae15\n  [3] activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(0x116c3700, 0xfa567d70), at 0xfcc5ff05\n  [4] activemq::transport::TransportFilter::onCommand(0x10bdaaa0, 0xfa567de0), at 0xfcb7ae15\n  [5] activemq::transport::inactivity::InactivityMonitor::onCommand(0x10bdaaa0, 0xfa567e40), at 0xfcbf69f7\n  [6] activemq::transport::TransportFilter::onCommand(0x1027cbc0, 0xfa567e90), at 0xfcb7ae15\n  [7] activemq::transport::IOTransport::fire(0x1bbc4ab8, 0xfa567ef0), at 0xfcb78a49\n  [8] activemq::transport::IOTransport::run(0x1bbc4ab8), at 0xfcb79827\n  [9] decaf::lang::Thread::run(0x1c2080a0), at 0xfcd58512\n  [10] __unnamed_syh4P47F8S2uD::runCallback(0x1c21c138), at 0xfcd1cc2f\n  [11] __unnamed_syh4P47F8S2uD::threadEntryMethod(0x1c21c138), at 0xfcd1cbc6\n  [12] _thr_setup(0xfac2a200), at 0xfc0771c0\n  [13] _lwp_start(), at 0xfc0774b0\n{noformat}\n{panel}\n\n{panel:title=Stack trace for the main thread|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\n-----------------  lwp# 1 / thread# 1  --------------------\n fc07750b __lwp_park (163995d8, 1bbc1e10, 8046358) + b\n fc071d07 cond_wait_queue (163995d8, 1bbc1e10, 8046358) + 5e\n fc072084 cond_wait_common (163995d8, 1bbc1e10, 8046358) + 1db\n fc0722b6 _cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 51\n fc072321 cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 24\n fc07235d pthread_cond_timedwait (163995d8, 1bbc1e10, 80463c8) + 1e\n fcd21550 bool decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(_pthread_cond*,_pthread_mutex*,long long,int,decaf::internal::util::concurrent::CompletionCondition&) (163995d8, 1bbc1e10, 493e0, 0, 0, 8046434) + 110\n fcd1f051 bool decaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle*,long long,int) (1bbe5660, 493e0, 0, 0, fcd5877a) + 13d\n fcd587a0 void decaf::lang::Thread::join(long long) (1c20d270, 493e0, 0) + 38\n fcb61945 void activemq::threads::CompositeTaskRunner::shutdown(long long) (f3b1730, 493e0, 0) + e5\n fcbd26d3 void activemq::transport::failover::FailoverTransport::close() (efde3f8) + 327\n fcb7b799 void activemq::transport::TransportFilter::close() (118b49e0) + 191\n fc940003 void activemq::core::ActiveMQConnection::disconnect(long long) (eef0fb8, 0, 0) + 52f\n fc93c3f3 void activemq::core::ActiveMQConnection::close() (eef0fb8) + b47\n 0888e6ec main     (7, 80475dc, 80475fc) + 149\n 0888dd6a _start   (7, 9e7dafc, 804775d, 8047760, 8047769, 804777f) + 7a\n{noformat}\n{panel}\n\nThis is happen only during the disconnect. So, what i suspected is that there have an concurrent issue between the ActiveMQConnection, TransportFilter, FailoverTransportListener.\n\nAs i dig into the code, i see during the disconnection, the transport listener will being set to NULL at the very first stage. However, the another thread may have access to the pointer of the null transport listener as the NULL check is not thread safe.\n\n{noformat}\nvoid ActiveMQConnection::disconnect(long long lastDeliveredSequenceId) {\n\n    try {\n\n        // Clear the listener, we don't care about async errors at this point.\n        this->config->transport->setTransportListener(NULL);\n\n        [...]\n{noformat}\n\n{noformat}\nvoid FailoverTransportListener::onCommand(const Pointer<Command> command) {\n\n    if (command == NULL) {\n        return;\n    }\n\n    if (command->isResponse()) {\n        Pointer<Response> response = command.dynamicCast<Response>();\n        parent->processResponse(response);\n    }\n\n    if (!parent->isInitialized()) {\n        parent->setInitialized(true);\n    }\n\n    if (command->isConnectionControl()) {\n        parent->handleConnectionControl(command);\n    }\n\n    if (parent->getTransportListener() != NULL) {\n        parent->getTransportListener()->onCommand(command);\n    }\n}\n{noformat}\n\n{noformat}\nvoid TransportFilter::onCommand(const Pointer<Command> command) {\n\n    if (!this->impl->started.get() || this->impl->closed.get()) {\n        return;\n    }\n\n    try {\n        if (this->listener != NULL) {\n            this->listener->onCommand(command);\n        }\n    } catch (...) {\n    }\n}\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'Closing connection with setTransportListener to NULL may cause core dump' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-534?\nA: This happen in random; and will cause core dump under Solaris 10.\n\n{panel:title=Core dump happened on thread #22 which is a thread for IO for activemq|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE}\n{noformat}\nt@22 (l@22) terminated by signal SEGV (no mapping at the fault address)\n0xfcbef02c: onCommand+0x0370:   movl     (%edi),%eax\n(dbx) where -h\ncurrent thread: t@22\n=>["}}
{"issue_key": "AMQCPP-533", "project": "AMQCPP", "title": "Memory leak in StompWireFormat.cpp", "status": "Resolved", "reporter": "Vince Hurrell", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-02-19T15:53:39.000+0000", "updated": "2014-02-19T19:24:04.000+0000", "description": "Here is the afflicted code:\n\n{code}\n    try {\n        Pointer<ActiveMQBytesMessage> bytesMessage = message.dynamicCast<ActiveMQBytesMessage>();\n        frame->setBody(bytesMessage->getBodyBytes(), bytesMessage->getBodyLength());\n        frame->setProperty(StompCommandConstants::HEADER_CONTENTLENGTH, Long::toString(bytesMessage->getBodyLength()));\n        return frame;\n    } catch (ClassCastException& ex) {\n    }\n{code}\n\nThe return from getBodyBytes is passed to the frame, which then accepts the contents of the buffer and copies it into a vector.  As the documentation for getBodyBytes indicates, freeing of the data returned by the function is the responsibility of the caller.\n\nHere is the valgrind output showing the leak:\n\n{noformat}\n==10913== 7,492 bytes in 276 blocks are definitely lost in loss record 89 of 90\n==10913==    at 0x4C28152: operator new[](unsigned long) (vg_replace_malloc.c:363)\n==10913==    by 0xED1EAF: activemq::commands::ActiveMQBytesMessage::getBodyBytes() const (ActiveMQBytesMessage.cpp:148)\n==10913==    by 0x10D6068: activemq::wireformat::stomp::StompWireFormat::marshalMessage(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (StompWireFormat.cpp:369)\n==10913==    by 0x10D7624: activemq::wireformat::stomp::StompWireFormat::marshal(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, activemq::transport::Transport const*, decaf::io::DataOutputStream*) (StompWireFormat.cpp:131)\n==10913==    by 0x1061F74: activemq::transport::IOTransport::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (IOTransport.cpp:146)\n==10913==    by 0x1094D21: activemq::transport::TransportFilter::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (TransportFilter.h:118)\n==10913==    by 0x108E2CA: activemq::transport::inactivity::InactivityMonitor::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (InactivityMonitor.cpp:366)\n==10913==    by 0x1067DEB: activemq::transport::correlator::ResponseCorrelator::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::lang::Pointer<activemq::transport::ResponseCallback, decaf::util::concurrent::atomic::AtomicRefCounter>) (ResponseCorrelator.cpp:170)\n==10913==    by 0xCFF44E: activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) (ActiveMQConnection.cpp:1304)\n==10913==    by 0xDC19C7: activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) (ActiveMQSessionKernel.cpp:1007)\n==10913==    by 0xDAE98F: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:269)\n==10913==    by 0xDAB644: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:149)\n{noformat}", "comments": [], "text": "Memory leak in StompWireFormat.cpp\n\nDescription:\nHere is the afflicted code:\n\n{code}\n    try {\n        Pointer<ActiveMQBytesMessage> bytesMessage = message.dynamicCast<ActiveMQBytesMessage>();\n        frame->setBody(bytesMessage->getBodyBytes(), bytesMessage->getBodyLength());\n        frame->setProperty(StompCommandConstants::HEADER_CONTENTLENGTH, Long::toString(bytesMessage->getBodyLength()));\n        return frame;\n    } catch (ClassCastException& ex) {\n    }\n{code}\n\nThe return from getBodyBytes is passed to the frame, which then accepts the contents of the buffer and copies it into a vector.  As the documentation for getBodyBytes indicates, freeing of the data returned by the function is the responsibility of the caller.\n\nHere is the valgrind output showing the leak:\n\n{noformat}\n==10913== 7,492 bytes in 276 blocks are definitely lost in loss record 89 of 90\n==10913==    at 0x4C28152: operator new[](unsigned long) (vg_replace_malloc.c:363)\n==10913==    by 0xED1EAF: activemq::commands::ActiveMQBytesMessage::getBodyBytes() const (ActiveMQBytesMessage.cpp:148)\n==10913==    by 0x10D6068: activemq::wireformat::stomp::StompWireFormat::marshalMessage(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (StompWireFormat.cpp:369)\n==10913==    by 0x10D7624: activemq::wireformat::stomp::StompWireFormat::marshal(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, activemq::transport::Transport const*, decaf::io::DataOutputStream*) (StompWireFormat.cpp:131)\n==10913==    by 0x1061F74: activemq::transport::IOTransport::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (IOTransport.cpp:146)\n==10913==    by 0x1094D21: activemq::transport::TransportFilter::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (TransportFilter.h:118)\n==10913==    by 0x108E2CA: activemq::transport::inactivity::InactivityMonitor::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (InactivityMonitor.cpp:366)\n==10913==    by 0x1067DEB: activemq::transport::correlator::ResponseCorrelator::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::lang::Pointer<activemq::transport::ResponseCallback, decaf::util::concurrent::atomic::AtomicRefCounter>) (ResponseCorrelator.cpp:170)\n==10913==    by 0xCFF44E: activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) (ActiveMQConnection.cpp:1304)\n==10913==    by 0xDC19C7: activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) (ActiveMQSessionKernel.cpp:1007)\n==10913==    by 0xDAE98F: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:269)\n==10913==    by 0xDAB644: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:149)\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak in StompWireFormat.cpp\n\nDescription:\nHere is the afflicted code:\n\n{code}\n    try {\n        Pointer<ActiveMQBytesMessage> bytesMessage = message.dynamicCast<ActiveMQBytesMessage>();\n        frame->setBody(bytesMessage->getBodyBytes(), bytesMessage->getBodyLength());\n        frame->setProperty(StompCommandConstants::HEADER_CONTENTLENGTH, Long::toString(bytesMessage->getBodyLength()));\n        return frame;\n    } catch (ClassCastException& ex) {\n    }\n{code}\n\nThe return from getBodyBytes is passed to the frame, which then accepts the contents of the buffer and copies it into a vector.  As the documentation for getBodyBytes indicates, freeing of the data returned by the function is the responsibility of the caller.\n\nHere is the valgrind output showing the leak:\n\n{noformat}\n==10913== 7,492 bytes in 276 blocks are definitely lost in loss record 89 of 90\n==10913==    at 0x4C28152: operator new[](unsigned long) (vg_replace_malloc.c:363)\n==10913==    by 0xED1EAF: activemq::commands::ActiveMQBytesMessage::getBodyBytes() const (ActiveMQBytesMessage.cpp:148)\n==10913==    by 0x10D6068: activemq::wireformat::stomp::StompWireFormat::marshalMessage(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (StompWireFormat.cpp:369)\n==10913==    by 0x10D7624: activemq::wireformat::stomp::StompWireFormat::marshal(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, activemq::transport::Transport const*, decaf::io::DataOutputStream*) (StompWireFormat.cpp:131)\n==10913==    by 0x1061F74: activemq::transport::IOTransport::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (IOTransport.cpp:146)\n==10913==    by 0x1094D21: activemq::transport::TransportFilter::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (TransportFilter.h:118)\n==10913==    by 0x108E2CA: activemq::transport::inactivity::InactivityMonitor::oneway(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) (InactivityMonitor.cpp:366)\n==10913==    by 0x1067DEB: activemq::transport::correlator::ResponseCorrelator::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, decaf::lang::Pointer<activemq::transport::ResponseCallback, decaf::util::concurrent::atomic::AtomicRefCounter>) (ResponseCorrelator.cpp:170)\n==10913==    by 0xCFF44E: activemq::core::ActiveMQConnection::asyncRequest(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::AsyncCallback*) (ActiveMQConnection.cpp:1304)\n==10913==    by 0xDC19C7: activemq::core::kernels::ActiveMQSessionKernel::send(activemq::core::kernels::ActiveMQProducerKernel*, decaf::lang::Pointer<activemq::commands::ActiveMQDestination, decaf::util::concurrent::atomic::AtomicRefCounter>, cms::Message*, int, int, long long, activemq::util::MemoryUsage*, long long, cms::AsyncCallback*) (ActiveMQSessionKernel.cpp:1007)\n==10913==    by 0xDAE98F: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Destination const*, cms::Message*, int, int, long long, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:269)\n==10913==    by 0xDAB644: activemq::core::kernels::ActiveMQProducerKernel::send(cms::Message*, cms::AsyncCallback*) (ActiveMQProducerKernel.cpp:149)\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'Memory leak in StompWireFormat.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-533?\nA: Here is the afflicted code:\n\n{code}\n    try {\n        Pointer<ActiveMQBytesMessage> bytesMessage = message.dynamicCast<ActiveMQBytesMessage>();\n        frame->setBody(bytesMessage->getBodyBytes(), bytesMessage->getBodyLength());\n        frame->setProperty(StompCommandConstants::HEADER_CONTENTLENGTH, Long::toString(bytesMessage->getBodyLength()));\n        return frame;\n    } catch (ClassCastExcepti"}}
{"issue_key": "AMQCPP-532", "project": "AMQCPP", "title": "Frequently deleting queue browser causes access violation", "status": "Resolved", "reporter": "Andrei Gheorghe", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-01-27T14:54:20.000+0000", "updated": "2015-07-29T21:52:34.000+0000", "description": "The following code should reproduce this issue :\n\n#include <activemq/library/ActiveMQCPP.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/commands/ActiveMQQueue.h>\n\nusing namespace cms;\n\nint main()\n{\n\ttry \n\t{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\tactivemq::core::ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616\" );\n\tauto connection = connectionFactory.createConnection();\n\tconnection->start();\n\tauto session = connection->createSession( Session::SESSION_TRANSACTED );\n\n\tactivemq::commands::ActiveMQQueue queue( \"testqueue\" ); //sometimes it doesn't crash if the queue is empty so it should have atleast a message\n\twhile ( 1 )\n\t{\n\t\tauto queueBrowser = session->createBrowser( &queue, \"\" );\n\t\tauto enumeration = queueBrowser->getEnumeration();\n\t\n\t\tif ( enumeration->hasMoreMessages() )\n\t\t\tauto message = enumeration->nextMessage();\n\n\t\tdelete queueBrowser;\n\t}\n\t}\n\tcatch ( const std::exception& e )\n\t{\n\t\tstd::string what = e.what(); //sometimes it throws an exception like \"Monitor is still in use!\"\n\t}\n\twhile ( 1 ) {} //wait, sometimes an activemq thread fails\n}", "comments": [], "text": "Frequently deleting queue browser causes access violation\n\nDescription:\nThe following code should reproduce this issue :\n\n#include <activemq/library/ActiveMQCPP.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/commands/ActiveMQQueue.h>\n\nusing namespace cms;\n\nint main()\n{\n\ttry \n\t{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\tactivemq::core::ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616\" );\n\tauto connection = connectionFactory.createConnection();\n\tconnection->start();\n\tauto session = connection->createSession( Session::SESSION_TRANSACTED );\n\n\tactivemq::commands::ActiveMQQueue queue( \"testqueue\" ); //sometimes it doesn't crash if the queue is empty so it should have atleast a message\n\twhile ( 1 )\n\t{\n\t\tauto queueBrowser = session->createBrowser( &queue, \"\" );\n\t\tauto enumeration = queueBrowser->getEnumeration();\n\t\n\t\tif ( enumeration->hasMoreMessages() )\n\t\t\tauto message = enumeration->nextMessage();\n\n\t\tdelete queueBrowser;\n\t}\n\t}\n\tcatch ( const std::exception& e )\n\t{\n\t\tstd::string what = e.what(); //sometimes it throws an exception like \"Monitor is still in use!\"\n\t}\n\twhile ( 1 ) {} //wait, sometimes an activemq thread fails\n}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Frequently deleting queue browser causes access violation\n\nDescription:\nThe following code should reproduce this issue :\n\n#include <activemq/library/ActiveMQCPP.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/commands/ActiveMQQueue.h>\n\nusing namespace cms;\n\nint main()\n{\n\ttry \n\t{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\tactivemq::core::ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616\" );\n\tauto connection = connectionFactory.createConnection();\n\tconnection->start();\n\tauto session = connection->createSession( Session::SESSION_TRANSACTED );\n\n\tactivemq::commands::ActiveMQQueue queue( \"testqueue\" ); //sometimes it doesn't crash if the queue is empty so it should have atleast a message\n\twhile ( 1 )\n\t{\n\t\tauto queueBrowser = session->createBrowser( &queue, \"\" );\n\t\tauto enumeration = queueBrowser->getEnumeration();\n\t\n\t\tif ( enumeration->hasMoreMessages() )\n\t\t\tauto message = enumeration->nextMessage();\n\n\t\tdelete queueBrowser;\n\t}\n\t}\n\tcatch ( const std::exception& e )\n\t{\n\t\tstd::string what = e.what(); //sometimes it throws an exception like \"Monitor is still in use!\"\n\t}\n\twhile ( 1 ) {} //wait, sometimes an activemq thread fails\n}\n\nComments:\n", "classification": "Classify the issue 'Frequently deleting queue browser causes access violation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-532?\nA: The following code should reproduce this issue :\n\n#include <activemq/library/ActiveMQCPP.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/commands/ActiveMQQueue.h>\n\nusing namespace cms;\n\nint main()\n{\n\ttry \n\t{\n\tactivemq::library::ActiveMQCPP::initializeLibrary();\n\tactivemq::core::ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616\" );\n\tauto connection = con"}}
{"issue_key": "AMQCPP-531", "project": "AMQCPP", "title": "receiveNoWait never returns", "status": "Resolved", "reporter": "Vincent Giacomini", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2014-01-24T10:49:43.000+0000", "updated": "2014-01-28T15:02:31.000+0000", "description": "Just built the last version 3.8.2 of activemq-cpp (SSL disabled)\n\nBut my application doesn't work anymore. \n\nThe reason : the consumer->ReceiveNoWait() method now never returns \n\nWorks well in activemq-cpp 3.4.1....", "comments": [], "text": "receiveNoWait never returns\n\nDescription:\nJust built the last version 3.8.2 of activemq-cpp (SSL disabled)\n\nBut my application doesn't work anymore. \n\nThe reason : the consumer->ReceiveNoWait() method now never returns \n\nWorks well in activemq-cpp 3.4.1....\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: receiveNoWait never returns\n\nDescription:\nJust built the last version 3.8.2 of activemq-cpp (SSL disabled)\n\nBut my application doesn't work anymore. \n\nThe reason : the consumer->ReceiveNoWait() method now never returns \n\nWorks well in activemq-cpp 3.4.1....\n\nComments:\n", "classification": "Classify the issue 'receiveNoWait never returns' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-531?\nA: Just built the last version 3.8.2 of activemq-cpp (SSL disabled)\n\nBut my application doesn't work anymore. \n\nThe reason : the consumer->ReceiveNoWait() method now never returns \n\nWorks well in activemq-cpp 3.4.1...."}}
{"issue_key": "AMQCPP-530", "project": "AMQCPP", "title": "SSL does not find hostname in cert with multiple cn's in dn", "status": "Resolved", "reporter": "Jeffrey B", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["ssl"], "created": "2014-01-16T18:06:16.000+0000", "updated": "2014-01-16T19:42:32.000+0000", "description": "The SSL certs that we use contain multiple cn's in the dn, such as \ndn=\"cn=%1, cn=hostname, cn=app, cn=project, ou=team, o=company, c=ww\"\n\nI do not know why they are created in this way. It is probably something legacy related. Anyway, with this ActiveMQ cpp will not find the hostname from the dn and fail dual ssl authentication.\n\nHere is a page on openssl that states the specific limitation of the method used in the code http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html\n\nAnd this link shows an example usage of the suggested method\nhttp://h71000.www7.hp.com/doc/83final/ba554_90007/rn02re186.html", "comments": [], "text": "SSL does not find hostname in cert with multiple cn's in dn\n\nDescription:\nThe SSL certs that we use contain multiple cn's in the dn, such as \ndn=\"cn=%1, cn=hostname, cn=app, cn=project, ou=team, o=company, c=ww\"\n\nI do not know why they are created in this way. It is probably something legacy related. Anyway, with this ActiveMQ cpp will not find the hostname from the dn and fail dual ssl authentication.\n\nHere is a page on openssl that states the specific limitation of the method used in the code http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html\n\nAnd this link shows an example usage of the suggested method\nhttp://h71000.www7.hp.com/doc/83final/ba554_90007/rn02re186.html\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SSL does not find hostname in cert with multiple cn's in dn\n\nDescription:\nThe SSL certs that we use contain multiple cn's in the dn, such as \ndn=\"cn=%1, cn=hostname, cn=app, cn=project, ou=team, o=company, c=ww\"\n\nI do not know why they are created in this way. It is probably something legacy related. Anyway, with this ActiveMQ cpp will not find the hostname from the dn and fail dual ssl authentication.\n\nHere is a page on openssl that states the specific limitation of the method used in the code http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html\n\nAnd this link shows an example usage of the suggested method\nhttp://h71000.www7.hp.com/doc/83final/ba554_90007/rn02re186.html\n\n\n\nComments:\n", "classification": "Classify the issue 'SSL does not find hostname in cert with multiple cn's in dn' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-530?\nA: The SSL certs that we use contain multiple cn's in the dn, such as \ndn=\"cn=%1, cn=hostname, cn=app, cn=project, ou=team, o=company, c=ww\"\n\nI do not know why they are created in this way. It is probably something legacy related. Anyway, with this ActiveMQ cpp will not find the hostname from the dn and fail dual ssl authentication.\n\nHere is a page on openssl that states the specific limitation of th"}}
{"issue_key": "AMQCPP-529", "project": "AMQCPP", "title": "Crash in Threads due to small stack size (set to 32768 bytes)", "status": "Resolved", "reporter": "omri zomet", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2014-01-01T14:50:22.000+0000", "updated": "2014-01-02T21:09:59.000+0000", "description": "Using version 3.8.1 of activemq-cpp (after using version 3.4.5) - we have suffered a crash in code running in amq threads.\nInvestigation shows that this happens when trying to use a char[] buffer on stack of size > 16384 , probably due to the stack size being of size 32768.\n\nThread::Thread() constructors call initializeSelf() with stackSize=(-1), which \nin turn call createThreadInstance() with negative stackSize value (hence using PLATFORM_DEFAULT_STACK_SIZE).\n\nRelevant code below:\n----------------------\n #define PLATFORM_DEFAULT_STACK_SIZE 0x8000\n-----------------------\nvoid createThreadInstance(ThreadHandle* thread, long long stackSize, int  priority, bool suspended, threadingTask threadMain, void* threadArg) {\n        if (stackSize <= 0) {\n            stackSize = PLATFORM_DEFAULT_STACK_SIZE;\n        }\n...\n}\n----------------------", "comments": [], "text": "Crash in Threads due to small stack size (set to 32768 bytes)\n\nDescription:\nUsing version 3.8.1 of activemq-cpp (after using version 3.4.5) - we have suffered a crash in code running in amq threads.\nInvestigation shows that this happens when trying to use a char[] buffer on stack of size > 16384 , probably due to the stack size being of size 32768.\n\nThread::Thread() constructors call initializeSelf() with stackSize=(-1), which \nin turn call createThreadInstance() with negative stackSize value (hence using PLATFORM_DEFAULT_STACK_SIZE).\n\nRelevant code below:\n----------------------\n #define PLATFORM_DEFAULT_STACK_SIZE 0x8000\n-----------------------\nvoid createThreadInstance(ThreadHandle* thread, long long stackSize, int  priority, bool suspended, threadingTask threadMain, void* threadArg) {\n        if (stackSize <= 0) {\n            stackSize = PLATFORM_DEFAULT_STACK_SIZE;\n        }\n...\n}\n----------------------\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash in Threads due to small stack size (set to 32768 bytes)\n\nDescription:\nUsing version 3.8.1 of activemq-cpp (after using version 3.4.5) - we have suffered a crash in code running in amq threads.\nInvestigation shows that this happens when trying to use a char[] buffer on stack of size > 16384 , probably due to the stack size being of size 32768.\n\nThread::Thread() constructors call initializeSelf() with stackSize=(-1), which \nin turn call createThreadInstance() with negative stackSize value (hence using PLATFORM_DEFAULT_STACK_SIZE).\n\nRelevant code below:\n----------------------\n #define PLATFORM_DEFAULT_STACK_SIZE 0x8000\n-----------------------\nvoid createThreadInstance(ThreadHandle* thread, long long stackSize, int  priority, bool suspended, threadingTask threadMain, void* threadArg) {\n        if (stackSize <= 0) {\n            stackSize = PLATFORM_DEFAULT_STACK_SIZE;\n        }\n...\n}\n----------------------\n\nComments:\n", "classification": "Classify the issue 'Crash in Threads due to small stack size (set to 32768 bytes)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-529?\nA: Using version 3.8.1 of activemq-cpp (after using version 3.4.5) - we have suffered a crash in code running in amq threads.\nInvestigation shows that this happens when trying to use a char[] buffer on stack of size > 16384 , probably due to the stack size being of size 32768.\n\nThread::Thread() constructors call initializeSelf() with stackSize=(-1), which \nin turn call createThreadInstance() with neg"}}
{"issue_key": "AMQCPP-528", "project": "AMQCPP", "title": " No output written to .libs/libactivemq-cpp.so.14.0.4", "status": "Closed", "reporter": "Beesa Sampath Kumar", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-12-23T13:23:43.000+0000", "updated": "2013-12-23T13:39:40.000+0000", "description": "-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/apr-util-1.5.3/.libs -Wl,-R -Wl,/usr/sfw/lib -Wl,-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/AMQP/AMQP_TOOLS/lib -Wl,-R -Wl,/usr/sfw/lib /usr/local/apr/lib/libapr-1.so -luuid -lsendfile -lrt /export/home/cdr_up/apr-util-1.5.3/.libs/libaprutil-1.so -L/export/home/cdr_up/apr-1.5.0/.libs -lexpat -lssl -lcrypto -lsocket -lnsl -ldl -L/usr/sfw/lib -lpthread -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3 -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../../../sparc-sun-solaris2.10/lib -L/usr/ccs/lib -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../.. /usr/sfw/lib/libstdc++.so -lm -lgcc_s /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtend.o /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtn.o  -O2   -Wl,-h -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\nld: fatal: file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o: wrong ELF class: ELFCLASS64\nld: fatal: file processing errors. No output written to .libs/libactivemq-cpp.so.14.0.4\ncollect2: ld returned 1 exit status\n*** Error code 1\nmake: Fatal error: Command failed for target `libactivemq-cpp.la'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4/src/main\n*** Error code 1\nThe following command caused the error:\nfail= failcom='exit 1'; \\\nfor f in x $MAKEFLAGS; do \\\n  case $f in \\\n    *=* | --[!k]*);; \\\n    *k*) failcom='fail=yes';; \\\n  esac; \\\ndone; \\\ndot_seen=no; \\\ntarget=`echo all-recursive | sed s/-recursive//`; \\\nlist='src/main src/examples '; for subdir in $list; do \\\n  echo \"Making $target in $subdir\"; \\\n  if test \"$subdir\" = \".\"; then \\\n    dot_seen=yes; \\\n    local_target=\"$target-am\"; \\\n  else \\\n    local_target=\"$target\"; \\\n  fi; \\\n  (CDPATH=\"${ZSH_VERSION+.}:\" && cd $subdir && make  $local_target) \\\n  || eval $failcom; \\\ndone; \\\nif test \"$dot_seen\" = \"no\"; then \\\n  make  \"$target-am\" || exit 1; \\\nfi; test -z \"$fail\"\nmake: Fatal error: Command failed for target `all-recursive'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4\n*** Error code 1\nmake: Fatal error: Command failed for target `all'\nbash-3.2$ file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o\ndecaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o:     cannot open: No such file or directory", "comments": [], "text": "No output written to .libs/libactivemq-cpp.so.14.0.4\n\nDescription:\n-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/apr-util-1.5.3/.libs -Wl,-R -Wl,/usr/sfw/lib -Wl,-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/AMQP/AMQP_TOOLS/lib -Wl,-R -Wl,/usr/sfw/lib /usr/local/apr/lib/libapr-1.so -luuid -lsendfile -lrt /export/home/cdr_up/apr-util-1.5.3/.libs/libaprutil-1.so -L/export/home/cdr_up/apr-1.5.0/.libs -lexpat -lssl -lcrypto -lsocket -lnsl -ldl -L/usr/sfw/lib -lpthread -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3 -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../../../sparc-sun-solaris2.10/lib -L/usr/ccs/lib -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../.. /usr/sfw/lib/libstdc++.so -lm -lgcc_s /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtend.o /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtn.o  -O2   -Wl,-h -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\nld: fatal: file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o: wrong ELF class: ELFCLASS64\nld: fatal: file processing errors. No output written to .libs/libactivemq-cpp.so.14.0.4\ncollect2: ld returned 1 exit status\n*** Error code 1\nmake: Fatal error: Command failed for target `libactivemq-cpp.la'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4/src/main\n*** Error code 1\nThe following command caused the error:\nfail= failcom='exit 1'; \\\nfor f in x $MAKEFLAGS; do \\\n  case $f in \\\n    *=* | --[!k]*);; \\\n    *k*) failcom='fail=yes';; \\\n  esac; \\\ndone; \\\ndot_seen=no; \\\ntarget=`echo all-recursive | sed s/-recursive//`; \\\nlist='src/main src/examples '; for subdir in $list; do \\\n  echo \"Making $target in $subdir\"; \\\n  if test \"$subdir\" = \".\"; then \\\n    dot_seen=yes; \\\n    local_target=\"$target-am\"; \\\n  else \\\n    local_target=\"$target\"; \\\n  fi; \\\n  (CDPATH=\"${ZSH_VERSION+.}:\" && cd $subdir && make  $local_target) \\\n  || eval $failcom; \\\ndone; \\\nif test \"$dot_seen\" = \"no\"; then \\\n  make  \"$target-am\" || exit 1; \\\nfi; test -z \"$fail\"\nmake: Fatal error: Command failed for target `all-recursive'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4\n*** Error code 1\nmake: Fatal error: Command failed for target `all'\nbash-3.2$ file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o\ndecaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o:     cannot open: No such file or directory\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue:  No output written to .libs/libactivemq-cpp.so.14.0.4\n\nDescription:\n-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/apr-util-1.5.3/.libs -Wl,-R -Wl,/usr/sfw/lib -Wl,-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/AMQP/AMQP_TOOLS/lib -Wl,-R -Wl,/usr/sfw/lib /usr/local/apr/lib/libapr-1.so -luuid -lsendfile -lrt /export/home/cdr_up/apr-util-1.5.3/.libs/libaprutil-1.so -L/export/home/cdr_up/apr-1.5.0/.libs -lexpat -lssl -lcrypto -lsocket -lnsl -ldl -L/usr/sfw/lib -lpthread -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3 -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../../../sparc-sun-solaris2.10/lib -L/usr/ccs/lib -L/usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/../../.. /usr/sfw/lib/libstdc++.so -lm -lgcc_s /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtend.o /usr/sfw/lib/gcc/sparc-sun-solaris2.10/3.4.3/crtn.o  -O2   -Wl,-h -Wl,libactivemq-cpp.so.14 -o .libs/libactivemq-cpp.so.14.0.4\nld: fatal: file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o: wrong ELF class: ELFCLASS64\nld: fatal: file processing errors. No output written to .libs/libactivemq-cpp.so.14.0.4\ncollect2: ld returned 1 exit status\n*** Error code 1\nmake: Fatal error: Command failed for target `libactivemq-cpp.la'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4/src/main\n*** Error code 1\nThe following command caused the error:\nfail= failcom='exit 1'; \\\nfor f in x $MAKEFLAGS; do \\\n  case $f in \\\n    *=* | --[!k]*);; \\\n    *k*) failcom='fail=yes';; \\\n  esac; \\\ndone; \\\ndot_seen=no; \\\ntarget=`echo all-recursive | sed s/-recursive//`; \\\nlist='src/main src/examples '; for subdir in $list; do \\\n  echo \"Making $target in $subdir\"; \\\n  if test \"$subdir\" = \".\"; then \\\n    dot_seen=yes; \\\n    local_target=\"$target-am\"; \\\n  else \\\n    local_target=\"$target\"; \\\n  fi; \\\n  (CDPATH=\"${ZSH_VERSION+.}:\" && cd $subdir && make  $local_target) \\\n  || eval $failcom; \\\ndone; \\\nif test \"$dot_seen\" = \"no\"; then \\\n  make  \"$target-am\" || exit 1; \\\nfi; test -z \"$fail\"\nmake: Fatal error: Command failed for target `all-recursive'\nCurrent working directory /export/home/cdr_up/AMQP/AMQP_CLIENT/activemq-cpp-library-3.4.4\n*** Error code 1\nmake: Fatal error: Command failed for target `all'\nbash-3.2$ file decaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o\ndecaf/internal/util/zip/.libs/libactivemq_cpp_la-adler32.o:     cannot open: No such file or directory\n\nComments:\n", "classification": "Classify the issue ' No output written to .libs/libactivemq-cpp.so.14.0.4' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-528?\nA: -R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/apr-util-1.5.3/.libs -Wl,-R -Wl,/usr/sfw/lib -Wl,-R -Wl,/usr/local/apr/lib -Wl,-R -Wl,/export/home/cdr_up/AMQP/AMQP_TOOLS/lib -Wl,-R -Wl,/usr/sfw/lib /usr/local/apr/lib/libapr-1.so -luuid -lsendfile -lrt /export/home/cdr_up/apr-util-1.5.3/.libs/libaprutil-1.so -L/export/home/cdr_up/apr-1.5.0/.libs -lexpat -lssl -lcrypto -lsocket -lnsl -ldl -"}}
{"issue_key": "AMQCPP-527", "project": "AMQCPP", "title": "ConcurrentStlMap - stl map find crash with empty map", "status": "Resolved", "reporter": "Christian Mamen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-12-11T18:42:57.000+0000", "updated": "2013-12-13T22:46:18.000+0000", "description": "Recently experience a crash while an activemq work thread attempts to remove a temporary destination from a ConcurrentStlMap. This crash happens inside a std::map::find() when the map is currently empty. \n\n{code}\nvirtual V remove(const K& key) {\n            V result = V();\n            synchronized(&mutex) {\n                typename std::map<K, V, COMPARATOR>::iterator iter = valueMap.find(key);\n                if (iter == valueMap.end()) {\n                    return result;\n                }\n[...]\n{code}\n\nI look arround in forums and found that some people do experience similar problems with stl map.\n\nhttp://social.msdn.microsoft.com/Forums/en-US/9fdd11cd-ab7a-4173-8fcc-ca239b10fd20/weird-crash-in-c-mapsfind-when-compiled-in-release-mode\n\nhttp://www.velocityreviews.com/forums/t278300-std-map-find-throws-exception-when-map-is-empty.html\n\nso it appears that this error might be an stl issue, (perhaps platform related?). The workaround suggested is the check if the map is empty before performing a find.\n\nThe stack trace i got\n{noformat}\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::_Lbound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1264 + 0x8 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::lower_bound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1004 + 0x10 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::find(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 982\tC++\n>\tactivemq-cpp.dll!decaf::util::concurrent::ConcurrentStlMap<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter> >::remove(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & key={...})  Line 920\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::removeTempDestination(decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> destination={...})  Line 1828 + 0x25 bytes\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::processDestinationInfo(decaf::lang::Pointer<activemq::commands::DestinationInfo,decaf::util::concurrent::atomic::AtomicRefCounter> info={...})  Line 154\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & message={...})  Line 135\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 1077\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 295\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 145\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 334\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 116\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::run()  Line 275\tC++\n \tactivemq-cpp.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::runCallback(void * arg=0x02d9c3c8)  Line 266 + 0x11 bytes\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x02d9c3c8)  Line 254 + 0x15 bytes\tC++\n{noformat}", "comments": [], "text": "ConcurrentStlMap - stl map find crash with empty map\n\nDescription:\nRecently experience a crash while an activemq work thread attempts to remove a temporary destination from a ConcurrentStlMap. This crash happens inside a std::map::find() when the map is currently empty. \n\n{code}\nvirtual V remove(const K& key) {\n            V result = V();\n            synchronized(&mutex) {\n                typename std::map<K, V, COMPARATOR>::iterator iter = valueMap.find(key);\n                if (iter == valueMap.end()) {\n                    return result;\n                }\n[...]\n{code}\n\nI look arround in forums and found that some people do experience similar problems with stl map.\n\nhttp://social.msdn.microsoft.com/Forums/en-US/9fdd11cd-ab7a-4173-8fcc-ca239b10fd20/weird-crash-in-c-mapsfind-when-compiled-in-release-mode\n\nhttp://www.velocityreviews.com/forums/t278300-std-map-find-throws-exception-when-map-is-empty.html\n\nso it appears that this error might be an stl issue, (perhaps platform related?). The workaround suggested is the check if the map is empty before performing a find.\n\nThe stack trace i got\n{noformat}\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::_Lbound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1264 + 0x8 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::lower_bound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1004 + 0x10 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::find(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 982\tC++\n>\tactivemq-cpp.dll!decaf::util::concurrent::ConcurrentStlMap<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter> >::remove(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & key={...})  Line 920\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::removeTempDestination(decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> destination={...})  Line 1828 + 0x25 bytes\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::processDestinationInfo(decaf::lang::Pointer<activemq::commands::DestinationInfo,decaf::util::concurrent::atomic::AtomicRefCounter> info={...})  Line 154\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & message={...})  Line 135\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 1077\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 295\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 145\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 334\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 116\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::run()  Line 275\tC++\n \tactivemq-cpp.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::runCallback(void * arg=0x02d9c3c8)  Line 266 + 0x11 bytes\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x02d9c3c8)  Line 254 + 0x15 bytes\tC++\n{noformat}\n\n\n\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ConcurrentStlMap - stl map find crash with empty map\n\nDescription:\nRecently experience a crash while an activemq work thread attempts to remove a temporary destination from a ConcurrentStlMap. This crash happens inside a std::map::find() when the map is currently empty. \n\n{code}\nvirtual V remove(const K& key) {\n            V result = V();\n            synchronized(&mutex) {\n                typename std::map<K, V, COMPARATOR>::iterator iter = valueMap.find(key);\n                if (iter == valueMap.end()) {\n                    return result;\n                }\n[...]\n{code}\n\nI look arround in forums and found that some people do experience similar problems with stl map.\n\nhttp://social.msdn.microsoft.com/Forums/en-US/9fdd11cd-ab7a-4173-8fcc-ca239b10fd20/weird-crash-in-c-mapsfind-when-compiled-in-release-mode\n\nhttp://www.velocityreviews.com/forums/t278300-std-map-find-throws-exception-when-map-is-empty.html\n\nso it appears that this error might be an stl issue, (perhaps platform related?). The workaround suggested is the check if the map is empty before performing a find.\n\nThe stack trace i got\n{noformat}\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::_Lbound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1264 + 0x8 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::lower_bound(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 1004 + 0x10 bytes\tC++\n \tactivemq-cpp.dll!std::_Tree<std::_Tmap_traits<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,std::allocator<std::pair<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> const ,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> > >,0> >::find(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & _Keyval={...})  Line 982\tC++\n>\tactivemq-cpp.dll!decaf::util::concurrent::ConcurrentStlMap<decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter>,decaf::lang::PointerComparator<activemq::commands::ActiveMQDestination,decaf::util::concurrent::atomic::AtomicRefCounter> >::remove(const decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> & key={...})  Line 920\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::removeTempDestination(decaf::lang::Pointer<activemq::commands::ActiveMQTempDestination,decaf::util::concurrent::atomic::AtomicRefCounter> destination={...})  Line 1828 + 0x25 bytes\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::processDestinationInfo(decaf::lang::Pointer<activemq::commands::DestinationInfo,decaf::util::concurrent::atomic::AtomicRefCounter> info={...})  Line 154\tC++\n \tactivemq-cpp.dll!activemq::core::AdvisoryConsumer::dispatch(const decaf::lang::Pointer<activemq::commands::MessageDispatch,decaf::util::concurrent::atomic::AtomicRefCounter> & message={...})  Line 135\tC++\n \tactivemq-cpp.dll!activemq::core::ActiveMQConnection::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 1077\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::correlator::ResponseCorrelator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 295\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::wireformat::openwire::OpenWireFormatNegotiator::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 145\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::inactivity::InactivityMonitor::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 334\tC++\n \tactivemq-cpp.dll!activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 91 + 0x27 bytes\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command={...})  Line 116\tC++\n \tactivemq-cpp.dll!activemq::transport::IOTransport::run()  Line 275\tC++\n \tactivemq-cpp.dll!decaf::lang::Thread::run()  Line 143\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::runCallback(void * arg=0x02d9c3c8)  Line 266 + 0x11 bytes\tC++\n \tactivemq-cpp.dll!`anonymous namespace'::threadEntryMethod(void * arg=0x02d9c3c8)  Line 254 + 0x15 bytes\tC++\n{noformat}\n\n\n\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'ConcurrentStlMap - stl map find crash with empty map' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-527?\nA: Recently experience a crash while an activemq work thread attempts to remove a temporary destination from a ConcurrentStlMap. This crash happens inside a std::map::find() when the map is currently empty. \n\n{code}\nvirtual V remove(const K& key) {\n            V result = V();\n            synchronized(&mutex) {\n                typename std::map<K, V, COMPARATOR>::iterator iter = valueMap.find(key);\n  "}}
{"issue_key": "AMQCPP-526", "project": "AMQCPP", "title": "Version >2.2.6 Segfault by initialization", "status": "Closed", "reporter": "Nikolaus Klimek", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": ["library", "segmenation_fault", "sharedLib"], "created": "2013-12-04T18:00:49.000+0000", "updated": "2013-12-04T18:10:59.000+0000", "description": "Hello,\n\nbecause our previous SLES Version does not support required apr-version, we used the ActiveMQ C++ Client 2.2.6, which was compiled to a shared object/library and called by a cobol application (via CALL). This combination works fine.\n\nActually we updated our SLES and a higher apr-version now is supported. So we tried to use a higher-version of the ActiveMQ C++ Client (e.g. 3.0 and 3.7.1), which we compiled to a shared object for calling via a cobol application, too. \nCalling the new version now causes a segmentation fault, the ActiveMQ shared object crashes on initialization, before any command is executed. \nWe think it deals with loading/initialising the activemq library (activemq::library; ActiveMQCPP::initializeLibrary()), because it is new since version 3.0.0. Another point is we reduced our ActiveMQ shared object to only print a line. This certainly works. Adding the command  activemq::library; ActiveMQCPP::initializeLibrary() causes the identicall segfault.\nBizarrely calling the identical shared object from a C++ application works.\n\nWe don't understand why calling the ActiveMQ shared object doens't work from cobol, however it works calling from a C++ application. With a release <=2.2.6 both call variations working.\n\nWe hope you have any ideas for let us understand this issue or to give us some advice for solving this problem.\n\nThanks in regards!\nNiko", "comments": [], "text": "Version >2.2.6 Segfault by initialization\n\nDescription:\nHello,\n\nbecause our previous SLES Version does not support required apr-version, we used the ActiveMQ C++ Client 2.2.6, which was compiled to a shared object/library and called by a cobol application (via CALL). This combination works fine.\n\nActually we updated our SLES and a higher apr-version now is supported. So we tried to use a higher-version of the ActiveMQ C++ Client (e.g. 3.0 and 3.7.1), which we compiled to a shared object for calling via a cobol application, too. \nCalling the new version now causes a segmentation fault, the ActiveMQ shared object crashes on initialization, before any command is executed. \nWe think it deals with loading/initialising the activemq library (activemq::library; ActiveMQCPP::initializeLibrary()), because it is new since version 3.0.0. Another point is we reduced our ActiveMQ shared object to only print a line. This certainly works. Adding the command  activemq::library; ActiveMQCPP::initializeLibrary() causes the identicall segfault.\nBizarrely calling the identical shared object from a C++ application works.\n\nWe don't understand why calling the ActiveMQ shared object doens't work from cobol, however it works calling from a C++ application. With a release <=2.2.6 both call variations working.\n\nWe hope you have any ideas for let us understand this issue or to give us some advice for solving this problem.\n\nThanks in regards!\nNiko\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Version >2.2.6 Segfault by initialization\n\nDescription:\nHello,\n\nbecause our previous SLES Version does not support required apr-version, we used the ActiveMQ C++ Client 2.2.6, which was compiled to a shared object/library and called by a cobol application (via CALL). This combination works fine.\n\nActually we updated our SLES and a higher apr-version now is supported. So we tried to use a higher-version of the ActiveMQ C++ Client (e.g. 3.0 and 3.7.1), which we compiled to a shared object for calling via a cobol application, too. \nCalling the new version now causes a segmentation fault, the ActiveMQ shared object crashes on initialization, before any command is executed. \nWe think it deals with loading/initialising the activemq library (activemq::library; ActiveMQCPP::initializeLibrary()), because it is new since version 3.0.0. Another point is we reduced our ActiveMQ shared object to only print a line. This certainly works. Adding the command  activemq::library; ActiveMQCPP::initializeLibrary() causes the identicall segfault.\nBizarrely calling the identical shared object from a C++ application works.\n\nWe don't understand why calling the ActiveMQ shared object doens't work from cobol, however it works calling from a C++ application. With a release <=2.2.6 both call variations working.\n\nWe hope you have any ideas for let us understand this issue or to give us some advice for solving this problem.\n\nThanks in regards!\nNiko\n\nComments:\n", "classification": "Classify the issue 'Version >2.2.6 Segfault by initialization' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-526?\nA: Hello,\n\nbecause our previous SLES Version does not support required apr-version, we used the ActiveMQ C++ Client 2.2.6, which was compiled to a shared object/library and called by a cobol application (via CALL). This combination works fine.\n\nActually we updated our SLES and a higher apr-version now is supported. So we tried to use a higher-version of the ActiveMQ C++ Client (e.g. 3.0 and 3.7.1), w"}}
{"issue_key": "AMQCPP-525", "project": "AMQCPP", "title": "C++ client hangs when using the failover transport to connect to a network of brokers", "status": "Resolved", "reporter": "Matthew Western", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-11-23T23:31:49.000+0000", "updated": "2013-11-24T15:51:22.000+0000", "description": "I have a network of three brokers on three different hosts each with nio transport connectors as follows (host 1 below, hosts 2 and 3 follow the same pattern):\n\n<transportConnector name=\"openwire-client\"\nuri=\"nio://host1.somedomain.com:44320\"\nupdateClusterClients=\"true\"\nrebalanceClusterClients=\"true\"\nupdateClusterClientsOnRemove=\"true\"\n/>\n\nI modified the ActiveMQ C++ example Listener (Listener.cpp) with the following broker URL:\n\nfailover:(tcp://host1.somedomain.com:44320)\n\nThe Listener hangs in connection->start() and never establishes a connection with any of the three brokers.\n\nI put debug into FailoverTransport.cpp  and discovered that the URIs received from the three brokers are being used verbatim by the C++ client - i.e. it tries to rebalance/reconnect using the nio scheme in the URIs received from the broker transport connector configuration.\n\nThe C++ client has no handling for the nio scheme and so continually iterates though the URI pool but never establishes a connection to any of the URIs, hence the hang.\n\nAccording to the ActiveMQ website \"Configuring Transports\" documentation if the nio transport is specified in a URI used by an OpenWire client, it should simply instantiate the normal tcp transport, but this handling seems to be missing from the C++ client.\n\nI put a quick fix into the FailoverTransport::updateURIs() method to convert any URI received from a broker with a scheme of \"nio\" to the same URI but with a scheme of \"tcp\" and then the client successfully connected to one of the brokers:\n\n            Pointer<Iterator<URI> > setIter(set.iterator());\n            while (setIter->hasNext()) {\n                URI value = setIter->next();\n                if (value.getScheme() == \"nio\") {\n                    std::cout << \"Found NIO scheme, changing to TCP\" << std::endl;\n                    URI newValue = URI(\"tcp\", value.getAuthority(),\n                        value.getPath(), value.getQuery(), value.getFragment());\n                   value = newValue;\n                }\n                this->impl->updated->addURI(value);\n            }\n\n\nThis is obviously not an appropriate solution for the production code, but it does serve to demonstrate the issue.", "comments": [], "text": "C++ client hangs when using the failover transport to connect to a network of brokers\n\nDescription:\nI have a network of three brokers on three different hosts each with nio transport connectors as follows (host 1 below, hosts 2 and 3 follow the same pattern):\n\n<transportConnector name=\"openwire-client\"\nuri=\"nio://host1.somedomain.com:44320\"\nupdateClusterClients=\"true\"\nrebalanceClusterClients=\"true\"\nupdateClusterClientsOnRemove=\"true\"\n/>\n\nI modified the ActiveMQ C++ example Listener (Listener.cpp) with the following broker URL:\n\nfailover:(tcp://host1.somedomain.com:44320)\n\nThe Listener hangs in connection->start() and never establishes a connection with any of the three brokers.\n\nI put debug into FailoverTransport.cpp  and discovered that the URIs received from the three brokers are being used verbatim by the C++ client - i.e. it tries to rebalance/reconnect using the nio scheme in the URIs received from the broker transport connector configuration.\n\nThe C++ client has no handling for the nio scheme and so continually iterates though the URI pool but never establishes a connection to any of the URIs, hence the hang.\n\nAccording to the ActiveMQ website \"Configuring Transports\" documentation if the nio transport is specified in a URI used by an OpenWire client, it should simply instantiate the normal tcp transport, but this handling seems to be missing from the C++ client.\n\nI put a quick fix into the FailoverTransport::updateURIs() method to convert any URI received from a broker with a scheme of \"nio\" to the same URI but with a scheme of \"tcp\" and then the client successfully connected to one of the brokers:\n\n            Pointer<Iterator<URI> > setIter(set.iterator());\n            while (setIter->hasNext()) {\n                URI value = setIter->next();\n                if (value.getScheme() == \"nio\") {\n                    std::cout << \"Found NIO scheme, changing to TCP\" << std::endl;\n                    URI newValue = URI(\"tcp\", value.getAuthority(),\n                        value.getPath(), value.getQuery(), value.getFragment());\n                   value = newValue;\n                }\n                this->impl->updated->addURI(value);\n            }\n\n\nThis is obviously not an appropriate solution for the production code, but it does serve to demonstrate the issue.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: C++ client hangs when using the failover transport to connect to a network of brokers\n\nDescription:\nI have a network of three brokers on three different hosts each with nio transport connectors as follows (host 1 below, hosts 2 and 3 follow the same pattern):\n\n<transportConnector name=\"openwire-client\"\nuri=\"nio://host1.somedomain.com:44320\"\nupdateClusterClients=\"true\"\nrebalanceClusterClients=\"true\"\nupdateClusterClientsOnRemove=\"true\"\n/>\n\nI modified the ActiveMQ C++ example Listener (Listener.cpp) with the following broker URL:\n\nfailover:(tcp://host1.somedomain.com:44320)\n\nThe Listener hangs in connection->start() and never establishes a connection with any of the three brokers.\n\nI put debug into FailoverTransport.cpp  and discovered that the URIs received from the three brokers are being used verbatim by the C++ client - i.e. it tries to rebalance/reconnect using the nio scheme in the URIs received from the broker transport connector configuration.\n\nThe C++ client has no handling for the nio scheme and so continually iterates though the URI pool but never establishes a connection to any of the URIs, hence the hang.\n\nAccording to the ActiveMQ website \"Configuring Transports\" documentation if the nio transport is specified in a URI used by an OpenWire client, it should simply instantiate the normal tcp transport, but this handling seems to be missing from the C++ client.\n\nI put a quick fix into the FailoverTransport::updateURIs() method to convert any URI received from a broker with a scheme of \"nio\" to the same URI but with a scheme of \"tcp\" and then the client successfully connected to one of the brokers:\n\n            Pointer<Iterator<URI> > setIter(set.iterator());\n            while (setIter->hasNext()) {\n                URI value = setIter->next();\n                if (value.getScheme() == \"nio\") {\n                    std::cout << \"Found NIO scheme, changing to TCP\" << std::endl;\n                    URI newValue = URI(\"tcp\", value.getAuthority(),\n                        value.getPath(), value.getQuery(), value.getFragment());\n                   value = newValue;\n                }\n                this->impl->updated->addURI(value);\n            }\n\n\nThis is obviously not an appropriate solution for the production code, but it does serve to demonstrate the issue.\n\nComments:\n", "classification": "Classify the issue 'C++ client hangs when using the failover transport to connect to a network of brokers' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-525?\nA: I have a network of three brokers on three different hosts each with nio transport connectors as follows (host 1 below, hosts 2 and 3 follow the same pattern):\n\n<transportConnector name=\"openwire-client\"\nuri=\"nio://host1.somedomain.com:44320\"\nupdateClusterClients=\"true\"\nrebalanceClusterClients=\"true\"\nupdateClusterClientsOnRemove=\"true\"\n/>\n\nI modified the ActiveMQ C++ example Listener (Listener.cpp"}}
{"issue_key": "AMQCPP-524", "project": "AMQCPP", "title": "Experiencing deadlock while destroying activemq::core::ActiveMQConnection", "status": "Closed", "reporter": "Christian Mamen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-11-06T01:17:02.000+0000", "updated": "2013-11-07T22:50:04.000+0000", "description": "The deadlock occurs while destroying an amq connection, a broker connection as been establish.\n\nI added a break point inside before termination decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition, and before the deadlock occurs i can see\nthe following threads:\n{noformat} \n0\t \t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::Threading::join\tNormal\t0\n0\t \t8252\tWorker Thread\tWin32 Thread\t776ef959\tNormal\t0\n0\t \t5280\tWorker Thread\tWin32 Thread\t776f015d\tNormal\t0\n0\t \t8588\tWorker Thread\t_threadstartex\tCtiLocalConnect<CtiOutMessage,INMESS>::CtiLocalConnectRead\tNormal\t0\n0\t \t4916\tWorker Thread\t_threadstartex\t_CrtDefaultAllocHook\tNormal\t0\n0\t>\t5532\tWorker Thread\t_threadstartex\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n0\t \t1956\tWorker Thread\t_threadstartex\tstd::_Lockit::~_Lockit\tNormal\t0\n0\t \t5784\tWorker Thread\tWin32 Thread\tCtrlHandler\tHighest\t0\n0\t \t4512\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t7180\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t1668\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n{noformat} \n\nAt this moment, the call stack for thread 5532 is the following:\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x000007d8, _RTL_CRITICAL_SECTION * mutex=0x077dee10, __int64 mills=7659, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\n`anonymous namespace'::doWaitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, decaf::internal::util::concurrent::ThreadHandle * thread=0x05f338a8, __int64 mills=7659, int nanos=0, bool interruptible=true)  Line 752 + 0x23 bytes\tC++\ndecaf::internal::util::concurrent::Threading::waitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, __int64 mills=7659, int nanos=0)  Line 1558 + 0x1b bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659, int nanos=0)  Line 180 + 0x1a bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659)  Line 162\tC++\ndecaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=7659)  Line 54\tC++\ndecaf::util::TimerImpl::run()  Line 102 + 0x1f bytes\tC++\n`anonymous namespace'::runCallback(void * arg=0x05f338a8)  Line 266 + 0x11 bytes\tC++\n`anonymous namespace'::threadEntryMethod(void * arg=0x05f338a8)  Line 254 + 0x15 bytes\tC++\n{noformat} \n\nAfterwards, only the main thread is left and the deadlock occurs interruptibleWaitOnCondition at \"PlatformThread::unlockMutex(mutex);\"\n{noformat} \n0\t>\t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n{noformat} \n\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x001293d0, _RTL_CRITICAL_SECTION * mutex=0x1f13f1e8, __int64 mills=600000, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\ndecaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread=0x043eb370, __int64 mills=600000, int nanos=0)  Line 1168 + 0x23 bytes\tC++\ndecaf::lang::Thread::join(__int64 millisecs=600000)  Line 178 + 0x19 bytes\tC++\ndecaf::util::Timer::awaitTermination(__int64 timeout=10, const decaf::util::concurrent::TimeUnit & unit={...})  Line 236\tC++\ndecaf::util::concurrent::ExecutorKernel::~ExecutorKernel()  Line 419\tC++\ndecaf::util::concurrent::ExecutorKernel::`scalar deleting destructor'()  + 0xf bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::~ThreadPoolExecutor()  Line 1481 + 0x1f bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::`vector deleting destructor'()  + 0x4d bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::concurrent::ExecutorService * value=0x1f13b7f8)  Line 317 + 0x20 bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>()  Line 148 + 0xf bytes\tC++\nactivemq::core::ConnectionConfig::~ConnectionConfig()  Line 303 + 0x1ba bytes\tC++\nactivemq::core::ConnectionConfig::`scalar deleting destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::~ActiveMQConnection()  Line 501 + 0x1f bytes\tC++\nactivemq::core::ActiveMQConnection::`vbase destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::`vector deleting destructor'()  + 0x4d bytes\tC++\n{noformat} \n\nIf i look into the ThreadHandle object, i can see the threadId\t5532 and state == 4 (Thread::TIMED_WAITING), however the thread at this point is not running\n{noformat} \n-\t\tthread\t0x06054520 {parent=0x060543c0 handle=0x000007bc mutex=0x062ad498 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tparent\t0x060543c0 {heap={...} cancelled=true }\tdecaf::lang::Thread *\n\t\thandle\t0x000007bc\tvoid *\n+\t\tmutex\t0x062ad498 {DebugInfo=0x00373658 LockCount=-2 RecursionCount=1 ...}\t_RTL_CRITICAL_SECTION *\n\t\tcondition\t0x000007b8\tvoid *\n\t\tstate\t4\tvolatile int\n\t\treferences\t2\tvolatile int\n\t\tpriority\t5\tint\n\t\tinterrupted\tfalse\tbool\n\t\tinterruptible\ttrue\tbool\n\t\ttimerSet\ttrue\tbool\n\t\tcanceled\tfalse\tbool\n\t\tunparked\tfalse\tbool\n\t\tparked\tfalse\tbool\n\t\tsleeping\tfalse\tbool\n\t\twaiting\tfalse\tbool\n\t\tnotified\ttrue\tbool\n\t\tblocked\ttrue\tbool\n\t\tsuspended\tfalse\tbool\n+\t\tname\t0x062ad580 \"Thread-2\"\tchar *\n\t\tstackSize\t32768\t__int64\n+\t\ttls\t0x06054558\tvoid * [384]\n\t\tthreadMain\t0x00ecbf7c `anonymous namespace'::runCallback(void *)\tvoid (void *)*\n\t\tthreadArg\t0x06054520\tvoid *\n\t\tthreadId\t5532\t__int64\n\t\tosThread\tfalse\tbool\n+\t\tinterruptingThread\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n\t\tnumAttached\t0\tint\n+\t\tnext\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tjoiners\t0x060e65c0 {parent=0x077a1d90 handle=0xfffffffe mutex=0x05fcf318 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tmonitor\t0x052e47e8 {name=0xcdcdcdcd <Bad Ptr> mutex=0x06bfed80 lock=0x06bff148 ...}\tdecaf::internal::util::concurrent::MonitorHandle *\n{noformat} \n\nI'm not sure if this is a race condition or if the flags are not updated properly.", "comments": [], "text": "Experiencing deadlock while destroying activemq::core::ActiveMQConnection\n\nDescription:\nThe deadlock occurs while destroying an amq connection, a broker connection as been establish.\n\nI added a break point inside before termination decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition, and before the deadlock occurs i can see\nthe following threads:\n{noformat} \n0\t \t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::Threading::join\tNormal\t0\n0\t \t8252\tWorker Thread\tWin32 Thread\t776ef959\tNormal\t0\n0\t \t5280\tWorker Thread\tWin32 Thread\t776f015d\tNormal\t0\n0\t \t8588\tWorker Thread\t_threadstartex\tCtiLocalConnect<CtiOutMessage,INMESS>::CtiLocalConnectRead\tNormal\t0\n0\t \t4916\tWorker Thread\t_threadstartex\t_CrtDefaultAllocHook\tNormal\t0\n0\t>\t5532\tWorker Thread\t_threadstartex\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n0\t \t1956\tWorker Thread\t_threadstartex\tstd::_Lockit::~_Lockit\tNormal\t0\n0\t \t5784\tWorker Thread\tWin32 Thread\tCtrlHandler\tHighest\t0\n0\t \t4512\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t7180\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t1668\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n{noformat} \n\nAt this moment, the call stack for thread 5532 is the following:\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x000007d8, _RTL_CRITICAL_SECTION * mutex=0x077dee10, __int64 mills=7659, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\n`anonymous namespace'::doWaitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, decaf::internal::util::concurrent::ThreadHandle * thread=0x05f338a8, __int64 mills=7659, int nanos=0, bool interruptible=true)  Line 752 + 0x23 bytes\tC++\ndecaf::internal::util::concurrent::Threading::waitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, __int64 mills=7659, int nanos=0)  Line 1558 + 0x1b bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659, int nanos=0)  Line 180 + 0x1a bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659)  Line 162\tC++\ndecaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=7659)  Line 54\tC++\ndecaf::util::TimerImpl::run()  Line 102 + 0x1f bytes\tC++\n`anonymous namespace'::runCallback(void * arg=0x05f338a8)  Line 266 + 0x11 bytes\tC++\n`anonymous namespace'::threadEntryMethod(void * arg=0x05f338a8)  Line 254 + 0x15 bytes\tC++\n{noformat} \n\nAfterwards, only the main thread is left and the deadlock occurs interruptibleWaitOnCondition at \"PlatformThread::unlockMutex(mutex);\"\n{noformat} \n0\t>\t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n{noformat} \n\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x001293d0, _RTL_CRITICAL_SECTION * mutex=0x1f13f1e8, __int64 mills=600000, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\ndecaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread=0x043eb370, __int64 mills=600000, int nanos=0)  Line 1168 + 0x23 bytes\tC++\ndecaf::lang::Thread::join(__int64 millisecs=600000)  Line 178 + 0x19 bytes\tC++\ndecaf::util::Timer::awaitTermination(__int64 timeout=10, const decaf::util::concurrent::TimeUnit & unit={...})  Line 236\tC++\ndecaf::util::concurrent::ExecutorKernel::~ExecutorKernel()  Line 419\tC++\ndecaf::util::concurrent::ExecutorKernel::`scalar deleting destructor'()  + 0xf bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::~ThreadPoolExecutor()  Line 1481 + 0x1f bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::`vector deleting destructor'()  + 0x4d bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::concurrent::ExecutorService * value=0x1f13b7f8)  Line 317 + 0x20 bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>()  Line 148 + 0xf bytes\tC++\nactivemq::core::ConnectionConfig::~ConnectionConfig()  Line 303 + 0x1ba bytes\tC++\nactivemq::core::ConnectionConfig::`scalar deleting destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::~ActiveMQConnection()  Line 501 + 0x1f bytes\tC++\nactivemq::core::ActiveMQConnection::`vbase destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::`vector deleting destructor'()  + 0x4d bytes\tC++\n{noformat} \n\nIf i look into the ThreadHandle object, i can see the threadId\t5532 and state == 4 (Thread::TIMED_WAITING), however the thread at this point is not running\n{noformat} \n-\t\tthread\t0x06054520 {parent=0x060543c0 handle=0x000007bc mutex=0x062ad498 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tparent\t0x060543c0 {heap={...} cancelled=true }\tdecaf::lang::Thread *\n\t\thandle\t0x000007bc\tvoid *\n+\t\tmutex\t0x062ad498 {DebugInfo=0x00373658 LockCount=-2 RecursionCount=1 ...}\t_RTL_CRITICAL_SECTION *\n\t\tcondition\t0x000007b8\tvoid *\n\t\tstate\t4\tvolatile int\n\t\treferences\t2\tvolatile int\n\t\tpriority\t5\tint\n\t\tinterrupted\tfalse\tbool\n\t\tinterruptible\ttrue\tbool\n\t\ttimerSet\ttrue\tbool\n\t\tcanceled\tfalse\tbool\n\t\tunparked\tfalse\tbool\n\t\tparked\tfalse\tbool\n\t\tsleeping\tfalse\tbool\n\t\twaiting\tfalse\tbool\n\t\tnotified\ttrue\tbool\n\t\tblocked\ttrue\tbool\n\t\tsuspended\tfalse\tbool\n+\t\tname\t0x062ad580 \"Thread-2\"\tchar *\n\t\tstackSize\t32768\t__int64\n+\t\ttls\t0x06054558\tvoid * [384]\n\t\tthreadMain\t0x00ecbf7c `anonymous namespace'::runCallback(void *)\tvoid (void *)*\n\t\tthreadArg\t0x06054520\tvoid *\n\t\tthreadId\t5532\t__int64\n\t\tosThread\tfalse\tbool\n+\t\tinterruptingThread\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n\t\tnumAttached\t0\tint\n+\t\tnext\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tjoiners\t0x060e65c0 {parent=0x077a1d90 handle=0xfffffffe mutex=0x05fcf318 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tmonitor\t0x052e47e8 {name=0xcdcdcdcd <Bad Ptr> mutex=0x06bfed80 lock=0x06bff148 ...}\tdecaf::internal::util::concurrent::MonitorHandle *\n{noformat} \n\nI'm not sure if this is a race condition or if the flags are not updated properly.\n\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Experiencing deadlock while destroying activemq::core::ActiveMQConnection\n\nDescription:\nThe deadlock occurs while destroying an amq connection, a broker connection as been establish.\n\nI added a break point inside before termination decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition, and before the deadlock occurs i can see\nthe following threads:\n{noformat} \n0\t \t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::Threading::join\tNormal\t0\n0\t \t8252\tWorker Thread\tWin32 Thread\t776ef959\tNormal\t0\n0\t \t5280\tWorker Thread\tWin32 Thread\t776f015d\tNormal\t0\n0\t \t8588\tWorker Thread\t_threadstartex\tCtiLocalConnect<CtiOutMessage,INMESS>::CtiLocalConnectRead\tNormal\t0\n0\t \t4916\tWorker Thread\t_threadstartex\t_CrtDefaultAllocHook\tNormal\t0\n0\t>\t5532\tWorker Thread\t_threadstartex\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n0\t \t1956\tWorker Thread\t_threadstartex\tstd::_Lockit::~_Lockit\tNormal\t0\n0\t \t5784\tWorker Thread\tWin32 Thread\tCtrlHandler\tHighest\t0\n0\t \t4512\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t7180\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n0\t \t1668\tWorker Thread\tWin32 Thread\t776f1f46\tNormal\t0\n{noformat} \n\nAt this moment, the call stack for thread 5532 is the following:\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x000007d8, _RTL_CRITICAL_SECTION * mutex=0x077dee10, __int64 mills=7659, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\n`anonymous namespace'::doWaitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, decaf::internal::util::concurrent::ThreadHandle * thread=0x05f338a8, __int64 mills=7659, int nanos=0, bool interruptible=true)  Line 752 + 0x23 bytes\tC++\ndecaf::internal::util::concurrent::Threading::waitOnMonitor(decaf::internal::util::concurrent::MonitorHandle * monitor=0x0771acf8, __int64 mills=7659, int nanos=0)  Line 1558 + 0x1b bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659, int nanos=0)  Line 180 + 0x1a bytes\tC++\ndecaf::util::concurrent::Mutex::wait(__int64 millisecs=7659)  Line 162\tC++\ndecaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=7659)  Line 54\tC++\ndecaf::util::TimerImpl::run()  Line 102 + 0x1f bytes\tC++\n`anonymous namespace'::runCallback(void * arg=0x05f338a8)  Line 266 + 0x11 bytes\tC++\n`anonymous namespace'::threadEntryMethod(void * arg=0x05f338a8)  Line 254 + 0x15 bytes\tC++\n{noformat} \n\nAfterwards, only the main thread is left and the deadlock occurs interruptibleWaitOnCondition at \"PlatformThread::unlockMutex(mutex);\"\n{noformat} \n0\t>\t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition\tNormal\t0\n{noformat} \n\n{noformat} \ndecaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition(void * condition=0x001293d0, _RTL_CRITICAL_SECTION * mutex=0x1f13f1e8, __int64 mills=600000, int nanos=0, decaf::internal::util::concurrent::CompletionCondition & complete={...})  Line 305 + 0xe bytes\tC++\ndecaf::internal::util::concurrent::Threading::join(decaf::internal::util::concurrent::ThreadHandle * thread=0x043eb370, __int64 mills=600000, int nanos=0)  Line 1168 + 0x23 bytes\tC++\ndecaf::lang::Thread::join(__int64 millisecs=600000)  Line 178 + 0x19 bytes\tC++\ndecaf::util::Timer::awaitTermination(__int64 timeout=10, const decaf::util::concurrent::TimeUnit & unit={...})  Line 236\tC++\ndecaf::util::concurrent::ExecutorKernel::~ExecutorKernel()  Line 419\tC++\ndecaf::util::concurrent::ExecutorKernel::`scalar deleting destructor'()  + 0xf bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::~ThreadPoolExecutor()  Line 1481 + 0x1f bytes\tC++\ndecaf::util::concurrent::ThreadPoolExecutor::`vector deleting destructor'()  + 0x4d bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(decaf::util::concurrent::ExecutorService * value=0x1f13b7f8)  Line 317 + 0x20 bytes\tC++\ndecaf::lang::Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<decaf::util::concurrent::ExecutorService,decaf::util::concurrent::atomic::AtomicRefCounter>()  Line 148 + 0xf bytes\tC++\nactivemq::core::ConnectionConfig::~ConnectionConfig()  Line 303 + 0x1ba bytes\tC++\nactivemq::core::ConnectionConfig::`scalar deleting destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::~ActiveMQConnection()  Line 501 + 0x1f bytes\tC++\nactivemq::core::ActiveMQConnection::`vbase destructor'()  + 0xf bytes\tC++\nactivemq::core::ActiveMQConnection::`vector deleting destructor'()  + 0x4d bytes\tC++\n{noformat} \n\nIf i look into the ThreadHandle object, i can see the threadId\t5532 and state == 4 (Thread::TIMED_WAITING), however the thread at this point is not running\n{noformat} \n-\t\tthread\t0x06054520 {parent=0x060543c0 handle=0x000007bc mutex=0x062ad498 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tparent\t0x060543c0 {heap={...} cancelled=true }\tdecaf::lang::Thread *\n\t\thandle\t0x000007bc\tvoid *\n+\t\tmutex\t0x062ad498 {DebugInfo=0x00373658 LockCount=-2 RecursionCount=1 ...}\t_RTL_CRITICAL_SECTION *\n\t\tcondition\t0x000007b8\tvoid *\n\t\tstate\t4\tvolatile int\n\t\treferences\t2\tvolatile int\n\t\tpriority\t5\tint\n\t\tinterrupted\tfalse\tbool\n\t\tinterruptible\ttrue\tbool\n\t\ttimerSet\ttrue\tbool\n\t\tcanceled\tfalse\tbool\n\t\tunparked\tfalse\tbool\n\t\tparked\tfalse\tbool\n\t\tsleeping\tfalse\tbool\n\t\twaiting\tfalse\tbool\n\t\tnotified\ttrue\tbool\n\t\tblocked\ttrue\tbool\n\t\tsuspended\tfalse\tbool\n+\t\tname\t0x062ad580 \"Thread-2\"\tchar *\n\t\tstackSize\t32768\t__int64\n+\t\ttls\t0x06054558\tvoid * [384]\n\t\tthreadMain\t0x00ecbf7c `anonymous namespace'::runCallback(void *)\tvoid (void *)*\n\t\tthreadArg\t0x06054520\tvoid *\n\t\tthreadId\t5532\t__int64\n\t\tosThread\tfalse\tbool\n+\t\tinterruptingThread\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n\t\tnumAttached\t0\tint\n+\t\tnext\t0x00000000 {parent=??? handle=??? mutex=??? ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tjoiners\t0x060e65c0 {parent=0x077a1d90 handle=0xfffffffe mutex=0x05fcf318 ...}\tdecaf::internal::util::concurrent::ThreadHandle *\n+\t\tmonitor\t0x052e47e8 {name=0xcdcdcdcd <Bad Ptr> mutex=0x06bfed80 lock=0x06bff148 ...}\tdecaf::internal::util::concurrent::MonitorHandle *\n{noformat} \n\nI'm not sure if this is a race condition or if the flags are not updated properly.\n\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Experiencing deadlock while destroying activemq::core::ActiveMQConnection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-524?\nA: The deadlock occurs while destroying an amq connection, a broker connection as been establish.\n\nI added a break point inside before termination decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition, and before the deadlock occurs i can see\nthe following threads:\n{noformat} \n0\t \t4396\tMain Thread\tPorterSvc\tdecaf::internal::util::concurrent::Threading::join\tNormal\t0\n0\t \t8252"}}
{"issue_key": "AMQCPP-523", "project": "AMQCPP", "title": "Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework", "status": "Closed", "reporter": "Sahayaraj", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2013-10-31T10:46:49.000+0000", "updated": "2013-10-31T13:47:26.000+0000", "description": "Steps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283", "comments": [], "text": "Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework\n\nDescription:\nSteps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework\n\nDescription:\nSteps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283\n\n\nComments:\n", "classification": "Classify the issue 'Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-523?\nA: Steps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with"}}
{"issue_key": "AMQCPP-522", "project": "AMQCPP", "title": "Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework", "status": "Closed", "reporter": "Sahayaraj", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2013-10-31T10:46:35.000+0000", "updated": "2013-10-31T15:59:24.000+0000", "description": "Steps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283", "comments": [], "text": "Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework\n\nDescription:\nSteps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework\n\nDescription:\nSteps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with the usage of CoreFoundation.framework from Mac OS 10.7 SDK.\n\nStep 5 :- Define the structure to createa linked list as follows\n\ntypedef struct myList {\n char name[128];\n struct myList *next;\n} myListType;\n\nvoid functiontocrash() {\nmyListType namelist[100] = {0};\n\n        CFStringRef pathRef = CFSTR(\"MyLib:Apache:ActiveMQ:\"); // it could be any folder path in HFS notion.\n        CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, pathRef, 2, TRUE);\n\n}\n\nStep 6: Build the application. It would be successful.\n\nStep 7: Run the application, then it crashes\n\nYou could get the following crash consistently\n\nThread 11 Crashed:\n0   com.apple.CoreFoundation      \t0x00007fff8ccd6f04 __CFStringCreateImmutableFunnel3 + 20\n1   com.apple.CoreFoundation      \t0x00007fff8ccebccb CFStringCreateWithBytes + 59\n2   com.apple.CoreFoundation      \t0x00007fff8ccf1a6c CFURLCreateFromFileSystemRepresentation + 428\n3   com.apple.CoreFoundation      \t0x00007fff8ccebdfb CFURLCreateWithFileSystemPath + 283\n\n\nComments:\n", "classification": "Classify the issue 'Memory corruption happens consistently during the access of any CFURL API's of CoreFoundation framework' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-522?\nA: Steps to recreate the issue.\n\nStep 1 :- Download the activemq-cpp-library-3.8.1-src.tar file from activemq website.\n\nStep 2 :- Build the library on Mac OS X 10.8.5 as per instructions given in ReadMe.txt file\n\nStep 3 :- Build will be successful and you could get static and dynamic binaries.\n\nStep 4:- Create a sample cmd-line application in XCode 4.4.1 and use the activemq static library along with"}}
{"issue_key": "AMQCPP-521", "project": "AMQCPP", "title": "The unit test \"TcpTransportTest::testTransportCreateWithRadomFailures\" can't pass", "status": "Closed", "reporter": "chenchen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-10-29T09:11:17.000+0000", "updated": "2013-11-07T23:15:57.000+0000", "description": "it will be bolcked while the unittest is executing TcpTransportTest::testTransportCreateWithRadomFailures. And when starting the transport, it will throw the Exception\"exceptionListener is invalid   FILE: ..\\src\\main\\activemq\\transport\\TransportFilter.cpp, LINE: 148\"", "comments": [], "text": "The unit test \"TcpTransportTest::testTransportCreateWithRadomFailures\" can't pass\n\nDescription:\nit will be bolcked while the unittest is executing TcpTransportTest::testTransportCreateWithRadomFailures. And when starting the transport, it will throw the Exception\"exceptionListener is invalid   FILE: ..\\src\\main\\activemq\\transport\\TransportFilter.cpp, LINE: 148\"\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The unit test \"TcpTransportTest::testTransportCreateWithRadomFailures\" can't pass\n\nDescription:\nit will be bolcked while the unittest is executing TcpTransportTest::testTransportCreateWithRadomFailures. And when starting the transport, it will throw the Exception\"exceptionListener is invalid   FILE: ..\\src\\main\\activemq\\transport\\TransportFilter.cpp, LINE: 148\"\n\nComments:\n", "classification": "Classify the issue 'The unit test \"TcpTransportTest::testTransportCreateWithRadomFailures\" can't pass' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-521?\nA: it will be bolcked while the unittest is executing TcpTransportTest::testTransportCreateWithRadomFailures. And when starting the transport, it will throw the Exception\"exceptionListener is invalid   FILE: ..\\src\\main\\activemq\\transport\\TransportFilter.cpp, LINE: 148\""}}
{"issue_key": "AMQCPP-520", "project": "AMQCPP", "title": "AMQ crashes when an exception comes during the connection closure", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["AMQCPP-463", "Regression", "from"], "created": "2013-10-15T08:24:18.000+0000", "updated": "2013-10-22T16:32:11.000+0000", "description": "From one thread, an exception comes and FailoverTransport::handleTransportFailure () is called:\n\nactivemq::transport::failover::CloseTransportsTask::add(const Pointer<Transport> transport)\nactivemq::transport::failover::FailoverTransport::handleTransportFailure(const decaf::lang::Exception & error={...})\nactivemq::transport::failover::FailoverTransportListener::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::wireformat::openwire::OpenWireFormatNegotiator::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::run()\ndecaf::lang::Thread::run()\n\n\nFrom another thread, the amq connection is being closed. It destructs the FailoverTransport without waiting that the first thread finishes to call handleTransportFailure():\n\nactivemq::transport::failover::FailoverTransport::~FailoverTransport()\nactivemq::transport::failover::FailoverTransport::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x02f307b0)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::transport::TransportFilter::~TransportFilter()\nactivemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator()\nactivemq::transport::correlator::ResponseCorrelator::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x03ba6058)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::core::ActiveMQConnection::disconnect(__int64 lastDeliveredSequenceId=0)\nactivemq::core::ActiveMQConnection::close()\n\n\nI don't have any simple test case as it is a race condition.\nI've attached a proposal patch.", "comments": [], "text": "AMQ crashes when an exception comes during the connection closure\n\nDescription:\nFrom one thread, an exception comes and FailoverTransport::handleTransportFailure () is called:\n\nactivemq::transport::failover::CloseTransportsTask::add(const Pointer<Transport> transport)\nactivemq::transport::failover::FailoverTransport::handleTransportFailure(const decaf::lang::Exception & error={...})\nactivemq::transport::failover::FailoverTransportListener::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::wireformat::openwire::OpenWireFormatNegotiator::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::run()\ndecaf::lang::Thread::run()\n\n\nFrom another thread, the amq connection is being closed. It destructs the FailoverTransport without waiting that the first thread finishes to call handleTransportFailure():\n\nactivemq::transport::failover::FailoverTransport::~FailoverTransport()\nactivemq::transport::failover::FailoverTransport::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x02f307b0)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::transport::TransportFilter::~TransportFilter()\nactivemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator()\nactivemq::transport::correlator::ResponseCorrelator::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x03ba6058)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::core::ActiveMQConnection::disconnect(__int64 lastDeliveredSequenceId=0)\nactivemq::core::ActiveMQConnection::close()\n\n\nI don't have any simple test case as it is a race condition.\nI've attached a proposal patch.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AMQ crashes when an exception comes during the connection closure\n\nDescription:\nFrom one thread, an exception comes and FailoverTransport::handleTransportFailure () is called:\n\nactivemq::transport::failover::CloseTransportsTask::add(const Pointer<Transport> transport)\nactivemq::transport::failover::FailoverTransport::handleTransportFailure(const decaf::lang::Exception & error={...})\nactivemq::transport::failover::FailoverTransportListener::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::wireformat::openwire::OpenWireFormatNegotiator::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::inactivity::InactivityMonitor::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::TransportFilter::onException(const decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::fire(decaf::lang::Exception & ex={...})\nactivemq::transport::IOTransport::run()\ndecaf::lang::Thread::run()\n\n\nFrom another thread, the amq connection is being closed. It destructs the FailoverTransport without waiting that the first thread finishes to call handleTransportFailure():\n\nactivemq::transport::failover::FailoverTransport::~FailoverTransport()\nactivemq::transport::failover::FailoverTransport::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x02f307b0)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::transport::TransportFilter::~TransportFilter()\nactivemq::transport::correlator::ResponseCorrelator::~ResponseCorrelator()\nactivemq::transport::correlator::ResponseCorrelator::`vector deleting destructor'(unsigned int)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::onDeleteFunc(activemq::transport::Transport * value=0x03ba6058)\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::~Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>()\ndecaf::lang::Pointer<activemq::transport::Transport,decaf::util::concurrent::atomic::AtomicRefCounter>::reset(activemq::transport::Transport * value=0x00000000)\nactivemq::core::ActiveMQConnection::disconnect(__int64 lastDeliveredSequenceId=0)\nactivemq::core::ActiveMQConnection::close()\n\n\nI don't have any simple test case as it is a race condition.\nI've attached a proposal patch.\n\n\nComments:\n", "classification": "Classify the issue 'AMQ crashes when an exception comes during the connection closure' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-520?\nA: From one thread, an exception comes and FailoverTransport::handleTransportFailure () is called:\n\nactivemq::transport::failover::CloseTransportsTask::add(const Pointer<Transport> transport)\nactivemq::transport::failover::FailoverTransport::handleTransportFailure(const decaf::lang::Exception & error={...})\nactivemq::transport::failover::FailoverTransportListener::onException(const decaf::lang::Excep"}}
{"issue_key": "AMQCPP-519", "project": "AMQCPP", "title": "Add framework for DiscoveryTransport and underlying agents.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-10-14T19:57:05.000+0000", "updated": "2015-07-16T16:36:12.000+0000", "description": "Future versions might want to add in Discovery Agents to allow for automatic discovery of running Brokers via multicast or http etc.  Before that can happen we need the framework around discovery transports.  The basic DiscoveryTransport is straight forward enough to add first and implement using the FailoverTransport and its ability to have new URIs added and removed.", "comments": [], "text": "Add framework for DiscoveryTransport and underlying agents.\n\nDescription:\nFuture versions might want to add in Discovery Agents to allow for automatic discovery of running Brokers via multicast or http etc.  Before that can happen we need the framework around discovery transports.  The basic DiscoveryTransport is straight forward enough to add first and implement using the FailoverTransport and its ability to have new URIs added and removed.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add framework for DiscoveryTransport and underlying agents.\n\nDescription:\nFuture versions might want to add in Discovery Agents to allow for automatic discovery of running Brokers via multicast or http etc.  Before that can happen we need the framework around discovery transports.  The basic DiscoveryTransport is straight forward enough to add first and implement using the FailoverTransport and its ability to have new URIs added and removed.  \n\nComments:\n", "classification": "Classify the issue 'Add framework for DiscoveryTransport and underlying agents.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-519?\nA: Future versions might want to add in Discovery Agents to allow for automatic discovery of running Brokers via multicast or http etc.  Before that can happen we need the framework around discovery transports.  The basic DiscoveryTransport is straight forward enough to add first and implement using the FailoverTransport and its ability to have new URIs added and removed.  "}}
{"issue_key": "AMQCPP-518", "project": "AMQCPP", "title": "dispatch paused, waiting for outstanding dispatch interruption processing to complete..", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2013-10-09T21:58:29.000+0000", "updated": "2013-10-09T22:06:14.000+0000", "description": "Race condition between consumer close and transport calculation of outstanding interruption processing. Transport thinks there are more responses required before allowing dispatch due to a mis count of active consumers.\n\nPort this fix from AMQ-4791", "comments": [], "text": "dispatch paused, waiting for outstanding dispatch interruption processing to complete..\n\nDescription:\nRace condition between consumer close and transport calculation of outstanding interruption processing. Transport thinks there are more responses required before allowing dispatch due to a mis count of active consumers.\n\nPort this fix from AMQ-4791\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: dispatch paused, waiting for outstanding dispatch interruption processing to complete..\n\nDescription:\nRace condition between consumer close and transport calculation of outstanding interruption processing. Transport thinks there are more responses required before allowing dispatch due to a mis count of active consumers.\n\nPort this fix from AMQ-4791\n\n\nComments:\n", "classification": "Classify the issue 'dispatch paused, waiting for outstanding dispatch interruption processing to complete..' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-518?\nA: Race condition between consumer close and transport calculation of outstanding interruption processing. Transport thinks there are more responses required before allowing dispatch due to a mis count of active consumers.\n\nPort this fix from AMQ-4791\n"}}
{"issue_key": "AMQCPP-517", "project": "AMQCPP", "title": "Can anyone to help me.....to building a function in C that send a message to insert in queue of Apollo??", "status": "Closed", "reporter": "Vilmar Resende", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2013-10-09T19:11:13.000+0000", "updated": "2013-10-16T13:14:20.000+0000", "description": "", "comments": [], "text": "Can anyone to help me.....to building a function in C that send a message to insert in queue of Apollo??\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can anyone to help me.....to building a function in C that send a message to insert in queue of Apollo??\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Can anyone to help me.....to building a function in C that send a message to insert in queue of Apollo??' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-517?\nA: "}}
{"issue_key": "AMQCPP-516", "project": "AMQCPP", "title": "Don't fire transport interrupted event when no resume is possuble", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2013-10-09T16:31:55.000+0000", "updated": "2013-10-09T16:34:13.000+0000", "description": "Don't fire transport interrupted if there will never be a transport resumed such as the case where maxReconnectAttempts is zero.", "comments": [], "text": "Don't fire transport interrupted event when no resume is possuble\n\nDescription:\nDon't fire transport interrupted if there will never be a transport resumed such as the case where maxReconnectAttempts is zero.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Don't fire transport interrupted event when no resume is possuble\n\nDescription:\nDon't fire transport interrupted if there will never be a transport resumed such as the case where maxReconnectAttempts is zero.  \n\nComments:\n", "classification": "Classify the issue 'Don't fire transport interrupted event when no resume is possuble' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-516?\nA: Don't fire transport interrupted if there will never be a transport resumed such as the case where maxReconnectAttempts is zero.  "}}
{"issue_key": "AMQCPP-621", "project": "AMQCPP", "title": "Failover - transport connected to one broker fails due to error in connection to another broker", "status": "Open", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["failover", "race-condition"], "created": "2017-12-19T08:52:56.000+0000", "updated": "2017-12-19T08:52:56.000+0000", "description": "C++ client has the same issue of AMQ-6248.\r\nCould someone merge the fix to the C++ API?", "comments": [], "text": "Failover - transport connected to one broker fails due to error in connection to another broker\n\nDescription:\nC++ client has the same issue of AMQ-6248.\r\nCould someone merge the fix to the C++ API?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover - transport connected to one broker fails due to error in connection to another broker\n\nDescription:\nC++ client has the same issue of AMQ-6248.\r\nCould someone merge the fix to the C++ API?\n\nComments:\n", "classification": "Classify the issue 'Failover - transport connected to one broker fails due to error in connection to another broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-621?\nA: C++ client has the same issue of AMQ-6248.\r\nCould someone merge the fix to the C++ API?"}}
{"issue_key": "AMQCPP-620", "project": "AMQCPP", "title": "Retroactive consumer not reliable", "status": "Open", "reporter": "John Prillaman", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2017-08-30T13:51:14.000+0000", "updated": "2017-08-30T19:05:30.000+0000", "description": "Adding the retroactive parameter to the broker URI does not produce reliable results. This can be reproduced by modifying the example code (http://activemq.apache.org/cms/example.html), changing the brokerURI value to  \"failover:(tcp://localhost:61616?consumer.retroactive=true)\";\n\nIf the destination topic has been created and populated on the activeMQ broker the expected result is to see the data printed from the onMessage callback immediately. This happens most of the time but if the example program is run multiple times the expected result will not be observed. Modifying the waitMillis by reducing the wait time will allow for a quicker reproducing of the issue, however if the data is seen immediately the program can be killed and executed again. It may take up to 25-30 times or more before seeing the failure or it may take 3 times.\n\nThe dispatch count is observed to be incremented in the JMX console when the data is not printed. The data will be printed if the topic is populated through another client connection publishing data even if the 'retroactive' data was not received.\n\nI believe this issue is in the ActiveMQ-CPP library as other clients reliably receive this data through other connections. if the CPP client is changed to use the synchronous blocking receive method as opposed to the asynchronous callbacks in the consumer the data is received as expected.", "comments": [], "text": "Retroactive consumer not reliable\n\nDescription:\nAdding the retroactive parameter to the broker URI does not produce reliable results. This can be reproduced by modifying the example code (http://activemq.apache.org/cms/example.html), changing the brokerURI value to  \"failover:(tcp://localhost:61616?consumer.retroactive=true)\";\n\nIf the destination topic has been created and populated on the activeMQ broker the expected result is to see the data printed from the onMessage callback immediately. This happens most of the time but if the example program is run multiple times the expected result will not be observed. Modifying the waitMillis by reducing the wait time will allow for a quicker reproducing of the issue, however if the data is seen immediately the program can be killed and executed again. It may take up to 25-30 times or more before seeing the failure or it may take 3 times.\n\nThe dispatch count is observed to be incremented in the JMX console when the data is not printed. The data will be printed if the topic is populated through another client connection publishing data even if the 'retroactive' data was not received.\n\nI believe this issue is in the ActiveMQ-CPP library as other clients reliably receive this data through other connections. if the CPP client is changed to use the synchronous blocking receive method as opposed to the asynchronous callbacks in the consumer the data is received as expected.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Retroactive consumer not reliable\n\nDescription:\nAdding the retroactive parameter to the broker URI does not produce reliable results. This can be reproduced by modifying the example code (http://activemq.apache.org/cms/example.html), changing the brokerURI value to  \"failover:(tcp://localhost:61616?consumer.retroactive=true)\";\n\nIf the destination topic has been created and populated on the activeMQ broker the expected result is to see the data printed from the onMessage callback immediately. This happens most of the time but if the example program is run multiple times the expected result will not be observed. Modifying the waitMillis by reducing the wait time will allow for a quicker reproducing of the issue, however if the data is seen immediately the program can be killed and executed again. It may take up to 25-30 times or more before seeing the failure or it may take 3 times.\n\nThe dispatch count is observed to be incremented in the JMX console when the data is not printed. The data will be printed if the topic is populated through another client connection publishing data even if the 'retroactive' data was not received.\n\nI believe this issue is in the ActiveMQ-CPP library as other clients reliably receive this data through other connections. if the CPP client is changed to use the synchronous blocking receive method as opposed to the asynchronous callbacks in the consumer the data is received as expected.\n\n\nComments:\n", "classification": "Classify the issue 'Retroactive consumer not reliable' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-620?\nA: Adding the retroactive parameter to the broker URI does not produce reliable results. This can be reproduced by modifying the example code (http://activemq.apache.org/cms/example.html), changing the brokerURI value to  \"failover:(tcp://localhost:61616?consumer.retroactive=true)\";\n\nIf the destination topic has been created and populated on the activeMQ broker the expected result is to see the data "}}
{"issue_key": "AMQCPP-619", "project": "AMQCPP", "title": "Support for SSL wilcard certificate", "status": "Resolved", "reporter": "Francois Godin", "assignee": "Jamie Mark Goodyear", "priority": "Major", "labels": [], "created": "2017-08-16T14:46:53.000+0000", "updated": "2018-12-07T18:20:13.000+0000", "description": "SSL certificate can contain wildcard in the hostname. For example, the certificate URL \"*.proxy.app.com\" should match the following address:\n* 1.proxy.app.com\n* 2.proxy.app.com\n\nSadly, ActiveMQ-CPP simply compare the two values and thus does not accept such certificates.\n\nThe Openssl page https://wiki.openssl.org/index.php/Hostname_validation describe some possible implementation.", "comments": [], "text": "Support for SSL wilcard certificate\n\nDescription:\nSSL certificate can contain wildcard in the hostname. For example, the certificate URL \"*.proxy.app.com\" should match the following address:\n* 1.proxy.app.com\n* 2.proxy.app.com\n\nSadly, ActiveMQ-CPP simply compare the two values and thus does not accept such certificates.\n\nThe Openssl page https://wiki.openssl.org/index.php/Hostname_validation describe some possible implementation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Support for SSL wilcard certificate\n\nDescription:\nSSL certificate can contain wildcard in the hostname. For example, the certificate URL \"*.proxy.app.com\" should match the following address:\n* 1.proxy.app.com\n* 2.proxy.app.com\n\nSadly, ActiveMQ-CPP simply compare the two values and thus does not accept such certificates.\n\nThe Openssl page https://wiki.openssl.org/index.php/Hostname_validation describe some possible implementation.\n\nComments:\n", "classification": "Classify the issue 'Support for SSL wilcard certificate' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-619?\nA: SSL certificate can contain wildcard in the hostname. For example, the certificate URL \"*.proxy.app.com\" should match the following address:\n* 1.proxy.app.com\n* 2.proxy.app.com\n\nSadly, ActiveMQ-CPP simply compare the two values and thus does not accept such certificates.\n\nThe Openssl page https://wiki.openssl.org/index.php/Hostname_validation describe some possible implementation."}}
{"issue_key": "AMQCPP-618", "project": "AMQCPP", "title": "Build failure on Ubuntu 16.04", "status": "Open", "reporter": "Jerry Quinn", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["build"], "created": "2017-08-15T19:21:46.000+0000", "updated": "2017-08-15T19:21:46.000+0000", "description": "I downloaded and configured as:\n\n./configure --prefix=/opt/apache/activemq-cpp-3.9.4\n\nThe configure completed with no problems, but the build failed with a couple of errors:\n\nIn file included from decaf/internal/net/ssl/openssl/OpenSSLParameters.cpp:18:0:\ndecaf/internal/net/ssl/openssl/OpenSSLParameters.h:27:25: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX -D_REENTRANT -D_GNU_SOURCE -I/usr/include/apr-1.0 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.lo -MD -MP -MF activemq/commands/.deps/libactivemq_cpp_la-ActiveMQTempQueue.Tpo -c activemq/commands/ActiveMQTempQueue.cpp -o activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.o >/dev/null 2>&1\ndecaf/internal/net/ssl/openssl/OpenSSLServerSocket.cpp:21:29: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\n\nOn Ubuntu, the solution to the build failure is to install libssl-dev.  However, I feel the configure script should require the presence of this file if the build will fail without it.", "comments": [], "text": "Build failure on Ubuntu 16.04\n\nDescription:\nI downloaded and configured as:\n\n./configure --prefix=/opt/apache/activemq-cpp-3.9.4\n\nThe configure completed with no problems, but the build failed with a couple of errors:\n\nIn file included from decaf/internal/net/ssl/openssl/OpenSSLParameters.cpp:18:0:\ndecaf/internal/net/ssl/openssl/OpenSSLParameters.h:27:25: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX -D_REENTRANT -D_GNU_SOURCE -I/usr/include/apr-1.0 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.lo -MD -MP -MF activemq/commands/.deps/libactivemq_cpp_la-ActiveMQTempQueue.Tpo -c activemq/commands/ActiveMQTempQueue.cpp -o activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.o >/dev/null 2>&1\ndecaf/internal/net/ssl/openssl/OpenSSLServerSocket.cpp:21:29: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\n\nOn Ubuntu, the solution to the build failure is to install libssl-dev.  However, I feel the configure script should require the presence of this file if the build will fail without it.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Build failure on Ubuntu 16.04\n\nDescription:\nI downloaded and configured as:\n\n./configure --prefix=/opt/apache/activemq-cpp-3.9.4\n\nThe configure completed with no problems, but the build failed with a couple of errors:\n\nIn file included from decaf/internal/net/ssl/openssl/OpenSSLParameters.cpp:18:0:\ndecaf/internal/net/ssl/openssl/OpenSSLParameters.h:27:25: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX -D_REENTRANT -D_GNU_SOURCE -I/usr/include/apr-1.0 -W -Wall -Wextra -Wconversion -fPIC -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -pthread -MT activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.lo -MD -MP -MF activemq/commands/.deps/libactivemq_cpp_la-ActiveMQTempQueue.Tpo -c activemq/commands/ActiveMQTempQueue.cpp -o activemq/commands/libactivemq_cpp_la-ActiveMQTempQueue.o >/dev/null 2>&1\ndecaf/internal/net/ssl/openssl/OpenSSLServerSocket.cpp:21:29: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\n\nOn Ubuntu, the solution to the build failure is to install libssl-dev.  However, I feel the configure script should require the presence of this file if the build will fail without it.\n\n\n\nComments:\n", "classification": "Classify the issue 'Build failure on Ubuntu 16.04' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-618?\nA: I downloaded and configured as:\n\n./configure --prefix=/opt/apache/activemq-cpp-3.9.4\n\nThe configure completed with no problems, but the build failed with a couple of errors:\n\nIn file included from decaf/internal/net/ssl/openssl/OpenSSLParameters.cpp:18:0:\ndecaf/internal/net/ssl/openssl/OpenSSLParameters.h:27:25: fatal error: openssl/ssl.h: No such file or directory\ncompilation terminated.\n\n\nlibtoo"}}
{"issue_key": "AMQCPP-617", "project": "AMQCPP", "title": "Segfault when using a QueueBrowser.", "status": "Open", "reporter": "Francois Godin", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2017-07-12T18:05:20.000+0000", "updated": "2017-08-16T14:38:54.000+0000", "description": "I encountered a rare (but that still happened a couple of time) crash due to the ActiveMQ C++ library.\n\nh2. Information\nI've done some digging and the crash happen when the function activemq::core::Browser::dispatch call activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable. The segfault happen at the first member access in ActiveMQQueueBrowser.\n\nh3. Core dump\n#0  0x00007f38f7736758 in decaf::util::concurrent::Lock::lock() ()\n   from .../lib/libactivemq-cpp.so.19\n#1  0x00007f38f7736875 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) ()\n   from .../lib/libactivemq-cpp.so.19\n#2  0x00007f38f73f0f5d in activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable() ()\n   from .../lib/libactivemq-cpp.so.19\n#3  0x00007f38f73f4cd1 in activemq::core::Browser::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#4  0x00007f38f7406c24 in activemq::core::ActiveMQSessionExecutor::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#5  0x00007f38f7407ce5 in activemq::core::ActiveMQSessionExecutor::iterate() ()\n   from .../lib/libactivemq-cpp.so.19\n#6  0x00007f38f7543565 in activemq::threads::DedicatedTaskRunner::run() ()\n   from .../lib/libactivemq-cpp.so.19\n#7  0x00007f38f76acbef in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#8  0x00007f38f76ac964 in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#9  0x00007f38f9120aa1 in start_thread () from /lib64/libpthread.so.0\n#10 0x00007f38f941eaad in ioperm () from /lib64/libc.so.6\n#11 0x0000000000000000 in ?? ()\n\nh3. Usage of the library\nint getMessageCountInQueue(cms::Session* session, cms::Queue* queue) {\n\tstd::unique_ptr<cms::QueueBrowser> browser(session->createBrowser(queue));\n\tcms::MessageEnumeration* enumeration = browser->getEnumeration();\n\tint count = 0;\n\twhile(enumeration->hasMoreMessages()) {\n\t\tcount++;\n\t\tcms::Message* msg = enumeration->nextMessage();\n\t\tdelete msg;\n\t}\n\treturn count;\n}\n\nh2. After some analysis, I have the following hypothesis:\nIt seems that when I destroy the ActiveMQQueueBrowser (and thus call destroyConsumer), the Browser instance that refer to it may be kept alive by activemq::core::ActiveMQSessionExecutor::dispatch (as it is stored in a shared_ptr). \nOften it is no problem as Browser::dispatch is not called but I guess it may happen rarely and cause the segfault.\n\nh2. Proposed solution\nThe basic ActiveMQConsumerKernel::dispatch should be protected against that problem because it lock and check if the consumer is closed (which it is). It just happen that the Browser::dispatch did not have those check and thus will always execute the code.\nAs such, I propose splitting ActiveMQConsumerKernel::dispatch into two:\n# The cleanup, locking and check into the new ActiveMQConsumerKernel::dispatch\n# The operation itself into ActiveMQConsummerKernel::dispatchImpl.\n\nThen, Browser only need to override dispatchImpl and will have the same protection that ActiveMQConsumerKernel had.", "comments": [], "text": "Segfault when using a QueueBrowser.\n\nDescription:\nI encountered a rare (but that still happened a couple of time) crash due to the ActiveMQ C++ library.\n\nh2. Information\nI've done some digging and the crash happen when the function activemq::core::Browser::dispatch call activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable. The segfault happen at the first member access in ActiveMQQueueBrowser.\n\nh3. Core dump\n#0  0x00007f38f7736758 in decaf::util::concurrent::Lock::lock() ()\n   from .../lib/libactivemq-cpp.so.19\n#1  0x00007f38f7736875 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) ()\n   from .../lib/libactivemq-cpp.so.19\n#2  0x00007f38f73f0f5d in activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable() ()\n   from .../lib/libactivemq-cpp.so.19\n#3  0x00007f38f73f4cd1 in activemq::core::Browser::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#4  0x00007f38f7406c24 in activemq::core::ActiveMQSessionExecutor::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#5  0x00007f38f7407ce5 in activemq::core::ActiveMQSessionExecutor::iterate() ()\n   from .../lib/libactivemq-cpp.so.19\n#6  0x00007f38f7543565 in activemq::threads::DedicatedTaskRunner::run() ()\n   from .../lib/libactivemq-cpp.so.19\n#7  0x00007f38f76acbef in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#8  0x00007f38f76ac964 in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#9  0x00007f38f9120aa1 in start_thread () from /lib64/libpthread.so.0\n#10 0x00007f38f941eaad in ioperm () from /lib64/libc.so.6\n#11 0x0000000000000000 in ?? ()\n\nh3. Usage of the library\nint getMessageCountInQueue(cms::Session* session, cms::Queue* queue) {\n\tstd::unique_ptr<cms::QueueBrowser> browser(session->createBrowser(queue));\n\tcms::MessageEnumeration* enumeration = browser->getEnumeration();\n\tint count = 0;\n\twhile(enumeration->hasMoreMessages()) {\n\t\tcount++;\n\t\tcms::Message* msg = enumeration->nextMessage();\n\t\tdelete msg;\n\t}\n\treturn count;\n}\n\nh2. After some analysis, I have the following hypothesis:\nIt seems that when I destroy the ActiveMQQueueBrowser (and thus call destroyConsumer), the Browser instance that refer to it may be kept alive by activemq::core::ActiveMQSessionExecutor::dispatch (as it is stored in a shared_ptr). \nOften it is no problem as Browser::dispatch is not called but I guess it may happen rarely and cause the segfault.\n\nh2. Proposed solution\nThe basic ActiveMQConsumerKernel::dispatch should be protected against that problem because it lock and check if the consumer is closed (which it is). It just happen that the Browser::dispatch did not have those check and thus will always execute the code.\nAs such, I propose splitting ActiveMQConsumerKernel::dispatch into two:\n# The cleanup, locking and check into the new ActiveMQConsumerKernel::dispatch\n# The operation itself into ActiveMQConsummerKernel::dispatchImpl.\n\nThen, Browser only need to override dispatchImpl and will have the same protection that ActiveMQConsumerKernel had.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segfault when using a QueueBrowser.\n\nDescription:\nI encountered a rare (but that still happened a couple of time) crash due to the ActiveMQ C++ library.\n\nh2. Information\nI've done some digging and the crash happen when the function activemq::core::Browser::dispatch call activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable. The segfault happen at the first member access in ActiveMQQueueBrowser.\n\nh3. Core dump\n#0  0x00007f38f7736758 in decaf::util::concurrent::Lock::lock() ()\n   from .../lib/libactivemq-cpp.so.19\n#1  0x00007f38f7736875 in decaf::util::concurrent::Lock::Lock(decaf::util::concurrent::Synchronizable*, bool) ()\n   from .../lib/libactivemq-cpp.so.19\n#2  0x00007f38f73f0f5d in activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable() ()\n   from .../lib/libactivemq-cpp.so.19\n#3  0x00007f38f73f4cd1 in activemq::core::Browser::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#4  0x00007f38f7406c24 in activemq::core::ActiveMQSessionExecutor::dispatch(decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> const&) ()\n   from .../lib/libactivemq-cpp.so.19\n#5  0x00007f38f7407ce5 in activemq::core::ActiveMQSessionExecutor::iterate() ()\n   from .../lib/libactivemq-cpp.so.19\n#6  0x00007f38f7543565 in activemq::threads::DedicatedTaskRunner::run() ()\n   from .../lib/libactivemq-cpp.so.19\n#7  0x00007f38f76acbef in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#8  0x00007f38f76ac964 in ?? ()\n   from .../lib/libactivemq-cpp.so.19\n#9  0x00007f38f9120aa1 in start_thread () from /lib64/libpthread.so.0\n#10 0x00007f38f941eaad in ioperm () from /lib64/libc.so.6\n#11 0x0000000000000000 in ?? ()\n\nh3. Usage of the library\nint getMessageCountInQueue(cms::Session* session, cms::Queue* queue) {\n\tstd::unique_ptr<cms::QueueBrowser> browser(session->createBrowser(queue));\n\tcms::MessageEnumeration* enumeration = browser->getEnumeration();\n\tint count = 0;\n\twhile(enumeration->hasMoreMessages()) {\n\t\tcount++;\n\t\tcms::Message* msg = enumeration->nextMessage();\n\t\tdelete msg;\n\t}\n\treturn count;\n}\n\nh2. After some analysis, I have the following hypothesis:\nIt seems that when I destroy the ActiveMQQueueBrowser (and thus call destroyConsumer), the Browser instance that refer to it may be kept alive by activemq::core::ActiveMQSessionExecutor::dispatch (as it is stored in a shared_ptr). \nOften it is no problem as Browser::dispatch is not called but I guess it may happen rarely and cause the segfault.\n\nh2. Proposed solution\nThe basic ActiveMQConsumerKernel::dispatch should be protected against that problem because it lock and check if the consumer is closed (which it is). It just happen that the Browser::dispatch did not have those check and thus will always execute the code.\nAs such, I propose splitting ActiveMQConsumerKernel::dispatch into two:\n# The cleanup, locking and check into the new ActiveMQConsumerKernel::dispatch\n# The operation itself into ActiveMQConsummerKernel::dispatchImpl.\n\nThen, Browser only need to override dispatchImpl and will have the same protection that ActiveMQConsumerKernel had.\n\n\nComments:\n", "classification": "Classify the issue 'Segfault when using a QueueBrowser.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-617?\nA: I encountered a rare (but that still happened a couple of time) crash due to the ActiveMQ C++ library.\n\nh2. Information\nI've done some digging and the crash happen when the function activemq::core::Browser::dispatch call activemq::core::ActiveMQQueueBrowser::notifyMessageAvailable. The segfault happen at the first member access in ActiveMQQueueBrowser.\n\nh3. Core dump\n#0  0x00007f38f7736758 in deca"}}
{"issue_key": "AMQCPP-612", "project": "AMQCPP", "title": "System::arraycopy weird tests", "status": "Open", "reporter": "David Carlier", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2017-03-28T13:08:36.000+0000", "updated": "2017-03-28T13:09:23.000+0000", "description": "Hi,\n\nI was reading the source code especially System::arraycopy family methods :\n\nhttps://git-wip-us.apache.org/repos/asf?p=activemq-cpp.git;a=blob;f=activemq-cpp/src/main/decaf/lang/System.cpp;h=199dd660ca58a23862e93109fa9827444728bf13;hb=HEAD#l120\n\nand was wonderined if :\n- Testing twice src was intentional since I suppose it should be dest as second test for example ?\n- Should not it be always memmove since src and dest can still overlap ?\n\nRegards.", "comments": [], "text": "System::arraycopy weird tests\n\nDescription:\nHi,\n\nI was reading the source code especially System::arraycopy family methods :\n\nhttps://git-wip-us.apache.org/repos/asf?p=activemq-cpp.git;a=blob;f=activemq-cpp/src/main/decaf/lang/System.cpp;h=199dd660ca58a23862e93109fa9827444728bf13;hb=HEAD#l120\n\nand was wonderined if :\n- Testing twice src was intentional since I suppose it should be dest as second test for example ?\n- Should not it be always memmove since src and dest can still overlap ?\n\nRegards.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: System::arraycopy weird tests\n\nDescription:\nHi,\n\nI was reading the source code especially System::arraycopy family methods :\n\nhttps://git-wip-us.apache.org/repos/asf?p=activemq-cpp.git;a=blob;f=activemq-cpp/src/main/decaf/lang/System.cpp;h=199dd660ca58a23862e93109fa9827444728bf13;hb=HEAD#l120\n\nand was wonderined if :\n- Testing twice src was intentional since I suppose it should be dest as second test for example ?\n- Should not it be always memmove since src and dest can still overlap ?\n\nRegards.\n\nComments:\n", "classification": "Classify the issue 'System::arraycopy weird tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-612?\nA: Hi,\n\nI was reading the source code especially System::arraycopy family methods :\n\nhttps://git-wip-us.apache.org/repos/asf?p=activemq-cpp.git;a=blob;f=activemq-cpp/src/main/decaf/lang/System.cpp;h=199dd660ca58a23862e93109fa9827444728bf13;hb=HEAD#l120\n\nand was wonderined if :\n- Testing twice src was intentional since I suppose it should be dest as second test for example ?\n- Should not it be always "}}
{"issue_key": "AMQCPP-611", "project": "AMQCPP", "title": "Issue with backup option", "status": "Open", "reporter": "Michele Bozzaotre", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["windows"], "created": "2017-02-21T11:20:59.000+0000", "updated": "2017-02-21T11:20:59.000+0000", "description": "I'm running a client connecting to a cluster of two brokers, with backup option enabled.\n\nScenario 1:\n\nThe client URI is:\nfailover:(tcp://host1:61616,tcp://host2:61616)?randomize=false&backup=true\nWhen both hosts are active, the client connects to host1 at the startup and works fine. Once I unplug host1 from the network, the client is able to switch very fast to host2 as expected and continues to work fine. Now, if I immediately restore the network connection on host1, the client remains connected to host2, but it starts to loose entire sequences of messages from the broker.\n\n\nScenario 2\n\nThe client URI is:\nfailover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true\nThe clients starts and establishes connection to local host.\nIf I unplug local host from the network, the client is able to switch to the remote host very quickly, as expected. Now, if I immediately restore the network connection on local host, the client enters a loop where it switches very fast the connection between the two hosts, with a frequency of about half a second. During this swing, the client is still able to receive all the messages. Once you unplug one of the hosts, the client stops to switch and stayes connected to the other one.\n\nPlease, let me know if you need more details.\nThanks", "comments": [], "text": "Issue with backup option\n\nDescription:\nI'm running a client connecting to a cluster of two brokers, with backup option enabled.\n\nScenario 1:\n\nThe client URI is:\nfailover:(tcp://host1:61616,tcp://host2:61616)?randomize=false&backup=true\nWhen both hosts are active, the client connects to host1 at the startup and works fine. Once I unplug host1 from the network, the client is able to switch very fast to host2 as expected and continues to work fine. Now, if I immediately restore the network connection on host1, the client remains connected to host2, but it starts to loose entire sequences of messages from the broker.\n\n\nScenario 2\n\nThe client URI is:\nfailover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true\nThe clients starts and establishes connection to local host.\nIf I unplug local host from the network, the client is able to switch to the remote host very quickly, as expected. Now, if I immediately restore the network connection on local host, the client enters a loop where it switches very fast the connection between the two hosts, with a frequency of about half a second. During this swing, the client is still able to receive all the messages. Once you unplug one of the hosts, the client stops to switch and stayes connected to the other one.\n\nPlease, let me know if you need more details.\nThanks\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Issue with backup option\n\nDescription:\nI'm running a client connecting to a cluster of two brokers, with backup option enabled.\n\nScenario 1:\n\nThe client URI is:\nfailover:(tcp://host1:61616,tcp://host2:61616)?randomize=false&backup=true\nWhen both hosts are active, the client connects to host1 at the startup and works fine. Once I unplug host1 from the network, the client is able to switch very fast to host2 as expected and continues to work fine. Now, if I immediately restore the network connection on host1, the client remains connected to host2, but it starts to loose entire sequences of messages from the broker.\n\n\nScenario 2\n\nThe client URI is:\nfailover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true\nThe clients starts and establishes connection to local host.\nIf I unplug local host from the network, the client is able to switch to the remote host very quickly, as expected. Now, if I immediately restore the network connection on local host, the client enters a loop where it switches very fast the connection between the two hosts, with a frequency of about half a second. During this swing, the client is still able to receive all the messages. Once you unplug one of the hosts, the client stops to switch and stayes connected to the other one.\n\nPlease, let me know if you need more details.\nThanks\n\nComments:\n", "classification": "Classify the issue 'Issue with backup option' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-611?\nA: I'm running a client connecting to a cluster of two brokers, with backup option enabled.\n\nScenario 1:\n\nThe client URI is:\nfailover:(tcp://host1:61616,tcp://host2:61616)?randomize=false&backup=true\nWhen both hosts are active, the client connects to host1 at the startup and works fine. Once I unplug host1 from the network, the client is able to switch very fast to host2 as expected and continues to "}}
{"issue_key": "AMQCPP-610", "project": "AMQCPP", "title": "Stall when maxReconnectAttempts is set to zero", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2017-02-09T21:41:25.000+0000", "updated": "2017-02-09T21:43:53.000+0000", "description": "If failover maxReconnectAttempts is set to zero no initial connect attempt is tried and the close can hang", "comments": [], "text": "Stall when maxReconnectAttempts is set to zero\n\nDescription:\nIf failover maxReconnectAttempts is set to zero no initial connect attempt is tried and the close can hang\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stall when maxReconnectAttempts is set to zero\n\nDescription:\nIf failover maxReconnectAttempts is set to zero no initial connect attempt is tried and the close can hang\n\nComments:\n", "classification": "Classify the issue 'Stall when maxReconnectAttempts is set to zero' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-610?\nA: If failover maxReconnectAttempts is set to zero no initial connect attempt is tried and the close can hang"}}
{"issue_key": "AMQCPP-609", "project": "AMQCPP", "title": "Prevent unnecesary reconnect attempt with failover during shutdown", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2017-02-08T22:34:53.000+0000", "updated": "2017-02-08T22:37:27.000+0000", "description": "During connection close the shutdown command is sent to the broker and it is possible for the socket connection to be broken before the actual calls to close the transport registers which can lead to an unnecessary connection attempt.", "comments": [], "text": "Prevent unnecesary reconnect attempt with failover during shutdown\n\nDescription:\nDuring connection close the shutdown command is sent to the broker and it is possible for the socket connection to be broken before the actual calls to close the transport registers which can lead to an unnecessary connection attempt.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Prevent unnecesary reconnect attempt with failover during shutdown\n\nDescription:\nDuring connection close the shutdown command is sent to the broker and it is possible for the socket connection to be broken before the actual calls to close the transport registers which can lead to an unnecessary connection attempt.\n\nComments:\n", "classification": "Classify the issue 'Prevent unnecesary reconnect attempt with failover during shutdown' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-609?\nA: During connection close the shutdown command is sent to the broker and it is possible for the socket connection to be broken before the actual calls to close the transport registers which can lead to an unnecessary connection attempt."}}
{"issue_key": "AMQCPP-608", "project": "AMQCPP", "title": "cannot disable InactivityMonitor", "status": "Closed", "reporter": "Wolfgang Klein", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2017-01-25T11:01:26.000+0000", "updated": "2017-02-07T20:47:27.000+0000", "description": "Broker Version:  wok as 1033373 Jun  4  2014 activemq-broker-5.10-SNAPSHOT.jar I don't know which Subversion it is, maybe the date clarifies.\nClient: libactivemq-cpp.so.19\nI tried Setting in active.xml:\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600;transport.useInactivityMonitor=false;wireFormat.maxInactivityDuration=66666\"/>\nand in the Client API:\n brokerURI  tcp://wlp-sc1:61616?wireFormat=openwire&transport.useAsyncSend=true&inputBufferSize=32767&outputBufferSize=32767&transport.commandTracingEnabled=true&transport.tcpTracingEnabled=true&wireFormat.maxInactivityDuration=55555&transport.useInactivityMonitor=false&transport.useKeepAlive=true&wireFormat.tightEncodingEnabled=false\nBut in the Broker log I see\n2017-01-25 11:57:07,868 | DEBUG | Using min of local: WireFormatInfo { version=10, properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=9223372036854775807, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} and remote: WireFormatInfo { version=11, properties={CacheSize=1024, SizePrefixDisabled=false, TcpNoDelayEnabled=true, StackTraceEnabled=true, CacheEnabled=false, TightEncodingEnabled=false, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} | org.apache.activemq.transport.InactivityMonitor | ActiveMQ Transport: tcp:///10.56.231.72:22017@61616\n\norg.apache.activemq.transport.InactivityIOException: Channel was inactive for too (>30000) long: tcp://10.56.231.72:9894\n[", "comments": [], "text": "cannot disable InactivityMonitor\n\nDescription:\nBroker Version:  wok as 1033373 Jun  4  2014 activemq-broker-5.10-SNAPSHOT.jar I don't know which Subversion it is, maybe the date clarifies.\nClient: libactivemq-cpp.so.19\nI tried Setting in active.xml:\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600;transport.useInactivityMonitor=false;wireFormat.maxInactivityDuration=66666\"/>\nand in the Client API:\n brokerURI  tcp://wlp-sc1:61616?wireFormat=openwire&transport.useAsyncSend=true&inputBufferSize=32767&outputBufferSize=32767&transport.commandTracingEnabled=true&transport.tcpTracingEnabled=true&wireFormat.maxInactivityDuration=55555&transport.useInactivityMonitor=false&transport.useKeepAlive=true&wireFormat.tightEncodingEnabled=false\nBut in the Broker log I see\n2017-01-25 11:57:07,868 | DEBUG | Using min of local: WireFormatInfo { version=10, properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=9223372036854775807, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} and remote: WireFormatInfo { version=11, properties={CacheSize=1024, SizePrefixDisabled=false, TcpNoDelayEnabled=true, StackTraceEnabled=true, CacheEnabled=false, TightEncodingEnabled=false, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} | org.apache.activemq.transport.InactivityMonitor | ActiveMQ Transport: tcp:///10.56.231.72:22017@61616\n\norg.apache.activemq.transport.InactivityIOException: Channel was inactive for too (>30000) long: tcp://10.56.231.72:9894\n[\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: cannot disable InactivityMonitor\n\nDescription:\nBroker Version:  wok as 1033373 Jun  4  2014 activemq-broker-5.10-SNAPSHOT.jar I don't know which Subversion it is, maybe the date clarifies.\nClient: libactivemq-cpp.so.19\nI tried Setting in active.xml:\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600;transport.useInactivityMonitor=false;wireFormat.maxInactivityDuration=66666\"/>\nand in the Client API:\n brokerURI  tcp://wlp-sc1:61616?wireFormat=openwire&transport.useAsyncSend=true&inputBufferSize=32767&outputBufferSize=32767&transport.commandTracingEnabled=true&transport.tcpTracingEnabled=true&wireFormat.maxInactivityDuration=55555&transport.useInactivityMonitor=false&transport.useKeepAlive=true&wireFormat.tightEncodingEnabled=false\nBut in the Broker log I see\n2017-01-25 11:57:07,868 | DEBUG | Using min of local: WireFormatInfo { version=10, properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=9223372036854775807, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} and remote: WireFormatInfo { version=11, properties={CacheSize=1024, SizePrefixDisabled=false, TcpNoDelayEnabled=true, StackTraceEnabled=true, CacheEnabled=false, TightEncodingEnabled=false, MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} | org.apache.activemq.transport.InactivityMonitor | ActiveMQ Transport: tcp:///10.56.231.72:22017@61616\n\norg.apache.activemq.transport.InactivityIOException: Channel was inactive for too (>30000) long: tcp://10.56.231.72:9894\n[\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'cannot disable InactivityMonitor' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-608?\nA: Broker Version:  wok as 1033373 Jun  4  2014 activemq-broker-5.10-SNAPSHOT.jar I don't know which Subversion it is, maybe the date clarifies.\nClient: libactivemq-cpp.so.19\nI tried Setting in active.xml:\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600;transport.useInactivityMonitor=false;wireFormat.maxInactivityD"}}
{"issue_key": "AMQCPP-607", "project": "AMQCPP", "title": "Add Openwire properties for client metadata to CMS client", "status": "Resolved", "reporter": "Brian D. Johnson", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2017-01-16T15:45:53.000+0000", "updated": "2017-02-07T22:10:45.000+0000", "description": "AMQ-6379 added Openwire properties to the Java client containing client metadata ({{ProviderName}}, {{ProviderVersion}}, and {{PlatformDetails}}).  Please update the CMS client to provide the same properties.", "comments": [], "text": "Add Openwire properties for client metadata to CMS client\n\nDescription:\nAMQ-6379 added Openwire properties to the Java client containing client metadata ({{ProviderName}}, {{ProviderVersion}}, and {{PlatformDetails}}).  Please update the CMS client to provide the same properties.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add Openwire properties for client metadata to CMS client\n\nDescription:\nAMQ-6379 added Openwire properties to the Java client containing client metadata ({{ProviderName}}, {{ProviderVersion}}, and {{PlatformDetails}}).  Please update the CMS client to provide the same properties.\n\nComments:\n", "classification": "Classify the issue 'Add Openwire properties for client metadata to CMS client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-607?\nA: AMQ-6379 added Openwire properties to the Java client containing client metadata ({{ProviderName}}, {{ProviderVersion}}, and {{PlatformDetails}}).  Please update the CMS client to provide the same properties."}}
{"issue_key": "AMQCPP-606", "project": "AMQCPP", "title": "CMS: Add support for AMQP", "status": "Closed", "reporter": "Matt Pavlovich", "assignee": "Unassigned", "priority": "Minor", "labels": [], "created": "2016-10-05T13:13:18.000+0000", "updated": "2018-11-15T19:26:50.000+0000", "description": "Add AMQP support to CMS in order to close a gap and provide uniform programming API options for users looking to use the AMQP protocol.", "comments": [], "text": "CMS: Add support for AMQP\n\nDescription:\nAdd AMQP support to CMS in order to close a gap and provide uniform programming API options for users looking to use the AMQP protocol.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS: Add support for AMQP\n\nDescription:\nAdd AMQP support to CMS in order to close a gap and provide uniform programming API options for users looking to use the AMQP protocol.\n\nComments:\n", "classification": "Classify the issue 'CMS: Add support for AMQP' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-606?\nA: Add AMQP support to CMS in order to close a gap and provide uniform programming API options for users looking to use the AMQP protocol."}}
{"issue_key": "AMQCPP-605", "project": "AMQCPP", "title": "ActiveMQ CPP clients don't support IPv6", "status": "Closed", "reporter": "MARIUS KAPEA", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2016-09-20T13:07:19.000+0000", "updated": "2018-11-15T19:26:42.000+0000", "description": "#ActiveMQ CPP 3.9.3\n\nWe want to use ActiveMQ Cpp client with the IPv6 but we are facing an issue.\n => There is no syntax  error, but the client(Producer) is not sending packets.\n\nActiveMQ broker supports IPv6 protocol. But the current ActiveMQ-CPP clients don't.\n\nI am wondering if today  there is an issue related to the IPv6 on ActiveMQ-CPP client?\n\nCould you please help us?\n\n\nKind regards,\nMarius", "comments": [], "text": "ActiveMQ CPP clients don't support IPv6\n\nDescription:\n#ActiveMQ CPP 3.9.3\n\nWe want to use ActiveMQ Cpp client with the IPv6 but we are facing an issue.\n => There is no syntax  error, but the client(Producer) is not sending packets.\n\nActiveMQ broker supports IPv6 protocol. But the current ActiveMQ-CPP clients don't.\n\nI am wondering if today  there is an issue related to the IPv6 on ActiveMQ-CPP client?\n\nCould you please help us?\n\n\nKind regards,\nMarius\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ CPP clients don't support IPv6\n\nDescription:\n#ActiveMQ CPP 3.9.3\n\nWe want to use ActiveMQ Cpp client with the IPv6 but we are facing an issue.\n => There is no syntax  error, but the client(Producer) is not sending packets.\n\nActiveMQ broker supports IPv6 protocol. But the current ActiveMQ-CPP clients don't.\n\nI am wondering if today  there is an issue related to the IPv6 on ActiveMQ-CPP client?\n\nCould you please help us?\n\n\nKind regards,\nMarius\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ CPP clients don't support IPv6' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-605?\nA: #ActiveMQ CPP 3.9.3\n\nWe want to use ActiveMQ Cpp client with the IPv6 but we are facing an issue.\n => There is no syntax  error, but the client(Producer) is not sending packets.\n\nActiveMQ broker supports IPv6 protocol. But the current ActiveMQ-CPP clients don't.\n\nI am wondering if today  there is an issue related to the IPv6 on ActiveMQ-CPP client?\n\nCould you please help us?\n\n\nKind regards,\nMarius"}}
{"issue_key": "AMQCPP-604", "project": "AMQCPP", "title": "Exception in decaf::lang::Thread::runCallback", "status": "Closed", "reporter": "ramesh", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-09-20T08:00:18.000+0000", "updated": "2016-09-20T12:58:09.000+0000", "description": "We have upgraded activemq cpp from 2.1.3 to 2.2.3 due to below known issue in 2.1.3.\n\n#6  0x00007f030582ca5f in activemq::exceptions::ActiveMQException::buildMessage (this=<value optimized out>, \n    format=0x7f030595d618 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:76\n        buffer = 0x7f02d0009910 \"No valid response received for command: \"\n        written = <value optimized out>\n        size = 256\n#7  0x00007f030583f518 in activemq::transport::CommandIOException::CommandIOException (this=0x7f02d000f020, \n    file=0x7f030595d5e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146, \n    msg=0x7f030595d618 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n        vargs = {{gp_offset = 48, fp_offset = 48, overflow_arg_area = 0x7f0290f5a750, reg_save_area = 0x7f0290f5a670}}\n\n\nOnce it is upgraded to 2.2.3 the issue is resolved. But we are getting decaf  exception and resulted in to crash of my application -\n\nThread 1:\n\n#4  0x000000000062a168 in std::string::_Rep::_S_empty_rep_storage ()\n\n#5  0x00007f291ea4d6bd in decaf::lang::Exception::printStackTrace (this=0x7f28fa13fc08, stream=...) at decaf/lang/Exception.cpp:137\n#6  0x00007f292444a3fd in MyExceptionListener::onException (this=0x25886c0, ex=...) at MyExceptionListener.cpp:37\n#7  0x00007f291e9e170f in fire (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>) at ./activemq/connector/openwire/OpenWireConnector.h:262\n#8  activemq::connector::openwire::OpenWireConnector::onTransportException (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1484\n#9  0x00007f291e9df045 in fire (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#10 activemq::connector::openwire::OpenWireFormatNegotiator::onTransportException (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:184\n\n#11 0x00007f291ea0bb50 in fire (this=0x7f28bc007510, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#12 activemq::transport::filters::ResponseCorrelator::onTransportException (this=0x7f28bc007510, source=<value optimized out>, ex=...) at activemq/transport/filters/ResponseCorrelator.cpp:296\n#13 0x00007f291ea05609 in fire (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.h:75\n#14 activemq::transport::TransportFilter::onTransportException (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.cpp:55\n#15 0x00007f291ea06cf2 in activemq::transport::IOTransport::run (this=0x7f28bc0076f0) at activemq/transport/IOTransport.h:105\n#16 0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7b0, param=0x7f28fa13fc08) at decaf/lang/Thread.cpp:125\n\n\nThread 2:\n\n#0  0x00007f291e39b68c in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n\n#1  0x00007f291ea62ac3 in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f250, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#2  0x00007f291ea6299f in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f6c4) at decaf/util/concurrent/Mutex.cpp:82\n#3  0x00007f291e99678f in activemq::core::ActiveMQSessionExecutor::run (this=0x7f28bc03f220) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#4  0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7e0, param=0x80) at decaf/lang/Thread.cpp:125\n#5  0x00007f291e397aa1 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f291d74093d in clone () from /lib64/libc.so.6\n\nIt seems synchronization issue between thread 1 and thread 2 causes the exception  in decaf.\n\nCan you please let me know if issue is fixed in latest versions to check it.", "comments": [], "text": "Exception in decaf::lang::Thread::runCallback\n\nDescription:\n\nWe have upgraded activemq cpp from 2.1.3 to 2.2.3 due to below known issue in 2.1.3.\n\n#6  0x00007f030582ca5f in activemq::exceptions::ActiveMQException::buildMessage (this=<value optimized out>, \n    format=0x7f030595d618 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:76\n        buffer = 0x7f02d0009910 \"No valid response received for command: \"\n        written = <value optimized out>\n        size = 256\n#7  0x00007f030583f518 in activemq::transport::CommandIOException::CommandIOException (this=0x7f02d000f020, \n    file=0x7f030595d5e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146, \n    msg=0x7f030595d618 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n        vargs = {{gp_offset = 48, fp_offset = 48, overflow_arg_area = 0x7f0290f5a750, reg_save_area = 0x7f0290f5a670}}\n\n\nOnce it is upgraded to 2.2.3 the issue is resolved. But we are getting decaf  exception and resulted in to crash of my application -\n\nThread 1:\n\n#4  0x000000000062a168 in std::string::_Rep::_S_empty_rep_storage ()\n\n#5  0x00007f291ea4d6bd in decaf::lang::Exception::printStackTrace (this=0x7f28fa13fc08, stream=...) at decaf/lang/Exception.cpp:137\n#6  0x00007f292444a3fd in MyExceptionListener::onException (this=0x25886c0, ex=...) at MyExceptionListener.cpp:37\n#7  0x00007f291e9e170f in fire (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>) at ./activemq/connector/openwire/OpenWireConnector.h:262\n#8  activemq::connector::openwire::OpenWireConnector::onTransportException (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1484\n#9  0x00007f291e9df045 in fire (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#10 activemq::connector::openwire::OpenWireFormatNegotiator::onTransportException (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:184\n\n#11 0x00007f291ea0bb50 in fire (this=0x7f28bc007510, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#12 activemq::transport::filters::ResponseCorrelator::onTransportException (this=0x7f28bc007510, source=<value optimized out>, ex=...) at activemq/transport/filters/ResponseCorrelator.cpp:296\n#13 0x00007f291ea05609 in fire (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.h:75\n#14 activemq::transport::TransportFilter::onTransportException (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.cpp:55\n#15 0x00007f291ea06cf2 in activemq::transport::IOTransport::run (this=0x7f28bc0076f0) at activemq/transport/IOTransport.h:105\n#16 0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7b0, param=0x7f28fa13fc08) at decaf/lang/Thread.cpp:125\n\n\nThread 2:\n\n#0  0x00007f291e39b68c in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n\n#1  0x00007f291ea62ac3 in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f250, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#2  0x00007f291ea6299f in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f6c4) at decaf/util/concurrent/Mutex.cpp:82\n#3  0x00007f291e99678f in activemq::core::ActiveMQSessionExecutor::run (this=0x7f28bc03f220) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#4  0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7e0, param=0x80) at decaf/lang/Thread.cpp:125\n#5  0x00007f291e397aa1 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f291d74093d in clone () from /lib64/libc.so.6\n\nIt seems synchronization issue between thread 1 and thread 2 causes the exception  in decaf.\n\nCan you please let me know if issue is fixed in latest versions to check it.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception in decaf::lang::Thread::runCallback\n\nDescription:\n\nWe have upgraded activemq cpp from 2.1.3 to 2.2.3 due to below known issue in 2.1.3.\n\n#6  0x00007f030582ca5f in activemq::exceptions::ActiveMQException::buildMessage (this=<value optimized out>, \n    format=0x7f030595d618 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:76\n        buffer = 0x7f02d0009910 \"No valid response received for command: \"\n        written = <value optimized out>\n        size = 256\n#7  0x00007f030583f518 in activemq::transport::CommandIOException::CommandIOException (this=0x7f02d000f020, \n    file=0x7f030595d5e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146, \n    msg=0x7f030595d618 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n        vargs = {{gp_offset = 48, fp_offset = 48, overflow_arg_area = 0x7f0290f5a750, reg_save_area = 0x7f0290f5a670}}\n\n\nOnce it is upgraded to 2.2.3 the issue is resolved. But we are getting decaf  exception and resulted in to crash of my application -\n\nThread 1:\n\n#4  0x000000000062a168 in std::string::_Rep::_S_empty_rep_storage ()\n\n#5  0x00007f291ea4d6bd in decaf::lang::Exception::printStackTrace (this=0x7f28fa13fc08, stream=...) at decaf/lang/Exception.cpp:137\n#6  0x00007f292444a3fd in MyExceptionListener::onException (this=0x25886c0, ex=...) at MyExceptionListener.cpp:37\n#7  0x00007f291e9e170f in fire (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>) at ./activemq/connector/openwire/OpenWireConnector.h:262\n#8  activemq::connector::openwire::OpenWireConnector::onTransportException (this=0x7f28bc018590, source=<value optimized out>, ex=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1484\n#9  0x00007f291e9df045 in fire (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#10 activemq::connector::openwire::OpenWireFormatNegotiator::onTransportException (this=0x7f28bc02e5e0, source=<value optimized out>, ex=...)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:184\n\n#11 0x00007f291ea0bb50 in fire (this=0x7f28bc007510, source=<value optimized out>, ex=...) at ./activemq/transport/TransportFilter.h:75\n#12 activemq::transport::filters::ResponseCorrelator::onTransportException (this=0x7f28bc007510, source=<value optimized out>, ex=...) at activemq/transport/filters/ResponseCorrelator.cpp:296\n#13 0x00007f291ea05609 in fire (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.h:75\n#14 activemq::transport::TransportFilter::onTransportException (this=0x0, source=<value optimized out>, ex=...) at activemq/transport/TransportFilter.cpp:55\n#15 0x00007f291ea06cf2 in activemq::transport::IOTransport::run (this=0x7f28bc0076f0) at activemq/transport/IOTransport.h:105\n#16 0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7b0, param=0x7f28fa13fc08) at decaf/lang/Thread.cpp:125\n\n\nThread 2:\n\n#0  0x00007f291e39b68c in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n\n#1  0x00007f291ea62ac3 in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f250, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#2  0x00007f291ea6299f in decaf::util::concurrent::Mutex::wait (this=0x7f28bc03f6c4) at decaf/util/concurrent/Mutex.cpp:82\n#3  0x00007f291e99678f in activemq::core::ActiveMQSessionExecutor::run (this=0x7f28bc03f220) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#4  0x00007f291ea50190 in decaf::lang::Thread::runCallback (self=0x225d7e0, param=0x80) at decaf/lang/Thread.cpp:125\n#5  0x00007f291e397aa1 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f291d74093d in clone () from /lib64/libc.so.6\n\nIt seems synchronization issue between thread 1 and thread 2 causes the exception  in decaf.\n\nCan you please let me know if issue is fixed in latest versions to check it.\n\nComments:\n", "classification": "Classify the issue 'Exception in decaf::lang::Thread::runCallback' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-604?\nA: \nWe have upgraded activemq cpp from 2.1.3 to 2.2.3 due to below known issue in 2.1.3.\n\n#6  0x00007f030582ca5f in activemq::exceptions::ActiveMQException::buildMessage (this=<value optimized out>, \n    format=0x7f030595d618 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:76\n        buffer = 0x7f02d0009910 \"No val"}}
{"issue_key": "AMQCPP-603", "project": "AMQCPP", "title": "TcpTransportTest::testTransportCreateWithRadomFailures() test fails under FreeBSD clang/libc++", "status": "Open", "reporter": "David Carlier", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-08-25T13:57:07.000+0000", "updated": "2016-08-29T18:21:03.000+0000", "description": "Hi all,\n\nWhen I try to launch the activemq-test application under FreeBSD compiled with clang/libc++, it gets stuck ... it does not it I add a transport listener manually to the transport instance (which I think it is not intended ...).\n\nAny idea where it would come from ?\n\nThanks in advance.", "comments": [], "text": "TcpTransportTest::testTransportCreateWithRadomFailures() test fails under FreeBSD clang/libc++\n\nDescription:\nHi all,\n\nWhen I try to launch the activemq-test application under FreeBSD compiled with clang/libc++, it gets stuck ... it does not it I add a transport listener manually to the transport instance (which I think it is not intended ...).\n\nAny idea where it would come from ?\n\nThanks in advance.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: TcpTransportTest::testTransportCreateWithRadomFailures() test fails under FreeBSD clang/libc++\n\nDescription:\nHi all,\n\nWhen I try to launch the activemq-test application under FreeBSD compiled with clang/libc++, it gets stuck ... it does not it I add a transport listener manually to the transport instance (which I think it is not intended ...).\n\nAny idea where it would come from ?\n\nThanks in advance.\n\nComments:\n", "classification": "Classify the issue 'TcpTransportTest::testTransportCreateWithRadomFailures() test fails under FreeBSD clang/libc++' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-603?\nA: Hi all,\n\nWhen I try to launch the activemq-test application under FreeBSD compiled with clang/libc++, it gets stuck ... it does not it I add a transport listener manually to the transport instance (which I think it is not intended ...).\n\nAny idea where it would come from ?\n\nThanks in advance."}}
{"issue_key": "AMQCPP-601", "project": "AMQCPP", "title": "PriorityBackup isn't working", "status": "Resolved", "reporter": "Jawad Bokhari", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-07-28T22:38:00.000+0000", "updated": "2017-02-20T18:30:18.000+0000", "description": "I am trying to take advantage of the ActiveMQ priority backup feature.\n\nI'm running 2 brokers on 2 different sites (machines). Each site has 2 AMQ clients, one of which is a Java client and the other one is a C++ client.\nBoth brokers are linked as network of brokers in duplex mode. \n\nI want the following behavior for my apps.\n\n* Always connect to local broker on startup\n* If local broker goes down, connect to the remote\n* {color:red} While connected to remote, if local comes back up, we then reconnect to local. {color}\n\nThis works on my java app by simply adding priorityBackup to my URI options \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true??\n\nHowever, the part highlighted in {color:red}red{color} doesn't work for CPP client.\n\nThe following works fine on the CPP apps (with basic working failover functionality - aka jumping to remote when local goes down )\n\n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false??\n\nBut updating the uri options with priorityBackup even breaks failover functionality completely (my apps never failover to the remote broker, they just stay in some kind of broker-less/limbo state when their local broker goes down) \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false{color:red}&priorityBackup=true{color}??\n\nI tried this with 3.9.3 without success. Then, I tried with the version 3.7.0 when this feature *priorityBackup* was first introduced but without luck.\n\nActiveMQ broker versions: *5.9.0*, *5.13.2*\nI'm using Visual Studio 2008 toolset (V90) for my client application.", "comments": [], "text": "PriorityBackup isn't working\n\nDescription:\nI am trying to take advantage of the ActiveMQ priority backup feature.\n\nI'm running 2 brokers on 2 different sites (machines). Each site has 2 AMQ clients, one of which is a Java client and the other one is a C++ client.\nBoth brokers are linked as network of brokers in duplex mode. \n\nI want the following behavior for my apps.\n\n* Always connect to local broker on startup\n* If local broker goes down, connect to the remote\n* {color:red} While connected to remote, if local comes back up, we then reconnect to local. {color}\n\nThis works on my java app by simply adding priorityBackup to my URI options \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true??\n\nHowever, the part highlighted in {color:red}red{color} doesn't work for CPP client.\n\nThe following works fine on the CPP apps (with basic working failover functionality - aka jumping to remote when local goes down )\n\n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false??\n\nBut updating the uri options with priorityBackup even breaks failover functionality completely (my apps never failover to the remote broker, they just stay in some kind of broker-less/limbo state when their local broker goes down) \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false{color:red}&priorityBackup=true{color}??\n\nI tried this with 3.9.3 without success. Then, I tried with the version 3.7.0 when this feature *priorityBackup* was first introduced but without luck.\n\nActiveMQ broker versions: *5.9.0*, *5.13.2*\nI'm using Visual Studio 2008 toolset (V90) for my client application. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: PriorityBackup isn't working\n\nDescription:\nI am trying to take advantage of the ActiveMQ priority backup feature.\n\nI'm running 2 brokers on 2 different sites (machines). Each site has 2 AMQ clients, one of which is a Java client and the other one is a C++ client.\nBoth brokers are linked as network of brokers in duplex mode. \n\nI want the following behavior for my apps.\n\n* Always connect to local broker on startup\n* If local broker goes down, connect to the remote\n* {color:red} While connected to remote, if local comes back up, we then reconnect to local. {color}\n\nThis works on my java app by simply adding priorityBackup to my URI options \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false&priorityBackup=true??\n\nHowever, the part highlighted in {color:red}red{color} doesn't work for CPP client.\n\nThe following works fine on the CPP apps (with basic working failover functionality - aka jumping to remote when local goes down )\n\n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false??\n\nBut updating the uri options with priorityBackup even breaks failover functionality completely (my apps never failover to the remote broker, they just stay in some kind of broker-less/limbo state when their local broker goes down) \n??failover:(tcp://local:61616,tcp://remote:61616)?randomize=false{color:red}&priorityBackup=true{color}??\n\nI tried this with 3.9.3 without success. Then, I tried with the version 3.7.0 when this feature *priorityBackup* was first introduced but without luck.\n\nActiveMQ broker versions: *5.9.0*, *5.13.2*\nI'm using Visual Studio 2008 toolset (V90) for my client application. \n\nComments:\n", "classification": "Classify the issue 'PriorityBackup isn't working' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-601?\nA: I am trying to take advantage of the ActiveMQ priority backup feature.\n\nI'm running 2 brokers on 2 different sites (machines). Each site has 2 AMQ clients, one of which is a Java client and the other one is a C++ client.\nBoth brokers are linked as network of brokers in duplex mode. \n\nI want the following behavior for my apps.\n\n* Always connect to local broker on startup\n* If local broker goes down"}}
{"issue_key": "AMQCPP-600", "project": "AMQCPP", "title": "Segfault in MutexProperties after shutdownLibrary was called and returned", "status": "Closed", "reporter": "Josh Schwartz", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-07-26T18:43:46.000+0000", "updated": "2017-02-07T19:55:21.000+0000", "description": "During shutdown of our application there seem to still be ActiveMQ-CPP threads running which rarely cause a segfault.  Attached is an analysis of the core file from one of these instances.  The stack trace of the thread which caused the segfault was:\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#1  0x0000003624a9dadc in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /usr/lib64/libstdc++.so.6\n#2  0x00002ba8ca62d152 in MutexProperties (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:50\n#3  decaf::util::concurrent::Mutex::Mutex (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:78\n#4  0x00002ba8ca63c3ee in AbstractCollection (this=0x22bd960) at ./decaf/util/AbstractCollection.h:65\n#5  AbstractList (this=0x22bd960) at ./decaf/util/AbstractList.h:341\n#6  AbstractSequentialList (this=0x22bd960) at ./decaf/util/AbstractSequentialList.h:59\n#7  LinkedList (this=0x22bd960) at ./decaf/util/LinkedList.h:91\n#8  decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x22bd960) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248\n#9  0x00002ba8ca6270c2 in decaf::util::TimerImpl::run (this=0x23b32a0) at decaf/util/Timer.cpp:156\n#10 0x00002ba8ca5a612f in (anonymous namespace)::runCallback (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:268\n#11 0x00002ba8ca5a5ea4 in (anonymous namespace)::threadEntryMethod (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:256\n#12 0x000000361a207aa1 in start_thread () from /lib64/libpthread.so.0\n#13 0x00000036196e8aad in clone () from /lib64/libc.so.6", "comments": [], "text": "Segfault in MutexProperties after shutdownLibrary was called and returned\n\nDescription:\nDuring shutdown of our application there seem to still be ActiveMQ-CPP threads running which rarely cause a segfault.  Attached is an analysis of the core file from one of these instances.  The stack trace of the thread which caused the segfault was:\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#1  0x0000003624a9dadc in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /usr/lib64/libstdc++.so.6\n#2  0x00002ba8ca62d152 in MutexProperties (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:50\n#3  decaf::util::concurrent::Mutex::Mutex (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:78\n#4  0x00002ba8ca63c3ee in AbstractCollection (this=0x22bd960) at ./decaf/util/AbstractCollection.h:65\n#5  AbstractList (this=0x22bd960) at ./decaf/util/AbstractList.h:341\n#6  AbstractSequentialList (this=0x22bd960) at ./decaf/util/AbstractSequentialList.h:59\n#7  LinkedList (this=0x22bd960) at ./decaf/util/LinkedList.h:91\n#8  decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x22bd960) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248\n#9  0x00002ba8ca6270c2 in decaf::util::TimerImpl::run (this=0x23b32a0) at decaf/util/Timer.cpp:156\n#10 0x00002ba8ca5a612f in (anonymous namespace)::runCallback (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:268\n#11 0x00002ba8ca5a5ea4 in (anonymous namespace)::threadEntryMethod (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:256\n#12 0x000000361a207aa1 in start_thread () from /lib64/libpthread.so.0\n#13 0x00000036196e8aad in clone () from /lib64/libc.so.6\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segfault in MutexProperties after shutdownLibrary was called and returned\n\nDescription:\nDuring shutdown of our application there seem to still be ActiveMQ-CPP threads running which rarely cause a segfault.  Attached is an analysis of the core file from one of these instances.  The stack trace of the thread which caused the segfault was:\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#1  0x0000003624a9dadc in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::append(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /usr/lib64/libstdc++.so.6\n#2  0x00002ba8ca62d152 in MutexProperties (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:50\n#3  decaf::util::concurrent::Mutex::Mutex (this=0x2ba8d81ffb40) at decaf/util/concurrent/Mutex.cpp:78\n#4  0x00002ba8ca63c3ee in AbstractCollection (this=0x22bd960) at ./decaf/util/AbstractCollection.h:65\n#5  AbstractList (this=0x22bd960) at ./decaf/util/AbstractList.h:341\n#6  AbstractSequentialList (this=0x22bd960) at ./decaf/util/AbstractSequentialList.h:59\n#7  LinkedList (this=0x22bd960) at ./decaf/util/LinkedList.h:91\n#8  decaf::util::concurrent::ExecutorKernel::WorkerKiller::run (this=0x22bd960) at decaf/util/concurrent/ThreadPoolExecutor.cpp:248\n#9  0x00002ba8ca6270c2 in decaf::util::TimerImpl::run (this=0x23b32a0) at decaf/util/Timer.cpp:156\n#10 0x00002ba8ca5a612f in (anonymous namespace)::runCallback (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:268\n#11 0x00002ba8ca5a5ea4 in (anonymous namespace)::threadEntryMethod (arg=0x226a890) at decaf/internal/util/concurrent/Threading.cpp:256\n#12 0x000000361a207aa1 in start_thread () from /lib64/libpthread.so.0\n#13 0x00000036196e8aad in clone () from /lib64/libc.so.6\n\nComments:\n", "classification": "Classify the issue 'Segfault in MutexProperties after shutdownLibrary was called and returned' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-600?\nA: During shutdown of our application there seem to still be ActiveMQ-CPP threads running which rarely cause a segfault.  Attached is an analysis of the core file from one of these instances.  The stack trace of the thread which caused the segfault was:\n\nProgram terminated with signal 11, Segmentation fault.\n#0  0x0000003619689adf in memcpy () from /lib64/libc.so.6\n#0  0x0000003619689adf in memcpy ()"}}
{"issue_key": "AMQCPP-599", "project": "AMQCPP", "title": "Support for proxy", "status": "Closed", "reporter": "Francois Godin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-06-21T15:04:06.000+0000", "updated": "2018-11-15T19:26:32.000+0000", "description": "ActiveMQ C++ does not support connecting to the broker via a HTTP (or sock, or other) proxy.", "comments": [], "text": "Support for proxy\n\nDescription:\nActiveMQ C++ does not support connecting to the broker via a HTTP (or sock, or other) proxy.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Support for proxy\n\nDescription:\nActiveMQ C++ does not support connecting to the broker via a HTTP (or sock, or other) proxy.\n\nComments:\n", "classification": "Classify the issue 'Support for proxy' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-599?\nA: ActiveMQ C++ does not support connecting to the broker via a HTTP (or sock, or other) proxy."}}
{"issue_key": "AMQCPP-598", "project": "AMQCPP", "title": "CmsTemplate::createConsumer possible dereference of null pointer", "status": "Resolved", "reporter": "Daniel L. Robertson", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2016-05-30T18:42:41.000+0000", "updated": "2016-05-31T20:38:53.000+0000", "description": "If `CMSTemplate::takeSession()` returns NULL in `CMSTemplate::execute`, it is dereferenced in `CmsTemplate::createConsumer`. As far as I could tell, this is a plausible scenario, but I could be wrong. It looks like `ProducerExecutor::doInCms` checks for a NULL session, but `ReceiveExecutor::doInCms` does not. If this is because it is known that the session cannot be NULL, please close this issue. It just looked a bit off to me.", "comments": [], "text": "CmsTemplate::createConsumer possible dereference of null pointer\n\nDescription:\nIf `CMSTemplate::takeSession()` returns NULL in `CMSTemplate::execute`, it is dereferenced in `CmsTemplate::createConsumer`. As far as I could tell, this is a plausible scenario, but I could be wrong. It looks like `ProducerExecutor::doInCms` checks for a NULL session, but `ReceiveExecutor::doInCms` does not. If this is because it is known that the session cannot be NULL, please close this issue. It just looked a bit off to me.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CmsTemplate::createConsumer possible dereference of null pointer\n\nDescription:\nIf `CMSTemplate::takeSession()` returns NULL in `CMSTemplate::execute`, it is dereferenced in `CmsTemplate::createConsumer`. As far as I could tell, this is a plausible scenario, but I could be wrong. It looks like `ProducerExecutor::doInCms` checks for a NULL session, but `ReceiveExecutor::doInCms` does not. If this is because it is known that the session cannot be NULL, please close this issue. It just looked a bit off to me.\n\nComments:\n", "classification": "Classify the issue 'CmsTemplate::createConsumer possible dereference of null pointer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-598?\nA: If `CMSTemplate::takeSession()` returns NULL in `CMSTemplate::execute`, it is dereferenced in `CmsTemplate::createConsumer`. As far as I could tell, this is a plausible scenario, but I could be wrong. It looks like `ProducerExecutor::doInCms` checks for a NULL session, but `ReceiveExecutor::doInCms` does not. If this is because it is known that the session cannot be NULL, please close this issue. "}}
{"issue_key": "AMQCPP-596", "project": "AMQCPP", "title": "decaf/internal/security/provider/crypto/MD4MessageDigestSpi.cpp:394]: (error) Mismatching allocation and deallocation: temp", "status": "Resolved", "reporter": "David Binderman", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2016-04-06T15:01:31.000+0000", "updated": "2016-04-06T16:23:10.000+0000", "description": "temp = new unsigned char[length];\n        input.get(temp, length, 0, length);\n        engineUpdate(temp, length, 0, length);\n        delete temp;\n\nWrong delete. Suggest use delete [].\n\nAlso, some possible duplicates:\n\n[decaf/internal/security/provider/crypto/MD5MessageDigestSpi.cpp:441]: (error) Mismatching allocation and deallocation: temp\n[decaf/internal/security/provider/crypto/SHA1MessageDigestSpi.cpp:333]: (error) Mismatching allocation and deallocation: temp", "comments": [], "text": "decaf/internal/security/provider/crypto/MD4MessageDigestSpi.cpp:394]: (error) Mismatching allocation and deallocation: temp\n\nDescription:\n        temp = new unsigned char[length];\n        input.get(temp, length, 0, length);\n        engineUpdate(temp, length, 0, length);\n        delete temp;\n\nWrong delete. Suggest use delete [].\n\nAlso, some possible duplicates:\n\n[decaf/internal/security/provider/crypto/MD5MessageDigestSpi.cpp:441]: (error) Mismatching allocation and deallocation: temp\n[decaf/internal/security/provider/crypto/SHA1MessageDigestSpi.cpp:333]: (error) Mismatching allocation and deallocation: temp\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf/internal/security/provider/crypto/MD4MessageDigestSpi.cpp:394]: (error) Mismatching allocation and deallocation: temp\n\nDescription:\n        temp = new unsigned char[length];\n        input.get(temp, length, 0, length);\n        engineUpdate(temp, length, 0, length);\n        delete temp;\n\nWrong delete. Suggest use delete [].\n\nAlso, some possible duplicates:\n\n[decaf/internal/security/provider/crypto/MD5MessageDigestSpi.cpp:441]: (error) Mismatching allocation and deallocation: temp\n[decaf/internal/security/provider/crypto/SHA1MessageDigestSpi.cpp:333]: (error) Mismatching allocation and deallocation: temp\n\n\n\nComments:\n", "classification": "Classify the issue 'decaf/internal/security/provider/crypto/MD4MessageDigestSpi.cpp:394]: (error) Mismatching allocation and deallocation: temp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-596?\nA:         temp = new unsigned char[length];\n        input.get(temp, length, 0, length);\n        engineUpdate(temp, length, 0, length);\n        delete temp;\n\nWrong delete. Suggest use delete [].\n\nAlso, some possible duplicates:\n\n[decaf/internal/security/provider/crypto/MD5MessageDigestSpi.cpp:441]: (error) Mismatching allocation and deallocation: temp\n[decaf/internal/security/provider/crypto/SHA1Mess"}}
{"issue_key": "AMQCPP-595", "project": "AMQCPP", "title": "ActiveMQMessageProducer sends producer registration async which causes it to miss possible exceptions on creation like security exceptions.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-03-17T14:41:30.000+0000", "updated": "2016-03-17T15:31:12.000+0000", "description": "When creating a producer the ActiveMQMessageProducer sends its producer info asynchronously which can cause it to not propagate exceptions back to the client like Security exceptions and it won't remove itself from the session right away. This should be sent sync so that these errors are propagated correctly to the client.", "comments": [], "text": "ActiveMQMessageProducer sends producer registration async which causes it to miss possible exceptions on creation like security exceptions.\n\nDescription:\nWhen creating a producer the ActiveMQMessageProducer sends its producer info asynchronously which can cause it to not propagate exceptions back to the client like Security exceptions and it won't remove itself from the session right away. This should be sent sync so that these errors are propagated correctly to the client.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQMessageProducer sends producer registration async which causes it to miss possible exceptions on creation like security exceptions.\n\nDescription:\nWhen creating a producer the ActiveMQMessageProducer sends its producer info asynchronously which can cause it to not propagate exceptions back to the client like Security exceptions and it won't remove itself from the session right away. This should be sent sync so that these errors are propagated correctly to the client.\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQMessageProducer sends producer registration async which causes it to miss possible exceptions on creation like security exceptions.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-595?\nA: When creating a producer the ActiveMQMessageProducer sends its producer info asynchronously which can cause it to not propagate exceptions back to the client like Security exceptions and it won't remove itself from the session right away. This should be sent sync so that these errors are propagated correctly to the client.\n"}}
{"issue_key": "AMQCPP-594", "project": "AMQCPP", "title": "ActiveMQ-CPP does not build on Solaris 11", "status": "Resolved", "reporter": "Mark Williams", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2016-01-11T09:07:19.000+0000", "updated": "2016-03-17T15:55:23.000+0000", "description": "Using:\n\nConfigure options:\n./configure '--disable-ssl' '--prefix=<dir>' '--with-apr=<dir>'\n\nI get error:\nCC: -library=Cstd cannot be used with -library=stlport4\n\n[Removing -library=Cstd -library=Crun from the build fixes this]", "comments": [], "text": "ActiveMQ-CPP does not build on Solaris 11\n\nDescription:\nUsing:\n\nConfigure options:\n./configure '--disable-ssl' '--prefix=<dir>' '--with-apr=<dir>'\n\nI get error:\nCC: -library=Cstd cannot be used with -library=stlport4\n\n[Removing -library=Cstd -library=Crun from the build fixes this]\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ-CPP does not build on Solaris 11\n\nDescription:\nUsing:\n\nConfigure options:\n./configure '--disable-ssl' '--prefix=<dir>' '--with-apr=<dir>'\n\nI get error:\nCC: -library=Cstd cannot be used with -library=stlport4\n\n[Removing -library=Cstd -library=Crun from the build fixes this]\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ-CPP does not build on Solaris 11' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-594?\nA: Using:\n\nConfigure options:\n./configure '--disable-ssl' '--prefix=<dir>' '--with-apr=<dir>'\n\nI get error:\nCC: -library=Cstd cannot be used with -library=stlport4\n\n[Removing -library=Cstd -library=Crun from the build fixes this]\n"}}
{"issue_key": "AMQCPP-593", "project": "AMQCPP", "title": "reconnect a not exist broker", "status": "Closed", "reporter": "Sen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2016-01-07T09:10:14.000+0000", "updated": "2016-01-07T11:00:14.000+0000", "description": "i'm using amq failover protocol ensure every client could connect a broker. like: failover:(tcp://123.124.125.126:80,tcp://123.124.125.127:80,tcp://123.124.125.128:80)?timeout=15000&useExponentialBackOff=true&maxReconnectAttempts=-1\n\neverything runs ok but when i restart broker, a little percent of my servers reconnect to an unknown broker address.like: 202.106.199.37:61617\n\nanyone have ideas? thanks a lot.", "comments": [], "text": "reconnect a not exist broker\n\nDescription:\ni'm using amq failover protocol ensure every client could connect a broker. like: failover:(tcp://123.124.125.126:80,tcp://123.124.125.127:80,tcp://123.124.125.128:80)?timeout=15000&useExponentialBackOff=true&maxReconnectAttempts=-1\n\neverything runs ok but when i restart broker, a little percent of my servers reconnect to an unknown broker address.like: 202.106.199.37:61617\n\nanyone have ideas? thanks a lot.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: reconnect a not exist broker\n\nDescription:\ni'm using amq failover protocol ensure every client could connect a broker. like: failover:(tcp://123.124.125.126:80,tcp://123.124.125.127:80,tcp://123.124.125.128:80)?timeout=15000&useExponentialBackOff=true&maxReconnectAttempts=-1\n\neverything runs ok but when i restart broker, a little percent of my servers reconnect to an unknown broker address.like: 202.106.199.37:61617\n\nanyone have ideas? thanks a lot.\n\n\nComments:\n", "classification": "Classify the issue 'reconnect a not exist broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-593?\nA: i'm using amq failover protocol ensure every client could connect a broker. like: failover:(tcp://123.124.125.126:80,tcp://123.124.125.127:80,tcp://123.124.125.128:80)?timeout=15000&useExponentialBackOff=true&maxReconnectAttempts=-1\n\neverything runs ok but when i restart broker, a little percent of my servers reconnect to an unknown broker address.like: 202.106.199.37:61617\n\nanyone have ideas? tha"}}
{"issue_key": "AMQCPP-592", "project": "AMQCPP", "title": " memory and handle leak of session", "status": "Closed", "reporter": "Jerry Tan", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2016-01-04T07:45:31.000+0000", "updated": "2017-11-09T19:47:20.000+0000", "description": "if  we keep creating one thread and then create one session ( all sessions share a common connnection  ) , then  close  session  and  thread ; the memory and handle  is leak, and eventually causing an ugly crash\nstatistical information ï¼ from 8:00 am  to 14:00 pm\n memory / handle is begin with(1,612k/ 161)   end with (22,300k/ 11,218)\nhere is my code:\n=================================\n#include<cms/Connection.h>\n#include<boost/shared_ptr.hpp>\n#include<cms/ConnectionFactory.h>\n#include<winsock.h>\n#include<boost/thread/thread.hpp>\n#include<activemq/library/ActiveMQCPP.h>\n#Include<iostream>\nusing boost::shared_ptr\nusing namespace cms;\nusing namespace std;\nvoid fun(Connection* conn)\n{\n// == create session==\nSession* session = conn->createSession(Session::AUTO_ACKNOWLEDGE);\n\n//== close session==\nsession->close();\ndelete session;\nSleep(500);\n}\n\nint main()\n{\n   activemq::library::ActiveMQCPP::initializeLibrary();\n   ConnectionFactory* connectionFactory = ConnectionFactory::createCMSConnectionFactory(\"failover:(tcp://127.0.0.1:61616)\");\nConnection* connection = connectionFactory->createConnection();\nconnection->start();\n while(1)\n {\n   boost::thread  Thread(fun, connection);  //== share common connection\n   Thread.join();\n }\n}", "comments": [], "text": "memory and handle leak of session\n\nDescription:\n if  we keep creating one thread and then create one session ( all sessions share a common connnection  ) , then  close  session  and  thread ; the memory and handle  is leak, and eventually causing an ugly crash\nstatistical information ï¼ from 8:00 am  to 14:00 pm\n memory / handle is begin with(1,612k/ 161)   end with (22,300k/ 11,218)\nhere is my code:\n=================================\n#include<cms/Connection.h>\n#include<boost/shared_ptr.hpp>\n#include<cms/ConnectionFactory.h>\n#include<winsock.h>\n#include<boost/thread/thread.hpp>\n#include<activemq/library/ActiveMQCPP.h>\n#Include<iostream>\nusing boost::shared_ptr\nusing namespace cms;\nusing namespace std;\nvoid fun(Connection* conn)\n{\n// == create session==\nSession* session = conn->createSession(Session::AUTO_ACKNOWLEDGE);\n\n//== close session==\nsession->close();\ndelete session;\nSleep(500);\n}\n\nint main()\n{\n   activemq::library::ActiveMQCPP::initializeLibrary();\n   ConnectionFactory* connectionFactory = ConnectionFactory::createCMSConnectionFactory(\"failover:(tcp://127.0.0.1:61616)\");\nConnection* connection = connectionFactory->createConnection();\nconnection->start();\n while(1)\n {\n   boost::thread  Thread(fun, connection);  //== share common connection\n   Thread.join();\n }\n}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue:  memory and handle leak of session\n\nDescription:\n if  we keep creating one thread and then create one session ( all sessions share a common connnection  ) , then  close  session  and  thread ; the memory and handle  is leak, and eventually causing an ugly crash\nstatistical information ï¼ from 8:00 am  to 14:00 pm\n memory / handle is begin with(1,612k/ 161)   end with (22,300k/ 11,218)\nhere is my code:\n=================================\n#include<cms/Connection.h>\n#include<boost/shared_ptr.hpp>\n#include<cms/ConnectionFactory.h>\n#include<winsock.h>\n#include<boost/thread/thread.hpp>\n#include<activemq/library/ActiveMQCPP.h>\n#Include<iostream>\nusing boost::shared_ptr\nusing namespace cms;\nusing namespace std;\nvoid fun(Connection* conn)\n{\n// == create session==\nSession* session = conn->createSession(Session::AUTO_ACKNOWLEDGE);\n\n//== close session==\nsession->close();\ndelete session;\nSleep(500);\n}\n\nint main()\n{\n   activemq::library::ActiveMQCPP::initializeLibrary();\n   ConnectionFactory* connectionFactory = ConnectionFactory::createCMSConnectionFactory(\"failover:(tcp://127.0.0.1:61616)\");\nConnection* connection = connectionFactory->createConnection();\nconnection->start();\n while(1)\n {\n   boost::thread  Thread(fun, connection);  //== share common connection\n   Thread.join();\n }\n}\n\n\nComments:\n", "classification": "Classify the issue ' memory and handle leak of session' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-592?\nA:  if  we keep creating one thread and then create one session ( all sessions share a common connnection  ) , then  close  session  and  thread ; the memory and handle  is leak, and eventually causing an ugly crash\nstatistical information ï¼ from 8:00 am  to 14:00 pm\n memory / handle is begin with(1,612k/ 161)   end with (22,300k/ 11,218)\nhere is my code:\n=================================\n#include<cm"}}
{"issue_key": "AMQCPP-591", "project": "AMQCPP", "title": "Stomp client connections can't properly convert composite destinations", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-12-21T23:22:15.000+0000", "updated": "2015-12-21T23:54:44.000+0000", "description": "When a STOMP client tries to subscribe or send to a composite destination the destination conversion doesn't properly manage the conversion of the ActiveMQDestination into a STOMP destination string and can result in a bad subscription being made.", "comments": [], "text": "Stomp client connections can't properly convert composite destinations\n\nDescription:\nWhen a STOMP client tries to subscribe or send to a composite destination the destination conversion doesn't properly manage the conversion of the ActiveMQDestination into a STOMP destination string and can result in a bad subscription being made.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stomp client connections can't properly convert composite destinations\n\nDescription:\nWhen a STOMP client tries to subscribe or send to a composite destination the destination conversion doesn't properly manage the conversion of the ActiveMQDestination into a STOMP destination string and can result in a bad subscription being made.\n\nComments:\n", "classification": "Classify the issue 'Stomp client connections can't properly convert composite destinations' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-591?\nA: When a STOMP client tries to subscribe or send to a composite destination the destination conversion doesn't properly manage the conversion of the ActiveMQDestination into a STOMP destination string and can result in a bad subscription being made."}}
{"issue_key": "AMQCPP-590", "project": "AMQCPP", "title": "Some methods in AdvisorySupport return invalid composite destination names", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-12-15T16:33:28.000+0000", "updated": "2015-12-15T20:45:42.000+0000", "description": "These methods return a bad name for the composite destination, all but the first destination lack a topic prefix.  \n\ngetTempDestinationCompositeAdvisoryTopic\ngetAllDestinationsCompositeAdvisoryTopic", "comments": [], "text": "Some methods in AdvisorySupport return invalid composite destination names\n\nDescription:\nThese methods return a bad name for the composite destination, all but the first destination lack a topic prefix.  \n\ngetTempDestinationCompositeAdvisoryTopic\ngetAllDestinationsCompositeAdvisoryTopic\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Some methods in AdvisorySupport return invalid composite destination names\n\nDescription:\nThese methods return a bad name for the composite destination, all but the first destination lack a topic prefix.  \n\ngetTempDestinationCompositeAdvisoryTopic\ngetAllDestinationsCompositeAdvisoryTopic\n\nComments:\n", "classification": "Classify the issue 'Some methods in AdvisorySupport return invalid composite destination names' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-590?\nA: These methods return a bad name for the composite destination, all but the first destination lack a topic prefix.  \n\ngetTempDestinationCompositeAdvisoryTopic\ngetAllDestinationsCompositeAdvisoryTopic"}}
{"issue_key": "AMQCPP-589", "project": "AMQCPP", "title": "NPE when acknowledge called on message in some cases", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-11-30T19:05:06.000+0000", "updated": "2015-11-30T19:14:57.000+0000", "description": "If the Session is not Transacted or Individual Acknowledge an NPE segfault occurs in the ActiveMQMessage implementation.", "comments": [], "text": "NPE when acknowledge called on message in some cases\n\nDescription:\nIf the Session is not Transacted or Individual Acknowledge an NPE segfault occurs in the ActiveMQMessage implementation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: NPE when acknowledge called on message in some cases\n\nDescription:\nIf the Session is not Transacted or Individual Acknowledge an NPE segfault occurs in the ActiveMQMessage implementation.\n\nComments:\n", "classification": "Classify the issue 'NPE when acknowledge called on message in some cases' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-589?\nA: If the Session is not Transacted or Individual Acknowledge an NPE segfault occurs in the ActiveMQMessage implementation."}}
{"issue_key": "AMQCPP-588", "project": "AMQCPP", "title": "Always set a rollback cause on exception thrown in onMessage", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-11-30T19:01:11.000+0000", "updated": "2015-11-30T19:14:42.000+0000", "description": "In ActiveMQMessageConsumerKernel, currently the rollback cause is only set for the case auto- or individual-acks. However, it should also be set for the other cases, so that in the rollback() method it can be picked up when creating the poison ack.  This ports the same fix as seen in AMQ-6042", "comments": [], "text": "Always set a rollback cause on exception thrown in onMessage\n\nDescription:\nIn ActiveMQMessageConsumerKernel, currently the rollback cause is only set for the case auto- or individual-acks. However, it should also be set for the other cases, so that in the rollback() method it can be picked up when creating the poison ack.  This ports the same fix as seen in AMQ-6042\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Always set a rollback cause on exception thrown in onMessage\n\nDescription:\nIn ActiveMQMessageConsumerKernel, currently the rollback cause is only set for the case auto- or individual-acks. However, it should also be set for the other cases, so that in the rollback() method it can be picked up when creating the poison ack.  This ports the same fix as seen in AMQ-6042\n\nComments:\n", "classification": "Classify the issue 'Always set a rollback cause on exception thrown in onMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-588?\nA: In ActiveMQMessageConsumerKernel, currently the rollback cause is only set for the case auto- or individual-acks. However, it should also be set for the other cases, so that in the rollback() method it can be picked up when creating the poison ack.  This ports the same fix as seen in AMQ-6042"}}
{"issue_key": "AMQCPP-587", "project": "AMQCPP", "title": "ActiveMQ CPP (CMS) integration unit tests leads to client segmentation fault when executed against Artemis", "status": "Resolved", "reporter": "Petra Svobodova", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-11-20T14:00:04.000+0000", "updated": "2015-11-23T17:22:32.000+0000", "description": "CMS tests that leads to client segmentation fault:  N8activemq4test8openwire26OpenwireXATransactionsTestE::testSendReceiveTransactedBatchesSegmentation fault (core dumped)  N8activemq4test8openwire36OpenWireCmsSendWithAsyncCallbackTestE::testAsyncCallbackIsFasterSegmentation fault (core dumped) - Occasionally only\n\nother failing test from the suite:  N8activemq4test8openwire21OpenwireAdvisorysTestE::testConnectionAdvisories. : assertionF  N8activemq4test8openwire30OpenwireEnhancedConnectionTestE::testDestinationSourceGetters. : assertionF  N8activemq4test8openwire22OpenwireMapMessageTestE::testEmptyMapSendReceive. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testTextMessageCompression. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testStreamMessageCompression. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testReceiveBrowseReceive. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testQueueBrowserWith2Consumers. : assertionF  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testDLQHandling. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryReceiveNoCommit. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryOnMessageNoCommit. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleConnections. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleSessions. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testReceiveAlreadyInQueue. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testWithZeroConsumerPrefetchWithInFlightExpiration. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::tesstStreamMessage. : assertionF  N8activemq4test8openwire27OpenwireTempDestinationTestE::testBasics. : errorE  N8activemq4test8openwire27OpenwireTempDestinationTestE::testTwoConnections. : assertionF  N8activemq4test8openwire23OpenwireTransactionTestE::testSendSessionClose. : errorE  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveAutoAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveClinetAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveTransacted. : assertionF\n\nSteps to reproduce:\n1.) wget http://apache.miloslavbrada.cz/activemq/activemq-artemis/1.1.0/apache-artemis-1.1.0-bin.zip\n2.) unzip apache-artemis-1.1.0-bin.zip\n3.) cd apache-artemis-1.1.0/bin/\n4.) ./artemis create broker110 --data /tmp/artemis/broker110 --allow-anonymous --user pematous --password pematous ../runtime/broker110\n5.) /root/A-MQ/r7.0.0/upstream/apache-artemis-1.1.0/runtime/broker110/bin/artemis-service start\n6.) cd -\n7.) cd activemq-cpp-library-3.9.0/src/test-integration/\n8.) wget http://apache.miloslavbrada.cz/activemq/activemq-cpp/3.9.0/activemq-cpp-library-3.9.0-src.tar.gz\n9.) tar -xf activemq-cpp-library-3.9.0-src.tar.gz\n10.) cd activemq-cpp-library-3.9.0\n11.) ./configure\n12.) make check\n13.) cd src/test-integration\n14.) ./activemq-test-integration", "comments": [], "text": "ActiveMQ CPP (CMS) integration unit tests leads to client segmentation fault when executed against Artemis\n\nDescription:\nCMS tests that leads to client segmentation fault:  N8activemq4test8openwire26OpenwireXATransactionsTestE::testSendReceiveTransactedBatchesSegmentation fault (core dumped)  N8activemq4test8openwire36OpenWireCmsSendWithAsyncCallbackTestE::testAsyncCallbackIsFasterSegmentation fault (core dumped) - Occasionally only\n\nother failing test from the suite:  N8activemq4test8openwire21OpenwireAdvisorysTestE::testConnectionAdvisories. : assertionF  N8activemq4test8openwire30OpenwireEnhancedConnectionTestE::testDestinationSourceGetters. : assertionF  N8activemq4test8openwire22OpenwireMapMessageTestE::testEmptyMapSendReceive. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testTextMessageCompression. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testStreamMessageCompression. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testReceiveBrowseReceive. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testQueueBrowserWith2Consumers. : assertionF  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testDLQHandling. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryReceiveNoCommit. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryOnMessageNoCommit. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleConnections. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleSessions. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testReceiveAlreadyInQueue. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testWithZeroConsumerPrefetchWithInFlightExpiration. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::tesstStreamMessage. : assertionF  N8activemq4test8openwire27OpenwireTempDestinationTestE::testBasics. : errorE  N8activemq4test8openwire27OpenwireTempDestinationTestE::testTwoConnections. : assertionF  N8activemq4test8openwire23OpenwireTransactionTestE::testSendSessionClose. : errorE  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveAutoAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveClinetAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveTransacted. : assertionF\n\nSteps to reproduce:\n1.) wget http://apache.miloslavbrada.cz/activemq/activemq-artemis/1.1.0/apache-artemis-1.1.0-bin.zip\n2.) unzip apache-artemis-1.1.0-bin.zip\n3.) cd apache-artemis-1.1.0/bin/\n4.) ./artemis create broker110 --data /tmp/artemis/broker110 --allow-anonymous --user pematous --password pematous ../runtime/broker110\n5.) /root/A-MQ/r7.0.0/upstream/apache-artemis-1.1.0/runtime/broker110/bin/artemis-service start\n6.) cd -\n7.) cd activemq-cpp-library-3.9.0/src/test-integration/\n8.) wget http://apache.miloslavbrada.cz/activemq/activemq-cpp/3.9.0/activemq-cpp-library-3.9.0-src.tar.gz\n9.) tar -xf activemq-cpp-library-3.9.0-src.tar.gz\n10.) cd activemq-cpp-library-3.9.0\n11.) ./configure\n12.) make check\n13.) cd src/test-integration\n14.) ./activemq-test-integration\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ CPP (CMS) integration unit tests leads to client segmentation fault when executed against Artemis\n\nDescription:\nCMS tests that leads to client segmentation fault:  N8activemq4test8openwire26OpenwireXATransactionsTestE::testSendReceiveTransactedBatchesSegmentation fault (core dumped)  N8activemq4test8openwire36OpenWireCmsSendWithAsyncCallbackTestE::testAsyncCallbackIsFasterSegmentation fault (core dumped) - Occasionally only\n\nother failing test from the suite:  N8activemq4test8openwire21OpenwireAdvisorysTestE::testConnectionAdvisories. : assertionF  N8activemq4test8openwire30OpenwireEnhancedConnectionTestE::testDestinationSourceGetters. : assertionF  N8activemq4test8openwire22OpenwireMapMessageTestE::testEmptyMapSendReceive. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testTextMessageCompression. : assertionF  N8activemq4test8openwire30OpenwireMessageCompressionTestE::testStreamMessageCompression. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testReceiveBrowseReceive. : assertionF  N8activemq4test8openwire24OpenwireQueueBrowserTestE::testQueueBrowserWith2Consumers. : assertionF  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testDLQHandling. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryReceiveNoCommit. : errorE  N8activemq4test8openwire28OpenWireRedeliveryPolicyTestE::testRepeatedRedeliveryOnMessageNoCommit. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleConnections. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testMultipleSessions. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testReceiveAlreadyInQueue. : assertionF  N8activemq4test8openwire18OpenwireSimpleTestE::testWithZeroConsumerPrefetchWithInFlightExpiration. : errorE  N8activemq4test8openwire18OpenwireSimpleTestE::tesstStreamMessage. : assertionF  N8activemq4test8openwire27OpenwireTempDestinationTestE::testBasics. : errorE  N8activemq4test8openwire27OpenwireTempDestinationTestE::testTwoConnections. : assertionF  N8activemq4test8openwire23OpenwireTransactionTestE::testSendSessionClose. : errorE  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveAutoAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveClinetAck. : assertionF  N8activemq4test8openwire24OpenwireVirtualTopicTestE::testVirtualTopicSyncReceiveTransacted. : assertionF\n\nSteps to reproduce:\n1.) wget http://apache.miloslavbrada.cz/activemq/activemq-artemis/1.1.0/apache-artemis-1.1.0-bin.zip\n2.) unzip apache-artemis-1.1.0-bin.zip\n3.) cd apache-artemis-1.1.0/bin/\n4.) ./artemis create broker110 --data /tmp/artemis/broker110 --allow-anonymous --user pematous --password pematous ../runtime/broker110\n5.) /root/A-MQ/r7.0.0/upstream/apache-artemis-1.1.0/runtime/broker110/bin/artemis-service start\n6.) cd -\n7.) cd activemq-cpp-library-3.9.0/src/test-integration/\n8.) wget http://apache.miloslavbrada.cz/activemq/activemq-cpp/3.9.0/activemq-cpp-library-3.9.0-src.tar.gz\n9.) tar -xf activemq-cpp-library-3.9.0-src.tar.gz\n10.) cd activemq-cpp-library-3.9.0\n11.) ./configure\n12.) make check\n13.) cd src/test-integration\n14.) ./activemq-test-integration\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ CPP (CMS) integration unit tests leads to client segmentation fault when executed against Artemis' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-587?\nA: CMS tests that leads to client segmentation fault:  N8activemq4test8openwire26OpenwireXATransactionsTestE::testSendReceiveTransactedBatchesSegmentation fault (core dumped)  N8activemq4test8openwire36OpenWireCmsSendWithAsyncCallbackTestE::testAsyncCallbackIsFasterSegmentation fault (core dumped) - Occasionally only\n\nother failing test from the suite:  N8activemq4test8openwire21OpenwireAdvisorysTest"}}
{"issue_key": "AMQCPP-586", "project": "AMQCPP", "title": "Messages erroneously rejected as duplicates.", "status": "Open", "reporter": "Mark Williams", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-11-02T09:00:38.000+0000", "updated": "2015-11-02T09:09:29.000+0000", "description": "Messages erroneously rejected as duplicates.\n\nUsing the failover transport, INDIVIDUAL_ACKNOWLEDGE mode and the redelivery\nplug-in if we repeatedly close and reopen the consumer without acknowledging\nthe messages then, after a while, messages are marked as duplicates.\n\nUsing the option \"connection.checkForDuplicates=false\" provides a workaround.\n\nThe attached sample program illustrates the problem.  You may need to run it with\nmany 100 loops to see the problem, although sometimes it occurs quickly.", "comments": [], "text": "Messages erroneously rejected as duplicates.\n\nDescription:\nMessages erroneously rejected as duplicates.\n\nUsing the failover transport, INDIVIDUAL_ACKNOWLEDGE mode and the redelivery\nplug-in if we repeatedly close and reopen the consumer without acknowledging\nthe messages then, after a while, messages are marked as duplicates.\n\nUsing the option \"connection.checkForDuplicates=false\" provides a workaround.\n\nThe attached sample program illustrates the problem.  You may need to run it with\nmany 100 loops to see the problem, although sometimes it occurs quickly.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Messages erroneously rejected as duplicates.\n\nDescription:\nMessages erroneously rejected as duplicates.\n\nUsing the failover transport, INDIVIDUAL_ACKNOWLEDGE mode and the redelivery\nplug-in if we repeatedly close and reopen the consumer without acknowledging\nthe messages then, after a while, messages are marked as duplicates.\n\nUsing the option \"connection.checkForDuplicates=false\" provides a workaround.\n\nThe attached sample program illustrates the problem.  You may need to run it with\nmany 100 loops to see the problem, although sometimes it occurs quickly.\n\n\nComments:\n", "classification": "Classify the issue 'Messages erroneously rejected as duplicates.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-586?\nA: Messages erroneously rejected as duplicates.\n\nUsing the failover transport, INDIVIDUAL_ACKNOWLEDGE mode and the redelivery\nplug-in if we repeatedly close and reopen the consumer without acknowledging\nthe messages then, after a while, messages are marked as duplicates.\n\nUsing the option \"connection.checkForDuplicates=false\" provides a workaround.\n\nThe attached sample program illustrates the problem"}}
{"issue_key": "AMQCPP-585", "project": "AMQCPP", "title": "Date::toString() return wrong date string.", "status": "Closed", "reporter": "Li Shaohui", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-09-10T06:18:20.000+0000", "updated": "2015-11-25T18:55:14.000+0000", "description": "decaf::util::Date::toString() return wrong date string.\nIt call apr_time_exp_lt(apr_time_exp_t *result, apr_time_t input);\nThe param input should be microseconds, but the time saved in Date is millisecond. So toString() return wrong string.", "comments": [], "text": "Date::toString() return wrong date string.\n\nDescription:\ndecaf::util::Date::toString() return wrong date string.\nIt call apr_time_exp_lt(apr_time_exp_t *result, apr_time_t input);\nThe param input should be microseconds, but the time saved in Date is millisecond. So toString() return wrong string.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Date::toString() return wrong date string.\n\nDescription:\ndecaf::util::Date::toString() return wrong date string.\nIt call apr_time_exp_lt(apr_time_exp_t *result, apr_time_t input);\nThe param input should be microseconds, but the time saved in Date is millisecond. So toString() return wrong string.\n\nComments:\n", "classification": "Classify the issue 'Date::toString() return wrong date string.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-585?\nA: decaf::util::Date::toString() return wrong date string.\nIt call apr_time_exp_lt(apr_time_exp_t *result, apr_time_t input);\nThe param input should be microseconds, but the time saved in Date is millisecond. So toString() return wrong string."}}
{"issue_key": "AMQCPP-584", "project": "AMQCPP", "title": "core dump in testNonFailureSendCasepure", "status": "Closed", "reporter": "Wolfgang Klein", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-08-25T11:43:15.000+0000", "updated": "2015-08-25T13:53:13.000+0000", "description": "running ./src/test/activemq-test i get\n\nN8activemq9transport10inactivity21InactivityMonitorTestE::testNonFailureSendCasepure virtual method called\nterminate called without an active exception\n.Aborted (core dumped)\n\ndebuginfo-install apr-1.3.9-5.el6_2.x86_64 cppunit-1.12.1-3.1.el6.x86_64 glibc-2.12-1.107.el6.x86_64 libgcc-4.4.7-3.el6.x86_64 libstdc++-4.4.7-3.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64\n\n(gdb) bt\n#0  0x0000003d8f4328a5 in raise () from /lib64/libc.so.6\n#1  0x0000003d8f434085 in abort () from /lib64/libc.so.6\n#2  0x0000003d954bea5d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6\n#3  0x0000003d954bcbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#4  0x0000003d954bcc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#5  0x0000003d954bd53f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#6  0x00007f0c4419145b in decaf::util::concurrent::Lock::lock (this=0x7f0c27ffec40) at decaf/util/concurrent/Lock.cpp:54\n#7  0x00007f0c44191575 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>,\n    intiallyLocked=<value optimized out>) at decaf/util/concurrent/Lock.cpp:32\n#8  0x00007f0c4400c1cf in activemq::transport::inactivity::InactivityMonitor::onCommand (this=<value optimized out>, command=...)\n    at activemq/transport/inactivity/InactivityMonitor.cpp:321\n#9  0x00007f0c4401344d in activemq::transport::mock::MockTransport::fireCommand (this=0x2c8b330, command=...)\n    at ./activemq/transport/mock/MockTransport.h:110\n#10 0x00007f0c44010421 in activemq::transport::mock::InternalCommandListener::run (this=0x2c8b3a0)\n    at activemq/transport/mock/InternalCommandListener.cpp:97\n#11 0x00007f0c4410ae0f in (anonymous namespace)::runCallback (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:268\n#12 0x00007f0c4410ab84 in (anonymous namespace)::threadEntryMethod (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:256\n#13 0x0000003a3dc07851 in start_thread () from /lib64/libpthread.so.0\n#14 0x0000003d8f4e890d in clone () from /lib64/libc.so.6", "comments": [], "text": "core dump in testNonFailureSendCasepure\n\nDescription:\nrunning ./src/test/activemq-test i get\n\nN8activemq9transport10inactivity21InactivityMonitorTestE::testNonFailureSendCasepure virtual method called\nterminate called without an active exception\n.Aborted (core dumped)\n\ndebuginfo-install apr-1.3.9-5.el6_2.x86_64 cppunit-1.12.1-3.1.el6.x86_64 glibc-2.12-1.107.el6.x86_64 libgcc-4.4.7-3.el6.x86_64 libstdc++-4.4.7-3.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64\n\n(gdb) bt\n#0  0x0000003d8f4328a5 in raise () from /lib64/libc.so.6\n#1  0x0000003d8f434085 in abort () from /lib64/libc.so.6\n#2  0x0000003d954bea5d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6\n#3  0x0000003d954bcbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#4  0x0000003d954bcc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#5  0x0000003d954bd53f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#6  0x00007f0c4419145b in decaf::util::concurrent::Lock::lock (this=0x7f0c27ffec40) at decaf/util/concurrent/Lock.cpp:54\n#7  0x00007f0c44191575 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>,\n    intiallyLocked=<value optimized out>) at decaf/util/concurrent/Lock.cpp:32\n#8  0x00007f0c4400c1cf in activemq::transport::inactivity::InactivityMonitor::onCommand (this=<value optimized out>, command=...)\n    at activemq/transport/inactivity/InactivityMonitor.cpp:321\n#9  0x00007f0c4401344d in activemq::transport::mock::MockTransport::fireCommand (this=0x2c8b330, command=...)\n    at ./activemq/transport/mock/MockTransport.h:110\n#10 0x00007f0c44010421 in activemq::transport::mock::InternalCommandListener::run (this=0x2c8b3a0)\n    at activemq/transport/mock/InternalCommandListener.cpp:97\n#11 0x00007f0c4410ae0f in (anonymous namespace)::runCallback (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:268\n#12 0x00007f0c4410ab84 in (anonymous namespace)::threadEntryMethod (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:256\n#13 0x0000003a3dc07851 in start_thread () from /lib64/libpthread.so.0\n#14 0x0000003d8f4e890d in clone () from /lib64/libc.so.6\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: core dump in testNonFailureSendCasepure\n\nDescription:\nrunning ./src/test/activemq-test i get\n\nN8activemq9transport10inactivity21InactivityMonitorTestE::testNonFailureSendCasepure virtual method called\nterminate called without an active exception\n.Aborted (core dumped)\n\ndebuginfo-install apr-1.3.9-5.el6_2.x86_64 cppunit-1.12.1-3.1.el6.x86_64 glibc-2.12-1.107.el6.x86_64 libgcc-4.4.7-3.el6.x86_64 libstdc++-4.4.7-3.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_64 nss-softokn-freebl-3.12.9-11.el6.x86_64\n\n(gdb) bt\n#0  0x0000003d8f4328a5 in raise () from /lib64/libc.so.6\n#1  0x0000003d8f434085 in abort () from /lib64/libc.so.6\n#2  0x0000003d954bea5d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6\n#3  0x0000003d954bcbe6 in ?? () from /usr/lib64/libstdc++.so.6\n#4  0x0000003d954bcc13 in std::terminate() () from /usr/lib64/libstdc++.so.6\n#5  0x0000003d954bd53f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6\n#6  0x00007f0c4419145b in decaf::util::concurrent::Lock::lock (this=0x7f0c27ffec40) at decaf/util/concurrent/Lock.cpp:54\n#7  0x00007f0c44191575 in decaf::util::concurrent::Lock::Lock (this=<value optimized out>, object=<value optimized out>,\n    intiallyLocked=<value optimized out>) at decaf/util/concurrent/Lock.cpp:32\n#8  0x00007f0c4400c1cf in activemq::transport::inactivity::InactivityMonitor::onCommand (this=<value optimized out>, command=...)\n    at activemq/transport/inactivity/InactivityMonitor.cpp:321\n#9  0x00007f0c4401344d in activemq::transport::mock::MockTransport::fireCommand (this=0x2c8b330, command=...)\n    at ./activemq/transport/mock/MockTransport.h:110\n#10 0x00007f0c44010421 in activemq::transport::mock::InternalCommandListener::run (this=0x2c8b3a0)\n    at activemq/transport/mock/InternalCommandListener.cpp:97\n#11 0x00007f0c4410ae0f in (anonymous namespace)::runCallback (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:268\n#12 0x00007f0c4410ab84 in (anonymous namespace)::threadEntryMethod (arg=0x2c39ae0) at decaf/internal/util/concurrent/Threading.cpp:256\n#13 0x0000003a3dc07851 in start_thread () from /lib64/libpthread.so.0\n#14 0x0000003d8f4e890d in clone () from /lib64/libc.so.6\n\n\nComments:\n", "classification": "Classify the issue 'core dump in testNonFailureSendCasepure' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-584?\nA: running ./src/test/activemq-test i get\n\nN8activemq9transport10inactivity21InactivityMonitorTestE::testNonFailureSendCasepure virtual method called\nterminate called without an active exception\n.Aborted (core dumped)\n\ndebuginfo-install apr-1.3.9-5.el6_2.x86_64 cppunit-1.12.1-3.1.el6.x86_64 glibc-2.12-1.107.el6.x86_64 libgcc-4.4.7-3.el6.x86_64 libstdc++-4.4.7-3.el6.x86_64 libuuid-2.17.2-12.7.el6.x86_"}}
{"issue_key": "AMQCPP-583", "project": "AMQCPP", "title": "Segmentation Fault within TransportFilter::onCommand()", "status": "Closed", "reporter": "David Whitney", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-08-21T12:06:48.000+0000", "updated": "2015-11-25T16:23:11.000+0000", "description": "Occasionally, but not always, during the course of closing the CMS connection, a segmentation fault occurs.  This issue is eerily similar to that described in AMQCPP-534.  However, the issue in AMQCPP-534 was supposedly fixed for ActiveMQ CMS 3.8.4, and this just so happens to be the version I'm using.  I also witnessed the same issue when using version 3.8.3.\n\nThe client application I'm a running is essentially opening and closing connections at a rapid pace (i.e. a stress test).  A transport listener has been set up, so as to receive notifications as to when the connection has been interrupted (broken).  Whether I call upon ActiveMQConnection::removeTransportListener() or not, the segmentation fault occurs.\n\nHere's the stack trace:\n\n#0  0x00007f74aa4373af in activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#1  0x00007f74aa435b5c in activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#2  0x00007f74aa436da1 in activemq::transport::IOTransport::run() () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#3  0x00007f74aa57ab82 in (anonymous namespace)::runCallback(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#4  0x00007f74aa57b48c in (anonymous namespace)::threadEntryMethod(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#5  0x00007f74aba32df3 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f74aaf413dd in clone () from /lib64/libc.so.6\n\n\nIf additional information is required, please let me know.", "comments": [], "text": "Segmentation Fault within TransportFilter::onCommand()\n\nDescription:\nOccasionally, but not always, during the course of closing the CMS connection, a segmentation fault occurs.  This issue is eerily similar to that described in AMQCPP-534.  However, the issue in AMQCPP-534 was supposedly fixed for ActiveMQ CMS 3.8.4, and this just so happens to be the version I'm using.  I also witnessed the same issue when using version 3.8.3.\n\nThe client application I'm a running is essentially opening and closing connections at a rapid pace (i.e. a stress test).  A transport listener has been set up, so as to receive notifications as to when the connection has been interrupted (broken).  Whether I call upon ActiveMQConnection::removeTransportListener() or not, the segmentation fault occurs.\n\nHere's the stack trace:\n\n#0  0x00007f74aa4373af in activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#1  0x00007f74aa435b5c in activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#2  0x00007f74aa436da1 in activemq::transport::IOTransport::run() () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#3  0x00007f74aa57ab82 in (anonymous namespace)::runCallback(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#4  0x00007f74aa57b48c in (anonymous namespace)::threadEntryMethod(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#5  0x00007f74aba32df3 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f74aaf413dd in clone () from /lib64/libc.so.6\n\n\nIf additional information is required, please let me know.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation Fault within TransportFilter::onCommand()\n\nDescription:\nOccasionally, but not always, during the course of closing the CMS connection, a segmentation fault occurs.  This issue is eerily similar to that described in AMQCPP-534.  However, the issue in AMQCPP-534 was supposedly fixed for ActiveMQ CMS 3.8.4, and this just so happens to be the version I'm using.  I also witnessed the same issue when using version 3.8.3.\n\nThe client application I'm a running is essentially opening and closing connections at a rapid pace (i.e. a stress test).  A transport listener has been set up, so as to receive notifications as to when the connection has been interrupted (broken).  Whether I call upon ActiveMQConnection::removeTransportListener() or not, the segmentation fault occurs.\n\nHere's the stack trace:\n\n#0  0x00007f74aa4373af in activemq::transport::TransportFilter::onCommand(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#1  0x00007f74aa435b5c in activemq::transport::IOTransport::fire(decaf::lang::Pointer<activemq::commands::Command, decaf::util::concurrent::atomic::AtomicRefCounter>) ()\n   from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#2  0x00007f74aa436da1 in activemq::transport::IOTransport::run() () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#3  0x00007f74aa57ab82 in (anonymous namespace)::runCallback(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#4  0x00007f74aa57b48c in (anonymous namespace)::threadEntryMethod(void*) () from /home/nightrun/gmsec/SUPPORT/activemq384/lib/libactivemq-cpp.so.18\n#5  0x00007f74aba32df3 in start_thread () from /lib64/libpthread.so.0\n#6  0x00007f74aaf413dd in clone () from /lib64/libc.so.6\n\n\nIf additional information is required, please let me know.\n\nComments:\n", "classification": "Classify the issue 'Segmentation Fault within TransportFilter::onCommand()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-583?\nA: Occasionally, but not always, during the course of closing the CMS connection, a segmentation fault occurs.  This issue is eerily similar to that described in AMQCPP-534.  However, the issue in AMQCPP-534 was supposedly fixed for ActiveMQ CMS 3.8.4, and this just so happens to be the version I'm using.  I also witnessed the same issue when using version 3.8.3.\n\nThe client application I'm a running"}}
{"issue_key": "AMQCPP-582", "project": "AMQCPP", "title": "Pull consumer hang when message expires in flight.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-08-03T17:55:15.000+0000", "updated": "2015-08-03T18:54:49.000+0000", "description": "If a message expires in-flight or while in a rolled back transaction the pull consumer does not send another pull request and can hang when  ending the poison Ack for the expired message.", "comments": [], "text": "Pull consumer hang when message expires in flight.\n\nDescription:\nIf a message expires in-flight or while in a rolled back transaction the pull consumer does not send another pull request and can hang when  ending the poison Ack for the expired message.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Pull consumer hang when message expires in flight.\n\nDescription:\nIf a message expires in-flight or while in a rolled back transaction the pull consumer does not send another pull request and can hang when  ending the poison Ack for the expired message.\n\n\nComments:\n", "classification": "Classify the issue 'Pull consumer hang when message expires in flight.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-582?\nA: If a message expires in-flight or while in a rolled back transaction the pull consumer does not send another pull request and can hang when  ending the poison Ack for the expired message.\n"}}
{"issue_key": "AMQCPP-581", "project": "AMQCPP", "title": "Pull consumer can hang in receive if RedeliveryPolicy is configured with max redeliveries ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-07-30T21:19:58.000+0000", "updated": "2015-07-30T22:34:57.000+0000", "description": "For a pull consumer (prefetch = 0) with a redelivery policy that enforces maximum redeliveries we now eagerly poison the incoming messages if they exceed the maximum redelivery value. The consumer does not attempt to issue another pull request in this case which can stall receive().\n\nAlso the consumer does not recompute the timeout if one is set leading to a longer wait than might otherwise be expected.", "comments": [], "text": "Pull consumer can hang in receive if RedeliveryPolicy is configured with max redeliveries \n\nDescription:\n\n\nFor a pull consumer (prefetch = 0) with a redelivery policy that enforces maximum redeliveries we now eagerly poison the incoming messages if they exceed the maximum redelivery value. The consumer does not attempt to issue another pull request in this case which can stall receive().\n\nAlso the consumer does not recompute the timeout if one is set leading to a longer wait than might otherwise be expected.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Pull consumer can hang in receive if RedeliveryPolicy is configured with max redeliveries \n\nDescription:\n\n\nFor a pull consumer (prefetch = 0) with a redelivery policy that enforces maximum redeliveries we now eagerly poison the incoming messages if they exceed the maximum redelivery value. The consumer does not attempt to issue another pull request in this case which can stall receive().\n\nAlso the consumer does not recompute the timeout if one is set leading to a longer wait than might otherwise be expected.\n\n\nComments:\n", "classification": "Classify the issue 'Pull consumer can hang in receive if RedeliveryPolicy is configured with max redeliveries ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-581?\nA: \n\nFor a pull consumer (prefetch = 0) with a redelivery policy that enforces maximum redeliveries we now eagerly poison the incoming messages if they exceed the maximum redelivery value. The consumer does not attempt to issue another pull request in this case which can stall receive().\n\nAlso the consumer does not recompute the timeout if one is set leading to a longer wait than might otherwise be e"}}
{"issue_key": "AMQCPP-580", "project": "AMQCPP", "title": "Add property maximumRedeliveryDelay in RedeliveryPolicy", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-07-28T20:07:53.000+0000", "updated": "2015-07-28T21:02:05.000+0000", "description": "When useExponentialBackOff was set to true (and with backOffMultiplier default value 5), the delay period each time increases very fast. So we should have a property maximumRedeliveryDelay to make sense.", "comments": [], "text": "Add property maximumRedeliveryDelay in RedeliveryPolicy\n\nDescription:\nWhen useExponentialBackOff was set to true (and with backOffMultiplier default value 5), the delay period each time increases very fast. So we should have a property maximumRedeliveryDelay to make sense.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add property maximumRedeliveryDelay in RedeliveryPolicy\n\nDescription:\nWhen useExponentialBackOff was set to true (and with backOffMultiplier default value 5), the delay period each time increases very fast. So we should have a property maximumRedeliveryDelay to make sense.\n\nComments:\n", "classification": "Classify the issue 'Add property maximumRedeliveryDelay in RedeliveryPolicy' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-580?\nA: When useExponentialBackOff was set to true (and with backOffMultiplier default value 5), the delay period each time increases very fast. So we should have a property maximumRedeliveryDelay to make sense."}}
{"issue_key": "AMQCPP-579", "project": "AMQCPP", "title": "Disable message priority reordering on client by default", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-07-28T18:05:16.000+0000", "updated": "2015-07-28T20:56:19.000+0000", "description": "with mixed priority messages, consuming in batches, occasional async error on batched ack pre commit.\n\nThe reordering client side breaks a range ack. Disabling by default b/c when it is enabled individual ack mode is required which for transactions will negate the typical batch use case.", "comments": [], "text": "Disable message priority reordering on client by default\n\nDescription:\nwith mixed priority messages, consuming in batches, occasional async error on batched ack pre commit.\n\nThe reordering client side breaks a range ack. Disabling by default b/c when it is enabled individual ack mode is required which for transactions will negate the typical batch use case.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Disable message priority reordering on client by default\n\nDescription:\nwith mixed priority messages, consuming in batches, occasional async error on batched ack pre commit.\n\nThe reordering client side breaks a range ack. Disabling by default b/c when it is enabled individual ack mode is required which for transactions will negate the typical batch use case.\n\nComments:\n", "classification": "Classify the issue 'Disable message priority reordering on client by default' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-579?\nA: with mixed priority messages, consuming in batches, occasional async error on batched ack pre commit.\n\nThe reordering client side breaks a range ack. Disabling by default b/c when it is enabled individual ack mode is required which for transactions will negate the typical batch use case."}}
{"issue_key": "AMQCPP-578", "project": "AMQCPP", "title": "Port fix for AMQ-5089 to C++", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-07-17T18:22:49.000+0000", "updated": "2015-07-17T18:49:21.000+0000", "description": "AMQ-5089 adds the Expired Ack type for message that have expired in the prefetch buffer in order to sort issues with incorrect broker statistics.", "comments": [], "text": "Port fix for AMQ-5089 to C++\n\nDescription:\nAMQ-5089 adds the Expired Ack type for message that have expired in the prefetch buffer in order to sort issues with incorrect broker statistics.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Port fix for AMQ-5089 to C++\n\nDescription:\nAMQ-5089 adds the Expired Ack type for message that have expired in the prefetch buffer in order to sort issues with incorrect broker statistics.\n\nComments:\n", "classification": "Classify the issue 'Port fix for AMQ-5089 to C++' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-578?\nA: AMQ-5089 adds the Expired Ack type for message that have expired in the prefetch buffer in order to sort issues with incorrect broker statistics."}}
{"issue_key": "AMQCPP-577", "project": "AMQCPP", "title": "Transacted processing stops working correctly after failover", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-07-17T14:41:33.000+0000", "updated": "2015-07-29T16:37:12.000+0000", "description": "When a C++ application with Failover transport in use consumes from a queue on a master-slave broker pair or a single broker instance, and consumption is in transactional batches, then when a failover occurs the application does not recover from the failover properly. Although the application reconnects to the surviving broker, and new consumers are established, message flow is erratic and more exceptions are thrown.", "comments": [], "text": "Transacted processing stops working correctly after failover\n\nDescription:\nWhen a C++ application with Failover transport in use consumes from a queue on a master-slave broker pair or a single broker instance, and consumption is in transactional batches, then when a failover occurs the application does not recover from the failover properly. Although the application reconnects to the surviving broker, and new consumers are established, message flow is erratic and more exceptions are thrown. \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Transacted processing stops working correctly after failover\n\nDescription:\nWhen a C++ application with Failover transport in use consumes from a queue on a master-slave broker pair or a single broker instance, and consumption is in transactional batches, then when a failover occurs the application does not recover from the failover properly. Although the application reconnects to the surviving broker, and new consumers are established, message flow is erratic and more exceptions are thrown. \n\n\nComments:\n", "classification": "Classify the issue 'Transacted processing stops working correctly after failover' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-577?\nA: When a C++ application with Failover transport in use consumes from a queue on a master-slave broker pair or a single broker instance, and consumption is in transactional batches, then when a failover occurs the application does not recover from the failover properly. Although the application reconnects to the surviving broker, and new consumers are established, message flow is erratic and more ex"}}
{"issue_key": "AMQCPP-576", "project": "AMQCPP", "title": "QueueBrowser should not check for expired messages", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-07-16T22:40:09.000+0000", "updated": "2015-07-17T16:44:16.000+0000", "description": "QueueBrowser should not perform expired message processing but instead just replay the snapshot of messages since its create time.  \n\nRelates to: AMQ-5340", "comments": [], "text": "QueueBrowser should not check for expired messages\n\nDescription:\nQueueBrowser should not perform expired message processing but instead just replay the snapshot of messages since its create time.  \n\nRelates to: AMQ-5340\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: QueueBrowser should not check for expired messages\n\nDescription:\nQueueBrowser should not perform expired message processing but instead just replay the snapshot of messages since its create time.  \n\nRelates to: AMQ-5340\n\nComments:\n", "classification": "Classify the issue 'QueueBrowser should not check for expired messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-576?\nA: QueueBrowser should not perform expired message processing but instead just replay the snapshot of messages since its create time.  \n\nRelates to: AMQ-5340"}}
{"issue_key": "AMQCPP-575", "project": "AMQCPP", "title": "Add support for disable of expiration checks in MessageConsumer", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-07-16T22:34:39.000+0000", "updated": "2015-07-17T16:44:26.000+0000", "description": "Add support for disabling the consumer expired message processing checks for those rare cases where folks know that the clocks are out of sync and they are ok with that.  \n\nSame fix as in AMQ-5406", "comments": [], "text": "Add support for disable of expiration checks in MessageConsumer\n\nDescription:\nAdd support for disabling the consumer expired message processing checks for those rare cases where folks know that the clocks are out of sync and they are ok with that.  \n\nSame fix as in AMQ-5406\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for disable of expiration checks in MessageConsumer\n\nDescription:\nAdd support for disabling the consumer expired message processing checks for those rare cases where folks know that the clocks are out of sync and they are ok with that.  \n\nSame fix as in AMQ-5406\n\nComments:\n", "classification": "Classify the issue 'Add support for disable of expiration checks in MessageConsumer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-575?\nA: Add support for disabling the consumer expired message processing checks for those rare cases where folks know that the clocks are out of sync and they are ok with that.  \n\nSame fix as in AMQ-5406"}}
{"issue_key": "AMQCPP-574", "project": "AMQCPP", "title": "[IGNORE] Testing svngit2jira integration", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2015-07-14T15:25:21.000+0000", "updated": "2015-07-14T15:28:20.000+0000", "description": "Issue used for testing svngit2jira integration", "comments": [], "text": "[IGNORE] Testing svngit2jira integration\n\nDescription:\nIssue used for testing svngit2jira integration \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: [IGNORE] Testing svngit2jira integration\n\nDescription:\nIssue used for testing svngit2jira integration \n\nComments:\n", "classification": "Classify the issue '[IGNORE] Testing svngit2jira integration' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-574?\nA: Issue used for testing svngit2jira integration "}}
{"issue_key": "AMQCPP-573", "project": "AMQCPP", "title": "Update OpenWire support to v11", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-07-10T18:40:47.000+0000", "updated": "2015-07-10T19:01:07.000+0000", "description": "Regenerate openwire code to include v11", "comments": [], "text": "Update OpenWire support to v11\n\nDescription:\nRegenerate openwire code to include v11 \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update OpenWire support to v11\n\nDescription:\nRegenerate openwire code to include v11 \n\nComments:\n", "classification": "Classify the issue 'Update OpenWire support to v11' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-573?\nA: Regenerate openwire code to include v11 "}}
{"issue_key": "AMQCPP-572", "project": "AMQCPP", "title": "activemq-cmstemplate-stressor.vcproj missing", "status": "Resolved", "reporter": "Wayne Johnson", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["VisualStudio"], "created": "2015-06-25T13:54:33.000+0000", "updated": "2015-07-10T19:27:32.000+0000", "description": "Unpacked a new copy of activemq-cpp-library-3.8.4-src.zip to build on VisualStudio 2013.  During the upgrade of the project files it (VisualStudio 2013 upgrade) reported:\n\tactivemq-cmstemplate-stressor.vcproj: File 'C:\\Users\\C9915437\\environment\\libraries\\apache\\activemq-cpp\\activemq-cpp-library-3.8.4\\vs2008-build\\activemq-cmstemplate-stressor.vcproj' was not found.\n\nSVN appears to be missing (or the solution is erroneously referencing) the project as well.", "comments": [], "text": "activemq-cmstemplate-stressor.vcproj missing\n\nDescription:\nUnpacked a new copy of activemq-cpp-library-3.8.4-src.zip to build on VisualStudio 2013.  During the upgrade of the project files it (VisualStudio 2013 upgrade) reported:\n\tactivemq-cmstemplate-stressor.vcproj: File 'C:\\Users\\C9915437\\environment\\libraries\\apache\\activemq-cpp\\activemq-cpp-library-3.8.4\\vs2008-build\\activemq-cmstemplate-stressor.vcproj' was not found.\n\nSVN appears to be missing (or the solution is erroneously referencing) the project as well.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cmstemplate-stressor.vcproj missing\n\nDescription:\nUnpacked a new copy of activemq-cpp-library-3.8.4-src.zip to build on VisualStudio 2013.  During the upgrade of the project files it (VisualStudio 2013 upgrade) reported:\n\tactivemq-cmstemplate-stressor.vcproj: File 'C:\\Users\\C9915437\\environment\\libraries\\apache\\activemq-cpp\\activemq-cpp-library-3.8.4\\vs2008-build\\activemq-cmstemplate-stressor.vcproj' was not found.\n\nSVN appears to be missing (or the solution is erroneously referencing) the project as well.\n\nComments:\n", "classification": "Classify the issue 'activemq-cmstemplate-stressor.vcproj missing' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-572?\nA: Unpacked a new copy of activemq-cpp-library-3.8.4-src.zip to build on VisualStudio 2013.  During the upgrade of the project files it (VisualStudio 2013 upgrade) reported:\n\tactivemq-cmstemplate-stressor.vcproj: File 'C:\\Users\\C9915437\\environment\\libraries\\apache\\activemq-cpp\\activemq-cpp-library-3.8.4\\vs2008-build\\activemq-cmstemplate-stressor.vcproj' was not found.\n\nSVN appears to be missing (or "}}
{"issue_key": "AMQCPP-571", "project": "AMQCPP", "title": "Unacknowledged messages dissappear from broker if session/consumer is closed and then re-created", "status": "Resolved", "reporter": "Mark Williams", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-06-15T11:53:41.000+0000", "updated": "2015-07-17T14:17:13.000+0000", "description": "Unacknowledged messages dissappear from broker if session is stopped and restarted and/or if the consumer object is deleted and re-created.", "comments": [], "text": "Unacknowledged messages dissappear from broker if session/consumer is closed and then re-created\n\nDescription:\nUnacknowledged messages dissappear from broker if session is stopped and restarted and/or if the consumer object is deleted and re-created.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unacknowledged messages dissappear from broker if session/consumer is closed and then re-created\n\nDescription:\nUnacknowledged messages dissappear from broker if session is stopped and restarted and/or if the consumer object is deleted and re-created.\n\nComments:\n", "classification": "Classify the issue 'Unacknowledged messages dissappear from broker if session/consumer is closed and then re-created' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-571?\nA: Unacknowledged messages dissappear from broker if session is stopped and restarted and/or if the consumer object is deleted and re-created."}}
{"issue_key": "AMQCPP-570", "project": "AMQCPP", "title": "Please update projects to use later versions of broker", "status": "Closed", "reporter": "Susan Javurek", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-04-20T14:25:33.000+0000", "updated": "2015-04-20T15:44:49.000+0000", "description": "When I cloned the 3.8.3 source code, I noticed we are still using 5.7 broker and as such activemq-core. \n\nWould you bump these up so we can easily use the newer versions, so activemq-broker instead.", "comments": [], "text": "Please update projects to use later versions of broker\n\nDescription:\nWhen I cloned the 3.8.3 source code, I noticed we are still using 5.7 broker and as such activemq-core. \n\nWould you bump these up so we can easily use the newer versions, so activemq-broker instead. \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Please update projects to use later versions of broker\n\nDescription:\nWhen I cloned the 3.8.3 source code, I noticed we are still using 5.7 broker and as such activemq-core. \n\nWould you bump these up so we can easily use the newer versions, so activemq-broker instead. \n\n\n\nComments:\n", "classification": "Classify the issue 'Please update projects to use later versions of broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-570?\nA: When I cloned the 3.8.3 source code, I noticed we are still using 5.7 broker and as such activemq-core. \n\nWould you bump these up so we can easily use the newer versions, so activemq-broker instead. \n\n"}}
{"issue_key": "AMQCPP-569", "project": "AMQCPP", "title": "thread creation leak with failover transport after disconnect", "status": "Resolved", "reporter": "Arthur Naseef", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-03-19T19:01:34.000+0000", "updated": "2015-07-15T17:50:19.000+0000", "description": "As reported here: http://activemq.2283324.n4.nabble.com/ActiveMQ-High-number-of-threads-td4693185.html#a4693477\n\nThe following steps lead to a thread leak:\n\n* Start client with failover transport with at least 2 brokers in the URL\n* Wait for the client to successfully connect to the broker\n* Shutdown the broker\n* Watch the number of threads in the process\n\nUsing GDB, I found the following stack trace in a good number of the most recent threads:\n\n{noformat}\n#0  0x00007ffff68a2705 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n#1  0x00007ffff774087b in decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition (\n    condition=0x7fffc8002790, mutex=0x7fffc8000a20, complete=...)\n    at decaf/internal/util/concurrent/unix/PlatformThread.cpp:210\n#2  0x00007ffff773f5c5 in doWaitOnMonitor (interruptible=true, nanos=<optimized out>, mills=0, thread=0x7fffc8003a40, \n    monitor=0x618310) at decaf/internal/util/concurrent/Threading.cpp:754\n#3  decaf::internal::util::concurrent::Threading::waitOnMonitor (monitor=0x618310, mills=0, nanos=<optimized out>)\n    at decaf/internal/util/concurrent/Threading.cpp:1558\n#4  0x00007ffff77a7e5c in decaf::util::TimerImpl::run (this=0x7fffc8000d20) at decaf/util/Timer.cpp:79\n#5  0x00007ffff773cb72 in (anonymous namespace)::runCallback (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:266\n#6  0x00007ffff773d47c in (anonymous namespace)::threadEntryMethod (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:254\n#7  0x00007ffff689edf3 in start_thread () from /lib64/libpthread.so.0\n#8  0x00007ffff5ba91ad in clone () from /lib64/libc.so.6\n{noformat}\n\nI tested with a slightly-modified version of the example C++ program from the ActiveMQ wiki (http://activemq.apache.org/cms/example.html).  The modifications consist of adding a delay after producing each message (to slow down the program in order to make testing easier), and accepting the broker URL from the command-line.\n\nNote that watching the threads with \"ps\" over a period of time, the leak does not appear to occur with 100% consistency; at least a couple of times, the number of threads dropped back down and then increased again -- this is in the same run in which the number of threads did grow more than once.", "comments": [], "text": "thread creation leak with failover transport after disconnect\n\nDescription:\nAs reported here: http://activemq.2283324.n4.nabble.com/ActiveMQ-High-number-of-threads-td4693185.html#a4693477\n\nThe following steps lead to a thread leak:\n\n* Start client with failover transport with at least 2 brokers in the URL\n* Wait for the client to successfully connect to the broker\n* Shutdown the broker\n* Watch the number of threads in the process\n\nUsing GDB, I found the following stack trace in a good number of the most recent threads:\n\n{noformat}\n#0  0x00007ffff68a2705 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n#1  0x00007ffff774087b in decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition (\n    condition=0x7fffc8002790, mutex=0x7fffc8000a20, complete=...)\n    at decaf/internal/util/concurrent/unix/PlatformThread.cpp:210\n#2  0x00007ffff773f5c5 in doWaitOnMonitor (interruptible=true, nanos=<optimized out>, mills=0, thread=0x7fffc8003a40, \n    monitor=0x618310) at decaf/internal/util/concurrent/Threading.cpp:754\n#3  decaf::internal::util::concurrent::Threading::waitOnMonitor (monitor=0x618310, mills=0, nanos=<optimized out>)\n    at decaf/internal/util/concurrent/Threading.cpp:1558\n#4  0x00007ffff77a7e5c in decaf::util::TimerImpl::run (this=0x7fffc8000d20) at decaf/util/Timer.cpp:79\n#5  0x00007ffff773cb72 in (anonymous namespace)::runCallback (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:266\n#6  0x00007ffff773d47c in (anonymous namespace)::threadEntryMethod (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:254\n#7  0x00007ffff689edf3 in start_thread () from /lib64/libpthread.so.0\n#8  0x00007ffff5ba91ad in clone () from /lib64/libc.so.6\n{noformat}\n\nI tested with a slightly-modified version of the example C++ program from the ActiveMQ wiki (http://activemq.apache.org/cms/example.html).  The modifications consist of adding a delay after producing each message (to slow down the program in order to make testing easier), and accepting the broker URL from the command-line.\n\nNote that watching the threads with \"ps\" over a period of time, the leak does not appear to occur with 100% consistency; at least a couple of times, the number of threads dropped back down and then increased again -- this is in the same run in which the number of threads did grow more than once.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: thread creation leak with failover transport after disconnect\n\nDescription:\nAs reported here: http://activemq.2283324.n4.nabble.com/ActiveMQ-High-number-of-threads-td4693185.html#a4693477\n\nThe following steps lead to a thread leak:\n\n* Start client with failover transport with at least 2 brokers in the URL\n* Wait for the client to successfully connect to the broker\n* Shutdown the broker\n* Watch the number of threads in the process\n\nUsing GDB, I found the following stack trace in a good number of the most recent threads:\n\n{noformat}\n#0  0x00007ffff68a2705 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n#1  0x00007ffff774087b in decaf::internal::util::concurrent::PlatformThread::interruptibleWaitOnCondition (\n    condition=0x7fffc8002790, mutex=0x7fffc8000a20, complete=...)\n    at decaf/internal/util/concurrent/unix/PlatformThread.cpp:210\n#2  0x00007ffff773f5c5 in doWaitOnMonitor (interruptible=true, nanos=<optimized out>, mills=0, thread=0x7fffc8003a40, \n    monitor=0x618310) at decaf/internal/util/concurrent/Threading.cpp:754\n#3  decaf::internal::util::concurrent::Threading::waitOnMonitor (monitor=0x618310, mills=0, nanos=<optimized out>)\n    at decaf/internal/util/concurrent/Threading.cpp:1558\n#4  0x00007ffff77a7e5c in decaf::util::TimerImpl::run (this=0x7fffc8000d20) at decaf/util/Timer.cpp:79\n#5  0x00007ffff773cb72 in (anonymous namespace)::runCallback (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:266\n#6  0x00007ffff773d47c in (anonymous namespace)::threadEntryMethod (arg=0x7fffc8003a40)\n    at decaf/internal/util/concurrent/Threading.cpp:254\n#7  0x00007ffff689edf3 in start_thread () from /lib64/libpthread.so.0\n#8  0x00007ffff5ba91ad in clone () from /lib64/libc.so.6\n{noformat}\n\nI tested with a slightly-modified version of the example C++ program from the ActiveMQ wiki (http://activemq.apache.org/cms/example.html).  The modifications consist of adding a delay after producing each message (to slow down the program in order to make testing easier), and accepting the broker URL from the command-line.\n\nNote that watching the threads with \"ps\" over a period of time, the leak does not appear to occur with 100% consistency; at least a couple of times, the number of threads dropped back down and then increased again -- this is in the same run in which the number of threads did grow more than once.\n\nComments:\n", "classification": "Classify the issue 'thread creation leak with failover transport after disconnect' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-569?\nA: As reported here: http://activemq.2283324.n4.nabble.com/ActiveMQ-High-number-of-threads-td4693185.html#a4693477\n\nThe following steps lead to a thread leak:\n\n* Start client with failover transport with at least 2 brokers in the URL\n* Wait for the client to successfully connect to the broker\n* Shutdown the broker\n* Watch the number of threads in the process\n\nUsing GDB, I found the following stack tr"}}
{"issue_key": "AMQCPP-568", "project": "AMQCPP", "title": "CMS FailoverTransport Leaks Socket Descriptors with secondary backup", "status": "Resolved", "reporter": "Nelson Correia", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2015-03-18T10:09:20.000+0000", "updated": "2015-07-15T17:50:32.000+0000", "description": "I've configured the URI with failover and with 2 hosts:\nfailover:(tcp://primary:61616,tcp://secondary:61616)?randomize=false\n\nAssume that secondary is not working, and the primary is shut downed. The CMS enters in failover mode and the number of threads and sockets starts to enlarge.\n\nWhen I use the URI only with the primary it works well. I think this issue is somehow related with the https://issues.apache.org/jira/browse/AMQCPP-487 issue, but didn't figure out what is wrong.", "comments": [], "text": "CMS FailoverTransport Leaks Socket Descriptors with secondary backup\n\nDescription:\nI've configured the URI with failover and with 2 hosts:\nfailover:(tcp://primary:61616,tcp://secondary:61616)?randomize=false\n\nAssume that secondary is not working, and the primary is shut downed. The CMS enters in failover mode and the number of threads and sockets starts to enlarge.\n\nWhen I use the URI only with the primary it works well. I think this issue is somehow related with the https://issues.apache.org/jira/browse/AMQCPP-487 issue, but didn't figure out what is wrong.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS FailoverTransport Leaks Socket Descriptors with secondary backup\n\nDescription:\nI've configured the URI with failover and with 2 hosts:\nfailover:(tcp://primary:61616,tcp://secondary:61616)?randomize=false\n\nAssume that secondary is not working, and the primary is shut downed. The CMS enters in failover mode and the number of threads and sockets starts to enlarge.\n\nWhen I use the URI only with the primary it works well. I think this issue is somehow related with the https://issues.apache.org/jira/browse/AMQCPP-487 issue, but didn't figure out what is wrong.\n\n\nComments:\n", "classification": "Classify the issue 'CMS FailoverTransport Leaks Socket Descriptors with secondary backup' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-568?\nA: I've configured the URI with failover and with 2 hosts:\nfailover:(tcp://primary:61616,tcp://secondary:61616)?randomize=false\n\nAssume that secondary is not working, and the primary is shut downed. The CMS enters in failover mode and the number of threads and sockets starts to enlarge.\n\nWhen I use the URI only with the primary it works well. I think this issue is somehow related with the https://iss"}}
{"issue_key": "AMQCPP-567", "project": "AMQCPP", "title": "activemq-cpp.pc contains wrong package name for APR", "status": "Resolved", "reporter": "Wolfgang Herget", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["build"], "created": "2015-03-10T10:29:56.000+0000", "updated": "2017-02-09T21:46:51.000+0000", "description": "On OSX, {{pkg-config --exists activemq-cpp}} returns the wrong value.\nThat is because the {{activemq-cpp.pc}} file contains the line {{Requires.private: apr-1-config}}.\nAPR's .pc file however is called {{apr-1}} (minus the {{-config}}), which is why pkg-config thinks there's an unresolved dependency. \n\nAFAICS, the reason for this is that the sed script in {{m4/apr_tools.m4:83}} does the wrong thing with Apples BSD {{sed}}, leaving the {{-config}} in, when it should throw it away.", "comments": [], "text": "activemq-cpp.pc contains wrong package name for APR\n\nDescription:\nOn OSX, {{pkg-config --exists activemq-cpp}} returns the wrong value.\nThat is because the {{activemq-cpp.pc}} file contains the line {{Requires.private: apr-1-config}}.\nAPR's .pc file however is called {{apr-1}} (minus the {{-config}}), which is why pkg-config thinks there's an unresolved dependency. \n\nAFAICS, the reason for this is that the sed script in {{m4/apr_tools.m4:83}} does the wrong thing with Apples BSD {{sed}}, leaving the {{-config}} in, when it should throw it away.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cpp.pc contains wrong package name for APR\n\nDescription:\nOn OSX, {{pkg-config --exists activemq-cpp}} returns the wrong value.\nThat is because the {{activemq-cpp.pc}} file contains the line {{Requires.private: apr-1-config}}.\nAPR's .pc file however is called {{apr-1}} (minus the {{-config}}), which is why pkg-config thinks there's an unresolved dependency. \n\nAFAICS, the reason for this is that the sed script in {{m4/apr_tools.m4:83}} does the wrong thing with Apples BSD {{sed}}, leaving the {{-config}} in, when it should throw it away.\n\nComments:\n", "classification": "Classify the issue 'activemq-cpp.pc contains wrong package name for APR' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-567?\nA: On OSX, {{pkg-config --exists activemq-cpp}} returns the wrong value.\nThat is because the {{activemq-cpp.pc}} file contains the line {{Requires.private: apr-1-config}}.\nAPR's .pc file however is called {{apr-1}} (minus the {{-config}}), which is why pkg-config thinks there's an unresolved dependency. \n\nAFAICS, the reason for this is that the sed script in {{m4/apr_tools.m4:83}} does the wrong thin"}}
{"issue_key": "AMQCPP-566", "project": "AMQCPP", "title": "Potential spin in SecureRandomImpl if /dev/urandom does not exist", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2015-03-04T20:02:48.000+0000", "updated": "2017-02-09T21:47:01.000+0000", "description": "", "comments": [], "text": "Potential spin in SecureRandomImpl if /dev/urandom does not exist\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Potential spin in SecureRandomImpl if /dev/urandom does not exist\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Potential spin in SecureRandomImpl if /dev/urandom does not exist' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-566?\nA: "}}
{"issue_key": "AMQCPP-363", "project": "AMQCPP", "title": "failover: consumer does not always restart properly after reconnect", "status": "Resolved", "reporter": "Chris Hoffmann", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2011-04-20T17:17:02.000+0000", "updated": "2011-04-21T15:17:02.000+0000", "description": "Hi,\n\nWhile testing AMQCPP-355, we came across a problem when resuming from a broker restart. Resuming seems to be erratic when the broker shutdown happens during message processing in an onMessage callback.\n\na) if a message is ack'ed while the broker is still down, the same message will be redelivered after connection resumes. The command tracing does not show the sending of the 1st acknowledgment. \nb) if a message is ack'ed after the broker is brought back (connection resumed OK), the command tracing shows that the ack is send, but on the broker side we see an warning message:\n\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:hostname-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\ndestination = queue://test, transactionId = null, messageCount = 1, poisonCause = null}\n\nWe can't see any redelivery message in the command trace and subsequent messages are not delivered either. The consumer is nevertheless shown on broker admin console. \n\nWhen the connection is resumed, we see that the prefetch size is set to 0 in the consumerInfo message.\n\nc) resuming works fine, if the message is not in process when the shutdown happens.\n\nCases a+b work fine, when we tried to reproduce with a java client from the ActiveMQ examples dir.\n\n\nRegards,\nChris", "comments": [], "text": "failover: consumer does not always restart properly after reconnect\n\nDescription:\nHi,\n\nWhile testing AMQCPP-355, we came across a problem when resuming from a broker restart. Resuming seems to be erratic when the broker shutdown happens during message processing in an onMessage callback.\n\na) if a message is ack'ed while the broker is still down, the same message will be redelivered after connection resumes. The command tracing does not show the sending of the 1st acknowledgment. \nb) if a message is ack'ed after the broker is brought back (connection resumed OK), the command tracing shows that the ack is send, but on the broker side we see an warning message:\n\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:hostname-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\ndestination = queue://test, transactionId = null, messageCount = 1, poisonCause = null}\n\nWe can't see any redelivery message in the command trace and subsequent messages are not delivered either. The consumer is nevertheless shown on broker admin console. \n\nWhen the connection is resumed, we see that the prefetch size is set to 0 in the consumerInfo message.\n\nc) resuming works fine, if the message is not in process when the shutdown happens.\n\nCases a+b work fine, when we tried to reproduce with a java client from the ActiveMQ examples dir.\n\n\nRegards,\nChris\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: failover: consumer does not always restart properly after reconnect\n\nDescription:\nHi,\n\nWhile testing AMQCPP-355, we came across a problem when resuming from a broker restart. Resuming seems to be erratic when the broker shutdown happens during message processing in an onMessage callback.\n\na) if a message is ack'ed while the broker is still down, the same message will be redelivered after connection resumes. The command tracing does not show the sending of the 1st acknowledgment. \nb) if a message is ack'ed after the broker is brought back (connection resumed OK), the command tracing shows that the ack is send, but on the broker side we see an warning message:\n\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:hostname-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:hostname-58084-1303317597544-0:0:0:0:0,\ndestination = queue://test, transactionId = null, messageCount = 1, poisonCause = null}\n\nWe can't see any redelivery message in the command trace and subsequent messages are not delivered either. The consumer is nevertheless shown on broker admin console. \n\nWhen the connection is resumed, we see that the prefetch size is set to 0 in the consumerInfo message.\n\nc) resuming works fine, if the message is not in process when the shutdown happens.\n\nCases a+b work fine, when we tried to reproduce with a java client from the ActiveMQ examples dir.\n\n\nRegards,\nChris\n\nComments:\n", "classification": "Classify the issue 'failover: consumer does not always restart properly after reconnect' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-363?\nA: Hi,\n\nWhile testing AMQCPP-355, we came across a problem when resuming from a broker restart. Resuming seems to be erratic when the broker shutdown happens during message processing in an onMessage callback.\n\na) if a message is ack'ed while the broker is still down, the same message will be redelivered after connection resumes. The command tracing does not show the sending of the 1st acknowledgment"}}
{"issue_key": "AMQCPP-362", "project": "AMQCPP", "title": "Make Session and MessageConsumer both Startable and Stoppable in the CMS API", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2011-04-16T15:27:33.000+0000", "updated": "2011-04-16T15:49:56.000+0000", "description": "In order to allow users to more safely shut down CMS resources we should add the startable and stoppable interface to Session and MessageConsumer in CMS so that the user doesn't need to cast inner types.  The will be marked as optional methods in CMS and can throw cms::UnsupportedOperation exceptions if not implemented.", "comments": [], "text": "Make Session and MessageConsumer both Startable and Stoppable in the CMS API\n\nDescription:\nIn order to allow users to more safely shut down CMS resources we should add the startable and stoppable interface to Session and MessageConsumer in CMS so that the user doesn't need to cast inner types.  The will be marked as optional methods in CMS and can throw cms::UnsupportedOperation exceptions if not implemented.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Make Session and MessageConsumer both Startable and Stoppable in the CMS API\n\nDescription:\nIn order to allow users to more safely shut down CMS resources we should add the startable and stoppable interface to Session and MessageConsumer in CMS so that the user doesn't need to cast inner types.  The will be marked as optional methods in CMS and can throw cms::UnsupportedOperation exceptions if not implemented.\n\nComments:\n", "classification": "Classify the issue 'Make Session and MessageConsumer both Startable and Stoppable in the CMS API' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-362?\nA: In order to allow users to more safely shut down CMS resources we should add the startable and stoppable interface to Session and MessageConsumer in CMS so that the user doesn't need to cast inner types.  The will be marked as optional methods in CMS and can throw cms::UnsupportedOperation exceptions if not implemented."}}
{"issue_key": "AMQCPP-361", "project": "AMQCPP", "title": "Destroying a consumer may cause a crash", "status": "Resolved", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-14T11:32:09.000+0000", "updated": "2011-07-02T23:55:59.000+0000", "description": "ActiveMQSessionExecutor::dispatch gets a consumer and calls consumer's dispatch method without holding any locks in between.  This leaves a window when a consumer can be no longer valid on a dispatch call causing a crash.\n\nSince this is a timing issue it is hard to demonstrate as such.  If one adds let's say one second sleep in ActiveMQSessionExecutor::dispatch before the call to the consumer->dispatch, and destroys a consumer on a destination which has messages incoming will likely crash the application.", "comments": [], "text": "Destroying a consumer may cause a crash\n\nDescription:\nActiveMQSessionExecutor::dispatch gets a consumer and calls consumer's dispatch method without holding any locks in between.  This leaves a window when a consumer can be no longer valid on a dispatch call causing a crash.\n\nSince this is a timing issue it is hard to demonstrate as such.  If one adds let's say one second sleep in ActiveMQSessionExecutor::dispatch before the call to the consumer->dispatch, and destroys a consumer on a destination which has messages incoming will likely crash the application.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Destroying a consumer may cause a crash\n\nDescription:\nActiveMQSessionExecutor::dispatch gets a consumer and calls consumer's dispatch method without holding any locks in between.  This leaves a window when a consumer can be no longer valid on a dispatch call causing a crash.\n\nSince this is a timing issue it is hard to demonstrate as such.  If one adds let's say one second sleep in ActiveMQSessionExecutor::dispatch before the call to the consumer->dispatch, and destroys a consumer on a destination which has messages incoming will likely crash the application.\n\nComments:\n", "classification": "Classify the issue 'Destroying a consumer may cause a crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-361?\nA: ActiveMQSessionExecutor::dispatch gets a consumer and calls consumer's dispatch method without holding any locks in between.  This leaves a window when a consumer can be no longer valid on a dispatch call causing a crash.\n\nSince this is a timing issue it is hard to demonstrate as such.  If one adds let's say one second sleep in ActiveMQSessionExecutor::dispatch before the call to the consumer->dis"}}
{"issue_key": "AMQCPP-360", "project": "AMQCPP", "title": "C Runtime Error when a consumer is created for Advisory messages on \"ActiveMQ.Advisory.Connection\" topic", "status": "Resolved", "reporter": "Suneel", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-01T12:07:32.000+0000", "updated": "2011-04-04T16:30:13.000+0000", "description": "In order to reproduce this issue, create a consumer with a destiantion \"ActiveMQ.Advisory.Connection\" and set up MessageLister for this consumer. When client application starts to register this consumer, it throws \"C Runtime Error\". This is happening only of \"ActiveMQ.Advisory.Connection\" topic. \nActiveMQ 5.4.2, ActiveMQ-CPP 3.2.5 are used to produce this issue.", "comments": [], "text": "C Runtime Error when a consumer is created for Advisory messages on \"ActiveMQ.Advisory.Connection\" topic\n\nDescription:\nIn order to reproduce this issue, create a consumer with a destiantion \"ActiveMQ.Advisory.Connection\" and set up MessageLister for this consumer. When client application starts to register this consumer, it throws \"C Runtime Error\". This is happening only of \"ActiveMQ.Advisory.Connection\" topic. \nActiveMQ 5.4.2, ActiveMQ-CPP 3.2.5 are used to produce this issue.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: C Runtime Error when a consumer is created for Advisory messages on \"ActiveMQ.Advisory.Connection\" topic\n\nDescription:\nIn order to reproduce this issue, create a consumer with a destiantion \"ActiveMQ.Advisory.Connection\" and set up MessageLister for this consumer. When client application starts to register this consumer, it throws \"C Runtime Error\". This is happening only of \"ActiveMQ.Advisory.Connection\" topic. \nActiveMQ 5.4.2, ActiveMQ-CPP 3.2.5 are used to produce this issue.\n\nComments:\n", "classification": "Classify the issue 'C Runtime Error when a consumer is created for Advisory messages on \"ActiveMQ.Advisory.Connection\" topic' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-360?\nA: In order to reproduce this issue, create a consumer with a destiantion \"ActiveMQ.Advisory.Connection\" and set up MessageLister for this consumer. When client application starts to register this consumer, it throws \"C Runtime Error\". This is happening only of \"ActiveMQ.Advisory.Connection\" topic. \nActiveMQ 5.4.2, ActiveMQ-CPP 3.2.5 are used to produce this issue."}}
{"issue_key": "AMQCPP-359", "project": "AMQCPP", "title": "ActiveMQBytesMessage should throw IndexOutOfBoundsException is array length is negative for readBytes method", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-03-31T15:34:47.000+0000", "updated": "2011-03-31T17:56:29.000+0000", "description": "The method readBytes in ActiveMQBytesMessage is not throwing an exception when the size parameter for the provided array of bytes is negative.", "comments": [], "text": "ActiveMQBytesMessage should throw IndexOutOfBoundsException is array length is negative for readBytes method\n\nDescription:\nThe method readBytes in ActiveMQBytesMessage is not throwing an exception when the size parameter for the provided array of bytes is negative.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQBytesMessage should throw IndexOutOfBoundsException is array length is negative for readBytes method\n\nDescription:\nThe method readBytes in ActiveMQBytesMessage is not throwing an exception when the size parameter for the provided array of bytes is negative.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQBytesMessage should throw IndexOutOfBoundsException is array length is negative for readBytes method' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-359?\nA: The method readBytes in ActiveMQBytesMessage is not throwing an exception when the size parameter for the provided array of bytes is negative."}}
{"issue_key": "AMQCPP-358", "project": "AMQCPP", "title": "FailoverTransport can peg CPU when connection attempts exceeds max and its waiting to be closed", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-03-29T23:02:17.000+0000", "updated": "2011-03-30T19:27:00.000+0000", "description": "While waiting for its parent to close it the FailoverTransport can peg the CPU in the case where a limit is set on reconnect attempts.", "comments": [], "text": "FailoverTransport can peg CPU when connection attempts exceeds max and its waiting to be closed\n\nDescription:\nWhile waiting for its parent to close it the FailoverTransport can peg the CPU in the case where a limit is set on reconnect attempts.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: FailoverTransport can peg CPU when connection attempts exceeds max and its waiting to be closed\n\nDescription:\nWhile waiting for its parent to close it the FailoverTransport can peg the CPU in the case where a limit is set on reconnect attempts.\n\nComments:\n", "classification": "Classify the issue 'FailoverTransport can peg CPU when connection attempts exceeds max and its waiting to be closed' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-358?\nA: While waiting for its parent to close it the FailoverTransport can peg the CPU in the case where a limit is set on reconnect attempts."}}
{"issue_key": "AMQCPP-357", "project": "AMQCPP", "title": "Typo in CMS_BytesMessage.cpp", "status": "Resolved", "reporter": "Steven A. Falco", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-03-05T16:55:27.000+0000", "updated": "2011-03-05T18:38:45.000+0000", "description": "There is a typo in src/main/c/CMS_BytesMessage.cpp from the activemq-c project.\n\nReplace\n\nif( readCount != -1 ) {\n\nwith\n\nif( readCount == -1 ) {\n\nAs it is now, the function always returns error 14.", "comments": [], "text": "Typo in CMS_BytesMessage.cpp\n\nDescription:\nThere is a typo in src/main/c/CMS_BytesMessage.cpp from the activemq-c project.\n\nReplace\n\nif( readCount != -1 ) {\n\nwith\n\nif( readCount == -1 ) {\n\nAs it is now, the function always returns error 14.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Typo in CMS_BytesMessage.cpp\n\nDescription:\nThere is a typo in src/main/c/CMS_BytesMessage.cpp from the activemq-c project.\n\nReplace\n\nif( readCount != -1 ) {\n\nwith\n\nif( readCount == -1 ) {\n\nAs it is now, the function always returns error 14.\n\nComments:\n", "classification": "Classify the issue 'Typo in CMS_BytesMessage.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-357?\nA: There is a typo in src/main/c/CMS_BytesMessage.cpp from the activemq-c project.\n\nReplace\n\nif( readCount != -1 ) {\n\nwith\n\nif( readCount == -1 ) {\n\nAs it is now, the function always returns error 14."}}
{"issue_key": "AMQCPP-356", "project": "AMQCPP", "title": "Auto-Acknowledge consumer using MessageListener freezes on destructor", "status": "Resolved", "reporter": "Henrique Magarotto", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-03-04T22:16:07.000+0000", "updated": "2011-03-17T18:19:35.000+0000", "description": "Consumer freezes on destructor.\n\nMaybe related to issue AMQCPP-355.\nFirst reported by Ãscar Pernas Plaza (http://activemq.2283324.n4.nabble.com/AMQCPP-Closing-consumer-freezes-if-broker-is-stopped-while-is-consuming-tt3319403.html).\n\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Apply simple change in test code (attached in AMQCPP-354):\n@@ -440,6 +440,7 @@\n             if(_delay) {\n                 std::cout<<\"Starting delay...\"<<std::endl;\n                 stopCheck(_delay);\n+                std::cout<<\"Delay finish...\"<<std::endl;\n             }\n \n         } catch (CMSException& e) {\n@@ -561,7 +562,7 @@\n \n     void loadEndPoins() {\n         for(int i=0; i<_consumer;i++) {\n-            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener) );\n+            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener,false) );\n         }\n         for(int i=0; i<_producer;i++) {\n             _endPointList.push_back( new Producer(&_poolManager,\"TEST.FOO\",_delay,_numMessages) );\n\n2- Start ActiveMQ\n3- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n4- Send one message './activemqTest -p1'\n5- Wait consumer 'Starting delay'\n6- Stop ActiveMQ\n7- Wait consumer delay finishes 'Delay finish'\n8- Try kill consumer\n9- Freezes\n\nBACKTRACE:\n\nThread 1:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008bfb5d in pthread_join (threadid=3061021552, thread_return=0xbfbff07c) at pthread_join.c:89\n#2  0x0132a3c0 in decaf::lang::Thread::join (this=0x9be0574) at decaf/lang/Thread.cpp:421\n#3  0x0804ca15 in AppTest::joinEndPoins (this=0xbfbff104) at main.cpp:587\n#4  0x0804c69c in AppTest::run (this=0xbfbff104) at main.cpp:556\n#5  0x0804a33c in main (argc=4, argv=0xbfbff224) at main.cpp:634\n\nThread 2:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c3015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x004ed9dd in __pthread_cond_wait (cond=0x9bd6e38, mutex=0x9bd6e08) at forward.c:139\n#3  0x012f86a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9bd6e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x01369353 in decaf::util::concurrent::Mutex::wait (this=0x9bd6d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x010949c5 in activemq::threads::CompositeTaskRunner::run (this=0x9bd6d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd6e90) at decaf/lang/Thread.cpp:135\n#7  0x0132a847 in threadWorker (arg=0x9bd6e90) at decaf/lang/Thread.cpp:188\n#8  0x008be96e in start_thread (arg=0xb7739b70) at pthread_create.c:300\n#9  0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x0105d770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11d8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x9be11d8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f37fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x01026102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x0104715c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9be0b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x01010543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9bd7210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x0109bb34 in activemq::transport::TransportFilter::transportInterrupted (this=0x9bd71c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x010b07ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9bd6a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x010bc06c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9bd6878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x01099b13 in activemq::transport::IOTransport::fire (this=0x9bd88e8, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x0109a3bf in activemq::transport::IOTransport::run (this=0x9bd88e8) at activemq/transport/IOTransport.cpp:246\n#23 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd8fe8) at decaf/lang/Thread.cpp:135\n#24 0x0132a847 in threadWorker (arg=0x9bd8fe8) at decaf/lang/Thread.cpp:188\n#25 0x008be96e in start_thread (arg=0xb6f38b70) at pthread_create.c:300\n#26 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01036830 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11e0)\n    at ./decaf/util/StlQueue.h:253\n#8  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6737064) at decaf/util/concurrent/Lock.cpp:54\n#9  0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#10 0x0105c507 in activemq::core::MessageDispatchChannel::clear (this=0x9be11d8) at activemq/core/MessageDispatchChannel.cpp:143\n#11 0x0102ec37 in activemq::core::ActiveMQConsumer::doClose (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:335\n#12 0x0102fb00 in activemq::core::ActiveMQConsumer::close (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:309\n#13 0x01030390 in ~ActiveMQConsumer (this=0x9be11a0, __in_chrg=<value optimized out>) at activemq/core/ActiveMQConsumer.cpp:261\n#14 0x0804c276 in Consumer::cleanup (this=0x9be0570) at main.cpp:469\n#15 0x0804bcdd in Consumer::run (this=0x9be0570) at main.cpp:394\n#16 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be05b0) at decaf/lang/Thread.cpp:135\n#17 0x0132a847 in threadWorker (arg=0x9be05b0) at decaf/lang/Thread.cpp:188\n#18 0x008be96e in start_thread (arg=0xb6737b70) at pthread_create.c:300\n#19 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9bd65e0) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9bd65e0) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9bd65e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9bd6a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f35ea0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x01368c08 in Lock (this=0xfffffe00, object=0x9bd65e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x010b38fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9bd6a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x0109ff9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x9bd71c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x010093be in activemq::core::ActiveMQConnection::oneway (this=0x9bd7210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x01048a4f in activemq::core::ActiveMQSession::oneway (this=0x9be0b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x01030df4 in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x9be11a0, message=..., messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:642\n#14 0x01031743 in activemq::core::ActiveMQConsumer::dispatch (this=0x9be11a0, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1021\n#15 0x010555c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9be0dc8, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#16 0x01055993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9be0dc8) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#17 0x010987f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9be1480) at activemq/threads/DedicatedTaskRunner.cpp:111\n#18 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be0ad8) at decaf/lang/Thread.cpp:135\n#19 0x0132a847 in threadWorker (arg=0x9be0ad8) at decaf/lang/Thread.cpp:188\n#20 0x008be96e in start_thread (arg=0xb5f36b70) at pthread_create.c:300\n#21 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130", "comments": [], "text": "Auto-Acknowledge consumer using MessageListener freezes on destructor\n\nDescription:\nConsumer freezes on destructor.\n\nMaybe related to issue AMQCPP-355.\nFirst reported by Ãscar Pernas Plaza (http://activemq.2283324.n4.nabble.com/AMQCPP-Closing-consumer-freezes-if-broker-is-stopped-while-is-consuming-tt3319403.html).\n\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Apply simple change in test code (attached in AMQCPP-354):\n@@ -440,6 +440,7 @@\n             if(_delay) {\n                 std::cout<<\"Starting delay...\"<<std::endl;\n                 stopCheck(_delay);\n+                std::cout<<\"Delay finish...\"<<std::endl;\n             }\n \n         } catch (CMSException& e) {\n@@ -561,7 +562,7 @@\n \n     void loadEndPoins() {\n         for(int i=0; i<_consumer;i++) {\n-            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener) );\n+            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener,false) );\n         }\n         for(int i=0; i<_producer;i++) {\n             _endPointList.push_back( new Producer(&_poolManager,\"TEST.FOO\",_delay,_numMessages) );\n\n2- Start ActiveMQ\n3- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n4- Send one message './activemqTest -p1'\n5- Wait consumer 'Starting delay'\n6- Stop ActiveMQ\n7- Wait consumer delay finishes 'Delay finish'\n8- Try kill consumer\n9- Freezes\n\nBACKTRACE:\n\nThread 1:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008bfb5d in pthread_join (threadid=3061021552, thread_return=0xbfbff07c) at pthread_join.c:89\n#2  0x0132a3c0 in decaf::lang::Thread::join (this=0x9be0574) at decaf/lang/Thread.cpp:421\n#3  0x0804ca15 in AppTest::joinEndPoins (this=0xbfbff104) at main.cpp:587\n#4  0x0804c69c in AppTest::run (this=0xbfbff104) at main.cpp:556\n#5  0x0804a33c in main (argc=4, argv=0xbfbff224) at main.cpp:634\n\nThread 2:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c3015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x004ed9dd in __pthread_cond_wait (cond=0x9bd6e38, mutex=0x9bd6e08) at forward.c:139\n#3  0x012f86a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9bd6e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x01369353 in decaf::util::concurrent::Mutex::wait (this=0x9bd6d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x010949c5 in activemq::threads::CompositeTaskRunner::run (this=0x9bd6d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd6e90) at decaf/lang/Thread.cpp:135\n#7  0x0132a847 in threadWorker (arg=0x9bd6e90) at decaf/lang/Thread.cpp:188\n#8  0x008be96e in start_thread (arg=0xb7739b70) at pthread_create.c:300\n#9  0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x0105d770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11d8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x9be11d8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f37fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x01026102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x0104715c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9be0b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x01010543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9bd7210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x0109bb34 in activemq::transport::TransportFilter::transportInterrupted (this=0x9bd71c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x010b07ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9bd6a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x010bc06c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9bd6878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x01099b13 in activemq::transport::IOTransport::fire (this=0x9bd88e8, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x0109a3bf in activemq::transport::IOTransport::run (this=0x9bd88e8) at activemq/transport/IOTransport.cpp:246\n#23 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd8fe8) at decaf/lang/Thread.cpp:135\n#24 0x0132a847 in threadWorker (arg=0x9bd8fe8) at decaf/lang/Thread.cpp:188\n#25 0x008be96e in start_thread (arg=0xb6f38b70) at pthread_create.c:300\n#26 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01036830 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11e0)\n    at ./decaf/util/StlQueue.h:253\n#8  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6737064) at decaf/util/concurrent/Lock.cpp:54\n#9  0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#10 0x0105c507 in activemq::core::MessageDispatchChannel::clear (this=0x9be11d8) at activemq/core/MessageDispatchChannel.cpp:143\n#11 0x0102ec37 in activemq::core::ActiveMQConsumer::doClose (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:335\n#12 0x0102fb00 in activemq::core::ActiveMQConsumer::close (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:309\n#13 0x01030390 in ~ActiveMQConsumer (this=0x9be11a0, __in_chrg=<value optimized out>) at activemq/core/ActiveMQConsumer.cpp:261\n#14 0x0804c276 in Consumer::cleanup (this=0x9be0570) at main.cpp:469\n#15 0x0804bcdd in Consumer::run (this=0x9be0570) at main.cpp:394\n#16 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be05b0) at decaf/lang/Thread.cpp:135\n#17 0x0132a847 in threadWorker (arg=0x9be05b0) at decaf/lang/Thread.cpp:188\n#18 0x008be96e in start_thread (arg=0xb6737b70) at pthread_create.c:300\n#19 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9bd65e0) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9bd65e0) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9bd65e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9bd6a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f35ea0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x01368c08 in Lock (this=0xfffffe00, object=0x9bd65e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x010b38fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9bd6a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x0109ff9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x9bd71c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x010093be in activemq::core::ActiveMQConnection::oneway (this=0x9bd7210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x01048a4f in activemq::core::ActiveMQSession::oneway (this=0x9be0b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x01030df4 in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x9be11a0, message=..., messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:642\n#14 0x01031743 in activemq::core::ActiveMQConsumer::dispatch (this=0x9be11a0, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1021\n#15 0x010555c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9be0dc8, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#16 0x01055993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9be0dc8) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#17 0x010987f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9be1480) at activemq/threads/DedicatedTaskRunner.cpp:111\n#18 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be0ad8) at decaf/lang/Thread.cpp:135\n#19 0x0132a847 in threadWorker (arg=0x9be0ad8) at decaf/lang/Thread.cpp:188\n#20 0x008be96e in start_thread (arg=0xb5f36b70) at pthread_create.c:300\n#21 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Auto-Acknowledge consumer using MessageListener freezes on destructor\n\nDescription:\nConsumer freezes on destructor.\n\nMaybe related to issue AMQCPP-355.\nFirst reported by Ãscar Pernas Plaza (http://activemq.2283324.n4.nabble.com/AMQCPP-Closing-consumer-freezes-if-broker-is-stopped-while-is-consuming-tt3319403.html).\n\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Apply simple change in test code (attached in AMQCPP-354):\n@@ -440,6 +440,7 @@\n             if(_delay) {\n                 std::cout<<\"Starting delay...\"<<std::endl;\n                 stopCheck(_delay);\n+                std::cout<<\"Delay finish...\"<<std::endl;\n             }\n \n         } catch (CMSException& e) {\n@@ -561,7 +562,7 @@\n \n     void loadEndPoins() {\n         for(int i=0; i<_consumer;i++) {\n-            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener) );\n+            _endPointList.push_back( new Consumer(&_poolManager,\"TEST.FOO\",_delay,_useListener,false) );\n         }\n         for(int i=0; i<_producer;i++) {\n             _endPointList.push_back( new Producer(&_poolManager,\"TEST.FOO\",_delay,_numMessages) );\n\n2- Start ActiveMQ\n3- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n4- Send one message './activemqTest -p1'\n5- Wait consumer 'Starting delay'\n6- Stop ActiveMQ\n7- Wait consumer delay finishes 'Delay finish'\n8- Try kill consumer\n9- Freezes\n\nBACKTRACE:\n\nThread 1:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008bfb5d in pthread_join (threadid=3061021552, thread_return=0xbfbff07c) at pthread_join.c:89\n#2  0x0132a3c0 in decaf::lang::Thread::join (this=0x9be0574) at decaf/lang/Thread.cpp:421\n#3  0x0804ca15 in AppTest::joinEndPoins (this=0xbfbff104) at main.cpp:587\n#4  0x0804c69c in AppTest::run (this=0xbfbff104) at main.cpp:556\n#5  0x0804a33c in main (argc=4, argv=0xbfbff224) at main.cpp:634\n\nThread 2:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c3015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x004ed9dd in __pthread_cond_wait (cond=0x9bd6e38, mutex=0x9bd6e08) at forward.c:139\n#3  0x012f86a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9bd6e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x01369353 in decaf::util::concurrent::Mutex::wait (this=0x9bd6d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x010949c5 in activemq::threads::CompositeTaskRunner::run (this=0x9bd6d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd6e90) at decaf/lang/Thread.cpp:135\n#7  0x0132a847 in threadWorker (arg=0x9bd6e90) at decaf/lang/Thread.cpp:188\n#8  0x008be96e in start_thread (arg=0xb7739b70) at pthread_create.c:300\n#9  0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x0105d770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11d8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x9be11d8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f37fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x01026102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x0104715c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9be0b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x01010543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9bd7210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x0109bb34 in activemq::transport::TransportFilter::transportInterrupted (this=0x9bd71c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x010b07ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9bd6a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x010bc06c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9bd6878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8ec8, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x0109bc0b in activemq::transport::TransportFilter::fire (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x0109bc64 in activemq::transport::TransportFilter::onException (this=0x9bd8938, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x01099b13 in activemq::transport::IOTransport::fire (this=0x9bd88e8, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x0109a3bf in activemq::transport::IOTransport::run (this=0x9bd88e8) at activemq/transport/IOTransport.cpp:246\n#23 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9bd8fe8) at decaf/lang/Thread.cpp:135\n#24 0x0132a847 in threadWorker (arg=0x9bd8fe8) at decaf/lang/Thread.cpp:188\n#25 0x008be96e in start_thread (arg=0xb6f38b70) at pthread_create.c:300\n#26 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9be12d8) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9be12d8) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9be12d8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9be11ec) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01036830 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x9be11e0)\n    at ./decaf/util/StlQueue.h:253\n#8  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb6737064) at decaf/util/concurrent/Lock.cpp:54\n#9  0x01368c08 in Lock (this=0xfffffe00, object=0x9be12d8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#10 0x0105c507 in activemq::core::MessageDispatchChannel::clear (this=0x9be11d8) at activemq/core/MessageDispatchChannel.cpp:143\n#11 0x0102ec37 in activemq::core::ActiveMQConsumer::doClose (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:335\n#12 0x0102fb00 in activemq::core::ActiveMQConsumer::close (this=0x9be11a0) at activemq/core/ActiveMQConsumer.cpp:309\n#13 0x01030390 in ~ActiveMQConsumer (this=0x9be11a0, __in_chrg=<value optimized out>) at activemq/core/ActiveMQConsumer.cpp:261\n#14 0x0804c276 in Consumer::cleanup (this=0x9be0570) at main.cpp:469\n#15 0x0804bcdd in Consumer::run (this=0x9be0570) at main.cpp:394\n#16 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be05b0) at decaf/lang/Thread.cpp:135\n#17 0x0132a847 in threadWorker (arg=0x9be05b0) at decaf/lang/Thread.cpp:188\n#18 0x008be96e in start_thread (arg=0xb6737b70) at pthread_create.c:300\n#19 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x0079b422 in __kernel_vsyscall ()\n#1  0x008c5af9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x008c113b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x008c0f61 in __pthread_mutex_lock (mutex=0x9bd65e0) at pthread_mutex_lock.c:61\n#4  0x004edba6 in pthread_mutex_lock (mutex=0x9bd65e0) at forward.c:182\n#5  0x012f8aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x9bd65e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x01369412 in decaf::util::concurrent::Mutex::lock (this=0x9bd6a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x01368ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f35ea0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x01368c08 in Lock (this=0xfffffe00, object=0x9bd65e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x010b38fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9bd6a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x0109ff9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x9bd71c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x010093be in activemq::core::ActiveMQConnection::oneway (this=0x9bd7210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x01048a4f in activemq::core::ActiveMQSession::oneway (this=0x9be0b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x01030df4 in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x9be11a0, message=..., messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:642\n#14 0x01031743 in activemq::core::ActiveMQConsumer::dispatch (this=0x9be11a0, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1021\n#15 0x010555c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9be0dc8, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#16 0x01055993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9be0dc8) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#17 0x010987f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9be1480) at activemq/threads/DedicatedTaskRunner.cpp:111\n#18 0x0132bcf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9be0ad8) at decaf/lang/Thread.cpp:135\n#19 0x0132a847 in threadWorker (arg=0x9be0ad8) at decaf/lang/Thread.cpp:188\n#20 0x008be96e in start_thread (arg=0xb5f36b70) at pthread_create.c:300\n#21 0x004e0a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\n\nComments:\n", "classification": "Classify the issue 'Auto-Acknowledge consumer using MessageListener freezes on destructor' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-356?\nA: Consumer freezes on destructor.\n\nMaybe related to issue AMQCPP-355.\nFirst reported by Ãscar Pernas Plaza (http://activemq.2283324.n4.nabble.com/AMQCPP-Closing-consumer-freezes-if-broker-is-stopped-while-is-consuming-tt3319403.html).\n\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Apply simple change in test code (attached in AMQCPP-354):\n@@ -440,6 +440,7 @@\n             if(_d"}}
{"issue_key": "AMQCPP-355", "project": "AMQCPP", "title": "Transactional consumer using MessageListener freezes on commit", "status": "Resolved", "reporter": "Henrique Magarotto", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-03-04T22:05:22.000+0000", "updated": "2011-04-14T13:19:52.000+0000", "description": "How to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Start ActiveMQ\n2- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n3- Send one message './activemqTest -p1'\n4- Wait consumer 'Starting delay'\n5- Stop ActiveMQ\n6- Consumer will try commit\n8- Freezes\n\nBACKTRACE:\n\nThread 1:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x00468b5d in pthread_join (threadid=3061414768, thread_return=0xbf951e8c) at pthread_join.c:89\n#2  0x00be23c0 in decaf::lang::Thread::join (this=0x9551574) at decaf/lang/Thread.cpp:421\n#3  0x0804c9f1 in AppTest::joinEndPoins (this=0xbf951f14) at main.cpp:586\n#4  0x0804c678 in AppTest::run (this=0xbf951f14) at main.cpp:555\n#5  0x0804a33c in main (argc=4, argv=0xbf952034) at main.cpp:633\n\nThread 2:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x9547e38, mutex=0x9547e08) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9547e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9547d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x0094c9c5 in activemq::threads::CompositeTaskRunner::run (this=0x9547d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9547e90) at decaf/lang/Thread.cpp:135\n#7  0x00be2847 in threadWorker (arg=0x9547e90) at decaf/lang/Thread.cpp:188\n#8  0x0046796e in start_thread (arg=0xb7799b70) at pthread_create.c:300\n#9  0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95523a8) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95523a8) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95523a8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x95522bc) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00915770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x95522a8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x95522a8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f97fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x00c20c08 in Lock (this=0xfffffe00, object=0x95523a8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x008de102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x008ff15c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x008c8543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9548210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x00953b34 in activemq::transport::TransportFilter::transportInterrupted (this=0x95481c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x009687ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9547a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x0097406c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9547878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x00951b13 in activemq::transport::IOTransport::fire (this=0x95497a0, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x009523bf in activemq::transport::IOTransport::run (this=0x95497a0) at activemq/transport/IOTransport.cpp:246\n#23 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9549ea0) at decaf/lang/Thread.cpp:135\n#24 0x00be2847 in threadWorker (arg=0x9549ea0) at decaf/lang/Thread.cpp:188\n#25 0x0046796e in start_thread (arg=0xb6f98b70) at pthread_create.c:300\n#26 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x95516c8, mutex=0x9551698) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x95516c8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9551584) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x00c2029a in decaf::util::concurrent::CountDownLatch::await (this=0x955157c) at decaf/util/concurrent/CountDownLatch.cpp:56\n#6  0x0804af84 in JMSEndPointThread::stopCheck (this=0x9551574, timeOut=-1) at main.cpp:226\n#7  0x0804bb46 in Consumer::run (this=0x9551570) at main.cpp:379\n#8  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x95515b0) at decaf/lang/Thread.cpp:135\n#9  0x00be2847 in threadWorker (arg=0x95515b0) at decaf/lang/Thread.cpp:188\n#10 0x0046796e in start_thread (arg=0xb6797b70) at pthread_create.c:300\n#11 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95475e0) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95475e0) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95475e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x9547a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f95ce0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x00c20c08 in Lock (this=0xfffffe00, object=0x95475e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x0096b8fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9547a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x00957f9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x95481c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x008c13be in activemq::core::ActiveMQConnection::oneway (this=0x9548210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x00900a4f in activemq::core::ActiveMQSession::oneway (this=0x9551b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x008e5a1c in activemq::core::ActiveMQConsumer::acknowledge (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:860\n#14 0x008ef885 in activemq::core::TransactionSynhcronization::beforeEnd (this=0x95529e8) at activemq/core/ActiveMQConsumer.cpp:85\n#15 0x00910588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:192\n#16 0x00910d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:127\n#17 0x008fe460 in activemq::core::ActiveMQSession::commit (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:189\n#18 0x007ec1a0 in activemq::cmsutil::PooledSession::commit (this=0x9551f38) at activemq/cmsutil/PooledSession.h:87\n#19 0x0804c0fb in Consumer::onMessage (this=0x9551570, message=0x9552ec0) at main.cpp:455\n#20 0x008e972f in activemq::core::ActiveMQConsumer::dispatch (this=0x9552270, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1018\n#21 0x0090d5c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9551e78, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#22 0x0090d993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9551e78) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#23 0x009507f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9552550) at activemq/threads/DedicatedTaskRunner.cpp:111\n#24 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9551ad8) at decaf/lang/Thread.cpp:135\n#25 0x00be2847 in threadWorker (arg=0x9551ad8) at decaf/lang/Thread.cpp:188\n#26 0x0046796e in start_thread (arg=0xb5f96b70) at pthread_create.c:300\n#27 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130", "comments": [], "text": "Transactional consumer using MessageListener freezes on commit\n\nDescription:\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Start ActiveMQ\n2- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n3- Send one message './activemqTest -p1'\n4- Wait consumer 'Starting delay'\n5- Stop ActiveMQ\n6- Consumer will try commit\n8- Freezes\n\nBACKTRACE:\n\nThread 1:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x00468b5d in pthread_join (threadid=3061414768, thread_return=0xbf951e8c) at pthread_join.c:89\n#2  0x00be23c0 in decaf::lang::Thread::join (this=0x9551574) at decaf/lang/Thread.cpp:421\n#3  0x0804c9f1 in AppTest::joinEndPoins (this=0xbf951f14) at main.cpp:586\n#4  0x0804c678 in AppTest::run (this=0xbf951f14) at main.cpp:555\n#5  0x0804a33c in main (argc=4, argv=0xbf952034) at main.cpp:633\n\nThread 2:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x9547e38, mutex=0x9547e08) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9547e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9547d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x0094c9c5 in activemq::threads::CompositeTaskRunner::run (this=0x9547d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9547e90) at decaf/lang/Thread.cpp:135\n#7  0x00be2847 in threadWorker (arg=0x9547e90) at decaf/lang/Thread.cpp:188\n#8  0x0046796e in start_thread (arg=0xb7799b70) at pthread_create.c:300\n#9  0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95523a8) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95523a8) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95523a8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x95522bc) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00915770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x95522a8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x95522a8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f97fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x00c20c08 in Lock (this=0xfffffe00, object=0x95523a8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x008de102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x008ff15c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x008c8543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9548210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x00953b34 in activemq::transport::TransportFilter::transportInterrupted (this=0x95481c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x009687ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9547a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x0097406c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9547878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x00951b13 in activemq::transport::IOTransport::fire (this=0x95497a0, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x009523bf in activemq::transport::IOTransport::run (this=0x95497a0) at activemq/transport/IOTransport.cpp:246\n#23 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9549ea0) at decaf/lang/Thread.cpp:135\n#24 0x00be2847 in threadWorker (arg=0x9549ea0) at decaf/lang/Thread.cpp:188\n#25 0x0046796e in start_thread (arg=0xb6f98b70) at pthread_create.c:300\n#26 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x95516c8, mutex=0x9551698) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x95516c8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9551584) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x00c2029a in decaf::util::concurrent::CountDownLatch::await (this=0x955157c) at decaf/util/concurrent/CountDownLatch.cpp:56\n#6  0x0804af84 in JMSEndPointThread::stopCheck (this=0x9551574, timeOut=-1) at main.cpp:226\n#7  0x0804bb46 in Consumer::run (this=0x9551570) at main.cpp:379\n#8  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x95515b0) at decaf/lang/Thread.cpp:135\n#9  0x00be2847 in threadWorker (arg=0x95515b0) at decaf/lang/Thread.cpp:188\n#10 0x0046796e in start_thread (arg=0xb6797b70) at pthread_create.c:300\n#11 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95475e0) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95475e0) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95475e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x9547a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f95ce0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x00c20c08 in Lock (this=0xfffffe00, object=0x95475e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x0096b8fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9547a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x00957f9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x95481c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x008c13be in activemq::core::ActiveMQConnection::oneway (this=0x9548210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x00900a4f in activemq::core::ActiveMQSession::oneway (this=0x9551b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x008e5a1c in activemq::core::ActiveMQConsumer::acknowledge (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:860\n#14 0x008ef885 in activemq::core::TransactionSynhcronization::beforeEnd (this=0x95529e8) at activemq/core/ActiveMQConsumer.cpp:85\n#15 0x00910588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:192\n#16 0x00910d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:127\n#17 0x008fe460 in activemq::core::ActiveMQSession::commit (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:189\n#18 0x007ec1a0 in activemq::cmsutil::PooledSession::commit (this=0x9551f38) at activemq/cmsutil/PooledSession.h:87\n#19 0x0804c0fb in Consumer::onMessage (this=0x9551570, message=0x9552ec0) at main.cpp:455\n#20 0x008e972f in activemq::core::ActiveMQConsumer::dispatch (this=0x9552270, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1018\n#21 0x0090d5c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9551e78, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#22 0x0090d993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9551e78) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#23 0x009507f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9552550) at activemq/threads/DedicatedTaskRunner.cpp:111\n#24 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9551ad8) at decaf/lang/Thread.cpp:135\n#25 0x00be2847 in threadWorker (arg=0x9551ad8) at decaf/lang/Thread.cpp:188\n#26 0x0046796e in start_thread (arg=0xb5f96b70) at pthread_create.c:300\n#27 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Transactional consumer using MessageListener freezes on commit\n\nDescription:\nHow to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Start ActiveMQ\n2- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n3- Send one message './activemqTest -p1'\n4- Wait consumer 'Starting delay'\n5- Stop ActiveMQ\n6- Consumer will try commit\n8- Freezes\n\nBACKTRACE:\n\nThread 1:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x00468b5d in pthread_join (threadid=3061414768, thread_return=0xbf951e8c) at pthread_join.c:89\n#2  0x00be23c0 in decaf::lang::Thread::join (this=0x9551574) at decaf/lang/Thread.cpp:421\n#3  0x0804c9f1 in AppTest::joinEndPoins (this=0xbf951f14) at main.cpp:586\n#4  0x0804c678 in AppTest::run (this=0xbf951f14) at main.cpp:555\n#5  0x0804a33c in main (argc=4, argv=0xbf952034) at main.cpp:633\n\nThread 2:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x9547e38, mutex=0x9547e08) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x9547e38) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9547d6c) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x0094c9c5 in activemq::threads::CompositeTaskRunner::run (this=0x9547d48) at activemq/threads/CompositeTaskRunner.cpp:118\n#6  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9547e90) at decaf/lang/Thread.cpp:135\n#7  0x00be2847 in threadWorker (arg=0x9547e90) at decaf/lang/Thread.cpp:188\n#8  0x0046796e in start_thread (arg=0xb7799b70) at pthread_create.c:300\n#9  0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 3:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95523a8) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95523a8) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95523a8) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x95522bc) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00915770 in decaf::util::StlQueue<decaf::lang::Pointer<activemq::commands::MessageDispatch, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0x95522a8)\n    at ./decaf/util/StlQueue.h:253\n#8  activemq::core::MessageDispatchChannel::lock (this=0x95522a8) at activemq/core/MessageDispatchChannel.h:153\n#9  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb6f97fe4) at decaf/util/concurrent/Lock.cpp:54\n#10 0x00c20c08 in Lock (this=0xfffffe00, object=0x95523a8, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#11 0x008de102 in activemq::core::ActiveMQConsumer::clearMessagesInProgress (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:1112\n#12 0x008ff15c in activemq::core::ActiveMQSession::clearMessagesInProgress (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:239\n#13 0x008c8543 in activemq::core::ActiveMQConnection::transportInterrupted (this=0x9548210) at activemq/core/ActiveMQConnection.cpp:704\n#14 0x00953b34 in activemq::transport::TransportFilter::transportInterrupted (this=0x95481c0) at activemq/transport/TransportFilter.cpp:67\n#15 0x009687ae in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0x9547a38, error=...) at activemq/transport/failover/FailoverTransport.cpp:476\n#16 0x0097406c in activemq::transport::failover::FailoverTransportListener::onException (this=0x9547878, ex=...) at activemq/transport/failover/FailoverTransportListener.cpp:97\n#17 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:49\n#18 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x9549d80, ex=...) at activemq/transport/TransportFilter.cpp:41\n#19 0x00953c0b in activemq::transport::TransportFilter::fire (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:49\n#20 0x00953c64 in activemq::transport::TransportFilter::onException (this=0x95497f0, ex=...) at activemq/transport/TransportFilter.cpp:41\n#21 0x00951b13 in activemq::transport::IOTransport::fire (this=0x95497a0, ex=...) at activemq/transport/IOTransport.cpp:73\n#22 0x009523bf in activemq::transport::IOTransport::run (this=0x95497a0) at activemq/transport/IOTransport.cpp:246\n#23 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9549ea0) at decaf/lang/Thread.cpp:135\n#24 0x00be2847 in threadWorker (arg=0x9549ea0) at decaf/lang/Thread.cpp:188\n#25 0x0046796e in start_thread (arg=0xb6f98b70) at pthread_create.c:300\n#26 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 4:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046c015 in pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/pthread_cond_wait.S:122\n#2  0x003259dd in __pthread_cond_wait (cond=0x95516c8, mutex=0x9551698) at forward.c:139\n#3  0x00bb06a9 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x95516c8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:94\n#4  0x00c21353 in decaf::util::concurrent::Mutex::wait (this=0x9551584) at decaf/util/concurrent/Mutex.cpp:95\n#5  0x00c2029a in decaf::util::concurrent::CountDownLatch::await (this=0x955157c) at decaf/util/concurrent/CountDownLatch.cpp:56\n#6  0x0804af84 in JMSEndPointThread::stopCheck (this=0x9551574, timeOut=-1) at main.cpp:226\n#7  0x0804bb46 in Consumer::run (this=0x9551570) at main.cpp:379\n#8  0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x95515b0) at decaf/lang/Thread.cpp:135\n#9  0x00be2847 in threadWorker (arg=0x95515b0) at decaf/lang/Thread.cpp:188\n#10 0x0046796e in start_thread (arg=0xb6797b70) at pthread_create.c:300\n#11 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nThread 5:\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x0046eaf9 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\n#2  0x0046a13b in _L_lock_748 () from /lib/tls/i686/cmov/libpthread.so.0\n#3  0x00469f61 in __pthread_mutex_lock (mutex=0x95475e0) at pthread_mutex_lock.c:61\n#4  0x00325ba6 in pthread_mutex_lock (mutex=0x95475e0) at forward.c:182\n#5  0x00bb0aa1 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0x95475e0) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:71\n#6  0x00c21412 in decaf::util::concurrent::Mutex::lock (this=0x9547a88) at decaf/util/concurrent/Mutex.cpp:75\n#7  0x00c20ab5 in decaf::util::concurrent::Lock::lock (this=0xb5f95ce0) at decaf/util/concurrent/Lock.cpp:54\n#8  0x00c20c08 in Lock (this=0xfffffe00, object=0x95475e0, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n#9  0x0096b8fd in activemq::transport::failover::FailoverTransport::oneway (this=0x9547a38, command=...) at activemq/transport/failover/FailoverTransport.cpp:186\n#10 0x00957f9f in activemq::transport::correlator::ResponseCorrelator::oneway (this=0x95481c0, command=...) at activemq/transport/correlator/ResponseCorrelator.cpp:82\n#11 0x008c13be in activemq::core::ActiveMQConnection::oneway (this=0x9548210, command=...) at activemq/core/ActiveMQConnection.cpp:741\n#12 0x00900a4f in activemq::core::ActiveMQSession::oneway (this=0x9551b90, command=...) at activemq/core/ActiveMQSession.cpp:903\n#13 0x008e5a1c in activemq::core::ActiveMQConsumer::acknowledge (this=0x9552270) at activemq/core/ActiveMQConsumer.cpp:860\n#14 0x008ef885 in activemq::core::TransactionSynhcronization::beforeEnd (this=0x95529e8) at activemq/core/ActiveMQConsumer.cpp:85\n#15 0x00910588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:192\n#16 0x00910d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x9551dc8) at activemq/core/ActiveMQTransactionContext.cpp:127\n#17 0x008fe460 in activemq::core::ActiveMQSession::commit (this=0x9551b90) at activemq/core/ActiveMQSession.cpp:189\n#18 0x007ec1a0 in activemq::cmsutil::PooledSession::commit (this=0x9551f38) at activemq/cmsutil/PooledSession.h:87\n#19 0x0804c0fb in Consumer::onMessage (this=0x9551570, message=0x9552ec0) at main.cpp:455\n#20 0x008e972f in activemq::core::ActiveMQConsumer::dispatch (this=0x9552270, dispatch=...) at activemq/core/ActiveMQConsumer.cpp:1018\n#21 0x0090d5c3 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x9551e78, dispatch=...) at activemq/core/ActiveMQSessionExecutor.cpp:129\n#22 0x0090d993 in activemq::core::ActiveMQSessionExecutor::iterate (this=0x9551e78) at activemq/core/ActiveMQSessionExecutor.cpp:166\n#23 0x009507f3 in activemq::threads::DedicatedTaskRunner::run (this=0x9552550) at activemq/threads/DedicatedTaskRunner.cpp:111\n#24 0x00be3cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x9551ad8) at decaf/lang/Thread.cpp:135\n#25 0x00be2847 in threadWorker (arg=0x9551ad8) at decaf/lang/Thread.cpp:188\n#26 0x0046796e in start_thread (arg=0xb5f96b70) at pthread_create.c:300\n#27 0x00318a4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Transactional consumer using MessageListener freezes on commit' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-355?\nA: How to reproduce (using test code attached in AMQCPP-354 issue):\n\n1- Start ActiveMQ\n2- Start 'MessageListener' consumer './activemqTest -l -c1 -d10000'\n3- Send one message './activemqTest -p1'\n4- Wait consumer 'Starting delay'\n5- Stop ActiveMQ\n6- Consumer will try commit\n8- Freezes\n\nBACKTRACE:\n\nThread 1:\n\n#0  0x00eed422 in __kernel_vsyscall ()\n#1  0x00468b5d in pthread_join (threadid=3061414768, t"}}
{"issue_key": "AMQCPP-354", "project": "AMQCPP", "title": "unexpected exception in TransactionSynhcronization::beforeEnd", "status": "Resolved", "reporter": "Henrique Magarotto", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-03-01T23:43:02.000+0000", "updated": "2011-03-04T21:00:35.000+0000", "description": "An unexpected exception is thrown if broker is stopped while consumer is in transaction.\n\n\nI get the following message:\n\nterminate called after throwing an instance of 'cms::CMSException'\n  what():  Failover timeout of 1000 ms reached.\nAborted (core dumped)\n\ncore backtrace:\n#0  0x001ef422 in __kernel_vsyscall ()\n#1  0x00c5a651 in *__GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n#2  0x00c5da82 in *__GI_abort () at abort.c:92\n#3  0x00bf952f in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/libstdc++.so.6\n#4  0x00bf7465 in ?? () from /usr/lib/libstdc++.so.6\n#5  0x00bf74a2 in std::terminate() () from /usr/lib/libstdc++.so.6\n#6  0x00bf74c5 in ?? () from /usr/lib/libstdc++.so.6\n#7  0x00bf6915 in __cxa_call_unexpected () from /usr/lib/libstdc++.so.6\n#8  0x0052f8ae in activemq::core::TransactionSynhcronization::beforeEnd (this=0x93ac548) at activemq/core/ActiveMQConsumer.cpp:84\n#9  0x00550588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:192\n#10 0x00550d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:127\n#11 0x0053e460 in activemq::core::ActiveMQSession::commit (this=0x93b3c10) at activemq/core/ActiveMQSession.cpp:189\n#12 0x0042c1a0 in activemq::cmsutil::PooledSession::commit (this=0x93b3fd8) at activemq/cmsutil/PooledSession.h:87\n#13 0x0804c0fb in Consumer::onMessage (this=0x93a8c30, message=0x93b49b0) at main.cpp:455\n#14 0x0804bdc8 in Consumer::consumeLoop (this=0x93a8c30) at main.cpp:415\n#15 0x0804bb56 in Consumer::run (this=0x93a8c30) at main.cpp:381\n#16 0x00823cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x93abff0) at decaf/lang/Thread.cpp:135\n#17 0x00822847 in threadWorker (arg=0x93abff0) at decaf/lang/Thread.cpp:188\n#18 0x0015a96e in start_thread (arg=0xb6f8bb70) at pthread_create.c:300\n#19 0x00cfda4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nException specification for method 'activemq::core::TransactionSynhcronization::beforeEnd' says: 'throw( exceptions::ActiveMQException )' but 'ActiveMQConsumer::acknowledge' throws 'cms::CMSException', so 'std::unexpected' is called and 'abort' occurs. (http://www.linuxprogrammingblog.com/cpp-exception-specifications-are-evil)", "comments": [], "text": "unexpected exception in TransactionSynhcronization::beforeEnd\n\nDescription:\nAn unexpected exception is thrown if broker is stopped while consumer is in transaction.\n\n\nI get the following message:\n\nterminate called after throwing an instance of 'cms::CMSException'\n  what():  Failover timeout of 1000 ms reached.\nAborted (core dumped)\n\ncore backtrace:\n#0  0x001ef422 in __kernel_vsyscall ()\n#1  0x00c5a651 in *__GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n#2  0x00c5da82 in *__GI_abort () at abort.c:92\n#3  0x00bf952f in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/libstdc++.so.6\n#4  0x00bf7465 in ?? () from /usr/lib/libstdc++.so.6\n#5  0x00bf74a2 in std::terminate() () from /usr/lib/libstdc++.so.6\n#6  0x00bf74c5 in ?? () from /usr/lib/libstdc++.so.6\n#7  0x00bf6915 in __cxa_call_unexpected () from /usr/lib/libstdc++.so.6\n#8  0x0052f8ae in activemq::core::TransactionSynhcronization::beforeEnd (this=0x93ac548) at activemq/core/ActiveMQConsumer.cpp:84\n#9  0x00550588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:192\n#10 0x00550d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:127\n#11 0x0053e460 in activemq::core::ActiveMQSession::commit (this=0x93b3c10) at activemq/core/ActiveMQSession.cpp:189\n#12 0x0042c1a0 in activemq::cmsutil::PooledSession::commit (this=0x93b3fd8) at activemq/cmsutil/PooledSession.h:87\n#13 0x0804c0fb in Consumer::onMessage (this=0x93a8c30, message=0x93b49b0) at main.cpp:455\n#14 0x0804bdc8 in Consumer::consumeLoop (this=0x93a8c30) at main.cpp:415\n#15 0x0804bb56 in Consumer::run (this=0x93a8c30) at main.cpp:381\n#16 0x00823cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x93abff0) at decaf/lang/Thread.cpp:135\n#17 0x00822847 in threadWorker (arg=0x93abff0) at decaf/lang/Thread.cpp:188\n#18 0x0015a96e in start_thread (arg=0xb6f8bb70) at pthread_create.c:300\n#19 0x00cfda4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nException specification for method 'activemq::core::TransactionSynhcronization::beforeEnd' says: 'throw( exceptions::ActiveMQException )' but 'ActiveMQConsumer::acknowledge' throws 'cms::CMSException', so 'std::unexpected' is called and 'abort' occurs. (http://www.linuxprogrammingblog.com/cpp-exception-specifications-are-evil)\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: unexpected exception in TransactionSynhcronization::beforeEnd\n\nDescription:\nAn unexpected exception is thrown if broker is stopped while consumer is in transaction.\n\n\nI get the following message:\n\nterminate called after throwing an instance of 'cms::CMSException'\n  what():  Failover timeout of 1000 ms reached.\nAborted (core dumped)\n\ncore backtrace:\n#0  0x001ef422 in __kernel_vsyscall ()\n#1  0x00c5a651 in *__GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n#2  0x00c5da82 in *__GI_abort () at abort.c:92\n#3  0x00bf952f in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/libstdc++.so.6\n#4  0x00bf7465 in ?? () from /usr/lib/libstdc++.so.6\n#5  0x00bf74a2 in std::terminate() () from /usr/lib/libstdc++.so.6\n#6  0x00bf74c5 in ?? () from /usr/lib/libstdc++.so.6\n#7  0x00bf6915 in __cxa_call_unexpected () from /usr/lib/libstdc++.so.6\n#8  0x0052f8ae in activemq::core::TransactionSynhcronization::beforeEnd (this=0x93ac548) at activemq/core/ActiveMQConsumer.cpp:84\n#9  0x00550588 in activemq::core::ActiveMQTransactionContext::beforeEnd (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:192\n#10 0x00550d63 in activemq::core::ActiveMQTransactionContext::commit (this=0x93b3e48) at activemq/core/ActiveMQTransactionContext.cpp:127\n#11 0x0053e460 in activemq::core::ActiveMQSession::commit (this=0x93b3c10) at activemq/core/ActiveMQSession.cpp:189\n#12 0x0042c1a0 in activemq::cmsutil::PooledSession::commit (this=0x93b3fd8) at activemq/cmsutil/PooledSession.h:87\n#13 0x0804c0fb in Consumer::onMessage (this=0x93a8c30, message=0x93b49b0) at main.cpp:455\n#14 0x0804bdc8 in Consumer::consumeLoop (this=0x93a8c30) at main.cpp:415\n#15 0x0804bb56 in Consumer::run (this=0x93a8c30) at main.cpp:381\n#16 0x00823cf1 in decaf::lang::ThreadProperties::runCallback (properties=0x93abff0) at decaf/lang/Thread.cpp:135\n#17 0x00822847 in threadWorker (arg=0x93abff0) at decaf/lang/Thread.cpp:188\n#18 0x0015a96e in start_thread (arg=0xb6f8bb70) at pthread_create.c:300\n#19 0x00cfda4e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n\nException specification for method 'activemq::core::TransactionSynhcronization::beforeEnd' says: 'throw( exceptions::ActiveMQException )' but 'ActiveMQConsumer::acknowledge' throws 'cms::CMSException', so 'std::unexpected' is called and 'abort' occurs. (http://www.linuxprogrammingblog.com/cpp-exception-specifications-are-evil)\n\n\nComments:\n", "classification": "Classify the issue 'unexpected exception in TransactionSynhcronization::beforeEnd' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-354?\nA: An unexpected exception is thrown if broker is stopped while consumer is in transaction.\n\n\nI get the following message:\n\nterminate called after throwing an instance of 'cms::CMSException'\n  what():  Failover timeout of 1000 ms reached.\nAborted (core dumped)\n\ncore backtrace:\n#0  0x001ef422 in __kernel_vsyscall ()\n#1  0x00c5a651 in *__GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n#2"}}
{"issue_key": "AMQCPP-353", "project": "AMQCPP", "title": "BaseDataStreamMarshaller::readAsciiString crashes ", "status": "Resolved", "reporter": "Matt Fisher", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-03-01T21:57:00.000+0000", "updated": "2011-03-02T14:23:55.000+0000", "description": "BaseDataStreamMarshaller::readAsciiString() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1 (which is default).", "comments": [], "text": "BaseDataStreamMarshaller::readAsciiString crashes \n\nDescription:\nBaseDataStreamMarshaller::readAsciiString() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1 (which is default).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: BaseDataStreamMarshaller::readAsciiString crashes \n\nDescription:\nBaseDataStreamMarshaller::readAsciiString() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1 (which is default).\n\nComments:\n", "classification": "Classify the issue 'BaseDataStreamMarshaller::readAsciiString crashes ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-353?\nA: BaseDataStreamMarshaller::readAsciiString() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1 (which is default)."}}
{"issue_key": "AMQCPP-352", "project": "AMQCPP", "title": "FailoverTransportFactory doesn't work correctly with more than two composite uris ", "status": "Resolved", "reporter": "Dmitry Babich", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-02-27T18:30:25.000+0000", "updated": "2011-02-28T14:18:04.000+0000", "description": "Only first and last composite uris are recognized by FailoverTransportFactory.\n\nFor example - given uri: \n   failover://(tcp://10.10.10.1:61616,tcp://10.10.10.2:61616,tcp://10.10.10.3:61616,tcp://10.10.10.4:61616)\nonly \"tcp://10.10.10.1:61616\" and \"tcp://10.10.10.4:61616\" will work.\n\nThe bug in URISupport::splitComponents(). \nLine 350:\n      std::string s = str.substr( last, i );\nshould be replaced by:\n      std::string s = str.substr( last, i - last );  // 2nd argument of substr() is length of substring", "comments": [], "text": "FailoverTransportFactory doesn't work correctly with more than two composite uris \n\nDescription:\nOnly first and last composite uris are recognized by FailoverTransportFactory.\n\nFor example - given uri: \n   failover://(tcp://10.10.10.1:61616,tcp://10.10.10.2:61616,tcp://10.10.10.3:61616,tcp://10.10.10.4:61616)\nonly \"tcp://10.10.10.1:61616\" and \"tcp://10.10.10.4:61616\" will work.\n\nThe bug in URISupport::splitComponents(). \nLine 350:\n      std::string s = str.substr( last, i );\nshould be replaced by:\n      std::string s = str.substr( last, i - last );  // 2nd argument of substr() is length of substring\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: FailoverTransportFactory doesn't work correctly with more than two composite uris \n\nDescription:\nOnly first and last composite uris are recognized by FailoverTransportFactory.\n\nFor example - given uri: \n   failover://(tcp://10.10.10.1:61616,tcp://10.10.10.2:61616,tcp://10.10.10.3:61616,tcp://10.10.10.4:61616)\nonly \"tcp://10.10.10.1:61616\" and \"tcp://10.10.10.4:61616\" will work.\n\nThe bug in URISupport::splitComponents(). \nLine 350:\n      std::string s = str.substr( last, i );\nshould be replaced by:\n      std::string s = str.substr( last, i - last );  // 2nd argument of substr() is length of substring\n\n\nComments:\n", "classification": "Classify the issue 'FailoverTransportFactory doesn't work correctly with more than two composite uris ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-352?\nA: Only first and last composite uris are recognized by FailoverTransportFactory.\n\nFor example - given uri: \n   failover://(tcp://10.10.10.1:61616,tcp://10.10.10.2:61616,tcp://10.10.10.3:61616,tcp://10.10.10.4:61616)\nonly \"tcp://10.10.10.1:61616\" and \"tcp://10.10.10.4:61616\" will work.\n\nThe bug in URISupport::splitComponents(). \nLine 350:\n      std::string s = str.substr( last, i );\nshould be replace"}}
{"issue_key": "AMQCPP-351", "project": "AMQCPP", "title": "Using incorrect peer list in failover transport", "status": "Resolved", "reporter": "Adam Sussman", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-02-16T02:59:47.000+0000", "updated": "2011-02-16T14:02:20.000+0000", "description": "In the failover transport, the broker hands the client a list of known peer brokers the client can attempt upon connection failure.  In the Java client libs, this list of peers is obtained from the ConnectionControl object and that list is subject to various configuration controls on the broker.  The C++ client gets its list from the BrokerInfo object who's list is NOT controlled at all by broker settings and which also retains query string artifacts that should not be used (see AMQ-3124).\n\nThe list of peers the C++ client is using is not correct and not under the same controls as the list the Java client is using. The C++ failover transport should be altered to use the same source of peer data as the Java client, the ConnectionControl object.\n\nIn currently released versions (3.2.4 and older), the entire reconnect list comes from BrokerInfo.getPeerBrokerInfos.  In trunk, the list comes from BrokerInfo.getPeerBrokerInfos PLUS ConnectionControl.getReconnectTo.  However, the Java client gets its list from ConnectionControl.getConnectedBrokers plus ConnectionControl.getReconnectTo and does not use BrokerInfo at all.\n\nAt a minimum, the usage of BrokerInfo.getPeerBrokerInfos needs to be removed in FailoverTransportListener.cpp and usage of getConnectedBrokers needs to be added to FailoverTransport.cpp:handleConnectionControl.", "comments": [], "text": "Using incorrect peer list in failover transport\n\nDescription:\nIn the failover transport, the broker hands the client a list of known peer brokers the client can attempt upon connection failure.  In the Java client libs, this list of peers is obtained from the ConnectionControl object and that list is subject to various configuration controls on the broker.  The C++ client gets its list from the BrokerInfo object who's list is NOT controlled at all by broker settings and which also retains query string artifacts that should not be used (see AMQ-3124).\n\nThe list of peers the C++ client is using is not correct and not under the same controls as the list the Java client is using. The C++ failover transport should be altered to use the same source of peer data as the Java client, the ConnectionControl object.\n\nIn currently released versions (3.2.4 and older), the entire reconnect list comes from BrokerInfo.getPeerBrokerInfos.  In trunk, the list comes from BrokerInfo.getPeerBrokerInfos PLUS ConnectionControl.getReconnectTo.  However, the Java client gets its list from ConnectionControl.getConnectedBrokers plus ConnectionControl.getReconnectTo and does not use BrokerInfo at all.\n\nAt a minimum, the usage of BrokerInfo.getPeerBrokerInfos needs to be removed in FailoverTransportListener.cpp and usage of getConnectedBrokers needs to be added to FailoverTransport.cpp:handleConnectionControl.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Using incorrect peer list in failover transport\n\nDescription:\nIn the failover transport, the broker hands the client a list of known peer brokers the client can attempt upon connection failure.  In the Java client libs, this list of peers is obtained from the ConnectionControl object and that list is subject to various configuration controls on the broker.  The C++ client gets its list from the BrokerInfo object who's list is NOT controlled at all by broker settings and which also retains query string artifacts that should not be used (see AMQ-3124).\n\nThe list of peers the C++ client is using is not correct and not under the same controls as the list the Java client is using. The C++ failover transport should be altered to use the same source of peer data as the Java client, the ConnectionControl object.\n\nIn currently released versions (3.2.4 and older), the entire reconnect list comes from BrokerInfo.getPeerBrokerInfos.  In trunk, the list comes from BrokerInfo.getPeerBrokerInfos PLUS ConnectionControl.getReconnectTo.  However, the Java client gets its list from ConnectionControl.getConnectedBrokers plus ConnectionControl.getReconnectTo and does not use BrokerInfo at all.\n\nAt a minimum, the usage of BrokerInfo.getPeerBrokerInfos needs to be removed in FailoverTransportListener.cpp and usage of getConnectedBrokers needs to be added to FailoverTransport.cpp:handleConnectionControl.\n\nComments:\n", "classification": "Classify the issue 'Using incorrect peer list in failover transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-351?\nA: In the failover transport, the broker hands the client a list of known peer brokers the client can attempt upon connection failure.  In the Java client libs, this list of peers is obtained from the ConnectionControl object and that list is subject to various configuration controls on the broker.  The C++ client gets its list from the BrokerInfo object who's list is NOT controlled at all by broker "}}
{"issue_key": "AMQCPP-350", "project": "AMQCPP", "title": "URI Query params are sometimes missed when creating Connections and Transports.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-02-10T21:02:18.000+0000", "updated": "2011-02-10T21:17:16.000+0000", "description": "Somee URI formats for composite URIs used for the FailoverTransport cause the parser to miss the options on the query portion of the outermost URI which means the options the user meant to apply won't be set.\n\nthis format works: failover://(...)?...\nthis doesn't: failover:(...)?...", "comments": [], "text": "URI Query params are sometimes missed when creating Connections and Transports.\n\nDescription:\nSomee URI formats for composite URIs used for the FailoverTransport cause the parser to miss the options on the query portion of the outermost URI which means the options the user meant to apply won't be set.\n\nthis format works: failover://(...)?...\nthis doesn't: failover:(...)?...\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: URI Query params are sometimes missed when creating Connections and Transports.\n\nDescription:\nSomee URI formats for composite URIs used for the FailoverTransport cause the parser to miss the options on the query portion of the outermost URI which means the options the user meant to apply won't be set.\n\nthis format works: failover://(...)?...\nthis doesn't: failover:(...)?...\n\nComments:\n", "classification": "Classify the issue 'URI Query params are sometimes missed when creating Connections and Transports.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-350?\nA: Somee URI formats for composite URIs used for the FailoverTransport cause the parser to miss the options on the query portion of the outermost URI which means the options the user meant to apply won't be set.\n\nthis format works: failover://(...)?...\nthis doesn't: failover:(...)?..."}}
{"issue_key": "AMQCPP-349", "project": "AMQCPP", "title": "broker restarts undetectable via tcp: transport", "status": "Closed", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-25T19:11:39.000+0000", "updated": "2011-01-25T19:40:04.000+0000", "description": "A client connected to a queue on a broker via a tcp: transport connection receives no indication of a broker restart.\n\nThis leaves the client waiting forever for messages on the queue but the broker does not have a subscription for that client.  The client has no indication that it must initiate a reconnection with the broker.", "comments": [], "text": "broker restarts undetectable via tcp: transport\n\nDescription:\nA client connected to a queue on a broker via a tcp: transport connection receives no indication of a broker restart.\n\nThis leaves the client waiting forever for messages on the queue but the broker does not have a subscription for that client.  The client has no indication that it must initiate a reconnection with the broker.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: broker restarts undetectable via tcp: transport\n\nDescription:\nA client connected to a queue on a broker via a tcp: transport connection receives no indication of a broker restart.\n\nThis leaves the client waiting forever for messages on the queue but the broker does not have a subscription for that client.  The client has no indication that it must initiate a reconnection with the broker.\n\nComments:\n", "classification": "Classify the issue 'broker restarts undetectable via tcp: transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-349?\nA: A client connected to a queue on a broker via a tcp: transport connection receives no indication of a broker restart.\n\nThis leaves the client waiting forever for messages on the queue but the broker does not have a subscription for that client.  The client has no indication that it must initiate a reconnection with the broker."}}
{"issue_key": "AMQCPP-348", "project": "AMQCPP", "title": "Allow unverified SSL peer", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-01-21T23:28:54.000+0000", "updated": "2011-02-07T19:55:46.000+0000", "description": "When using an ssl: connection, attempting to only provide a client certificate via:\n\n            decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nfails with the following:\n\nError occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nInit failure ERROR: Error occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\n\nIt would be nice if the library would set peer_verify to false if no decaf.net.ssl.trustStore was provided to allow the client to bypass verification of the broker.", "comments": [], "text": "Allow unverified SSL peer\n\nDescription:\nWhen using an ssl: connection, attempting to only provide a client certificate via:\n\n            decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nfails with the following:\n\nError occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nInit failure ERROR: Error occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\n\nIt would be nice if the library would set peer_verify to false if no decaf.net.ssl.trustStore was provided to allow the client to bypass verification of the broker.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Allow unverified SSL peer\n\nDescription:\nWhen using an ssl: connection, attempting to only provide a client certificate via:\n\n            decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nfails with the following:\n\nError occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nInit failure ERROR: Error occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\n\nIt would be nice if the library would set peer_verify to false if no decaf.net.ssl.trustStore was provided to allow the client to bypass verification of the broker.\n\n\n\nComments:\n", "classification": "Classify the issue 'Allow unverified SSL peer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-348?\nA: When using an ssl: connection, attempting to only provide a client certificate via:\n\n            decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nfails with the following:\n\nError occurred while accessing an OpenSSL library method:\nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nInit failure ERROR: Error occurred while accessing an OpenSSL lib"}}
{"issue_key": "AMQCPP-347", "project": "AMQCPP", "title": "SEGFAULT on ssl connections with certificates", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2011-01-21T23:11:09.000+0000", "updated": "2011-02-01T22:12:03.000+0000", "description": "Attempting to use an ssl:// connection with certificates via:\n\n        decaf::lang::System::setProperty(\"decaf.net.ssl.trustStore\", certfile);\n        decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nresults in a segfault when the connection is established.  The segfault appears to be in decaf's attempt to perform additional verification of the certificate:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000 in ?? ()\n(gdb) bt\n#0  0x00000000 in ?? ()\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n#2  0xb7d12d5d in decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake (this=0x81c8f40) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:368\n#3  0xb7d12174 in decaf::internal::net::ssl::openssl::OpenSSLSocket::write (this=0x81c8f40, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:555\n#4  0xb7d1823b in decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocketOutputStream.cpp:94\n#5  0xb7d76687 in decaf::io::OutputStream::doWriteArray (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:100\n#6  0xb7d76ae0 in decaf::io::OutputStream::write (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:70\n#7  0xb7d656e9 in decaf::io::BufferedOutputStream::emptyBuffer (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:87\n#8  0xb7d6610b in decaf::io::BufferedOutputStream::flush (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:104\n#9  0xb7d7270e in decaf::io::FilterOutputStream::flush (this=0x81cfa40) at decaf/io/FilterOutputStream.cpp:143\n#10 0xb7aa708f in activemq::transport::IOTransport::oneway (this=0x817ce40, command=...) at activemq/transport/IOTransport.cpp:131\n#11 0xb7aa854d in activemq::transport::TransportFilter::oneway (this=0x817ce90, command=...) at activemq/transport/TransportFilter.h:120\n#12 0xb7acffb4 in activemq::transport::inactivity::InactivityMonitor::oneway (this=0x81cfb30, command=...) at activemq/transport/inactivity/InactivityMonitor.cpp:335\n#13 0xb7b09644 in activemq::wireformat::openwire::OpenWireFormatNegotiator::start (this=0x81d0230) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:222\n#14 0xb7aac991 in activemq::transport::correlator::ResponseCorrelator::start (this=0x81d0350) at activemq/transport/correlator/ResponseCorrelator.cpp:240\n#15 0xb7a11528 in activemq::core::ActiveMQConnectionFactory::doCreateConnection (this=0xbfffbe04, url=..., username=..., password=..., clientId=...)\n    at activemq/core/ActiveMQConnectionFactory.cpp:263\n#16 0xb7a124ac in activemq::core::ActiveMQConnectionFactory::createConnection (url=..., username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:298\n#17 0xb7a12548 in activemq::core::ActiveMQConnectionFactory::createConnection (this=0x817c7a0, username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:211\n...\n(gdb) up\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n659\t                method->i2v( method, method->d2i( NULL, &data, extension->value->length ), NULL );\n(gdb) p method->d2i\n$1 = (X509V3_EXT_D2I) 0\n(gdb)", "comments": [], "text": "SEGFAULT on ssl connections with certificates\n\nDescription:\nAttempting to use an ssl:// connection with certificates via:\n\n        decaf::lang::System::setProperty(\"decaf.net.ssl.trustStore\", certfile);\n        decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nresults in a segfault when the connection is established.  The segfault appears to be in decaf's attempt to perform additional verification of the certificate:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000 in ?? ()\n(gdb) bt\n#0  0x00000000 in ?? ()\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n#2  0xb7d12d5d in decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake (this=0x81c8f40) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:368\n#3  0xb7d12174 in decaf::internal::net::ssl::openssl::OpenSSLSocket::write (this=0x81c8f40, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:555\n#4  0xb7d1823b in decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocketOutputStream.cpp:94\n#5  0xb7d76687 in decaf::io::OutputStream::doWriteArray (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:100\n#6  0xb7d76ae0 in decaf::io::OutputStream::write (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:70\n#7  0xb7d656e9 in decaf::io::BufferedOutputStream::emptyBuffer (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:87\n#8  0xb7d6610b in decaf::io::BufferedOutputStream::flush (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:104\n#9  0xb7d7270e in decaf::io::FilterOutputStream::flush (this=0x81cfa40) at decaf/io/FilterOutputStream.cpp:143\n#10 0xb7aa708f in activemq::transport::IOTransport::oneway (this=0x817ce40, command=...) at activemq/transport/IOTransport.cpp:131\n#11 0xb7aa854d in activemq::transport::TransportFilter::oneway (this=0x817ce90, command=...) at activemq/transport/TransportFilter.h:120\n#12 0xb7acffb4 in activemq::transport::inactivity::InactivityMonitor::oneway (this=0x81cfb30, command=...) at activemq/transport/inactivity/InactivityMonitor.cpp:335\n#13 0xb7b09644 in activemq::wireformat::openwire::OpenWireFormatNegotiator::start (this=0x81d0230) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:222\n#14 0xb7aac991 in activemq::transport::correlator::ResponseCorrelator::start (this=0x81d0350) at activemq/transport/correlator/ResponseCorrelator.cpp:240\n#15 0xb7a11528 in activemq::core::ActiveMQConnectionFactory::doCreateConnection (this=0xbfffbe04, url=..., username=..., password=..., clientId=...)\n    at activemq/core/ActiveMQConnectionFactory.cpp:263\n#16 0xb7a124ac in activemq::core::ActiveMQConnectionFactory::createConnection (url=..., username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:298\n#17 0xb7a12548 in activemq::core::ActiveMQConnectionFactory::createConnection (this=0x817c7a0, username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:211\n...\n(gdb) up\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n659\t                method->i2v( method, method->d2i( NULL, &data, extension->value->length ), NULL );\n(gdb) p method->d2i\n$1 = (X509V3_EXT_D2I) 0\n(gdb) \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SEGFAULT on ssl connections with certificates\n\nDescription:\nAttempting to use an ssl:// connection with certificates via:\n\n        decaf::lang::System::setProperty(\"decaf.net.ssl.trustStore\", certfile);\n        decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nresults in a segfault when the connection is established.  The segfault appears to be in decaf's attempt to perform additional verification of the certificate:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000 in ?? ()\n(gdb) bt\n#0  0x00000000 in ?? ()\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n#2  0xb7d12d5d in decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake (this=0x81c8f40) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:368\n#3  0xb7d12174 in decaf::internal::net::ssl::openssl::OpenSSLSocket::write (this=0x81c8f40, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:555\n#4  0xb7d1823b in decaf::internal::net::ssl::openssl::OpenSSLSocketOutputStream::doWriteArrayBounded (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221, offset=0, length=221)\n    at decaf/internal/net/ssl/openssl/OpenSSLSocketOutputStream.cpp:94\n#5  0xb7d76687 in decaf::io::OutputStream::doWriteArray (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:100\n#6  0xb7d76ae0 in decaf::io::OutputStream::write (this=0x81cb808, buffer=0x81cd9d0 \"\", size=221) at decaf/io/OutputStream.cpp:70\n#7  0xb7d656e9 in decaf::io::BufferedOutputStream::emptyBuffer (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:87\n#8  0xb7d6610b in decaf::io::BufferedOutputStream::flush (this=0x81cd938) at decaf/io/BufferedOutputStream.cpp:104\n#9  0xb7d7270e in decaf::io::FilterOutputStream::flush (this=0x81cfa40) at decaf/io/FilterOutputStream.cpp:143\n#10 0xb7aa708f in activemq::transport::IOTransport::oneway (this=0x817ce40, command=...) at activemq/transport/IOTransport.cpp:131\n#11 0xb7aa854d in activemq::transport::TransportFilter::oneway (this=0x817ce90, command=...) at activemq/transport/TransportFilter.h:120\n#12 0xb7acffb4 in activemq::transport::inactivity::InactivityMonitor::oneway (this=0x81cfb30, command=...) at activemq/transport/inactivity/InactivityMonitor.cpp:335\n#13 0xb7b09644 in activemq::wireformat::openwire::OpenWireFormatNegotiator::start (this=0x81d0230) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:222\n#14 0xb7aac991 in activemq::transport::correlator::ResponseCorrelator::start (this=0x81d0350) at activemq/transport/correlator/ResponseCorrelator.cpp:240\n#15 0xb7a11528 in activemq::core::ActiveMQConnectionFactory::doCreateConnection (this=0xbfffbe04, url=..., username=..., password=..., clientId=...)\n    at activemq/core/ActiveMQConnectionFactory.cpp:263\n#16 0xb7a124ac in activemq::core::ActiveMQConnectionFactory::createConnection (url=..., username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:298\n#17 0xb7a12548 in activemq::core::ActiveMQConnectionFactory::createConnection (this=0x817c7a0, username=..., password=..., clientId=...) at activemq/core/ActiveMQConnectionFactory.cpp:211\n...\n(gdb) up\n#1  0xb7d119e9 in decaf::internal::net::ssl::openssl::OpenSSLSocket::verifyServerCert (this=0x81c8f40, serverName=...) at decaf/internal/net/ssl/openssl/OpenSSLSocket.cpp:659\n659\t                method->i2v( method, method->d2i( NULL, &data, extension->value->length ), NULL );\n(gdb) p method->d2i\n$1 = (X509V3_EXT_D2I) 0\n(gdb) \n\n\nComments:\n", "classification": "Classify the issue 'SEGFAULT on ssl connections with certificates' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-347?\nA: Attempting to use an ssl:// connection with certificates via:\n\n        decaf::lang::System::setProperty(\"decaf.net.ssl.trustStore\", certfile);\n        decaf::lang::System::setProperty(\"decaf.net.ssl.keyStore\", certfile);\n\nresults in a segfault when the connection is established.  The segfault appears to be in decaf's attempt to perform additional verification of the certificate:\n\nProgram received "}}
{"issue_key": "AMQCPP-346", "project": "AMQCPP", "title": "No UTF8 conversation in OpenWire strings", "status": "Resolved", "reporter": "Peter Pfort", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-21T11:00:06.000+0000", "updated": "2011-01-24T15:41:05.000+0000", "description": "Hello,\n\nI have found a bug in the implementation of the OpenWire protocol. When you have non ascii character i.e. in the selector of a topic consumer, then the program hangs in createConsumer.\n\nThe problem is in the class BaseDataStreamMarshaller. In BaseDataStreamMarshaller::tightMarshalString1() thinks, the string will be converted to UTF8, but BaseDataStreamMarshaller::tightMarshalString2() write out the string with dataOut->writeChars( value );\n\nI have changed BaseDataStreamMarshaller::tightMarshalString2() to dataOut->writeUTF( value ); and everything works fine.\n\nPlease correct it in the source.\n\nBest regards", "comments": [], "text": "No UTF8 conversation in OpenWire strings\n\nDescription:\nHello,\n\nI have found a bug in the implementation of the OpenWire protocol. When you have non ascii character i.e. in the selector of a topic consumer, then the program hangs in createConsumer.\n\nThe problem is in the class BaseDataStreamMarshaller. In BaseDataStreamMarshaller::tightMarshalString1() thinks, the string will be converted to UTF8, but BaseDataStreamMarshaller::tightMarshalString2() write out the string with dataOut->writeChars( value );\n\nI have changed BaseDataStreamMarshaller::tightMarshalString2() to dataOut->writeUTF( value ); and everything works fine.\n\nPlease correct it in the source.\n\nBest regards\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: No UTF8 conversation in OpenWire strings\n\nDescription:\nHello,\n\nI have found a bug in the implementation of the OpenWire protocol. When you have non ascii character i.e. in the selector of a topic consumer, then the program hangs in createConsumer.\n\nThe problem is in the class BaseDataStreamMarshaller. In BaseDataStreamMarshaller::tightMarshalString1() thinks, the string will be converted to UTF8, but BaseDataStreamMarshaller::tightMarshalString2() write out the string with dataOut->writeChars( value );\n\nI have changed BaseDataStreamMarshaller::tightMarshalString2() to dataOut->writeUTF( value ); and everything works fine.\n\nPlease correct it in the source.\n\nBest regards\n\nComments:\n", "classification": "Classify the issue 'No UTF8 conversation in OpenWire strings' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-346?\nA: Hello,\n\nI have found a bug in the implementation of the OpenWire protocol. When you have non ascii character i.e. in the selector of a topic consumer, then the program hangs in createConsumer.\n\nThe problem is in the class BaseDataStreamMarshaller. In BaseDataStreamMarshaller::tightMarshalString1() thinks, the string will be converted to UTF8, but BaseDataStreamMarshaller::tightMarshalString2() wri"}}
{"issue_key": "AMQCPP-345", "project": "AMQCPP", "title": "Can't connect via Stomp to Apollo broker", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-01-19T21:11:29.000+0000", "updated": "2011-01-19T21:13:50.000+0000", "description": "Stomp protocol problem when connecting to Apollo broker causes the client to not connect because it doesn't see the CONNECTED frame as a proper response to the CONNECT frame.", "comments": [], "text": "Can't connect via Stomp to Apollo broker\n\nDescription:\nStomp protocol problem when connecting to Apollo broker causes the client to not connect because it doesn't see the CONNECTED frame as a proper response to the CONNECT frame.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't connect via Stomp to Apollo broker\n\nDescription:\nStomp protocol problem when connecting to Apollo broker causes the client to not connect because it doesn't see the CONNECTED frame as a proper response to the CONNECT frame.\n\nComments:\n", "classification": "Classify the issue 'Can't connect via Stomp to Apollo broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-345?\nA: Stomp protocol problem when connecting to Apollo broker causes the client to not connect because it doesn't see the CONNECTED frame as a proper response to the CONNECT frame."}}
{"issue_key": "AMQCPP-344", "project": "AMQCPP", "title": "incorrect validation of IP addresses", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T21:39:58.000+0000", "updated": "2011-01-11T21:52:49.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "incorrect validation of IP addresses\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: incorrect validation of IP addresses\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'incorrect validation of IP addresses' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-344?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-343", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:37:19.000+0000", "updated": "2011-01-11T16:50:55.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-343?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-342", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:37:15.000+0000", "updated": "2011-01-11T16:51:16.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-342?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-341", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:36:49.000+0000", "updated": "2011-01-11T16:51:37.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-341?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-340", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:36:43.000+0000", "updated": "2011-01-11T16:51:58.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-340?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-339", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:36:37.000+0000", "updated": "2011-01-11T16:52:17.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-339?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-338", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:36:29.000+0000", "updated": "2011-01-11T16:53:02.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-338?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-337", "project": "AMQCPP", "title": "Erroneous validation of IP address", "status": "Closed", "reporter": "andrzej k.", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-01-11T16:36:16.000+0000", "updated": "2011-01-11T16:50:29.000+0000", "description": "in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.", "comments": [], "text": "Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Erroneous validation of IP address\n\nDescription:\nin file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation.\n\nComments:\n", "classification": "Classify the issue 'Erroneous validation of IP address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-337?\nA: in file URIHelper.cpp, in function URIHelper::isValidIPv4Address, member function substr of std::string is used incorrectly. It is fed with two indexes, whereas it should be fed with an index and length. As a consequence valid IP addresses do not pass the validation."}}
{"issue_key": "AMQCPP-336", "project": "AMQCPP", "title": "This adds a submit timeout to the c wrapper library", "status": "Resolved", "reporter": "Jason Benguerel", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-12-28T04:47:56.000+0000", "updated": "2010-12-28T14:24:22.000+0000", "description": "I added a function to allow a timeout parameter to be passed. I will probably add the additional send calls as well if I get around to it.", "comments": [], "text": "This adds a submit timeout to the c wrapper library\n\nDescription:\nI added a function to allow a timeout parameter to be passed. I will probably add the additional send calls as well if I get around to it. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: This adds a submit timeout to the c wrapper library\n\nDescription:\nI added a function to allow a timeout parameter to be passed. I will probably add the additional send calls as well if I get around to it. \n\nComments:\n", "classification": "Classify the issue 'This adds a submit timeout to the c wrapper library' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-336?\nA: I added a function to allow a timeout parameter to be passed. I will probably add the additional send calls as well if I get around to it. "}}
{"issue_key": "AMQCPP-335", "project": "AMQCPP", "title": "redeliveryPolicy: rollback always loops", "status": "Resolved", "reporter": "Thomas Riccardi", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-11-24T11:08:03.000+0000", "updated": "2010-11-24T15:17:14.000+0000", "description": "The MaximumRedeliveries parameter from redeliveryPolicy is broken when using transactions sessions:\non session rollback, the message is always redelivered, even if MaximumRedeliveries is not set to -1.\n\n\nThe issue is in ActiveMQConsumer::rollback() where the RedeliveryCounter is incremented in Message objects:\nActiveMQConsumer.cpp:969: message->setRedeliveryCounter(\n\nand the check is done in the last MessageDispatch object:\nActiveMQConsumer.cpp:973: lastMsg->getRedeliveryCounter()\n\n\nWith\nActiveMQConsumer.cpp:973: lastMsg->getMessage()->getRedeliveryCounter()\n\nthe MaximumRedeliveries parameter is used correctly.", "comments": [], "text": "redeliveryPolicy: rollback always loops\n\nDescription:\nThe MaximumRedeliveries parameter from redeliveryPolicy is broken when using transactions sessions:\non session rollback, the message is always redelivered, even if MaximumRedeliveries is not set to -1.\n\n\nThe issue is in ActiveMQConsumer::rollback() where the RedeliveryCounter is incremented in Message objects:\nActiveMQConsumer.cpp:969: message->setRedeliveryCounter(\n\nand the check is done in the last MessageDispatch object:\nActiveMQConsumer.cpp:973: lastMsg->getRedeliveryCounter()\n\n\nWith\nActiveMQConsumer.cpp:973: lastMsg->getMessage()->getRedeliveryCounter()\n\nthe MaximumRedeliveries parameter is used correctly.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: redeliveryPolicy: rollback always loops\n\nDescription:\nThe MaximumRedeliveries parameter from redeliveryPolicy is broken when using transactions sessions:\non session rollback, the message is always redelivered, even if MaximumRedeliveries is not set to -1.\n\n\nThe issue is in ActiveMQConsumer::rollback() where the RedeliveryCounter is incremented in Message objects:\nActiveMQConsumer.cpp:969: message->setRedeliveryCounter(\n\nand the check is done in the last MessageDispatch object:\nActiveMQConsumer.cpp:973: lastMsg->getRedeliveryCounter()\n\n\nWith\nActiveMQConsumer.cpp:973: lastMsg->getMessage()->getRedeliveryCounter()\n\nthe MaximumRedeliveries parameter is used correctly.\n\n\nComments:\n", "classification": "Classify the issue 'redeliveryPolicy: rollback always loops' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-335?\nA: The MaximumRedeliveries parameter from redeliveryPolicy is broken when using transactions sessions:\non session rollback, the message is always redelivered, even if MaximumRedeliveries is not set to -1.\n\n\nThe issue is in ActiveMQConsumer::rollback() where the RedeliveryCounter is incremented in Message objects:\nActiveMQConsumer.cpp:969: message->setRedeliveryCounter(\n\nand the check is done in the l"}}
{"issue_key": "AMQCPP-334", "project": "AMQCPP", "title": "pkg-config output incorrect", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-11-23T23:37:46.000+0000", "updated": "2010-11-23T23:48:27.000+0000", "description": "The activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.", "comments": [], "text": "pkg-config output incorrect\n\nDescription:\nThe activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: pkg-config output incorrect\n\nDescription:\nThe activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.\n\nComments:\n", "classification": "Classify the issue 'pkg-config output incorrect' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-334?\nA: The activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a resu"}}
{"issue_key": "AMQCPP-333", "project": "AMQCPP", "title": "When disconnect MQ and try to reconnect, MqClient may crash", "status": "Closed", "reporter": "FangYu", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-11-23T08:36:04.000+0000", "updated": "2011-01-11T16:54:02.000+0000", "description": "This issue is found by my workmate, when disconnect the MqServer(stop server or cutdown the network), MqClient tried to reconnect the server, sometimes the client crash.here is the exception stack:\n\nexception code c0000005, flags 0 address 807d53 exception stack is:\nNetMgrServer.exe caused a EXCEPTION_ACCESS_VIOLATION in module activemq-cpp.dll at 001B:00807D53, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n\nEAX=04D0F300  EBX=04D0FA9C  ECX=00000000  EDX=04D0F4C8  ESI=02DE5320\nEDI=0058E700  EBP=04D0F4C0  ESP=04D0F12C  EIP=00807D53  FLG=00010206\nCS=001B   DS=0023  SS=0023  ES=0023   FS=003B  GS=0000\n\n001B:00807D53 (0x00903F80 0x02D4B400 0x02D8C930 0x00003A98) activemq-cpp.dll, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n001B:008092E7 (0x04D0F7B0 0x00003A98 0x176FD90E 0x0058E700) activemq-cpp.dll, activemq::core::ActiveMQConnection::disposeOf()+279 byte(s)\n001B:008094D5 (0x176FD89A 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::disconnect()+181 byte(s)\n001B:00809872 (0x176FDB26 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::close()+434 byte(s)\n001B:00809AEF (0x02DE5D28 0x04D0FAA8 0x0057D1E3 0x00000001) activemq-cpp.dll, activemq::core::ActiveMQConnection::~ActiveMQConnection()+111 byte(s)\n001B:00620830 (0x00000001 0x175A1078 0x005918A0 0x02DE5320) activemq-cpp.dll, decaf::lang::Comparable<activemq::commands::XATransactionId>::~Comparable<activemq::commands::XATransactionId>()+736 byte(s)\n001B:0057D1E3 (0x02DE5320 0x175A1068 0x02DE5320 0x04D0FF0C) NetManagerServer.dll, HPR_Guard::operator=()+49331 byte(s)\n001B:00578E83 (0x00000002 0x00001E30 0x00000000 0x00000000) NetManagerServer.dll, HPR_Guard::operator=()+32083 byte(s)\n001B:FFFFFFFE (0x001567E0 0x00156790 0x00000000 0x00000000) <UNKNOWN>", "comments": [], "text": "When disconnect MQ and try to reconnect, MqClient may crash\n\nDescription:\nThis issue is found by my workmate, when disconnect the MqServer(stop server or cutdown the network), MqClient tried to reconnect the server, sometimes the client crash.here is the exception stack:\n\nexception code c0000005, flags 0 address 807d53 exception stack is:\nNetMgrServer.exe caused a EXCEPTION_ACCESS_VIOLATION in module activemq-cpp.dll at 001B:00807D53, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n\nEAX=04D0F300  EBX=04D0FA9C  ECX=00000000  EDX=04D0F4C8  ESI=02DE5320\nEDI=0058E700  EBP=04D0F4C0  ESP=04D0F12C  EIP=00807D53  FLG=00010206\nCS=001B   DS=0023  SS=0023  ES=0023   FS=003B  GS=0000\n\n001B:00807D53 (0x00903F80 0x02D4B400 0x02D8C930 0x00003A98) activemq-cpp.dll, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n001B:008092E7 (0x04D0F7B0 0x00003A98 0x176FD90E 0x0058E700) activemq-cpp.dll, activemq::core::ActiveMQConnection::disposeOf()+279 byte(s)\n001B:008094D5 (0x176FD89A 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::disconnect()+181 byte(s)\n001B:00809872 (0x176FDB26 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::close()+434 byte(s)\n001B:00809AEF (0x02DE5D28 0x04D0FAA8 0x0057D1E3 0x00000001) activemq-cpp.dll, activemq::core::ActiveMQConnection::~ActiveMQConnection()+111 byte(s)\n001B:00620830 (0x00000001 0x175A1078 0x005918A0 0x02DE5320) activemq-cpp.dll, decaf::lang::Comparable<activemq::commands::XATransactionId>::~Comparable<activemq::commands::XATransactionId>()+736 byte(s)\n001B:0057D1E3 (0x02DE5320 0x175A1068 0x02DE5320 0x04D0FF0C) NetManagerServer.dll, HPR_Guard::operator=()+49331 byte(s)\n001B:00578E83 (0x00000002 0x00001E30 0x00000000 0x00000000) NetManagerServer.dll, HPR_Guard::operator=()+32083 byte(s)\n001B:FFFFFFFE (0x001567E0 0x00156790 0x00000000 0x00000000) <UNKNOWN>\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: When disconnect MQ and try to reconnect, MqClient may crash\n\nDescription:\nThis issue is found by my workmate, when disconnect the MqServer(stop server or cutdown the network), MqClient tried to reconnect the server, sometimes the client crash.here is the exception stack:\n\nexception code c0000005, flags 0 address 807d53 exception stack is:\nNetMgrServer.exe caused a EXCEPTION_ACCESS_VIOLATION in module activemq-cpp.dll at 001B:00807D53, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n\nEAX=04D0F300  EBX=04D0FA9C  ECX=00000000  EDX=04D0F4C8  ESI=02DE5320\nEDI=0058E700  EBP=04D0F4C0  ESP=04D0F12C  EIP=00807D53  FLG=00010206\nCS=001B   DS=0023  SS=0023  ES=0023   FS=003B  GS=0000\n\n001B:00807D53 (0x00903F80 0x02D4B400 0x02D8C930 0x00003A98) activemq-cpp.dll, activemq::core::ActiveMQConnection::syncRequest()+227 byte(s)\n001B:008092E7 (0x04D0F7B0 0x00003A98 0x176FD90E 0x0058E700) activemq-cpp.dll, activemq::core::ActiveMQConnection::disposeOf()+279 byte(s)\n001B:008094D5 (0x176FD89A 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::disconnect()+181 byte(s)\n001B:00809872 (0x176FDB26 0x0058E700 0x02DE5320 0x04D0FA9C) activemq-cpp.dll, activemq::core::ActiveMQConnection::close()+434 byte(s)\n001B:00809AEF (0x02DE5D28 0x04D0FAA8 0x0057D1E3 0x00000001) activemq-cpp.dll, activemq::core::ActiveMQConnection::~ActiveMQConnection()+111 byte(s)\n001B:00620830 (0x00000001 0x175A1078 0x005918A0 0x02DE5320) activemq-cpp.dll, decaf::lang::Comparable<activemq::commands::XATransactionId>::~Comparable<activemq::commands::XATransactionId>()+736 byte(s)\n001B:0057D1E3 (0x02DE5320 0x175A1068 0x02DE5320 0x04D0FF0C) NetManagerServer.dll, HPR_Guard::operator=()+49331 byte(s)\n001B:00578E83 (0x00000002 0x00001E30 0x00000000 0x00000000) NetManagerServer.dll, HPR_Guard::operator=()+32083 byte(s)\n001B:FFFFFFFE (0x001567E0 0x00156790 0x00000000 0x00000000) <UNKNOWN>\n\n\nComments:\n", "classification": "Classify the issue 'When disconnect MQ and try to reconnect, MqClient may crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-333?\nA: This issue is found by my workmate, when disconnect the MqServer(stop server or cutdown the network), MqClient tried to reconnect the server, sometimes the client crash.here is the exception stack:\n\nexception code c0000005, flags 0 address 807d53 exception stack is:\nNetMgrServer.exe caused a EXCEPTION_ACCESS_VIOLATION in module activemq-cpp.dll at 001B:00807D53, activemq::core::ActiveMQConnection:"}}
{"issue_key": "AMQCPP-332", "project": "AMQCPP", "title": "First send after we restart broker seems to always get a CmsException", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-11-22T19:25:54.000+0000", "updated": "2010-11-24T17:26:16.000+0000", "description": "First send after we restart broker seems to always get a CmsException.\n\nSteps to recreate the problem:\n(1) download and unzip the attached test program: BrokerMonitor2.zip. This program is very similar to the test program for jira item 328 with just a few modifications. (https://issues.apache.org/activemq/browse/AMQCPP-328)\n\n(2) Start broker\n\n(3) Run the test program. The test program will iterate for 10000 times. In each iteration, it will first send out a message, and then prompt you to enter a char to continue. Please do that and make sure that the first a few messages are sent without any problems.\n\n(4) Restart broker. Wait for a while,  Maybe 2-5 mins.\n\n(5) Enter a char for the test program to continue. Observe that the next send message gets a CmsException with the message \"Channel was inactive for too long\"", "comments": [], "text": "First send after we restart broker seems to always get a CmsException\n\nDescription:\nFirst send after we restart broker seems to always get a CmsException.\n\nSteps to recreate the problem:\n(1) download and unzip the attached test program: BrokerMonitor2.zip. This program is very similar to the test program for jira item 328 with just a few modifications. (https://issues.apache.org/activemq/browse/AMQCPP-328)\n\n(2) Start broker\n\n(3) Run the test program. The test program will iterate for 10000 times. In each iteration, it will first send out a message, and then prompt you to enter a char to continue. Please do that and make sure that the first a few messages are sent without any problems.\n\n(4) Restart broker. Wait for a while,  Maybe 2-5 mins.\n\n(5) Enter a char for the test program to continue. Observe that the next send message gets a CmsException with the message \"Channel was inactive for too long\"\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: First send after we restart broker seems to always get a CmsException\n\nDescription:\nFirst send after we restart broker seems to always get a CmsException.\n\nSteps to recreate the problem:\n(1) download and unzip the attached test program: BrokerMonitor2.zip. This program is very similar to the test program for jira item 328 with just a few modifications. (https://issues.apache.org/activemq/browse/AMQCPP-328)\n\n(2) Start broker\n\n(3) Run the test program. The test program will iterate for 10000 times. In each iteration, it will first send out a message, and then prompt you to enter a char to continue. Please do that and make sure that the first a few messages are sent without any problems.\n\n(4) Restart broker. Wait for a while,  Maybe 2-5 mins.\n\n(5) Enter a char for the test program to continue. Observe that the next send message gets a CmsException with the message \"Channel was inactive for too long\"\n\nComments:\n", "classification": "Classify the issue 'First send after we restart broker seems to always get a CmsException' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-332?\nA: First send after we restart broker seems to always get a CmsException.\n\nSteps to recreate the problem:\n(1) download and unzip the attached test program: BrokerMonitor2.zip. This program is very similar to the test program for jira item 328 with just a few modifications. (https://issues.apache.org/activemq/browse/AMQCPP-328)\n\n(2) Start broker\n\n(3) Run the test program. The test program will iterate"}}
{"issue_key": "AMQCPP-331", "project": "AMQCPP", "title": "Small typo in TcpTransportFactory.cpp", "status": "Resolved", "reporter": "Evan Kuhn", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-11-19T21:08:26.000+0000", "updated": "2010-11-19T21:21:58.000+0000", "description": "In /main/activemq/transport/tcp/TcpTransportFactory.cpp line 98, \"trnasport\" should be \"transport\":\n.\n\n{code}\nif( properties.getProperty( \"trnasport.useInactivityMonitor\", \"true\" ) == \"true\" ) {\n  transport.reset( new InactivityMonitor( transport, properties, wireFormat ) );\n}\n{code}", "comments": [], "text": "Small typo in TcpTransportFactory.cpp\n\nDescription:\nIn /main/activemq/transport/tcp/TcpTransportFactory.cpp line 98, \"trnasport\" should be \"transport\":\n.\n\n{code}\nif( properties.getProperty( \"trnasport.useInactivityMonitor\", \"true\" ) == \"true\" ) {\n  transport.reset( new InactivityMonitor( transport, properties, wireFormat ) );\n}\n{code}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Small typo in TcpTransportFactory.cpp\n\nDescription:\nIn /main/activemq/transport/tcp/TcpTransportFactory.cpp line 98, \"trnasport\" should be \"transport\":\n.\n\n{code}\nif( properties.getProperty( \"trnasport.useInactivityMonitor\", \"true\" ) == \"true\" ) {\n  transport.reset( new InactivityMonitor( transport, properties, wireFormat ) );\n}\n{code}\n\n\nComments:\n", "classification": "Classify the issue 'Small typo in TcpTransportFactory.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-331?\nA: In /main/activemq/transport/tcp/TcpTransportFactory.cpp line 98, \"trnasport\" should be \"transport\":\n.\n\n{code}\nif( properties.getProperty( \"trnasport.useInactivityMonitor\", \"true\" ) == \"true\" ) {\n  transport.reset( new InactivityMonitor( transport, properties, wireFormat ) );\n}\n{code}\n"}}
{"issue_key": "AMQCPP-330", "project": "AMQCPP", "title": "Unable to reinitialize ActiveMQ CMS library and then open a session", "status": "Resolved", "reporter": "Evan Kuhn", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-11-19T20:57:12.000+0000", "updated": "2010-12-05T17:10:10.000+0000", "description": "I'm working on a project that initializes and shuts down the ActiveMQ CMS library multiple times.  After upgrading from CMS 3.1.3 to 3.2.3, I noticed that my process crashes after these steps:\n\n1) Initialize ActiveMQ CMS library\n2) Create connection, session, etc and do work\n3) Shut down ActiveMQ CMS library\n4) Initialize ActiveMQ CMS library a second time\n5) Create a connection, then a session... crash\n\nFirst off, am I allowed to reinitialize the CMS library after shutting it down?  Is it recommended not to?\n\nEither way, the program crashes at:\n\n    /main/activemq/transport/tcp/TcpTransport.cpp line 163\n\nI believe the error is in  /main/decaf/net/SocketFactory.cpp.  The static SocketFactory::defaultFactory pointer (line 30) is set while creating the first session.  Then when shutting down the library, the Network object destroys the object pointed to by SocketFactory::defaultFactory.  The next time around, SocketFactory::getDefault() will try to use the pointer, but the factory object has been destroyed, so the process crashes.\n\nOne possible fix is to modify the SocketFactory destructor to set the defaultFactory pointer to NULL.  I have no idea if that's a good solution, though.\n\nI will attach a test program to reproduce the crash.", "comments": [], "text": "Unable to reinitialize ActiveMQ CMS library and then open a session\n\nDescription:\nI'm working on a project that initializes and shuts down the ActiveMQ CMS library multiple times.  After upgrading from CMS 3.1.3 to 3.2.3, I noticed that my process crashes after these steps:\n\n1) Initialize ActiveMQ CMS library\n2) Create connection, session, etc and do work\n3) Shut down ActiveMQ CMS library\n4) Initialize ActiveMQ CMS library a second time\n5) Create a connection, then a session... crash\n\nFirst off, am I allowed to reinitialize the CMS library after shutting it down?  Is it recommended not to?\n\nEither way, the program crashes at:\n\n    /main/activemq/transport/tcp/TcpTransport.cpp line 163\n\nI believe the error is in  /main/decaf/net/SocketFactory.cpp.  The static SocketFactory::defaultFactory pointer (line 30) is set while creating the first session.  Then when shutting down the library, the Network object destroys the object pointed to by SocketFactory::defaultFactory.  The next time around, SocketFactory::getDefault() will try to use the pointer, but the factory object has been destroyed, so the process crashes.\n\nOne possible fix is to modify the SocketFactory destructor to set the defaultFactory pointer to NULL.  I have no idea if that's a good solution, though.\n\nI will attach a test program to reproduce the crash.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unable to reinitialize ActiveMQ CMS library and then open a session\n\nDescription:\nI'm working on a project that initializes and shuts down the ActiveMQ CMS library multiple times.  After upgrading from CMS 3.1.3 to 3.2.3, I noticed that my process crashes after these steps:\n\n1) Initialize ActiveMQ CMS library\n2) Create connection, session, etc and do work\n3) Shut down ActiveMQ CMS library\n4) Initialize ActiveMQ CMS library a second time\n5) Create a connection, then a session... crash\n\nFirst off, am I allowed to reinitialize the CMS library after shutting it down?  Is it recommended not to?\n\nEither way, the program crashes at:\n\n    /main/activemq/transport/tcp/TcpTransport.cpp line 163\n\nI believe the error is in  /main/decaf/net/SocketFactory.cpp.  The static SocketFactory::defaultFactory pointer (line 30) is set while creating the first session.  Then when shutting down the library, the Network object destroys the object pointed to by SocketFactory::defaultFactory.  The next time around, SocketFactory::getDefault() will try to use the pointer, but the factory object has been destroyed, so the process crashes.\n\nOne possible fix is to modify the SocketFactory destructor to set the defaultFactory pointer to NULL.  I have no idea if that's a good solution, though.\n\nI will attach a test program to reproduce the crash.\n\nComments:\n", "classification": "Classify the issue 'Unable to reinitialize ActiveMQ CMS library and then open a session' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-330?\nA: I'm working on a project that initializes and shuts down the ActiveMQ CMS library multiple times.  After upgrading from CMS 3.1.3 to 3.2.3, I noticed that my process crashes after these steps:\n\n1) Initialize ActiveMQ CMS library\n2) Create connection, session, etc and do work\n3) Shut down ActiveMQ CMS library\n4) Initialize ActiveMQ CMS library a second time\n5) Create a connection, then a session..."}}
{"issue_key": "AMQCPP-329", "project": "AMQCPP", "title": "Add the ability to participate in XA Transactions", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-11-17T14:20:55.000+0000", "updated": "2010-11-18T23:04:23.000+0000", "description": "Create a JMS style XA Connection API to CMS and support XA in for openwire Connections.", "comments": [], "text": "Add the ability to participate in XA Transactions\n\nDescription:\nCreate a JMS style XA Connection API to CMS and support XA in for openwire Connections.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add the ability to participate in XA Transactions\n\nDescription:\nCreate a JMS style XA Connection API to CMS and support XA in for openwire Connections.\n\nComments:\n", "classification": "Classify the issue 'Add the ability to participate in XA Transactions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-329?\nA: Create a JMS style XA Connection API to CMS and support XA in for openwire Connections."}}
{"issue_key": "AMQCPP-328", "project": "AMQCPP", "title": "crash found in activemqcpp when turning broker offline", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-11-16T04:31:56.000+0000", "updated": "2011-01-11T16:55:05.000+0000", "description": "We found a crash in activemqcpp when we are shutting down the message broker.  In the meanwhile, our application is still trying to send messages to the broker, and to receive messages from it. Could you please take a look at this problem? Much thanks for your help! \n\nThe place of the crash appears to be in TransportFilter::Fire(Exception&) on line 49. The content of the address that the listener pointer is pointing to seems to be corrupted/garbage. Please see the call stack in the attached screen shot for details. \n\nAttached please also find a test program to reproduce the problem. Step to run the test program:\n(1) download and unzip test program\n(2) register GTOUD.dll\n(3) register CmsMessageHandlerCOMUD.dll\n(4) run CmsMessageHandlerCOMTest.exe\n(5) repeatedly restart activemqcpp broker. \n(6) observe the crash", "comments": [], "text": "crash found in activemqcpp when turning broker offline\n\nDescription:\nWe found a crash in activemqcpp when we are shutting down the message broker.  In the meanwhile, our application is still trying to send messages to the broker, and to receive messages from it. Could you please take a look at this problem? Much thanks for your help! \n\nThe place of the crash appears to be in TransportFilter::Fire(Exception&) on line 49. The content of the address that the listener pointer is pointing to seems to be corrupted/garbage. Please see the call stack in the attached screen shot for details. \n\nAttached please also find a test program to reproduce the problem. Step to run the test program:\n(1) download and unzip test program\n(2) register GTOUD.dll\n(3) register CmsMessageHandlerCOMUD.dll\n(4) run CmsMessageHandlerCOMTest.exe\n(5) repeatedly restart activemqcpp broker. \n(6) observe the crash\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: crash found in activemqcpp when turning broker offline\n\nDescription:\nWe found a crash in activemqcpp when we are shutting down the message broker.  In the meanwhile, our application is still trying to send messages to the broker, and to receive messages from it. Could you please take a look at this problem? Much thanks for your help! \n\nThe place of the crash appears to be in TransportFilter::Fire(Exception&) on line 49. The content of the address that the listener pointer is pointing to seems to be corrupted/garbage. Please see the call stack in the attached screen shot for details. \n\nAttached please also find a test program to reproduce the problem. Step to run the test program:\n(1) download and unzip test program\n(2) register GTOUD.dll\n(3) register CmsMessageHandlerCOMUD.dll\n(4) run CmsMessageHandlerCOMTest.exe\n(5) repeatedly restart activemqcpp broker. \n(6) observe the crash\n\n\nComments:\n", "classification": "Classify the issue 'crash found in activemqcpp when turning broker offline' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-328?\nA: We found a crash in activemqcpp when we are shutting down the message broker.  In the meanwhile, our application is still trying to send messages to the broker, and to receive messages from it. Could you please take a look at this problem? Much thanks for your help! \n\nThe place of the crash appears to be in TransportFilter::Fire(Exception&) on line 49. The content of the address that the listener "}}
{"issue_key": "AMQCPP-327", "project": "AMQCPP", "title": "SEGFAULT on shutdown with global variable AMQCPP references", "status": "Closed", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-11-09T17:27:33.000+0000", "updated": "2012-06-13T19:40:02.000+0000", "description": "If AMQ-CPP resources are managed by global variables and those global variables are not explicitly shutdown, the post-exit shutdown code ordering usually causes a segfault.  This is because the AMQ-CPP internal threads shutdown the apr library first and then the global variables attempt to close() their connections which result in apr calls.\n\nA simple program to demonstrate this is attached; when run it results in the segfault core trace:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n78\tatomic/unix/mutex.c: No such file or directory.\n\tin atomic/unix/mutex.c\n(gdb) bt\n#0  0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n#1  0xb72f7457 in apr_atomic_cas32 (mem=0x806089c, with=0, cmp=1) at atomic/unix/mutex.c:152\n#2  0xb7e35bca in decaf::util::concurrent::atomic::AtomicBoolean::compareAndSet (\n    this=0x8060898, expect=true, update=false)\n    at decaf/util/concurrent/atomic/AtomicBoolean.cpp:42\n#3  0xb7a51238 in activemq::core::ActiveMQConnection::stop (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:425\n#4  0xb7a56ad0 in activemq::core::ActiveMQConnection::close (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:355\n#5  0x08048adc in mgr::~mgr() ()\n#6  0x08048b6b in std::auto_ptr<mgr>::~auto_ptr() ()\n#7  0x08048974 in __tcf_1 ()\n#8  0xb7346529 in exit () from /System/Links/Libraries/libc.so.6\n\nNote: possibly related to AMQCPP-231.", "comments": [], "text": "SEGFAULT on shutdown with global variable AMQCPP references\n\nDescription:\nIf AMQ-CPP resources are managed by global variables and those global variables are not explicitly shutdown, the post-exit shutdown code ordering usually causes a segfault.  This is because the AMQ-CPP internal threads shutdown the apr library first and then the global variables attempt to close() their connections which result in apr calls.\n\nA simple program to demonstrate this is attached; when run it results in the segfault core trace:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n78\tatomic/unix/mutex.c: No such file or directory.\n\tin atomic/unix/mutex.c\n(gdb) bt\n#0  0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n#1  0xb72f7457 in apr_atomic_cas32 (mem=0x806089c, with=0, cmp=1) at atomic/unix/mutex.c:152\n#2  0xb7e35bca in decaf::util::concurrent::atomic::AtomicBoolean::compareAndSet (\n    this=0x8060898, expect=true, update=false)\n    at decaf/util/concurrent/atomic/AtomicBoolean.cpp:42\n#3  0xb7a51238 in activemq::core::ActiveMQConnection::stop (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:425\n#4  0xb7a56ad0 in activemq::core::ActiveMQConnection::close (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:355\n#5  0x08048adc in mgr::~mgr() ()\n#6  0x08048b6b in std::auto_ptr<mgr>::~auto_ptr() ()\n#7  0x08048974 in __tcf_1 ()\n#8  0xb7346529 in exit () from /System/Links/Libraries/libc.so.6\n\nNote: possibly related to AMQCPP-231.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SEGFAULT on shutdown with global variable AMQCPP references\n\nDescription:\nIf AMQ-CPP resources are managed by global variables and those global variables are not explicitly shutdown, the post-exit shutdown code ordering usually causes a segfault.  This is because the AMQ-CPP internal threads shutdown the apr library first and then the global variables attempt to close() their connections which result in apr calls.\n\nA simple program to demonstrate this is attached; when run it results in the segfault core trace:\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n78\tatomic/unix/mutex.c: No such file or directory.\n\tin atomic/unix/mutex.c\n(gdb) bt\n#0  0xb72f72fe in mutex_hash (mem=0x806089c) at atomic/unix/mutex.c:78\n#1  0xb72f7457 in apr_atomic_cas32 (mem=0x806089c, with=0, cmp=1) at atomic/unix/mutex.c:152\n#2  0xb7e35bca in decaf::util::concurrent::atomic::AtomicBoolean::compareAndSet (\n    this=0x8060898, expect=true, update=false)\n    at decaf/util/concurrent/atomic/AtomicBoolean.cpp:42\n#3  0xb7a51238 in activemq::core::ActiveMQConnection::stop (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:425\n#4  0xb7a56ad0 in activemq::core::ActiveMQConnection::close (this=0x8060880)\n    at activemq/core/ActiveMQConnection.cpp:355\n#5  0x08048adc in mgr::~mgr() ()\n#6  0x08048b6b in std::auto_ptr<mgr>::~auto_ptr() ()\n#7  0x08048974 in __tcf_1 ()\n#8  0xb7346529 in exit () from /System/Links/Libraries/libc.so.6\n\nNote: possibly related to AMQCPP-231.\n\n\nComments:\n", "classification": "Classify the issue 'SEGFAULT on shutdown with global variable AMQCPP references' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-327?\nA: If AMQ-CPP resources are managed by global variables and those global variables are not explicitly shutdown, the post-exit shutdown code ordering usually causes a segfault.  This is because the AMQ-CPP internal threads shutdown the apr library first and then the global variables attempt to close() their connections which result in apr calls.\n\nA simple program to demonstrate this is attached; when "}}
{"issue_key": "AMQCPP-326", "project": "AMQCPP", "title": "Returning std::string across a dll boundary in getTopicName causes crash", "status": "Closed", "reporter": "Brian McKinnon", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-11-02T18:48:29.000+0000", "updated": "2010-11-02T20:24:29.000+0000", "description": "The C4 game engine has recently implemented there own memory management module overloading the new and delete operations.  As a result the std::string returned by cms::Topic::getTopicName causes the system to crash.   The custom memory manager renders the simple solution of including the same msvc runtime dll unusable. A solution would be to implement a void cms::Topic::getTopicName(std::string & name) function instead or in addition to the existing function.", "comments": [], "text": "Returning std::string across a dll boundary in getTopicName causes crash\n\nDescription:\nThe C4 game engine has recently implemented there own memory management module overloading the new and delete operations.  As a result the std::string returned by cms::Topic::getTopicName causes the system to crash.   The custom memory manager renders the simple solution of including the same msvc runtime dll unusable. A solution would be to implement a void cms::Topic::getTopicName(std::string & name) function instead or in addition to the existing function.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Returning std::string across a dll boundary in getTopicName causes crash\n\nDescription:\nThe C4 game engine has recently implemented there own memory management module overloading the new and delete operations.  As a result the std::string returned by cms::Topic::getTopicName causes the system to crash.   The custom memory manager renders the simple solution of including the same msvc runtime dll unusable. A solution would be to implement a void cms::Topic::getTopicName(std::string & name) function instead or in addition to the existing function.\n\nComments:\n", "classification": "Classify the issue 'Returning std::string across a dll boundary in getTopicName causes crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-326?\nA: The C4 game engine has recently implemented there own memory management module overloading the new and delete operations.  As a result the std::string returned by cms::Topic::getTopicName causes the system to crash.   The custom memory manager renders the simple solution of including the same msvc runtime dll unusable. A solution would be to implement a void cms::Topic::getTopicName(std::string & "}}
{"issue_key": "AMQCPP-325", "project": "AMQCPP", "title": "Failover transport exception can cause CPU spin", "status": "Closed", "reporter": "FangYu", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-11-02T05:03:03.000+0000", "updated": "2010-11-04T20:17:26.000+0000", "description": "We find that when use the failover transport to connect the broker, if failed to connect, then the thread will not release and become a DEADLESS LOOP cause CPU spin.\n\nSee the source code:\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\transport\\failover\\failovertransport.cpp\n500 bool FailoverTransport::iterate() {\n......................................................................\n510        if( connectedTransport != NULL || closed || connectionFailure != NULL ) {\n511            return false;\n......................................................................\n702 }\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\threads\\compositetaskrunner.cpp\n97 void CompositeTaskRunner::run() {\n98 \n99     try {\n100 \n101         while( true ) {\n102 \n103            synchronized( &mutex ) {\n104                 pending = false;\n105                 if( shutDown ) {\n106                     return;\n107                  }\n108              }\n109 \n110             if( !this->iterate() ) {\n111 \n112                 // wait to be notified.\n113                 synchronized( &mutex ) {\n114                     if( shutDown ) {\n115                         return;\n116                     }\n117                     while( !pending ) {\n118                         mutex.wait();\n119                     }\n120                 }\n121             }\n122         }\n123     }\n124     AMQ_CATCH_NOTHROW( Exception )\n125     AMQ_CATCHALL_NOTHROW()\n126 \n127     // Make sure we notify any waiting threads that thread\n128     // has terminated.\n129     synchronized( &mutex ) {\n130         threadTerminated = true;\n131         mutex.notifyAll();\n132     }\n133 }\n\n............................................................................\n\n160 bool CompositeTaskRunner::iterate() {\n161\n162     synchronized( &tasks ) {\n163 \n164         auto_ptr< Iterator<CompositeTask*> > iter( tasks.iterator() );\n165 \n166         while( iter->hasNext() ) {\n167 \n168             CompositeTask* task = iter->next();\n169 \n170            if( task->isPending() ) {\n171                task->iterate() ;\n173\n174                // Always return true, so that we check again for\n175                // any of the other tasks that might now be pending.\n176                return true;\n177            }\n178        }\n179     }\n180 \n181     return false;\n182 }", "comments": [], "text": "Failover transport exception can cause CPU spin\n\nDescription:\nWe find that when use the failover transport to connect the broker, if failed to connect, then the thread will not release and become a DEADLESS LOOP cause CPU spin.\n\nSee the source code:\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\transport\\failover\\failovertransport.cpp\n500 bool FailoverTransport::iterate() {\n......................................................................\n510        if( connectedTransport != NULL || closed || connectionFailure != NULL ) {\n511            return false;\n......................................................................\n702 }\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\threads\\compositetaskrunner.cpp\n97 void CompositeTaskRunner::run() {\n98 \n99     try {\n100 \n101         while( true ) {\n102 \n103            synchronized( &mutex ) {\n104                 pending = false;\n105                 if( shutDown ) {\n106                     return;\n107                  }\n108              }\n109 \n110             if( !this->iterate() ) {\n111 \n112                 // wait to be notified.\n113                 synchronized( &mutex ) {\n114                     if( shutDown ) {\n115                         return;\n116                     }\n117                     while( !pending ) {\n118                         mutex.wait();\n119                     }\n120                 }\n121             }\n122         }\n123     }\n124     AMQ_CATCH_NOTHROW( Exception )\n125     AMQ_CATCHALL_NOTHROW()\n126 \n127     // Make sure we notify any waiting threads that thread\n128     // has terminated.\n129     synchronized( &mutex ) {\n130         threadTerminated = true;\n131         mutex.notifyAll();\n132     }\n133 }\n\n............................................................................\n\n160 bool CompositeTaskRunner::iterate() {\n161\n162     synchronized( &tasks ) {\n163 \n164         auto_ptr< Iterator<CompositeTask*> > iter( tasks.iterator() );\n165 \n166         while( iter->hasNext() ) {\n167 \n168             CompositeTask* task = iter->next();\n169 \n170            if( task->isPending() ) {\n171                task->iterate() ;\n173\n174                // Always return true, so that we check again for\n175                // any of the other tasks that might now be pending.\n176                return true;\n177            }\n178        }\n179     }\n180 \n181     return false;\n182 }\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover transport exception can cause CPU spin\n\nDescription:\nWe find that when use the failover transport to connect the broker, if failed to connect, then the thread will not release and become a DEADLESS LOOP cause CPU spin.\n\nSee the source code:\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\transport\\failover\\failovertransport.cpp\n500 bool FailoverTransport::iterate() {\n......................................................................\n510        if( connectedTransport != NULL || closed || connectionFailure != NULL ) {\n511            return false;\n......................................................................\n702 }\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\threads\\compositetaskrunner.cpp\n97 void CompositeTaskRunner::run() {\n98 \n99     try {\n100 \n101         while( true ) {\n102 \n103            synchronized( &mutex ) {\n104                 pending = false;\n105                 if( shutDown ) {\n106                     return;\n107                  }\n108              }\n109 \n110             if( !this->iterate() ) {\n111 \n112                 // wait to be notified.\n113                 synchronized( &mutex ) {\n114                     if( shutDown ) {\n115                         return;\n116                     }\n117                     while( !pending ) {\n118                         mutex.wait();\n119                     }\n120                 }\n121             }\n122         }\n123     }\n124     AMQ_CATCH_NOTHROW( Exception )\n125     AMQ_CATCHALL_NOTHROW()\n126 \n127     // Make sure we notify any waiting threads that thread\n128     // has terminated.\n129     synchronized( &mutex ) {\n130         threadTerminated = true;\n131         mutex.notifyAll();\n132     }\n133 }\n\n............................................................................\n\n160 bool CompositeTaskRunner::iterate() {\n161\n162     synchronized( &tasks ) {\n163 \n164         auto_ptr< Iterator<CompositeTask*> > iter( tasks.iterator() );\n165 \n166         while( iter->hasNext() ) {\n167 \n168             CompositeTask* task = iter->next();\n169 \n170            if( task->isPending() ) {\n171                task->iterate() ;\n173\n174                // Always return true, so that we check again for\n175                // any of the other tasks that might now be pending.\n176                return true;\n177            }\n178        }\n179     }\n180 \n181     return false;\n182 }\n\n\nComments:\n", "classification": "Classify the issue 'Failover transport exception can cause CPU spin' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-325?\nA: We find that when use the failover transport to connect the broker, if failed to connect, then the thread will not release and become a DEADLESS LOOP cause CPU spin.\n\nSee the source code:\n\nfile: ~\\activemq-cpp-library-3.2.3\\src\\main\\activemq\\transport\\failover\\failovertransport.cpp\n500 bool FailoverTransport::iterate() {\n......................................................................\n510   "}}
{"issue_key": "AMQCPP-324", "project": "AMQCPP", "title": "Destination options are ignored", "status": "Resolved", "reporter": "Mike Slegeir", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-10-22T20:51:39.000+0000", "updated": "2010-10-22T21:27:48.000+0000", "description": "It seems that any options set on a destination, although read, are ultimately ignored.\nIn this case, I was trying to set consumer.prefetchSize on a single queue that I was consuming.  However, the setting was never applied.  Stepping through, I saw that the setting was read and stored in the destination's properties.  But when the session created the consumer, it only checked the connection's prefetch.\nAfter further investigation, it seems that the problem is that ActiveMQConsumer::applyDestinationOptions is never called.  Adding the call applyDestinationOptions( consumerInfo ); to the end of the ActiveMQConsumer seems to fix the problem for me.  However, I would imagine that destination options for producers are ignored, but I didn't look into that as it's not been an issue yet.", "comments": [], "text": "Destination options are ignored\n\nDescription:\nIt seems that any options set on a destination, although read, are ultimately ignored.\nIn this case, I was trying to set consumer.prefetchSize on a single queue that I was consuming.  However, the setting was never applied.  Stepping through, I saw that the setting was read and stored in the destination's properties.  But when the session created the consumer, it only checked the connection's prefetch.\nAfter further investigation, it seems that the problem is that ActiveMQConsumer::applyDestinationOptions is never called.  Adding the call applyDestinationOptions( consumerInfo ); to the end of the ActiveMQConsumer seems to fix the problem for me.  However, I would imagine that destination options for producers are ignored, but I didn't look into that as it's not been an issue yet.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Destination options are ignored\n\nDescription:\nIt seems that any options set on a destination, although read, are ultimately ignored.\nIn this case, I was trying to set consumer.prefetchSize on a single queue that I was consuming.  However, the setting was never applied.  Stepping through, I saw that the setting was read and stored in the destination's properties.  But when the session created the consumer, it only checked the connection's prefetch.\nAfter further investigation, it seems that the problem is that ActiveMQConsumer::applyDestinationOptions is never called.  Adding the call applyDestinationOptions( consumerInfo ); to the end of the ActiveMQConsumer seems to fix the problem for me.  However, I would imagine that destination options for producers are ignored, but I didn't look into that as it's not been an issue yet.\n\nComments:\n", "classification": "Classify the issue 'Destination options are ignored' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-324?\nA: It seems that any options set on a destination, although read, are ultimately ignored.\nIn this case, I was trying to set consumer.prefetchSize on a single queue that I was consuming.  However, the setting was never applied.  Stepping through, I saw that the setting was read and stored in the destination's properties.  But when the session created the consumer, it only checked the connection's pref"}}
{"issue_key": "AMQCPP-323", "project": "AMQCPP", "title": "The OnException method of registered Exception listener is not called when broker is stopped.", "status": "Resolved", "reporter": "Hal Henderson", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-10-21T15:21:57.000+0000", "updated": "2010-10-21T15:59:38.000+0000", "description": "In order to reconnect when the broker is stopped, our application registers an exception listener by calling ActiveMQConnection::setExceptionListener.  Previously, we used activemq-cpp 3.0.1 which would call our applications onException method whenever the broker was stopped.  Our onException method cleans up the connection and attempts create a new connection until it is successful.  This worked fine with activemq-cpp 3.0.1.\n\nWe recently changed our application to use activemq-cpp 3.2.2.  We found that with this version of activemq-cpp (and no changes to our application) our onException method is not called when the broker is stopped.  The result is that our application can not send or receive any message without restarting the application.\n\nWe debugged the problem and found that in the class ConnectionConfig (ActiveMQConnection.cpp) there are two cms::ExceptionListener instance variables: defaultListener and exceptionListener. The method ActiveMQConnection::setExceptionListener sets defaultListener to the input listener object.  However, the method ActiveMQConnection::fire calls the onException method of exceptionListener (if it is not NULL).   As far as I could see there is no way for exceptionListener to be set to anything but NULL.\n\nThe fix proposed fix is to remove defaultListener and to replace all uses of  defaultListener with exceptionListener.  After making the proposed change, the OnException method is getting called as expected.\n\nThe diff of ActiveMQConnection.cpp are as follows:\n\nActiveMQConnection.cpp\n@@ -109,7 +109,6 @@\n         unsigned int closeTimeout;\n         unsigned int producerWindowSize;\n \n-        cms::ExceptionListener* defaultListener;\n         std::auto_ptr<PrefetchPolicy> defaultPrefetchPolicy;\n         std::auto_ptr<RedeliveryPolicy> defaultRedeliveryPolicy;\n \n@@ -130,7 +129,6 @@\n                              sendTimeout( 0 ),\n                              closeTimeout( 15000 ),\n                              producerWindowSize( 0 ),\n-                             defaultListener( NULL ),\n                              defaultPrefetchPolicy( NULL ),\n                              defaultRedeliveryPolicy( NULL ),\n                              exceptionListener( NULL ) {\n@@ -965,12 +963,12 @@\n \n ////////////////////////////////////////////////////////////////////////////////\n void ActiveMQConnection::setExceptionListener( cms::ExceptionListener* listener ) {\n-    this->config->defaultListener = listener;\n+    this->config->exceptionListener = listener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n cms::ExceptionListener* ActiveMQConnection::getExceptionListener() const {\n-    return this->config->defaultListener;\n+      return this->config->exceptionListener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////", "comments": [], "text": "The OnException method of registered Exception listener is not called when broker is stopped.\n\nDescription:\nIn order to reconnect when the broker is stopped, our application registers an exception listener by calling ActiveMQConnection::setExceptionListener.  Previously, we used activemq-cpp 3.0.1 which would call our applications onException method whenever the broker was stopped.  Our onException method cleans up the connection and attempts create a new connection until it is successful.  This worked fine with activemq-cpp 3.0.1.\n\nWe recently changed our application to use activemq-cpp 3.2.2.  We found that with this version of activemq-cpp (and no changes to our application) our onException method is not called when the broker is stopped.  The result is that our application can not send or receive any message without restarting the application.\n\nWe debugged the problem and found that in the class ConnectionConfig (ActiveMQConnection.cpp) there are two cms::ExceptionListener instance variables: defaultListener and exceptionListener. The method ActiveMQConnection::setExceptionListener sets defaultListener to the input listener object.  However, the method ActiveMQConnection::fire calls the onException method of exceptionListener (if it is not NULL).   As far as I could see there is no way for exceptionListener to be set to anything but NULL.\n\nThe fix proposed fix is to remove defaultListener and to replace all uses of  defaultListener with exceptionListener.  After making the proposed change, the OnException method is getting called as expected.\n\nThe diff of ActiveMQConnection.cpp are as follows:\n\nActiveMQConnection.cpp\n@@ -109,7 +109,6 @@\n         unsigned int closeTimeout;\n         unsigned int producerWindowSize;\n \n-        cms::ExceptionListener* defaultListener;\n         std::auto_ptr<PrefetchPolicy> defaultPrefetchPolicy;\n         std::auto_ptr<RedeliveryPolicy> defaultRedeliveryPolicy;\n \n@@ -130,7 +129,6 @@\n                              sendTimeout( 0 ),\n                              closeTimeout( 15000 ),\n                              producerWindowSize( 0 ),\n-                             defaultListener( NULL ),\n                              defaultPrefetchPolicy( NULL ),\n                              defaultRedeliveryPolicy( NULL ),\n                              exceptionListener( NULL ) {\n@@ -965,12 +963,12 @@\n \n ////////////////////////////////////////////////////////////////////////////////\n void ActiveMQConnection::setExceptionListener( cms::ExceptionListener* listener ) {\n-    this->config->defaultListener = listener;\n+    this->config->exceptionListener = listener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n cms::ExceptionListener* ActiveMQConnection::getExceptionListener() const {\n-    return this->config->defaultListener;\n+      return this->config->exceptionListener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The OnException method of registered Exception listener is not called when broker is stopped.\n\nDescription:\nIn order to reconnect when the broker is stopped, our application registers an exception listener by calling ActiveMQConnection::setExceptionListener.  Previously, we used activemq-cpp 3.0.1 which would call our applications onException method whenever the broker was stopped.  Our onException method cleans up the connection and attempts create a new connection until it is successful.  This worked fine with activemq-cpp 3.0.1.\n\nWe recently changed our application to use activemq-cpp 3.2.2.  We found that with this version of activemq-cpp (and no changes to our application) our onException method is not called when the broker is stopped.  The result is that our application can not send or receive any message without restarting the application.\n\nWe debugged the problem and found that in the class ConnectionConfig (ActiveMQConnection.cpp) there are two cms::ExceptionListener instance variables: defaultListener and exceptionListener. The method ActiveMQConnection::setExceptionListener sets defaultListener to the input listener object.  However, the method ActiveMQConnection::fire calls the onException method of exceptionListener (if it is not NULL).   As far as I could see there is no way for exceptionListener to be set to anything but NULL.\n\nThe fix proposed fix is to remove defaultListener and to replace all uses of  defaultListener with exceptionListener.  After making the proposed change, the OnException method is getting called as expected.\n\nThe diff of ActiveMQConnection.cpp are as follows:\n\nActiveMQConnection.cpp\n@@ -109,7 +109,6 @@\n         unsigned int closeTimeout;\n         unsigned int producerWindowSize;\n \n-        cms::ExceptionListener* defaultListener;\n         std::auto_ptr<PrefetchPolicy> defaultPrefetchPolicy;\n         std::auto_ptr<RedeliveryPolicy> defaultRedeliveryPolicy;\n \n@@ -130,7 +129,6 @@\n                              sendTimeout( 0 ),\n                              closeTimeout( 15000 ),\n                              producerWindowSize( 0 ),\n-                             defaultListener( NULL ),\n                              defaultPrefetchPolicy( NULL ),\n                              defaultRedeliveryPolicy( NULL ),\n                              exceptionListener( NULL ) {\n@@ -965,12 +963,12 @@\n \n ////////////////////////////////////////////////////////////////////////////////\n void ActiveMQConnection::setExceptionListener( cms::ExceptionListener* listener ) {\n-    this->config->defaultListener = listener;\n+    this->config->exceptionListener = listener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n cms::ExceptionListener* ActiveMQConnection::getExceptionListener() const {\n-    return this->config->defaultListener;\n+      return this->config->exceptionListener;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n\nComments:\n", "classification": "Classify the issue 'The OnException method of registered Exception listener is not called when broker is stopped.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-323?\nA: In order to reconnect when the broker is stopped, our application registers an exception listener by calling ActiveMQConnection::setExceptionListener.  Previously, we used activemq-cpp 3.0.1 which would call our applications onException method whenever the broker was stopped.  Our onException method cleans up the connection and attempts create a new connection until it is successful.  This worked "}}
{"issue_key": "AMQCPP-322", "project": "AMQCPP", "title": "Found memory leaks in ActiveMQCPP", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-10-21T13:28:52.000+0000", "updated": "2010-10-27T13:01:47.000+0000", "description": "We found a large number of memory leaks in ActiveMQCPP and APR while we ran DevPartner error detection. We are wondering if  you can fix them in branch 3.2.4? Thank you very much for your help in advance!\n\nWe saved a copy of the error detection report. Attached please find the file.  Also we did restart the message broker during our test.", "comments": [], "text": "Found memory leaks in ActiveMQCPP\n\nDescription:\nWe found a large number of memory leaks in ActiveMQCPP and APR while we ran DevPartner error detection. We are wondering if  you can fix them in branch 3.2.4? Thank you very much for your help in advance!\n\nWe saved a copy of the error detection report. Attached please find the file.  Also we did restart the message broker during our test. \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Found memory leaks in ActiveMQCPP\n\nDescription:\nWe found a large number of memory leaks in ActiveMQCPP and APR while we ran DevPartner error detection. We are wondering if  you can fix them in branch 3.2.4? Thank you very much for your help in advance!\n\nWe saved a copy of the error detection report. Attached please find the file.  Also we did restart the message broker during our test. \n\n\n\nComments:\n", "classification": "Classify the issue 'Found memory leaks in ActiveMQCPP' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-322?\nA: We found a large number of memory leaks in ActiveMQCPP and APR while we ran DevPartner error detection. We are wondering if  you can fix them in branch 3.2.4? Thank you very much for your help in advance!\n\nWe saved a copy of the error detection report. Attached please find the file.  Also we did restart the message broker during our test. \n\n"}}
{"issue_key": "AMQCPP-321", "project": "AMQCPP", "title": "Created separate producer and consumer examples", "status": "Resolved", "reporter": "Scott Cranton", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-10-14T16:24:33.000+0000", "updated": "2011-02-07T20:13:17.000+0000", "description": "split example into separate producer and consumer to make easier to test against Java clients", "comments": [], "text": "Created separate producer and consumer examples\n\nDescription:\nsplit example into separate producer and consumer to make easier to test against Java clients\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Created separate producer and consumer examples\n\nDescription:\nsplit example into separate producer and consumer to make easier to test against Java clients\n\nComments:\n", "classification": "Classify the issue 'Created separate producer and consumer examples' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-321?\nA: split example into separate producer and consumer to make easier to test against Java clients"}}
{"issue_key": "AMQCPP-320", "project": "AMQCPP", "title": "Memory leak or inconsistent documentation", "status": "Closed", "reporter": "Zach DeLuca", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-10-06T19:54:47.000+0000", "updated": "2010-10-20T15:49:29.000+0000", "description": "The documentation of getBodyBytes() for ActiveMQBytesMessage states \"Gets the bytes that are contained in this message, *user should copy this data into a user allocated buffer*.\" However, the implementation allocates and returns a pointer to a new buffer.", "comments": [], "text": "Memory leak or inconsistent documentation\n\nDescription:\nThe documentation of getBodyBytes() for ActiveMQBytesMessage states \"Gets the bytes that are contained in this message, *user should copy this data into a user allocated buffer*.\" However, the implementation allocates and returns a pointer to a new buffer.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak or inconsistent documentation\n\nDescription:\nThe documentation of getBodyBytes() for ActiveMQBytesMessage states \"Gets the bytes that are contained in this message, *user should copy this data into a user allocated buffer*.\" However, the implementation allocates and returns a pointer to a new buffer.\n\nComments:\n", "classification": "Classify the issue 'Memory leak or inconsistent documentation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-320?\nA: The documentation of getBodyBytes() for ActiveMQBytesMessage states \"Gets the bytes that are contained in this message, *user should copy this data into a user allocated buffer*.\" However, the implementation allocates and returns a pointer to a new buffer."}}
{"issue_key": "AMQCPP-319", "project": "AMQCPP", "title": "Add equals method to the CMS Destination interface to allow opaque compare of Destination instances.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-09-30T18:36:01.000+0000", "updated": "2010-10-04T15:23:47.000+0000", "description": "CMS Destinations aren't currently comparable without casting into the activemq::commands::ActiveMQDestination class.  Adding an equals method into the CMS Destination class makes this unnecessary and hides the provider implementation details.", "comments": [], "text": "Add equals method to the CMS Destination interface to allow opaque compare of Destination instances.\n\nDescription:\nCMS Destinations aren't currently comparable without casting into the activemq::commands::ActiveMQDestination class.  Adding an equals method into the CMS Destination class makes this unnecessary and hides the provider implementation details.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add equals method to the CMS Destination interface to allow opaque compare of Destination instances.\n\nDescription:\nCMS Destinations aren't currently comparable without casting into the activemq::commands::ActiveMQDestination class.  Adding an equals method into the CMS Destination class makes this unnecessary and hides the provider implementation details.\n\nComments:\n", "classification": "Classify the issue 'Add equals method to the CMS Destination interface to allow opaque compare of Destination instances.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-319?\nA: CMS Destinations aren't currently comparable without casting into the activemq::commands::ActiveMQDestination class.  Adding an equals method into the CMS Destination class makes this unnecessary and hides the provider implementation details."}}
{"issue_key": "AMQCPP-318", "project": "AMQCPP", "title": "Missing preprocessor definitions in Release SSL profile can cause the build to fail", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-09-29T13:09:41.000+0000", "updated": "2010-09-29T13:10:57.000+0000", "description": "The VS2008 project file is missing some preprocessor defines that can cause the build to fail.", "comments": [], "text": "Missing preprocessor definitions in Release SSL profile can cause the build to fail\n\nDescription:\nThe VS2008 project file is missing some preprocessor defines that can cause the build to fail.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Missing preprocessor definitions in Release SSL profile can cause the build to fail\n\nDescription:\nThe VS2008 project file is missing some preprocessor defines that can cause the build to fail.\n\nComments:\n", "classification": "Classify the issue 'Missing preprocessor definitions in Release SSL profile can cause the build to fail' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-318?\nA: The VS2008 project file is missing some preprocessor defines that can cause the build to fail."}}
{"issue_key": "AMQCPP-317", "project": "AMQCPP", "title": "activemq-cpp 3.2.2  will not work with activemq 5.4.0 broker using Stomp", "status": "Resolved", "reporter": "Scott Watson", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-09-13T23:48:30.000+0000", "updated": "2010-09-14T15:32:36.000+0000", "description": "I deployed activemq server on Windows 7 with JDK 1.6.0_20 and executed it using the command:\n\nbin\\activemq xbean:activemq-stomp.xml\n\nThe server started up with no problems and reported stomp+nio listening at port 61612 and stomp listening at port 61613.\n\nI also built the activemq-cpp solution using Visual C++ 2008 on Windows 7 and using the Debug configuration with the\nMultithreaded Debug runtime for all libraries and the executable.\n\nI only changed line 387 in the file main.cpp, from:\n\"failover:(tcp://localhost:61616\"\nto\n\"tcp://127.0.0.1:61613?wireFormat=stomp\"\n(note: also tried it with port 61612 with same results)\n\nExecuted activemq-cpp-example project and the Producer connected properly and sent its messages.  I could\nsee the messages enqueued in the http web console.  The Consumer, however, did connect (could see 1\nconsumer listed under the \"Queues\" section of the http web console) but did not dequeue any messages,\nnor did it report receiving any in its command prompt window.\n\nI put a breakpoint in the OnMessage method and saw that it was never being called.\n\nI then changed the code to use OpenWire by changing the above line to:\n\"tcp://127.0.0.1:61616\"\n\nI then executed activemq using the command:\n\nbin\\activemq xbean:activemq-demo.xml\n\nand then executed the activemq-cpp-example project.  It functioned perfectly with both consumer\nand producer reporting success.", "comments": [], "text": "activemq-cpp 3.2.2  will not work with activemq 5.4.0 broker using Stomp\n\nDescription:\nI deployed activemq server on Windows 7 with JDK 1.6.0_20 and executed it using the command:\n\nbin\\activemq xbean:activemq-stomp.xml\n\nThe server started up with no problems and reported stomp+nio listening at port 61612 and stomp listening at port 61613.\n\nI also built the activemq-cpp solution using Visual C++ 2008 on Windows 7 and using the Debug configuration with the\nMultithreaded Debug runtime for all libraries and the executable.\n\nI only changed line 387 in the file main.cpp, from:\n\"failover:(tcp://localhost:61616\"\nto\n\"tcp://127.0.0.1:61613?wireFormat=stomp\"\n(note: also tried it with port 61612 with same results)\n\nExecuted activemq-cpp-example project and the Producer connected properly and sent its messages.  I could\nsee the messages enqueued in the http web console.  The Consumer, however, did connect (could see 1\nconsumer listed under the \"Queues\" section of the http web console) but did not dequeue any messages,\nnor did it report receiving any in its command prompt window.\n\nI put a breakpoint in the OnMessage method and saw that it was never being called.\n\nI then changed the code to use OpenWire by changing the above line to:\n\"tcp://127.0.0.1:61616\"\n\nI then executed activemq using the command:\n\nbin\\activemq xbean:activemq-demo.xml\n\nand then executed the activemq-cpp-example project.  It functioned perfectly with both consumer\nand producer reporting success.\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cpp 3.2.2  will not work with activemq 5.4.0 broker using Stomp\n\nDescription:\nI deployed activemq server on Windows 7 with JDK 1.6.0_20 and executed it using the command:\n\nbin\\activemq xbean:activemq-stomp.xml\n\nThe server started up with no problems and reported stomp+nio listening at port 61612 and stomp listening at port 61613.\n\nI also built the activemq-cpp solution using Visual C++ 2008 on Windows 7 and using the Debug configuration with the\nMultithreaded Debug runtime for all libraries and the executable.\n\nI only changed line 387 in the file main.cpp, from:\n\"failover:(tcp://localhost:61616\"\nto\n\"tcp://127.0.0.1:61613?wireFormat=stomp\"\n(note: also tried it with port 61612 with same results)\n\nExecuted activemq-cpp-example project and the Producer connected properly and sent its messages.  I could\nsee the messages enqueued in the http web console.  The Consumer, however, did connect (could see 1\nconsumer listed under the \"Queues\" section of the http web console) but did not dequeue any messages,\nnor did it report receiving any in its command prompt window.\n\nI put a breakpoint in the OnMessage method and saw that it was never being called.\n\nI then changed the code to use OpenWire by changing the above line to:\n\"tcp://127.0.0.1:61616\"\n\nI then executed activemq using the command:\n\nbin\\activemq xbean:activemq-demo.xml\n\nand then executed the activemq-cpp-example project.  It functioned perfectly with both consumer\nand producer reporting success.\n\n\n\n\nComments:\n", "classification": "Classify the issue 'activemq-cpp 3.2.2  will not work with activemq 5.4.0 broker using Stomp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-317?\nA: I deployed activemq server on Windows 7 with JDK 1.6.0_20 and executed it using the command:\n\nbin\\activemq xbean:activemq-stomp.xml\n\nThe server started up with no problems and reported stomp+nio listening at port 61612 and stomp listening at port 61613.\n\nI also built the activemq-cpp solution using Visual C++ 2008 on Windows 7 and using the Debug configuration with the\nMultithreaded Debug runtime "}}
{"issue_key": "AMQCPP-316", "project": "AMQCPP", "title": "Unable to receive any messages after re-starting message broker", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2010-09-13T16:02:52.000+0000", "updated": "2011-01-25T19:39:41.000+0000", "description": "We developed two applications that use CmsTemplate to send and receive messages. The sender application is called MessageSender, and the receiver application is called MessageListener. We found that the MessageListener is unable to receive any messages after we re-start the message broker.\n\nThe followings are the steps to recreate the problem:\n(1) start the activemq message broker,\n(2) start MessageListener and MessageSender, and observe that messages are being sent and received successfully.\n(3) stop the message broker without stopping MessageListener and MessageSender. Wait for a while (for about a minute or two)\n(4) start the message broker again.\n\nWe expect we can send and receive messages successfully after step (4), but the MessageListener can never receive any messages any more. Also from the activemq admin page, we find that the consumer of the topic is gone. We did the test with url \"?keepAlive=true&wireFormat.maxInactivityDuration=0\", but it did not work.", "comments": [], "text": "Unable to receive any messages after re-starting message broker\n\nDescription:\nWe developed two applications that use CmsTemplate to send and receive messages. The sender application is called MessageSender, and the receiver application is called MessageListener. We found that the MessageListener is unable to receive any messages after we re-start the message broker.\n\nThe followings are the steps to recreate the problem:\n(1) start the activemq message broker,\n(2) start MessageListener and MessageSender, and observe that messages are being sent and received successfully.\n(3) stop the message broker without stopping MessageListener and MessageSender. Wait for a while (for about a minute or two)\n(4) start the message broker again.\n\nWe expect we can send and receive messages successfully after step (4), but the MessageListener can never receive any messages any more. Also from the activemq admin page, we find that the consumer of the topic is gone. We did the test with url \"?keepAlive=true&wireFormat.maxInactivityDuration=0\", but it did not work.\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unable to receive any messages after re-starting message broker\n\nDescription:\nWe developed two applications that use CmsTemplate to send and receive messages. The sender application is called MessageSender, and the receiver application is called MessageListener. We found that the MessageListener is unable to receive any messages after we re-start the message broker.\n\nThe followings are the steps to recreate the problem:\n(1) start the activemq message broker,\n(2) start MessageListener and MessageSender, and observe that messages are being sent and received successfully.\n(3) stop the message broker without stopping MessageListener and MessageSender. Wait for a while (for about a minute or two)\n(4) start the message broker again.\n\nWe expect we can send and receive messages successfully after step (4), but the MessageListener can never receive any messages any more. Also from the activemq admin page, we find that the consumer of the topic is gone. We did the test with url \"?keepAlive=true&wireFormat.maxInactivityDuration=0\", but it did not work.\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Unable to receive any messages after re-starting message broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-316?\nA: We developed two applications that use CmsTemplate to send and receive messages. The sender application is called MessageSender, and the receiver application is called MessageListener. We found that the MessageListener is unable to receive any messages after we re-start the message broker.\n\nThe followings are the steps to recreate the problem:\n(1) start the activemq message broker,\n(2) start Messa"}}
{"issue_key": "AMQCPP-315", "project": "AMQCPP", "title": "Advisory messages do not work with multiple listeners", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-08-27T21:17:37.000+0000", "updated": "2010-09-08T18:50:29.000+0000", "description": "We found that the advisory messages do not work as expected when there are multiple consumers listening to the same advisory topics.\n\nWe have three applications, AdvisoryMessageListener, MessageListener, and MessageSender.\n\nAdvisoryMessageListener listens to the following two topics:\nActiveMQ.Advisory.Consumer.Topic.cpp.itemLookup\nActiveMQ.Advisory.Producer.Topic.cpp.itemLookup\n\nMessageListener listens to topic: cpp.itemLookup\n\nMessageSender sends messages to topic: cpp.itemLookup\n\nIf there is only one instance of AdvisoryMessageListener , then everything work fine. We can get the advisory messages when we start/shut down MessageListener or MessageSender . However, when we start a second instance of AdvisoryMessageListener , it seems to knock out the existing connection of the first  AdvisoryMessageListener. The first instance can no longer receive any advisory messages after that. \n\nThis problem could be related to the problem reported in jira item \"AMQCPP-314 Starting app with Com using cms destroys connection of other app. New problem with recent lib version\". However in our problem,  we do not have any COM layers.", "comments": [], "text": "Advisory messages do not work with multiple listeners\n\nDescription:\nWe found that the advisory messages do not work as expected when there are multiple consumers listening to the same advisory topics.\n\nWe have three applications, AdvisoryMessageListener, MessageListener, and MessageSender.\n\nAdvisoryMessageListener listens to the following two topics:\nActiveMQ.Advisory.Consumer.Topic.cpp.itemLookup\nActiveMQ.Advisory.Producer.Topic.cpp.itemLookup\n\nMessageListener listens to topic: cpp.itemLookup\n\nMessageSender sends messages to topic: cpp.itemLookup\n\nIf there is only one instance of AdvisoryMessageListener , then everything work fine. We can get the advisory messages when we start/shut down MessageListener or MessageSender . However, when we start a second instance of AdvisoryMessageListener , it seems to knock out the existing connection of the first  AdvisoryMessageListener. The first instance can no longer receive any advisory messages after that. \n\nThis problem could be related to the problem reported in jira item \"AMQCPP-314 Starting app with Com using cms destroys connection of other app. New problem with recent lib version\". However in our problem,  we do not have any COM layers.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Advisory messages do not work with multiple listeners\n\nDescription:\nWe found that the advisory messages do not work as expected when there are multiple consumers listening to the same advisory topics.\n\nWe have three applications, AdvisoryMessageListener, MessageListener, and MessageSender.\n\nAdvisoryMessageListener listens to the following two topics:\nActiveMQ.Advisory.Consumer.Topic.cpp.itemLookup\nActiveMQ.Advisory.Producer.Topic.cpp.itemLookup\n\nMessageListener listens to topic: cpp.itemLookup\n\nMessageSender sends messages to topic: cpp.itemLookup\n\nIf there is only one instance of AdvisoryMessageListener , then everything work fine. We can get the advisory messages when we start/shut down MessageListener or MessageSender . However, when we start a second instance of AdvisoryMessageListener , it seems to knock out the existing connection of the first  AdvisoryMessageListener. The first instance can no longer receive any advisory messages after that. \n\nThis problem could be related to the problem reported in jira item \"AMQCPP-314 Starting app with Com using cms destroys connection of other app. New problem with recent lib version\". However in our problem,  we do not have any COM layers.\n\n\nComments:\n", "classification": "Classify the issue 'Advisory messages do not work with multiple listeners' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-315?\nA: We found that the advisory messages do not work as expected when there are multiple consumers listening to the same advisory topics.\n\nWe have three applications, AdvisoryMessageListener, MessageListener, and MessageSender.\n\nAdvisoryMessageListener listens to the following two topics:\nActiveMQ.Advisory.Consumer.Topic.cpp.itemLookup\nActiveMQ.Advisory.Producer.Topic.cpp.itemLookup\n\nMessageListener li"}}
{"issue_key": "AMQCPP-314", "project": "AMQCPP", "title": "Starting app with Com using cms destroys connection of other app. New problem with recent lib version", "status": "Resolved", "reporter": "Barbara Dawkins", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2010-08-19T22:47:26.000+0000", "updated": "2010-09-02T20:04:09.000+0000", "description": "We ran into a problem after we upgraded the CMS library from revison 3.1.3 to revision 3.2.2.  We have two applications. When we start up the second application, and try to send a message to the activemq broker, it seems to wipe out the existing connection that the first application has. This is a new problem. We have not seen this with the earlier version of CMS.\n\nHere are more details about our applications.\n\nBoth applications are using a COM component that we have created as a thin wrapper around CMS.\nApplication 1: \n The \"Catcher\" application creates listeners and waits for messages to arrive on two \"request\" topics.  When it receives messages, it sends out responses on the appropriate \"response\" topic.  This app is intended as a local, dumbed-down similator of a remote server.  The Catcher app uses only the COM wrapper of CMS.  When the catcher is started, you can see it's listeners on the \"Topics\" page.\n\nApplication 2:\nThe \"SimpleSender\" app uses an Additional COM object that loads the CMS wrapper.  SimpleSender creates listers on the \"response\" topics and sends messages on the \"request\" topics.    When SimpleSender starts,  it loads it's configuration, creates a listener on the response topic, and sends 1 message.  If you look at the topics page (http://localhost:8161/admin/topics.jsp) before the message is sent,  the Catcher listeners are undisturbed.  After it sends a message,  the listeners are destroyed.\n\nApplication 3:\nA simple message sender that only uses the COM wrapper.  It does not destroy Catcher's connections,  and can be used to test whether Catcher can receive messages.\n\nI will send an attachment containing the test programs.", "comments": [], "text": "Starting app with Com using cms destroys connection of other app. New problem with recent lib version\n\nDescription:\nWe ran into a problem after we upgraded the CMS library from revison 3.1.3 to revision 3.2.2.  We have two applications. When we start up the second application, and try to send a message to the activemq broker, it seems to wipe out the existing connection that the first application has. This is a new problem. We have not seen this with the earlier version of CMS.\n\nHere are more details about our applications.\n\nBoth applications are using a COM component that we have created as a thin wrapper around CMS.\nApplication 1: \n The \"Catcher\" application creates listeners and waits for messages to arrive on two \"request\" topics.  When it receives messages, it sends out responses on the appropriate \"response\" topic.  This app is intended as a local, dumbed-down similator of a remote server.  The Catcher app uses only the COM wrapper of CMS.  When the catcher is started, you can see it's listeners on the \"Topics\" page.\n\nApplication 2:\nThe \"SimpleSender\" app uses an Additional COM object that loads the CMS wrapper.  SimpleSender creates listers on the \"response\" topics and sends messages on the \"request\" topics.    When SimpleSender starts,  it loads it's configuration, creates a listener on the response topic, and sends 1 message.  If you look at the topics page (http://localhost:8161/admin/topics.jsp) before the message is sent,  the Catcher listeners are undisturbed.  After it sends a message,  the listeners are destroyed.\n\nApplication 3:\nA simple message sender that only uses the COM wrapper.  It does not destroy Catcher's connections,  and can be used to test whether Catcher can receive messages.\n\nI will send an attachment containing the test programs.\n \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Starting app with Com using cms destroys connection of other app. New problem with recent lib version\n\nDescription:\nWe ran into a problem after we upgraded the CMS library from revison 3.1.3 to revision 3.2.2.  We have two applications. When we start up the second application, and try to send a message to the activemq broker, it seems to wipe out the existing connection that the first application has. This is a new problem. We have not seen this with the earlier version of CMS.\n\nHere are more details about our applications.\n\nBoth applications are using a COM component that we have created as a thin wrapper around CMS.\nApplication 1: \n The \"Catcher\" application creates listeners and waits for messages to arrive on two \"request\" topics.  When it receives messages, it sends out responses on the appropriate \"response\" topic.  This app is intended as a local, dumbed-down similator of a remote server.  The Catcher app uses only the COM wrapper of CMS.  When the catcher is started, you can see it's listeners on the \"Topics\" page.\n\nApplication 2:\nThe \"SimpleSender\" app uses an Additional COM object that loads the CMS wrapper.  SimpleSender creates listers on the \"response\" topics and sends messages on the \"request\" topics.    When SimpleSender starts,  it loads it's configuration, creates a listener on the response topic, and sends 1 message.  If you look at the topics page (http://localhost:8161/admin/topics.jsp) before the message is sent,  the Catcher listeners are undisturbed.  After it sends a message,  the listeners are destroyed.\n\nApplication 3:\nA simple message sender that only uses the COM wrapper.  It does not destroy Catcher's connections,  and can be used to test whether Catcher can receive messages.\n\nI will send an attachment containing the test programs.\n \n\n\n\nComments:\n", "classification": "Classify the issue 'Starting app with Com using cms destroys connection of other app. New problem with recent lib version' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-314?\nA: We ran into a problem after we upgraded the CMS library from revison 3.1.3 to revision 3.2.2.  We have two applications. When we start up the second application, and try to send a message to the activemq broker, it seems to wipe out the existing connection that the first application has. This is a new problem. We have not seen this with the earlier version of CMS.\n\nHere are more details about our "}}
{"issue_key": "AMQCPP-414", "project": "AMQCPP", "title": "Remove bundled zlib and using external library", "status": "Closed", "reporter": "FrantiÅ¡ek DvoÅÃ¡k", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["build", "patch", "zlib"], "created": "2012-07-12T14:07:39.000+0000", "updated": "2012-07-12T14:11:42.000+0000", "description": "Decaf library is using its own copy of zlib. It would be problem in case of zlib updates, plus some dependencies (openssl) are already dynamically linked with zlib library anyway.\n\nAttached patch against current SVN. I don't know how to test the compression feature is working fine, but build and unit tests on Linux are OK.\n\nRemaining issues:\n- updating web page to add new dependency (zlib-devel)?\n- Windows project not touched by the patch (and zlib source files could be removed)", "comments": [], "text": "Remove bundled zlib and using external library\n\nDescription:\nDecaf library is using its own copy of zlib. It would be problem in case of zlib updates, plus some dependencies (openssl) are already dynamically linked with zlib library anyway.\n\nAttached patch against current SVN. I don't know how to test the compression feature is working fine, but build and unit tests on Linux are OK.\n\nRemaining issues:\n- updating web page to add new dependency (zlib-devel)?\n- Windows project not touched by the patch (and zlib source files could be removed)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Remove bundled zlib and using external library\n\nDescription:\nDecaf library is using its own copy of zlib. It would be problem in case of zlib updates, plus some dependencies (openssl) are already dynamically linked with zlib library anyway.\n\nAttached patch against current SVN. I don't know how to test the compression feature is working fine, but build and unit tests on Linux are OK.\n\nRemaining issues:\n- updating web page to add new dependency (zlib-devel)?\n- Windows project not touched by the patch (and zlib source files could be removed)\n\nComments:\n", "classification": "Classify the issue 'Remove bundled zlib and using external library' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-414?\nA: Decaf library is using its own copy of zlib. It would be problem in case of zlib updates, plus some dependencies (openssl) are already dynamically linked with zlib library anyway.\n\nAttached patch against current SVN. I don't know how to test the compression feature is working fine, but build and unit tests on Linux are OK.\n\nRemaining issues:\n- updating web page to add new dependency (zlib-devel)?\n"}}
{"issue_key": "AMQCPP-413", "project": "AMQCPP", "title": "Producer connection that causes broker to reach its memory/disk limits doesn't get the 'all full' exception even though the broker is configured to send it for Producer Flow Control.", "status": "Closed", "reporter": "John Rocha", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": ["cpp", "producer_flow_control"], "created": "2012-07-10T01:26:58.000+0000", "updated": "2012-07-12T15:10:49.000+0000", "description": "Producer connection that cause the broker to reach its memory/disk limits\ndoesn't get the 'all full' exception even though the broker is configured to\nsend it for Producer Flow Control.\n\n\n+Scenario #1+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the default sendTimeot of zero(0), it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will lock up and never recovers.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception.\n\n\n\n+Scenario #2+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the sendTimeot of 500 ms, it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will cause the broker to reach it's limit. And then the send method will start timing out. It never gets a 'broker full' exception.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n{noformat}\n######################################################################\n## SCENARIO #1\n######################################################################\n\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## View the activemq.xml configuration file used for startint active MQ\n##\nroot@psbu-jrr-lnx:#  cat /usr/BWhttpd/tomcat/webapps/amqbroker/WEB-INF/classes/conf/activemq.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:amq=\"http://activemq.apache.org/schema/core\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  \n  http://activemq.apache.org/schema/core \n  http://activemq.apache.org/schema/core/activemq-core-5.3.2.xsd\"\n  default-autowire=\"byName\">\n\n  <!-- Allows to use system properties as variables in this configuration file -->\n    <bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    </bean>\n\n    <broker xmlns=\"http://activemq.apache.org/schema/core\"\n            brokerName=\"localhost\"\n            advisorySupport=\"true\"\n            dataDirectory=\"${catalina.home}/activemq-data\"\n            useJmx=\"false\"\n            useShutdownHook=\"false\">\n        <!-- Destination specific policies using destination names or wildcards\n        -->\n        <destinationPolicy>\n            <policyMap>\n                <policyEntries>\n                    <policyEntry queue=\">\" memoryLimit=\"5mb\" />\n                    <policyEntry topic=\">\" memoryLimit=\"5mb\" />\n                </policyEntries>\n            </policyMap>\n        </destinationPolicy>\n\n        <systemUsage>\n            <systemUsage sendFailIfNoSpace=\"true\">\n                <memoryUsage>\n                    <memoryUsage limit=\"5 mb\" />\n                </memoryUsage>\n                <storeUsage>\n                    <storeUsage limit=\"4 mb\" />\n                </storeUsage>\n                <tempUsage>\n                    <tempUsage limit=\"1 mb\" />\n                </tempUsage>\n                </systemUsage>\n        </systemUsage>\n\n        <!-- The transport connectors ActiveMQ will listen to -->\n        <transportConnectors>\n            <transportConnector name=\"tcp\"\n             uri=\"tcp://0.0.0.0:61616?wireFormat.maxInactivityDuration=0\" />\n        </transportConnectors>\n    </broker>\n</beans>\n\n\n\n\n\n##\n## View the runtime environment to validate the library is 3.4.4, the latests.\n## I cannot explain why the number is 14.0.4, but I observed that 3.4.0 used\n## 14.0.0\n##\n242(TEST)jrr@[SUSE10.1]>  ls $LD_LIBRARY_PATH/libactive*\n/usr/BWhttpd/lib//libactivemq-cpp.so*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14.0.4*\n243(TEST)jrr@[SUSE10.1]>  \n\n\n\n\n##\n## Compile the simple producer\n##\nCompiling simple_producer.o\ng++ -g -c -MD -Wall -Werror -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/activemq-cpp/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/apr-1  simple_producer.cpp\ng++ -o simple_producer.exe simple_producer.o -lc -lrt \\\n    -lactivemq-cpp \\\n    -lboost_thread \\\n    -L /usr/BWhttpd/lib\n\nCompilation finished at Mon Jul  9 15:32:48\n\n\n\n\n\n\n##\n## Execute the test program. It creates a connection and then loops forever\n## sending messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## It locks up at 1775 messages\n##\n\n257(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\nSending message #2\nSending message #3\nSending message #4\nSending message #5\n...\n...\n...\nSending message #1772\nSending message #1773\nSending message #1774\nSending message #1775\nSending message #1776\n\n\n\n\n##\n## View the ActiveMQ disk usage during the lock up\n##\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## Use GDB to see where the simple_producer is blocked\n##\npsbu-jrr-lnx[SUSE10.1]:176>  ps auxw | egrep simple_producer.exe\njrr      16974  1.3  0.6  53980  6724 pts/12   Sl+  17:58   0:00 simple_producer.exe\njrr      16997  0.0  0.0   1864   660 pts/18   S+   17:59   0:00 /bin/grep -E simple_producer.exe\npsbu-jrr-lnx[SUSE10.1]:177>  \npsbu-jrr-lnx[SUSE10.1]:177>  gdb simple_producer.exe \nGNU gdb 6.6\nCopyright (C) 2006 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"i586-suse-linux\"...\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n\n\n(gdb) set print pretty\n\n\n(gdb) set pagination off\n\n\n(gdb) attach 16974\nAttaching to program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\nReading symbols from /lib/librt.so.1...done.\nLoaded symbols for /lib/librt.so.1\nReading symbols from /usr/BWhttpd/lib/libactivemq-cpp.so.14...done.\nLoaded symbols for /usr/BWhttpd/lib/libactivemq-cpp.so.14\nReading symbols from /usr/BWhttpd/lib/libboost_thread.so.1.43.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libboost_thread.so.1.43.0\nReading symbols from /usr/lib/libstdc++.so.6...done.\nLoaded symbols for /usr/lib/libstdc++.so.6\nReading symbols from /lib/libm.so.6...done.\nLoaded symbols for /lib/libm.so.6\nReading symbols from /lib/libc.so.6...done.\nLoaded symbols for /lib/libc.so.6\nReading symbols from /lib/libgcc_s.so.1...done.\nLoaded symbols for /lib/libgcc_s.so.1\nReading symbols from /lib/libpthread.so.0...done.\n[Thread debugging using libthread_db enabled]\n[New Thread -1221044560 (LWP 16974)]\n[New Thread -1254835296 (LWP 16981)]\n[New Thread -1246442592 (LWP 16978)]\n[New Thread -1238049888 (LWP 16977)]\n[New Thread -1229657184 (LWP 16976)]\n[New Thread -1221264480 (LWP 16975)]\nLoaded symbols for /lib/libpthread.so.0\nReading symbols from /lib/ld-linux.so.2...done.\nLoaded symbols for /lib/ld-linux.so.2\nReading symbols from /usr/BWhttpd/lib/libapr-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libapr-1.so.0\nReading symbols from /lib/libuuid.so.1...done.\nLoaded symbols for /lib/libuuid.so.1\nReading symbols from /lib/libcrypt.so.1...done.\nLoaded symbols for /lib/libcrypt.so.1\nReading symbols from /usr/BWhttpd/lib/libaprutil-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libaprutil-1.so.0\nReading symbols from /usr/BWhttpd/lib/libexpat.so.1...done.\nLoaded symbols for /usr/BWhttpd/lib/libexpat.so.1\nReading symbols from /usr/lib/libssl.so.0.9.8...done.\nLoaded symbols for /usr/lib/libssl.so.0.9.8\nReading symbols from /usr/lib/libcrypto.so.0.9.8...done.\nLoaded symbols for /usr/lib/libcrypto.so.0.9.8\nReading symbols from /lib/libdl.so.2...done.\nLoaded symbols for /lib/libdl.so.2\n0xffffe410 in __kernel_vsyscall ()\n\n\n(gdb) thread apply all where\n\n\n\nThread 6 (Thread -1221264480 (LWP 16975)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b120) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806ae5c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806ae58) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806ae50) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806aff8) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806aff8) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 5 (Thread -1229657184 (LWP 16976)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b368) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806b1fc) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806b1f8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806b1f0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806b240) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806b240) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 4 (Thread -1238049888 (LWP 16977)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806c718) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806c2ec) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806c2e8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806c2e0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c5c0) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c5c0) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 3 (Thread -1246442592 (LWP 16978)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb765ba8b in std::exception::what () from /lib/libc.so.6\n#2  0xb7580b7a in apr_socket_recv (sock=0x80649e8, buf=0x8066c10 \"\", len=0xb5b4c040) at network_io/unix/sendrecv.c:81\n#3  0xb7d49ebd in decaf::internal::net::tcp::TcpSocket::read (this=0x8064898, buffer=0x8066c10 \"\", size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocket.cpp:649\n#4  0xb7d4d1c0 in decaf::internal::net::tcp::TcpSocketInputStream::doReadArrayBounded (this=0x8066c10, buffer=0x2000 <Address 0x2000 out of bounds>, size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocketInputStream.cpp:108\n#5  0xb7d91d1f in decaf::io::InputStream::doReadArray (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:138\n#6  0xb7d92333 in decaf::io::InputStream::read (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:72\n#7  0xb7d866ef in decaf::io::BufferedInputStream::bufferData (this=0x8066b60, inputStream=0x8066998, buffer=@0xb5b4c1f8) at decaf/io/BufferedInputStream.cpp:326\n#8  0xb7d86d18 in decaf::io::BufferedInputStream::doReadArrayBounded (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/BufferedInputStream.cpp:228\n#9  0xb7d92191 in decaf::io::InputStream::read (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/InputStream.cpp:84\n#10 0xb7d8a757 in decaf::io::DataInputStream::readAllData (this=0x80669b8, buffer=0x80669ca \"\", length=4) at decaf/io/DataInputStream.cpp:492\n#11 0xb7d8c684 in decaf::io::DataInputStream::readInt (this=0x80669b8) at decaf/io/DataInputStream.cpp:124\n#12 0xb7cae1b8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x8063e10, transport=0x8064790, dis=0x80669b8) at activemq/wireformat/openwire/OpenWireFormat.cpp:245\n#13 0xb7c2c9f7 in activemq::transport::IOTransport::run (this=0x8064790) at activemq/transport/IOTransport.cpp:246\n#14 0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c088) at decaf/lang/Thread.cpp:137\n#15 0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c088) at decaf/lang/Thread.cpp:190\n#16 0xb75912ab in start_thread () from /lib/libpthread.so.0\n#17 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 2 (Thread -1254835296 (LWP 16981)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806cde8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806d24c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7c1fada in activemq::threads::CompositeTaskRunner::run (this=0x806d208) at activemq/threads/CompositeTaskRunner.cpp:115\n#6  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806cbc0) at decaf/lang/Thread.cpp:137\n#7  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806cbc0) at decaf/lang/Thread.cpp:190\n#8  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#9  0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 1 (Thread -1221044560 (LWP 16974)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806f1a8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806f13c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7de9395 in decaf::util::concurrent::CountDownLatch::await (this=0x806f134) at decaf/util/concurrent/CountDownLatch.cpp:53\n#6  0xb7c36025 in activemq::transport::correlator::FutureResponse::getResponse (this=0x806f130) at ./activemq/transport/correlator/FutureResponse.h:62\n#7  0xb7c33aa2 in activemq::transport::correlator::ResponseCorrelator::request (this=0x806b740, command=@0xbf9301cc) at activemq/transport/correlator/ResponseCorrelator.cpp:120\n#8  0xb7b649fa in activemq::core::ActiveMQConnection::syncRequest (this=0x806b858, command=@0xbf9301cc, timeout=0) at activemq/core/ActiveMQConnection.cpp:896\n#9  0xb7baf1d8 in activemq::core::ActiveMQSession::send (this=0x80635b8, message=0x806e640, producer=0x806e530, usage=0x0) at activemq/core/ActiveMQSession.cpp:921\n#10 0xb7ba1e71 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640, deliveryMode=1, priority=4, timeToLive=0) at activemq/core/ActiveMQProducer.cpp:211\n#11 0xb7ba2b07 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:152\n#12 0xb7ba3cab in activemq::core::ActiveMQProducer::send (this=0x806e530, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:128\n#13 0x0804c5ac in AMQ_Producer::send (this=0xbf9305c8, msg=@0xbf930600, type=@0xbf9305f8) at simple_producer.cpp:720\n#14 0x0804ca45 in run_test () at simple_producer.cpp:767\n#15 0x0804cd47 in main () at simple_producer.cpp:798\n#0  0xffffe410 in __kernel_vsyscall ()\n(gdb) detach\nDetaching from program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\n(gdb) quit\npsbu-jrr-lnx[SUSE10.1]:178>  \n\n\n\n\n\n##\n## If we kill the program and execute it again, then this time it will\n## terminate with the expected exception.\n##\n\n258(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622326f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSending message #2\n\n\n...\n...\n...\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622426f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n259(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{noformat}\n######################################################################\n## SCENARIO #2\n######################################################################\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n##\n## Execute the test program, this time pass in variables to cause the sendTime\n## to be set to 500ms. It creates a connection and then loops forever sending\n## messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## Now at 1775 messages the send times out. Moreover, the test moves on trying\n## more sends, and they all time out. After 10 failures the test exits. This\n## sender that causes the broker memory limmit to be reached never gets a\n## 'broker full' exception.\n##\n\n262(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\nSEND_TO set to 500\nSending message #2\nSEND_TO set to 500\nSending message #3\nSEND_TO set to 500\nSending message #4\n...\n...\n...\nSending message #1776\nException[1]: Error while sending message [No valid response received for command: Message { commandId = 8879, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882406582, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1776, check broker.]\nSEND_TO set to 500\nSending message #1777\n...\n...\n...\nSending message #1785\n\n\nException[10]: Error while sending message [No valid response received for command: Message { commandId = 8924, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882411136, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1785, check broker.]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n\n\n\n##\n##\n## View the ActiveMQ disk usage during the lock up\n##\n\nroot@psbu-jrr-lnx:#  !du\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n##\n## If we re-execute the test now that the broker is full, then this time it\n## will terminate with the expected broker full exception.\n##\n\n263(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622756f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSEND_TO set to 500\n...\n...\n...\nSEND_TO set to 500\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001623156f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n264(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{code}\n//////////////////////////////////////////////////////////////////////\n// Not so simple producer.\n//\n// The Active MQ Client's simple producer code has been modified to allow for\n\n// investigation into client behaviour. I've integrated the products engine for\n// obtaining a connection, session, queue, destination, sender and message.\n//\n// The code basically does the following:\n//       - create a connection to be used over and over for the test\n//       - loop forever\n//         - create a session, queue, destination, sender and message\n//         - send the message\n//         - destroy the message, sender, destination, topic and session.\n//\n// ----------------------------------------\n// ENVIRONMENT VARIABLE OVERRIDES\n// ----------------------------------------\n//\n// SEND_TO : default is 0. If non-zero then it appends connection.sendTimeout\n//           to the destination URI using the value set for SEND_TO. Refer to\n//           the connection options at\n//           http://activemq.apache.org/cms/configuring.html for details\n//           regarding its values.\n//\n\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <decaf/lang/Thread.h>\n#include <decaf/lang/Runnable.h>\n#include <decaf/util/concurrent/CountDownLatch.h>\n#include <decaf/lang/Long.h>\n#include <decaf/util/Date.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <cms/Connection.h>\n#include <cms/Session.h>\n#include <cms/TextMessage.h>\n#include <cms/BytesMessage.h>\n#include <cms/MapMessage.h>\n#include <cms/ExceptionListener.h>\n#include <cms/MessageListener.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <memory>\n#include <boost/scoped_ptr.hpp>\n#include <boost/thread/thread.hpp>\n#include <boost/lexical_cast.hpp>\n\n\nusing namespace activemq;\nusing namespace activemq::core;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace cms;\nusing namespace std;\n\n\n\n\n\n//\n// Override values with environement values if they exist\n//\ntemplate <class DEST>\nbool GetEnv (const std::string    var,\n             DEST                 &dst,\n             const DEST           &def_value)\n{\n    const char *val(::getenv(var.c_str()));\n\n    dst = def_value;\n\n    if (NULL == val) {\n        return (false);\n    }\n\n    try {\n        dst = boost::lexical_cast<DEST>(val);\n        printf(\"%s set to %s\\n\", var.c_str(), val);\n        return(true);\n    }\n    catch (std::exception    &e) {\n        printf(\"%s\\n\", e.what());\n        printf(\"Cannot convert '%s' to the desired output format\\n\", val);\n    }\n\n    return(false);\n}\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// EventEngineUtil.hxx\n// ---------------------------------------------------------------------------\nclass ee_except : public std::exception\n{\npublic:\n    // ee_except(std::string)\n    //\n    //    Create an exception using the specified string\n    //\n    explicit ee_except (const std::string    &_msg) :\n        msg(_msg)\n        {};\n\n    explicit ee_except (const std::stringstream    &_msg) :\n        msg(_msg.str())\n        {};\n\n\n    // ee_except(std::string, errNum)\n    //\n    //    Create an excpetion using the specified string, and then append the\n    //    numeric and string representation of the specified errno\n    //\n    explicit ee_except (const std::string    &_msg,\n                        int                  errNum) {\n        ee_except_helper(_msg, errNum);\n    }\n\n\n    explicit ee_except (const std::stringstream    &_msg,\n                       int                         errNum) {\n        ee_except_helper(_msg.str(), errNum);\n    }\n\n\n\n    // destroy the exception\n    ~ee_except() throw() {};\n\n\n    // return the message, overloading the standard what method\n    virtual const char *what() const throw() {\n        return msg.c_str();\n    }\n\n\nprotected:\n\n    void ee_except_helper (const std::string    &_msg,\n                           int                  errNum) {\n        std::stringstream    ss_error;\n\n\n        if (errNum) {\n            ss_error << _msg << \", errno: \" << errNum\n                     << \", \" << strerror(errNum);\n            msg = ss_error.str(); \n\n        } else {\n            msg = _msg;\n        }\n    }\n\n\n\nprivate:\n\n    std::string msg;\n};\n\n\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// From EventEngineAMQProducer\n// ---------------------------------------------------------------------------\n#include <boost/thread/thread.hpp>\n#include <boost/shared_ptr.hpp>\n#include <cms/DeliveryMode.h>\n#include <cms/Connection.h>\n#include <activemq/library/ActiveMQCPP.h>\n\n\n\n\n\n// CLASS: ConnSessionManager\n//\n//    Singleton class to manage Active MQ (AMQ) connections.\n//\n// getConnSession():\n//\n//    This method gets a connection for the specified broker, creates a session\n//    with the specified ackMode and populates the connSesn parameter with\n//    shared pointers to the alloated resources.\n//\n//    If a connection already exists for the brokerURI, it creates a session\n//    for it and returns them, if the connection does not exist it makes one\n//    attaches a session and returns them. If it cannot create the connection\n//    (such as the broker is not up), it throws an exception.\n//\n//    The connection manager can manage multiple connections based on the\n//    brokerURI. Each unique broker URI will be a different connection managed\n//    by the connection manager.\n//\n//\nclass ConnSessionManager {\npublic:\n    typedef boost::shared_ptr<cms::Connection>    P_SHR_CONN_T;\n    typedef boost::shared_ptr<cms::Session>       P_SHR_SESSION_T;\n\n\n    struct ConnSession {\n        P_SHR_CONN_T       p_conn;\n        P_SHR_SESSION_T    p_session;\n    };\n\n\n    static void getConnSession(ConnSession                    &connSesn,\n                               const std::string              &brokerURI,\n                               cms::Session::AcknowledgeMode  ackMode);\n\n\nprotected:\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   V A R I A B L E S\n\n    typedef std::map<const std::string, P_SHR_CONN_T>     CM_MAP_T;\n\n    CM_MAP_T               cm_map;\n\n    static boost::mutex    access_mtx;\n\n\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   F U N C T I O N\n\n    ConnSessionManager();\n\n    ~ConnSessionManager();\n\n    static ConnSessionManager &Singleton(void);\n\n    void addConnection(ConnSession                    &connSesn,\n                       const std::string              &brokerURI,\n                       cms::Session::AcknowledgeMode  ackMode);\n};\n\n\n\n\n\n// CLASS: AMQ_Producer\n//\n//    Active MQ (AMQ) message producer.\n//\n// The constructor creates an AMQ Producer object that has the ability to send\n// messages to the specified DESTination, HOST and PORT.\n//\n// The send() method causes the message to be sent. While creating the message,\n// the send() method will apply the properites (if any) that have been set.\n//\n// The initProperty() method clears the list of properties that have been\n// established for this producer. \n//\n// The setProperty() method sets an AMQ message property for the message to be\n// sent. A new property is added each time this command is invoked, unless it's\n// for an existing property, in which case the old property is overwritten with\n// the new property.\n//\nclass AMQ_Producer {\npublic:\n    AMQ_Producer(const std::string    &dest,\n                 const std::string    &host,\n                 const std::string    &port);\n\n    ~AMQ_Producer() {};\n\n    void send(const std::string    &msg,\n              const std::string    &type = \"\");\n\nprotected:\n\n    const std::string    m_dest;\n    std::string          m_broker_uri;\n\n    std::map<const std::string, std::string>    propertyInfo;\n\n    static const cms::DeliveryMode::DELIVERY_MODE    m_delivery_mode;\n};\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n\n#include <cms/ConnectionFactory.h>\n#include <boost/thread/once.hpp>\n\n\n\n\n\n// access control to the singleton.\nboost::mutex    ConnSessionManager::access_mtx;\n\nstatic boost::once_flag    init_flag = BOOST_ONCE_INIT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::ConnSessionManager\n**\n** Function:    Create the connection manage object (singleton) and initialize\n**              the Active MQ library that we use, once.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::ConnSessionManager () :\n    cm_map()\n{\n    // only call the library initialization ONCE.\n    boost::call_once(activemq::library::ActiveMQCPP::initializeLibrary,\n                     init_flag);\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::~ConnSessionManager\n**\n** Function:    Destroty the connection manager\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::~ConnSessionManager ()\n{\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::Singleton\n**\n** Function:    Return a referece to our singleton.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager &\nConnSessionManager::Singleton (void)\n{\n    static ConnSessionManager    singleton;\n\n    return (singleton);\n}\n\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::addConnection\n**\n** Function:    Add, or re-add a connection to the connection manager.\n**              Create a session on the connection and return them.\n**\n**              An exception is thrown if we cannot get a connection.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nConnSessionManager::addConnection (ConnSessionManager::ConnSession  &connSesn,\n                                   const std::string                &brokerURI,\n                                   cms::Session::AcknowledgeMode    ackMode)\n{\n    CM_MAP_T           &map_ref = Singleton().cm_map;\n    P_SHR_CONN_T       &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T    &p_session(connSesn.p_session);\n\n\n    // Create a ConnectionFactory that we automatically dealloate itself\n    std::auto_ptr<cms::ConnectionFactory>\n        connectionFactory(cms::ConnectionFactory::\n                          createCMSConnectionFactory(brokerURI));\n\n    // Create the connection and attach to shared pointer\n    p_conn.reset(connectionFactory->createConnection());\n\n\n    // Start the connection\n    p_conn->start();\n\n\n    // Create the session\n    p_session.reset(p_conn->createSession(ackMode));\n\n\n    // Update the map\n    map_ref.erase(brokerURI);\n    map_ref[brokerURI] = p_conn;\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::getConnSession\n**\n** Function:    Get a working Active MQ connection for the specified brokerURI\n**              and return it along with an allocated session or thrown an\n**              exception.\n**\n**              This finds the existing AMQ connection for the specified\n**              brokerURI, validates that it's still connected, creates a\n**              session on it and returns them. If the connection isn't valid\n**              anymore (i.e. the broker restarted) or if the connection\n**              doesn't exist yet, we create it.\n**\n**              If we cannot create the connection we throw an exception.\n**\n**              WHY DO WE ALLOCATE A SESSION TOO? Why don't we just get the\n**              conection and return it? It's possible that the connection was\n**              reset since the last time we used it (i.e the broker\n**              restarted). The only way we can tell this is if the\n**              createSession call fails. Since we have to create a session to\n**              prove that the connection works, lets use it. The caller would\n**              do it once it had a connection anyway!\n**\n**              Why don't we just return a shared pointer to the session, why\n**              do we also return a shared pointer to the connection? Sessions\n**              are built on top of connections. It would be BAD if the\n**              connection was deleted before the session. So we keep a shared\n**              pointer of both together to ensure that they have the same\n**              lifecycle.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: P_SHR_CONN_T - A shared pointer to the connection to use\n**\n****************************************************************************/\nvoid\nConnSessionManager::getConnSession (ConnSessionManager::ConnSession &connSesn,\n                                    const std::string               &brokerURI,\n                                    cms::Session::AcknowledgeMode   ackMode)\n{\n    P_SHR_CONN_T          &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T       &p_session(connSesn.p_session);\n    ConnSessionManager    &me = Singleton();\n    CM_MAP_T              &map_ref = me.cm_map;\n\n\n    // restrict access\n    boost::lock_guard<boost::mutex>    lock(access_mtx);\n\n\n    // get the entry\n    p_conn = map_ref[brokerURI];\n\n\n    // if it's not allocated yet, then allocate it, attach it and return it\n    if (NULL == p_conn) {\n        printf(\"Creating connection for %s\\n\",\n               brokerURI.c_str());\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n\n\n    // Check if the broker restarted and reset our connection. If it has,\n    // then create session will generate an exception and we know we then\n    // need to make a new connection. If it it works then use the session,\n    // passing it back in the connSession\n    try {\n        p_session.reset(p_conn->createSession(ackMode));\n    }\n    catch (std::exception    &e) {\n        printf(\"Re-creating connection for %s: %s\\n\",\n               brokerURI.c_str(), e.what());\n\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n}\n\n\n\n\n\n// **********************************************************************\n// **********************************************************************\n//                               AMQ_Producer\n// **********************************************************************\n// **********************************************************************\n\n\n// m_delivery_mode\n//\n//     The producer's delivery mode is set to NON_PERSISTENT. When persistent\n//     it causes the broker to save the message to disk so that it is available\n//     even if the broker restarts. However, this has a price, it greatly slows\n//     down the send (220,475 microseconds with persistance, vs. 226\n//     microseconds without.) These measurements where taken WITH synchronous\n//     sends. We could have investigated and used async sends to speed up the\n//     send call and keep persistence, however, this wasn't deemed necessary.\n//\n//     http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_delivery_mode.html\n//\n//     http://activemq.apache.org/persistence-questions.html\n//\n//     http://activemq.apache.org/what-is-the-difference-between-persistent-and-non-persistent-delivery.html\n//\nconst cms::DeliveryMode::DELIVERY_MODE\nAMQ_Producer::m_delivery_mode = cms::DeliveryMode::NON_PERSISTENT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::AMQ_Producer\n**\n** Function:    Create the Active MQ Producer client object, storing the\n**              destination and creating the URI string from the provided host\n**              name and port number.\n**\n** Input Parms: dest: The destination queue/topic to communicate with\n**\n**              host: The host to communicate with\n**\n**              port: The port on the host to communicate with\n**\n** Return Parm: \n**\n****************************************************************************/\nAMQ_Producer::AMQ_Producer (const std::string    &dest,\n                            const std::string    &host,\n                            const std::string    &port) :\n    m_dest(dest),\n    m_broker_uri(\"tcp://\" + host + \":\" + port +\n                 \"?connection.alwaysSyncSend=true\")\n{\n\n\n    // add the send timeout if its environemtn varialbe is given and its a\n    // value other than the default, zero.\n    int    sendTimeout(0);\n\n    GetEnv(\"SEND_TO\", sendTimeout, 0);\n\n    if (sendTimeout) {\n        std::stringstream    ss_sto;\n\n        ss_sto << \"&connection.sendTimeout=\" << sendTimeout;\n\n        m_broker_uri += ss_sto.str();\n    }\n\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::send\n**\n** Function:    Cause the message to be sent by this producer to the\n**              established message queue, host and port.\n**\n**              This gets a cached (or if needed new) connection which has a\n**              session created for it, it then creates the destination,\n**              producer and message. Finally it adds all of the properties\n**              that we want to the message and sends it.\n**\n**              This model is best explained at the Active MQ CPP example page\n**              at: http://activemq.apache.org/cms/cms-api-overview.html\n**\n** Input Parms: msg - The message to send with this producer\n**\n**              type - (optional) The CMSType/JMSType to set the message to. \n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nAMQ_Producer::send (const std::string    &msg,\n                    const std::string    &type)\n{\n    std::string    s_where;\n\n\n    try {\n        ConnSessionManager::ConnSession    conSesn;\n\n\n        // Create the Connection + Session\n        s_where = \"creating connection/session\";\n        ConnSessionManager::getConnSession(conSesn, m_broker_uri,\n                                           cms::Session::AUTO_ACKNOWLEDGE);\n\n\n        // Create the Destination (queue/topic)\n        s_where = \"creating destination\";\n        boost::shared_ptr<cms::Destination>\n            p_destination(conSesn.p_session->createQueue(m_dest));\n\n\n        // Create the Producer\n        s_where = \"creating message producer\";\n        boost::shared_ptr<cms::MessageProducer>\n            p_producer(conSesn.p_session->createProducer(p_destination.get()));\n        p_producer->setDeliveryMode(m_delivery_mode);\n\n\n\n        // Create the Message\n        s_where = \"creating connection\";\n        boost::shared_ptr<cms::TextMessage>\n            p_msg(conSesn.p_session->createTextMessage(msg));\n\n\n        // Set the Message's JMSType/CMSType\n        if (!type.empty()) {\n            p_msg->setCMSType(type);\n        }\n\n\n        std::map<const std::string, std::string>::iterator it;\n\n        // run through all properties, adding them to the message\n        for (it = propertyInfo.begin(); it != propertyInfo.end(); ++it) {\n            s_where = \"adding property \" + (*it).first;\n            p_msg->setStringProperty((*it).first, (*it).second);\n        }\n\n\n        // Send it!\n        s_where = \"sending message\";\n        p_producer->send(p_msg.get());\n    }\n    catch (std::exception    &e) {\n        std::stringstream    ss_err;\n\n        ss_err << \"Error while \" << s_where << \" [\" << e.what() << \"]\";\n        throw ee_except(ss_err);\n    }\n}\n\n\n// ---------------------------------------------------------------------------\n\n\n\n\n\n\nconst std::string    base_msg(\"1024 characters folowed by a message.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxHello world! \");\n\n\n\n\n\n\nvoid run_test ()\n{\n    std::string     host(\"127.0.0.1\");\n    std::string     port(\"61616\");\n    std::string     destURI(\"c.c.p.v.ms.events\");\n    unsigned int    iteration(0);\n    unsigned int    ex_count(0);\n\n\n    // Loop, creating producers and sending the message\n    while (1) {\n        iteration++;\n        AMQ_Producer    producer(destURI, host, port);\n\n\n        std::stringstream    msg;\n\n        msg << base_msg << iteration;\n\n        printf(\"Sending message #%d\\n\", iteration);\n\n        try {\n            producer.send(msg.str(), \"TEST_TYPE\");\n        }\n        catch (std::exception    &e) {\n            ex_count++;\n\n            printf(\"\\n\\nException[%d]: %s\\n\", ex_count, e.what());\n\n            if (ex_count >= 10 ) {\n                printf(\"\\n\\nException limit (%d) reached. Stopping test\\n\\n\\n\",\n                       ex_count);\n                break;\n            }\n        }\n\n    }\n}\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\nint main(int, char*) {\n\n    activemq::library::ActiveMQCPP::initializeLibrary();\n\n    std::cout << \"=====================================================\\n\";\n    std::cout << \"Starting the example:\" << std::endl;\n    std::cout << \"-----------------------------------------------------\\n\";\n\n    run_test();   \n\n\n    std::cout << \"-----------------------------------------------------\\n\";\n    std::cout << \"Finished with the example.\" << std::endl;\n    std::cout << \"=====================================================\\n\";\n\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n{code}", "comments": [], "text": "Producer connection that causes broker to reach its memory/disk limits doesn't get the 'all full' exception even though the broker is configured to send it for Producer Flow Control.\n\nDescription:\nProducer connection that cause the broker to reach its memory/disk limits\ndoesn't get the 'all full' exception even though the broker is configured to\nsend it for Producer Flow Control.\n\n\n+Scenario #1+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the default sendTimeot of zero(0), it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will lock up and never recovers.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception.\n\n\n\n+Scenario #2+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the sendTimeot of 500 ms, it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will cause the broker to reach it's limit. And then the send method will start timing out. It never gets a 'broker full' exception.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n{noformat}\n######################################################################\n## SCENARIO #1\n######################################################################\n\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## View the activemq.xml configuration file used for startint active MQ\n##\nroot@psbu-jrr-lnx:#  cat /usr/BWhttpd/tomcat/webapps/amqbroker/WEB-INF/classes/conf/activemq.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:amq=\"http://activemq.apache.org/schema/core\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  \n  http://activemq.apache.org/schema/core \n  http://activemq.apache.org/schema/core/activemq-core-5.3.2.xsd\"\n  default-autowire=\"byName\">\n\n  <!-- Allows to use system properties as variables in this configuration file -->\n    <bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    </bean>\n\n    <broker xmlns=\"http://activemq.apache.org/schema/core\"\n            brokerName=\"localhost\"\n            advisorySupport=\"true\"\n            dataDirectory=\"${catalina.home}/activemq-data\"\n            useJmx=\"false\"\n            useShutdownHook=\"false\">\n        <!-- Destination specific policies using destination names or wildcards\n        -->\n        <destinationPolicy>\n            <policyMap>\n                <policyEntries>\n                    <policyEntry queue=\">\" memoryLimit=\"5mb\" />\n                    <policyEntry topic=\">\" memoryLimit=\"5mb\" />\n                </policyEntries>\n            </policyMap>\n        </destinationPolicy>\n\n        <systemUsage>\n            <systemUsage sendFailIfNoSpace=\"true\">\n                <memoryUsage>\n                    <memoryUsage limit=\"5 mb\" />\n                </memoryUsage>\n                <storeUsage>\n                    <storeUsage limit=\"4 mb\" />\n                </storeUsage>\n                <tempUsage>\n                    <tempUsage limit=\"1 mb\" />\n                </tempUsage>\n                </systemUsage>\n        </systemUsage>\n\n        <!-- The transport connectors ActiveMQ will listen to -->\n        <transportConnectors>\n            <transportConnector name=\"tcp\"\n             uri=\"tcp://0.0.0.0:61616?wireFormat.maxInactivityDuration=0\" />\n        </transportConnectors>\n    </broker>\n</beans>\n\n\n\n\n\n##\n## View the runtime environment to validate the library is 3.4.4, the latests.\n## I cannot explain why the number is 14.0.4, but I observed that 3.4.0 used\n## 14.0.0\n##\n242(TEST)jrr@[SUSE10.1]>  ls $LD_LIBRARY_PATH/libactive*\n/usr/BWhttpd/lib//libactivemq-cpp.so*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14.0.4*\n243(TEST)jrr@[SUSE10.1]>  \n\n\n\n\n##\n## Compile the simple producer\n##\nCompiling simple_producer.o\ng++ -g -c -MD -Wall -Werror -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/activemq-cpp/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/apr-1  simple_producer.cpp\ng++ -o simple_producer.exe simple_producer.o -lc -lrt \\\n    -lactivemq-cpp \\\n    -lboost_thread \\\n    -L /usr/BWhttpd/lib\n\nCompilation finished at Mon Jul  9 15:32:48\n\n\n\n\n\n\n##\n## Execute the test program. It creates a connection and then loops forever\n## sending messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## It locks up at 1775 messages\n##\n\n257(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\nSending message #2\nSending message #3\nSending message #4\nSending message #5\n...\n...\n...\nSending message #1772\nSending message #1773\nSending message #1774\nSending message #1775\nSending message #1776\n\n\n\n\n##\n## View the ActiveMQ disk usage during the lock up\n##\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## Use GDB to see where the simple_producer is blocked\n##\npsbu-jrr-lnx[SUSE10.1]:176>  ps auxw | egrep simple_producer.exe\njrr      16974  1.3  0.6  53980  6724 pts/12   Sl+  17:58   0:00 simple_producer.exe\njrr      16997  0.0  0.0   1864   660 pts/18   S+   17:59   0:00 /bin/grep -E simple_producer.exe\npsbu-jrr-lnx[SUSE10.1]:177>  \npsbu-jrr-lnx[SUSE10.1]:177>  gdb simple_producer.exe \nGNU gdb 6.6\nCopyright (C) 2006 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"i586-suse-linux\"...\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n\n\n(gdb) set print pretty\n\n\n(gdb) set pagination off\n\n\n(gdb) attach 16974\nAttaching to program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\nReading symbols from /lib/librt.so.1...done.\nLoaded symbols for /lib/librt.so.1\nReading symbols from /usr/BWhttpd/lib/libactivemq-cpp.so.14...done.\nLoaded symbols for /usr/BWhttpd/lib/libactivemq-cpp.so.14\nReading symbols from /usr/BWhttpd/lib/libboost_thread.so.1.43.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libboost_thread.so.1.43.0\nReading symbols from /usr/lib/libstdc++.so.6...done.\nLoaded symbols for /usr/lib/libstdc++.so.6\nReading symbols from /lib/libm.so.6...done.\nLoaded symbols for /lib/libm.so.6\nReading symbols from /lib/libc.so.6...done.\nLoaded symbols for /lib/libc.so.6\nReading symbols from /lib/libgcc_s.so.1...done.\nLoaded symbols for /lib/libgcc_s.so.1\nReading symbols from /lib/libpthread.so.0...done.\n[Thread debugging using libthread_db enabled]\n[New Thread -1221044560 (LWP 16974)]\n[New Thread -1254835296 (LWP 16981)]\n[New Thread -1246442592 (LWP 16978)]\n[New Thread -1238049888 (LWP 16977)]\n[New Thread -1229657184 (LWP 16976)]\n[New Thread -1221264480 (LWP 16975)]\nLoaded symbols for /lib/libpthread.so.0\nReading symbols from /lib/ld-linux.so.2...done.\nLoaded symbols for /lib/ld-linux.so.2\nReading symbols from /usr/BWhttpd/lib/libapr-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libapr-1.so.0\nReading symbols from /lib/libuuid.so.1...done.\nLoaded symbols for /lib/libuuid.so.1\nReading symbols from /lib/libcrypt.so.1...done.\nLoaded symbols for /lib/libcrypt.so.1\nReading symbols from /usr/BWhttpd/lib/libaprutil-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libaprutil-1.so.0\nReading symbols from /usr/BWhttpd/lib/libexpat.so.1...done.\nLoaded symbols for /usr/BWhttpd/lib/libexpat.so.1\nReading symbols from /usr/lib/libssl.so.0.9.8...done.\nLoaded symbols for /usr/lib/libssl.so.0.9.8\nReading symbols from /usr/lib/libcrypto.so.0.9.8...done.\nLoaded symbols for /usr/lib/libcrypto.so.0.9.8\nReading symbols from /lib/libdl.so.2...done.\nLoaded symbols for /lib/libdl.so.2\n0xffffe410 in __kernel_vsyscall ()\n\n\n(gdb) thread apply all where\n\n\n\nThread 6 (Thread -1221264480 (LWP 16975)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b120) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806ae5c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806ae58) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806ae50) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806aff8) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806aff8) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 5 (Thread -1229657184 (LWP 16976)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b368) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806b1fc) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806b1f8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806b1f0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806b240) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806b240) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 4 (Thread -1238049888 (LWP 16977)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806c718) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806c2ec) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806c2e8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806c2e0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c5c0) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c5c0) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 3 (Thread -1246442592 (LWP 16978)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb765ba8b in std::exception::what () from /lib/libc.so.6\n#2  0xb7580b7a in apr_socket_recv (sock=0x80649e8, buf=0x8066c10 \"\", len=0xb5b4c040) at network_io/unix/sendrecv.c:81\n#3  0xb7d49ebd in decaf::internal::net::tcp::TcpSocket::read (this=0x8064898, buffer=0x8066c10 \"\", size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocket.cpp:649\n#4  0xb7d4d1c0 in decaf::internal::net::tcp::TcpSocketInputStream::doReadArrayBounded (this=0x8066c10, buffer=0x2000 <Address 0x2000 out of bounds>, size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocketInputStream.cpp:108\n#5  0xb7d91d1f in decaf::io::InputStream::doReadArray (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:138\n#6  0xb7d92333 in decaf::io::InputStream::read (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:72\n#7  0xb7d866ef in decaf::io::BufferedInputStream::bufferData (this=0x8066b60, inputStream=0x8066998, buffer=@0xb5b4c1f8) at decaf/io/BufferedInputStream.cpp:326\n#8  0xb7d86d18 in decaf::io::BufferedInputStream::doReadArrayBounded (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/BufferedInputStream.cpp:228\n#9  0xb7d92191 in decaf::io::InputStream::read (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/InputStream.cpp:84\n#10 0xb7d8a757 in decaf::io::DataInputStream::readAllData (this=0x80669b8, buffer=0x80669ca \"\", length=4) at decaf/io/DataInputStream.cpp:492\n#11 0xb7d8c684 in decaf::io::DataInputStream::readInt (this=0x80669b8) at decaf/io/DataInputStream.cpp:124\n#12 0xb7cae1b8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x8063e10, transport=0x8064790, dis=0x80669b8) at activemq/wireformat/openwire/OpenWireFormat.cpp:245\n#13 0xb7c2c9f7 in activemq::transport::IOTransport::run (this=0x8064790) at activemq/transport/IOTransport.cpp:246\n#14 0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c088) at decaf/lang/Thread.cpp:137\n#15 0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c088) at decaf/lang/Thread.cpp:190\n#16 0xb75912ab in start_thread () from /lib/libpthread.so.0\n#17 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 2 (Thread -1254835296 (LWP 16981)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806cde8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806d24c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7c1fada in activemq::threads::CompositeTaskRunner::run (this=0x806d208) at activemq/threads/CompositeTaskRunner.cpp:115\n#6  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806cbc0) at decaf/lang/Thread.cpp:137\n#7  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806cbc0) at decaf/lang/Thread.cpp:190\n#8  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#9  0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 1 (Thread -1221044560 (LWP 16974)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806f1a8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806f13c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7de9395 in decaf::util::concurrent::CountDownLatch::await (this=0x806f134) at decaf/util/concurrent/CountDownLatch.cpp:53\n#6  0xb7c36025 in activemq::transport::correlator::FutureResponse::getResponse (this=0x806f130) at ./activemq/transport/correlator/FutureResponse.h:62\n#7  0xb7c33aa2 in activemq::transport::correlator::ResponseCorrelator::request (this=0x806b740, command=@0xbf9301cc) at activemq/transport/correlator/ResponseCorrelator.cpp:120\n#8  0xb7b649fa in activemq::core::ActiveMQConnection::syncRequest (this=0x806b858, command=@0xbf9301cc, timeout=0) at activemq/core/ActiveMQConnection.cpp:896\n#9  0xb7baf1d8 in activemq::core::ActiveMQSession::send (this=0x80635b8, message=0x806e640, producer=0x806e530, usage=0x0) at activemq/core/ActiveMQSession.cpp:921\n#10 0xb7ba1e71 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640, deliveryMode=1, priority=4, timeToLive=0) at activemq/core/ActiveMQProducer.cpp:211\n#11 0xb7ba2b07 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:152\n#12 0xb7ba3cab in activemq::core::ActiveMQProducer::send (this=0x806e530, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:128\n#13 0x0804c5ac in AMQ_Producer::send (this=0xbf9305c8, msg=@0xbf930600, type=@0xbf9305f8) at simple_producer.cpp:720\n#14 0x0804ca45 in run_test () at simple_producer.cpp:767\n#15 0x0804cd47 in main () at simple_producer.cpp:798\n#0  0xffffe410 in __kernel_vsyscall ()\n(gdb) detach\nDetaching from program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\n(gdb) quit\npsbu-jrr-lnx[SUSE10.1]:178>  \n\n\n\n\n\n##\n## If we kill the program and execute it again, then this time it will\n## terminate with the expected exception.\n##\n\n258(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622326f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSending message #2\n\n\n...\n...\n...\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622426f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n259(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{noformat}\n######################################################################\n## SCENARIO #2\n######################################################################\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n##\n## Execute the test program, this time pass in variables to cause the sendTime\n## to be set to 500ms. It creates a connection and then loops forever sending\n## messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## Now at 1775 messages the send times out. Moreover, the test moves on trying\n## more sends, and they all time out. After 10 failures the test exits. This\n## sender that causes the broker memory limmit to be reached never gets a\n## 'broker full' exception.\n##\n\n262(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\nSEND_TO set to 500\nSending message #2\nSEND_TO set to 500\nSending message #3\nSEND_TO set to 500\nSending message #4\n...\n...\n...\nSending message #1776\nException[1]: Error while sending message [No valid response received for command: Message { commandId = 8879, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882406582, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1776, check broker.]\nSEND_TO set to 500\nSending message #1777\n...\n...\n...\nSending message #1785\n\n\nException[10]: Error while sending message [No valid response received for command: Message { commandId = 8924, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882411136, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1785, check broker.]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n\n\n\n##\n##\n## View the ActiveMQ disk usage during the lock up\n##\n\nroot@psbu-jrr-lnx:#  !du\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n##\n## If we re-execute the test now that the broker is full, then this time it\n## will terminate with the expected broker full exception.\n##\n\n263(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622756f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSEND_TO set to 500\n...\n...\n...\nSEND_TO set to 500\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001623156f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n264(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{code}\n//////////////////////////////////////////////////////////////////////\n// Not so simple producer.\n//\n// The Active MQ Client's simple producer code has been modified to allow for\n\n// investigation into client behaviour. I've integrated the products engine for\n// obtaining a connection, session, queue, destination, sender and message.\n//\n// The code basically does the following:\n//       - create a connection to be used over and over for the test\n//       - loop forever\n//         - create a session, queue, destination, sender and message\n//         - send the message\n//         - destroy the message, sender, destination, topic and session.\n//\n// ----------------------------------------\n// ENVIRONMENT VARIABLE OVERRIDES\n// ----------------------------------------\n//\n// SEND_TO : default is 0. If non-zero then it appends connection.sendTimeout\n//           to the destination URI using the value set for SEND_TO. Refer to\n//           the connection options at\n//           http://activemq.apache.org/cms/configuring.html for details\n//           regarding its values.\n//\n\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <decaf/lang/Thread.h>\n#include <decaf/lang/Runnable.h>\n#include <decaf/util/concurrent/CountDownLatch.h>\n#include <decaf/lang/Long.h>\n#include <decaf/util/Date.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <cms/Connection.h>\n#include <cms/Session.h>\n#include <cms/TextMessage.h>\n#include <cms/BytesMessage.h>\n#include <cms/MapMessage.h>\n#include <cms/ExceptionListener.h>\n#include <cms/MessageListener.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <memory>\n#include <boost/scoped_ptr.hpp>\n#include <boost/thread/thread.hpp>\n#include <boost/lexical_cast.hpp>\n\n\nusing namespace activemq;\nusing namespace activemq::core;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace cms;\nusing namespace std;\n\n\n\n\n\n//\n// Override values with environement values if they exist\n//\ntemplate <class DEST>\nbool GetEnv (const std::string    var,\n             DEST                 &dst,\n             const DEST           &def_value)\n{\n    const char *val(::getenv(var.c_str()));\n\n    dst = def_value;\n\n    if (NULL == val) {\n        return (false);\n    }\n\n    try {\n        dst = boost::lexical_cast<DEST>(val);\n        printf(\"%s set to %s\\n\", var.c_str(), val);\n        return(true);\n    }\n    catch (std::exception    &e) {\n        printf(\"%s\\n\", e.what());\n        printf(\"Cannot convert '%s' to the desired output format\\n\", val);\n    }\n\n    return(false);\n}\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// EventEngineUtil.hxx\n// ---------------------------------------------------------------------------\nclass ee_except : public std::exception\n{\npublic:\n    // ee_except(std::string)\n    //\n    //    Create an exception using the specified string\n    //\n    explicit ee_except (const std::string    &_msg) :\n        msg(_msg)\n        {};\n\n    explicit ee_except (const std::stringstream    &_msg) :\n        msg(_msg.str())\n        {};\n\n\n    // ee_except(std::string, errNum)\n    //\n    //    Create an excpetion using the specified string, and then append the\n    //    numeric and string representation of the specified errno\n    //\n    explicit ee_except (const std::string    &_msg,\n                        int                  errNum) {\n        ee_except_helper(_msg, errNum);\n    }\n\n\n    explicit ee_except (const std::stringstream    &_msg,\n                       int                         errNum) {\n        ee_except_helper(_msg.str(), errNum);\n    }\n\n\n\n    // destroy the exception\n    ~ee_except() throw() {};\n\n\n    // return the message, overloading the standard what method\n    virtual const char *what() const throw() {\n        return msg.c_str();\n    }\n\n\nprotected:\n\n    void ee_except_helper (const std::string    &_msg,\n                           int                  errNum) {\n        std::stringstream    ss_error;\n\n\n        if (errNum) {\n            ss_error << _msg << \", errno: \" << errNum\n                     << \", \" << strerror(errNum);\n            msg = ss_error.str(); \n\n        } else {\n            msg = _msg;\n        }\n    }\n\n\n\nprivate:\n\n    std::string msg;\n};\n\n\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// From EventEngineAMQProducer\n// ---------------------------------------------------------------------------\n#include <boost/thread/thread.hpp>\n#include <boost/shared_ptr.hpp>\n#include <cms/DeliveryMode.h>\n#include <cms/Connection.h>\n#include <activemq/library/ActiveMQCPP.h>\n\n\n\n\n\n// CLASS: ConnSessionManager\n//\n//    Singleton class to manage Active MQ (AMQ) connections.\n//\n// getConnSession():\n//\n//    This method gets a connection for the specified broker, creates a session\n//    with the specified ackMode and populates the connSesn parameter with\n//    shared pointers to the alloated resources.\n//\n//    If a connection already exists for the brokerURI, it creates a session\n//    for it and returns them, if the connection does not exist it makes one\n//    attaches a session and returns them. If it cannot create the connection\n//    (such as the broker is not up), it throws an exception.\n//\n//    The connection manager can manage multiple connections based on the\n//    brokerURI. Each unique broker URI will be a different connection managed\n//    by the connection manager.\n//\n//\nclass ConnSessionManager {\npublic:\n    typedef boost::shared_ptr<cms::Connection>    P_SHR_CONN_T;\n    typedef boost::shared_ptr<cms::Session>       P_SHR_SESSION_T;\n\n\n    struct ConnSession {\n        P_SHR_CONN_T       p_conn;\n        P_SHR_SESSION_T    p_session;\n    };\n\n\n    static void getConnSession(ConnSession                    &connSesn,\n                               const std::string              &brokerURI,\n                               cms::Session::AcknowledgeMode  ackMode);\n\n\nprotected:\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   V A R I A B L E S\n\n    typedef std::map<const std::string, P_SHR_CONN_T>     CM_MAP_T;\n\n    CM_MAP_T               cm_map;\n\n    static boost::mutex    access_mtx;\n\n\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   F U N C T I O N\n\n    ConnSessionManager();\n\n    ~ConnSessionManager();\n\n    static ConnSessionManager &Singleton(void);\n\n    void addConnection(ConnSession                    &connSesn,\n                       const std::string              &brokerURI,\n                       cms::Session::AcknowledgeMode  ackMode);\n};\n\n\n\n\n\n// CLASS: AMQ_Producer\n//\n//    Active MQ (AMQ) message producer.\n//\n// The constructor creates an AMQ Producer object that has the ability to send\n// messages to the specified DESTination, HOST and PORT.\n//\n// The send() method causes the message to be sent. While creating the message,\n// the send() method will apply the properites (if any) that have been set.\n//\n// The initProperty() method clears the list of properties that have been\n// established for this producer. \n//\n// The setProperty() method sets an AMQ message property for the message to be\n// sent. A new property is added each time this command is invoked, unless it's\n// for an existing property, in which case the old property is overwritten with\n// the new property.\n//\nclass AMQ_Producer {\npublic:\n    AMQ_Producer(const std::string    &dest,\n                 const std::string    &host,\n                 const std::string    &port);\n\n    ~AMQ_Producer() {};\n\n    void send(const std::string    &msg,\n              const std::string    &type = \"\");\n\nprotected:\n\n    const std::string    m_dest;\n    std::string          m_broker_uri;\n\n    std::map<const std::string, std::string>    propertyInfo;\n\n    static const cms::DeliveryMode::DELIVERY_MODE    m_delivery_mode;\n};\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n\n#include <cms/ConnectionFactory.h>\n#include <boost/thread/once.hpp>\n\n\n\n\n\n// access control to the singleton.\nboost::mutex    ConnSessionManager::access_mtx;\n\nstatic boost::once_flag    init_flag = BOOST_ONCE_INIT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::ConnSessionManager\n**\n** Function:    Create the connection manage object (singleton) and initialize\n**              the Active MQ library that we use, once.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::ConnSessionManager () :\n    cm_map()\n{\n    // only call the library initialization ONCE.\n    boost::call_once(activemq::library::ActiveMQCPP::initializeLibrary,\n                     init_flag);\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::~ConnSessionManager\n**\n** Function:    Destroty the connection manager\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::~ConnSessionManager ()\n{\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::Singleton\n**\n** Function:    Return a referece to our singleton.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager &\nConnSessionManager::Singleton (void)\n{\n    static ConnSessionManager    singleton;\n\n    return (singleton);\n}\n\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::addConnection\n**\n** Function:    Add, or re-add a connection to the connection manager.\n**              Create a session on the connection and return them.\n**\n**              An exception is thrown if we cannot get a connection.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nConnSessionManager::addConnection (ConnSessionManager::ConnSession  &connSesn,\n                                   const std::string                &brokerURI,\n                                   cms::Session::AcknowledgeMode    ackMode)\n{\n    CM_MAP_T           &map_ref = Singleton().cm_map;\n    P_SHR_CONN_T       &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T    &p_session(connSesn.p_session);\n\n\n    // Create a ConnectionFactory that we automatically dealloate itself\n    std::auto_ptr<cms::ConnectionFactory>\n        connectionFactory(cms::ConnectionFactory::\n                          createCMSConnectionFactory(brokerURI));\n\n    // Create the connection and attach to shared pointer\n    p_conn.reset(connectionFactory->createConnection());\n\n\n    // Start the connection\n    p_conn->start();\n\n\n    // Create the session\n    p_session.reset(p_conn->createSession(ackMode));\n\n\n    // Update the map\n    map_ref.erase(brokerURI);\n    map_ref[brokerURI] = p_conn;\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::getConnSession\n**\n** Function:    Get a working Active MQ connection for the specified brokerURI\n**              and return it along with an allocated session or thrown an\n**              exception.\n**\n**              This finds the existing AMQ connection for the specified\n**              brokerURI, validates that it's still connected, creates a\n**              session on it and returns them. If the connection isn't valid\n**              anymore (i.e. the broker restarted) or if the connection\n**              doesn't exist yet, we create it.\n**\n**              If we cannot create the connection we throw an exception.\n**\n**              WHY DO WE ALLOCATE A SESSION TOO? Why don't we just get the\n**              conection and return it? It's possible that the connection was\n**              reset since the last time we used it (i.e the broker\n**              restarted). The only way we can tell this is if the\n**              createSession call fails. Since we have to create a session to\n**              prove that the connection works, lets use it. The caller would\n**              do it once it had a connection anyway!\n**\n**              Why don't we just return a shared pointer to the session, why\n**              do we also return a shared pointer to the connection? Sessions\n**              are built on top of connections. It would be BAD if the\n**              connection was deleted before the session. So we keep a shared\n**              pointer of both together to ensure that they have the same\n**              lifecycle.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: P_SHR_CONN_T - A shared pointer to the connection to use\n**\n****************************************************************************/\nvoid\nConnSessionManager::getConnSession (ConnSessionManager::ConnSession &connSesn,\n                                    const std::string               &brokerURI,\n                                    cms::Session::AcknowledgeMode   ackMode)\n{\n    P_SHR_CONN_T          &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T       &p_session(connSesn.p_session);\n    ConnSessionManager    &me = Singleton();\n    CM_MAP_T              &map_ref = me.cm_map;\n\n\n    // restrict access\n    boost::lock_guard<boost::mutex>    lock(access_mtx);\n\n\n    // get the entry\n    p_conn = map_ref[brokerURI];\n\n\n    // if it's not allocated yet, then allocate it, attach it and return it\n    if (NULL == p_conn) {\n        printf(\"Creating connection for %s\\n\",\n               brokerURI.c_str());\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n\n\n    // Check if the broker restarted and reset our connection. If it has,\n    // then create session will generate an exception and we know we then\n    // need to make a new connection. If it it works then use the session,\n    // passing it back in the connSession\n    try {\n        p_session.reset(p_conn->createSession(ackMode));\n    }\n    catch (std::exception    &e) {\n        printf(\"Re-creating connection for %s: %s\\n\",\n               brokerURI.c_str(), e.what());\n\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n}\n\n\n\n\n\n// **********************************************************************\n// **********************************************************************\n//                               AMQ_Producer\n// **********************************************************************\n// **********************************************************************\n\n\n// m_delivery_mode\n//\n//     The producer's delivery mode is set to NON_PERSISTENT. When persistent\n//     it causes the broker to save the message to disk so that it is available\n//     even if the broker restarts. However, this has a price, it greatly slows\n//     down the send (220,475 microseconds with persistance, vs. 226\n//     microseconds without.) These measurements where taken WITH synchronous\n//     sends. We could have investigated and used async sends to speed up the\n//     send call and keep persistence, however, this wasn't deemed necessary.\n//\n//     http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_delivery_mode.html\n//\n//     http://activemq.apache.org/persistence-questions.html\n//\n//     http://activemq.apache.org/what-is-the-difference-between-persistent-and-non-persistent-delivery.html\n//\nconst cms::DeliveryMode::DELIVERY_MODE\nAMQ_Producer::m_delivery_mode = cms::DeliveryMode::NON_PERSISTENT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::AMQ_Producer\n**\n** Function:    Create the Active MQ Producer client object, storing the\n**              destination and creating the URI string from the provided host\n**              name and port number.\n**\n** Input Parms: dest: The destination queue/topic to communicate with\n**\n**              host: The host to communicate with\n**\n**              port: The port on the host to communicate with\n**\n** Return Parm: \n**\n****************************************************************************/\nAMQ_Producer::AMQ_Producer (const std::string    &dest,\n                            const std::string    &host,\n                            const std::string    &port) :\n    m_dest(dest),\n    m_broker_uri(\"tcp://\" + host + \":\" + port +\n                 \"?connection.alwaysSyncSend=true\")\n{\n\n\n    // add the send timeout if its environemtn varialbe is given and its a\n    // value other than the default, zero.\n    int    sendTimeout(0);\n\n    GetEnv(\"SEND_TO\", sendTimeout, 0);\n\n    if (sendTimeout) {\n        std::stringstream    ss_sto;\n\n        ss_sto << \"&connection.sendTimeout=\" << sendTimeout;\n\n        m_broker_uri += ss_sto.str();\n    }\n\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::send\n**\n** Function:    Cause the message to be sent by this producer to the\n**              established message queue, host and port.\n**\n**              This gets a cached (or if needed new) connection which has a\n**              session created for it, it then creates the destination,\n**              producer and message. Finally it adds all of the properties\n**              that we want to the message and sends it.\n**\n**              This model is best explained at the Active MQ CPP example page\n**              at: http://activemq.apache.org/cms/cms-api-overview.html\n**\n** Input Parms: msg - The message to send with this producer\n**\n**              type - (optional) The CMSType/JMSType to set the message to. \n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nAMQ_Producer::send (const std::string    &msg,\n                    const std::string    &type)\n{\n    std::string    s_where;\n\n\n    try {\n        ConnSessionManager::ConnSession    conSesn;\n\n\n        // Create the Connection + Session\n        s_where = \"creating connection/session\";\n        ConnSessionManager::getConnSession(conSesn, m_broker_uri,\n                                           cms::Session::AUTO_ACKNOWLEDGE);\n\n\n        // Create the Destination (queue/topic)\n        s_where = \"creating destination\";\n        boost::shared_ptr<cms::Destination>\n            p_destination(conSesn.p_session->createQueue(m_dest));\n\n\n        // Create the Producer\n        s_where = \"creating message producer\";\n        boost::shared_ptr<cms::MessageProducer>\n            p_producer(conSesn.p_session->createProducer(p_destination.get()));\n        p_producer->setDeliveryMode(m_delivery_mode);\n\n\n\n        // Create the Message\n        s_where = \"creating connection\";\n        boost::shared_ptr<cms::TextMessage>\n            p_msg(conSesn.p_session->createTextMessage(msg));\n\n\n        // Set the Message's JMSType/CMSType\n        if (!type.empty()) {\n            p_msg->setCMSType(type);\n        }\n\n\n        std::map<const std::string, std::string>::iterator it;\n\n        // run through all properties, adding them to the message\n        for (it = propertyInfo.begin(); it != propertyInfo.end(); ++it) {\n            s_where = \"adding property \" + (*it).first;\n            p_msg->setStringProperty((*it).first, (*it).second);\n        }\n\n\n        // Send it!\n        s_where = \"sending message\";\n        p_producer->send(p_msg.get());\n    }\n    catch (std::exception    &e) {\n        std::stringstream    ss_err;\n\n        ss_err << \"Error while \" << s_where << \" [\" << e.what() << \"]\";\n        throw ee_except(ss_err);\n    }\n}\n\n\n// ---------------------------------------------------------------------------\n\n\n\n\n\n\nconst std::string    base_msg(\"1024 characters folowed by a message.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxHello world! \");\n\n\n\n\n\n\nvoid run_test ()\n{\n    std::string     host(\"127.0.0.1\");\n    std::string     port(\"61616\");\n    std::string     destURI(\"c.c.p.v.ms.events\");\n    unsigned int    iteration(0);\n    unsigned int    ex_count(0);\n\n\n    // Loop, creating producers and sending the message\n    while (1) {\n        iteration++;\n        AMQ_Producer    producer(destURI, host, port);\n\n\n        std::stringstream    msg;\n\n        msg << base_msg << iteration;\n\n        printf(\"Sending message #%d\\n\", iteration);\n\n        try {\n            producer.send(msg.str(), \"TEST_TYPE\");\n        }\n        catch (std::exception    &e) {\n            ex_count++;\n\n            printf(\"\\n\\nException[%d]: %s\\n\", ex_count, e.what());\n\n            if (ex_count >= 10 ) {\n                printf(\"\\n\\nException limit (%d) reached. Stopping test\\n\\n\\n\",\n                       ex_count);\n                break;\n            }\n        }\n\n    }\n}\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\nint main(int, char*) {\n\n    activemq::library::ActiveMQCPP::initializeLibrary();\n\n    std::cout << \"=====================================================\\n\";\n    std::cout << \"Starting the example:\" << std::endl;\n    std::cout << \"-----------------------------------------------------\\n\";\n\n    run_test();   \n\n\n    std::cout << \"-----------------------------------------------------\\n\";\n    std::cout << \"Finished with the example.\" << std::endl;\n    std::cout << \"=====================================================\\n\";\n\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n{code}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Producer connection that causes broker to reach its memory/disk limits doesn't get the 'all full' exception even though the broker is configured to send it for Producer Flow Control.\n\nDescription:\nProducer connection that cause the broker to reach its memory/disk limits\ndoesn't get the 'all full' exception even though the broker is configured to\nsend it for Producer Flow Control.\n\n\n+Scenario #1+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the default sendTimeot of zero(0), it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will lock up and never recovers.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception.\n\n\n\n+Scenario #2+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the sendTimeot of 500 ms, it uses one connection, and enters a loop that just sends messages.\\\\\n\\\\\nAfter awhile the producer will cause the broker to reach it's limit. And then the send method will start timing out. It never gets a 'broker full' exception.\\\\\n\\\\\n# Start another producer in another window.\\\\\n\\\\\nIt immediate fails with a 'broker full' exception\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n{noformat}\n######################################################################\n## SCENARIO #1\n######################################################################\n\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## View the activemq.xml configuration file used for startint active MQ\n##\nroot@psbu-jrr-lnx:#  cat /usr/BWhttpd/tomcat/webapps/amqbroker/WEB-INF/classes/conf/activemq.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:amq=\"http://activemq.apache.org/schema/core\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  \n  http://activemq.apache.org/schema/core \n  http://activemq.apache.org/schema/core/activemq-core-5.3.2.xsd\"\n  default-autowire=\"byName\">\n\n  <!-- Allows to use system properties as variables in this configuration file -->\n    <bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    </bean>\n\n    <broker xmlns=\"http://activemq.apache.org/schema/core\"\n            brokerName=\"localhost\"\n            advisorySupport=\"true\"\n            dataDirectory=\"${catalina.home}/activemq-data\"\n            useJmx=\"false\"\n            useShutdownHook=\"false\">\n        <!-- Destination specific policies using destination names or wildcards\n        -->\n        <destinationPolicy>\n            <policyMap>\n                <policyEntries>\n                    <policyEntry queue=\">\" memoryLimit=\"5mb\" />\n                    <policyEntry topic=\">\" memoryLimit=\"5mb\" />\n                </policyEntries>\n            </policyMap>\n        </destinationPolicy>\n\n        <systemUsage>\n            <systemUsage sendFailIfNoSpace=\"true\">\n                <memoryUsage>\n                    <memoryUsage limit=\"5 mb\" />\n                </memoryUsage>\n                <storeUsage>\n                    <storeUsage limit=\"4 mb\" />\n                </storeUsage>\n                <tempUsage>\n                    <tempUsage limit=\"1 mb\" />\n                </tempUsage>\n                </systemUsage>\n        </systemUsage>\n\n        <!-- The transport connectors ActiveMQ will listen to -->\n        <transportConnectors>\n            <transportConnector name=\"tcp\"\n             uri=\"tcp://0.0.0.0:61616?wireFormat.maxInactivityDuration=0\" />\n        </transportConnectors>\n    </broker>\n</beans>\n\n\n\n\n\n##\n## View the runtime environment to validate the library is 3.4.4, the latests.\n## I cannot explain why the number is 14.0.4, but I observed that 3.4.0 used\n## 14.0.0\n##\n242(TEST)jrr@[SUSE10.1]>  ls $LD_LIBRARY_PATH/libactive*\n/usr/BWhttpd/lib//libactivemq-cpp.so*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14*\n/usr/BWhttpd/lib//libactivemq-cpp.so.14.0.4*\n243(TEST)jrr@[SUSE10.1]>  \n\n\n\n\n##\n## Compile the simple producer\n##\nCompiling simple_producer.o\ng++ -g -c -MD -Wall -Werror -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/activemq-cpp/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/ -I /views/LU-7.0-NEWAMQ/server/CommonLib/include/apr-1  simple_producer.cpp\ng++ -o simple_producer.exe simple_producer.o -lc -lrt \\\n    -lactivemq-cpp \\\n    -lboost_thread \\\n    -L /usr/BWhttpd/lib\n\nCompilation finished at Mon Jul  9 15:32:48\n\n\n\n\n\n\n##\n## Execute the test program. It creates a connection and then loops forever\n## sending messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## It locks up at 1775 messages\n##\n\n257(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\nSending message #2\nSending message #3\nSending message #4\nSending message #5\n...\n...\n...\nSending message #1772\nSending message #1773\nSending message #1774\nSending message #1775\nSending message #1776\n\n\n\n\n##\n## View the ActiveMQ disk usage during the lock up\n##\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n\n\n\n##\n## Use GDB to see where the simple_producer is blocked\n##\npsbu-jrr-lnx[SUSE10.1]:176>  ps auxw | egrep simple_producer.exe\njrr      16974  1.3  0.6  53980  6724 pts/12   Sl+  17:58   0:00 simple_producer.exe\njrr      16997  0.0  0.0   1864   660 pts/18   S+   17:59   0:00 /bin/grep -E simple_producer.exe\npsbu-jrr-lnx[SUSE10.1]:177>  \npsbu-jrr-lnx[SUSE10.1]:177>  gdb simple_producer.exe \nGNU gdb 6.6\nCopyright (C) 2006 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"i586-suse-linux\"...\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n\n\n(gdb) set print pretty\n\n\n(gdb) set pagination off\n\n\n(gdb) attach 16974\nAttaching to program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\nReading symbols from /lib/librt.so.1...done.\nLoaded symbols for /lib/librt.so.1\nReading symbols from /usr/BWhttpd/lib/libactivemq-cpp.so.14...done.\nLoaded symbols for /usr/BWhttpd/lib/libactivemq-cpp.so.14\nReading symbols from /usr/BWhttpd/lib/libboost_thread.so.1.43.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libboost_thread.so.1.43.0\nReading symbols from /usr/lib/libstdc++.so.6...done.\nLoaded symbols for /usr/lib/libstdc++.so.6\nReading symbols from /lib/libm.so.6...done.\nLoaded symbols for /lib/libm.so.6\nReading symbols from /lib/libc.so.6...done.\nLoaded symbols for /lib/libc.so.6\nReading symbols from /lib/libgcc_s.so.1...done.\nLoaded symbols for /lib/libgcc_s.so.1\nReading symbols from /lib/libpthread.so.0...done.\n[Thread debugging using libthread_db enabled]\n[New Thread -1221044560 (LWP 16974)]\n[New Thread -1254835296 (LWP 16981)]\n[New Thread -1246442592 (LWP 16978)]\n[New Thread -1238049888 (LWP 16977)]\n[New Thread -1229657184 (LWP 16976)]\n[New Thread -1221264480 (LWP 16975)]\nLoaded symbols for /lib/libpthread.so.0\nReading symbols from /lib/ld-linux.so.2...done.\nLoaded symbols for /lib/ld-linux.so.2\nReading symbols from /usr/BWhttpd/lib/libapr-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libapr-1.so.0\nReading symbols from /lib/libuuid.so.1...done.\nLoaded symbols for /lib/libuuid.so.1\nReading symbols from /lib/libcrypt.so.1...done.\nLoaded symbols for /lib/libcrypt.so.1\nReading symbols from /usr/BWhttpd/lib/libaprutil-1.so.0...done.\nLoaded symbols for /usr/BWhttpd/lib/libaprutil-1.so.0\nReading symbols from /usr/BWhttpd/lib/libexpat.so.1...done.\nLoaded symbols for /usr/BWhttpd/lib/libexpat.so.1\nReading symbols from /usr/lib/libssl.so.0.9.8...done.\nLoaded symbols for /usr/lib/libssl.so.0.9.8\nReading symbols from /usr/lib/libcrypto.so.0.9.8...done.\nLoaded symbols for /usr/lib/libcrypto.so.0.9.8\nReading symbols from /lib/libdl.so.2...done.\nLoaded symbols for /lib/libdl.so.2\n0xffffe410 in __kernel_vsyscall ()\n\n\n(gdb) thread apply all where\n\n\n\nThread 6 (Thread -1221264480 (LWP 16975)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b120) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806ae5c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806ae58) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806ae50) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806aff8) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806aff8) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 5 (Thread -1229657184 (LWP 16976)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806b368) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806b1fc) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806b1f8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806b1f0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806b240) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806b240) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 4 (Thread -1238049888 (LWP 16977)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806c718) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806c2ec) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7d77fc0 in decaf::internal::util::concurrent::SynchronizableImpl::wait (this=0x806c2e8) at decaf/internal/util/concurrent/SynchronizableImpl.cpp:48\n#6  0xb7de6ba9 in decaf::util::TimerImpl::run (this=0x806c2e0) at decaf/util/Timer.cpp:81\n#7  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c5c0) at decaf/lang/Thread.cpp:137\n#8  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c5c0) at decaf/lang/Thread.cpp:190\n#9  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#10 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 3 (Thread -1246442592 (LWP 16978)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb765ba8b in std::exception::what () from /lib/libc.so.6\n#2  0xb7580b7a in apr_socket_recv (sock=0x80649e8, buf=0x8066c10 \"\", len=0xb5b4c040) at network_io/unix/sendrecv.c:81\n#3  0xb7d49ebd in decaf::internal::net::tcp::TcpSocket::read (this=0x8064898, buffer=0x8066c10 \"\", size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocket.cpp:649\n#4  0xb7d4d1c0 in decaf::internal::net::tcp::TcpSocketInputStream::doReadArrayBounded (this=0x8066c10, buffer=0x2000 <Address 0x2000 out of bounds>, size=8192, offset=0, length=8192) at decaf/internal/net/tcp/TcpSocketInputStream.cpp:108\n#5  0xb7d91d1f in decaf::io::InputStream::doReadArray (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:138\n#6  0xb7d92333 in decaf::io::InputStream::read (this=0x8066998, buffer=0x8066c10 \"\", size=8192) at decaf/io/InputStream.cpp:72\n#7  0xb7d866ef in decaf::io::BufferedInputStream::bufferData (this=0x8066b60, inputStream=0x8066998, buffer=@0xb5b4c1f8) at decaf/io/BufferedInputStream.cpp:326\n#8  0xb7d86d18 in decaf::io::BufferedInputStream::doReadArrayBounded (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/BufferedInputStream.cpp:228\n#9  0xb7d92191 in decaf::io::InputStream::read (this=0x8066b60, buffer=0x80669ca \"\", size=4, offset=0, length=4) at decaf/io/InputStream.cpp:84\n#10 0xb7d8a757 in decaf::io::DataInputStream::readAllData (this=0x80669b8, buffer=0x80669ca \"\", length=4) at decaf/io/DataInputStream.cpp:492\n#11 0xb7d8c684 in decaf::io::DataInputStream::readInt (this=0x80669b8) at decaf/io/DataInputStream.cpp:124\n#12 0xb7cae1b8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x8063e10, transport=0x8064790, dis=0x80669b8) at activemq/wireformat/openwire/OpenWireFormat.cpp:245\n#13 0xb7c2c9f7 in activemq::transport::IOTransport::run (this=0x8064790) at activemq/transport/IOTransport.cpp:246\n#14 0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806c088) at decaf/lang/Thread.cpp:137\n#15 0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806c088) at decaf/lang/Thread.cpp:190\n#16 0xb75912ab in start_thread () from /lib/libpthread.so.0\n#17 0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 2 (Thread -1254835296 (LWP 16981)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806cde8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806d24c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7c1fada in activemq::threads::CompositeTaskRunner::run (this=0x806d208) at activemq/threads/CompositeTaskRunner.cpp:115\n#6  0xb7dac25a in decaf::lang::ThreadProperties::runCallback (properties=0x806cbc0) at decaf/lang/Thread.cpp:137\n#7  0xb7daa47c in (anonymous namespace)::threadWorker (arg=0x806cbc0) at decaf/lang/Thread.cpp:190\n#8  0xb75912ab in start_thread () from /lib/libpthread.so.0\n#9  0xb766aa4e in clone () from /lib/libc.so.6\n\n\n\nThread 1 (Thread -1221044560 (LWP 16974)):\n#0  0xffffe410 in __kernel_vsyscall ()\n#1  0xb7595056 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0xb767629d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6\n#3  0xb7d7841d in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x806f1a8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#4  0xb7df07c3 in decaf::util::concurrent::Mutex::wait (this=0x806f13c) at decaf/util/concurrent/Mutex.cpp:126\n#5  0xb7de9395 in decaf::util::concurrent::CountDownLatch::await (this=0x806f134) at decaf/util/concurrent/CountDownLatch.cpp:53\n#6  0xb7c36025 in activemq::transport::correlator::FutureResponse::getResponse (this=0x806f130) at ./activemq/transport/correlator/FutureResponse.h:62\n#7  0xb7c33aa2 in activemq::transport::correlator::ResponseCorrelator::request (this=0x806b740, command=@0xbf9301cc) at activemq/transport/correlator/ResponseCorrelator.cpp:120\n#8  0xb7b649fa in activemq::core::ActiveMQConnection::syncRequest (this=0x806b858, command=@0xbf9301cc, timeout=0) at activemq/core/ActiveMQConnection.cpp:896\n#9  0xb7baf1d8 in activemq::core::ActiveMQSession::send (this=0x80635b8, message=0x806e640, producer=0x806e530, usage=0x0) at activemq/core/ActiveMQSession.cpp:921\n#10 0xb7ba1e71 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640, deliveryMode=1, priority=4, timeToLive=0) at activemq/core/ActiveMQProducer.cpp:211\n#11 0xb7ba2b07 in activemq::core::ActiveMQProducer::send (this=0x806e530, destination=0x806e3ec, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:152\n#12 0xb7ba3cab in activemq::core::ActiveMQProducer::send (this=0x806e530, message=0x806e640) at activemq/core/ActiveMQProducer.cpp:128\n#13 0x0804c5ac in AMQ_Producer::send (this=0xbf9305c8, msg=@0xbf930600, type=@0xbf9305f8) at simple_producer.cpp:720\n#14 0x0804ca45 in run_test () at simple_producer.cpp:767\n#15 0x0804cd47 in main () at simple_producer.cpp:798\n#0  0xffffe410 in __kernel_vsyscall ()\n(gdb) detach\nDetaching from program: /views/TEST/AMQ/AMQ2/simple_producer.exe, process 16974\n(gdb) quit\npsbu-jrr-lnx[SUSE10.1]:178>  \n\n\n\n\n\n##\n## If we kill the program and execute it again, then this time it will\n## terminate with the expected exception.\n##\n\n258(TEST)jrr@[SUSE10.1]>  simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622326f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSending message #2\n\n\n...\n...\n...\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622426f 1048576). Stopping producer (ID:psbu-jrr-lnx-53043-1341882066464-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n259(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{noformat}\n######################################################################\n## SCENARIO #2\n######################################################################\n##\n## Restart our tomcat service which restarts the AMQ Broker and view the\n## directory size.\n##\n\n\nroot@psbu-jrr-lnx:#  /usr/BWhttpd/bin/init_tomcat stop; \\rm -rf /usr/BWhttpd/tomcat/activemq-data; /usr/BWhttpd/bin/init_tomcat start; du -sh /usr/BWhttpd/tomcat/activemq-data\nStopping tomcat ... done\nKilling tomcat ... done.\nStarting tomcat ... done\n44K     /usr/BWhttpd/tomcat/activemq-data\nroot@psbu-jrr-lnx:#  \n\n\n##\n## Execute the test program, this time pass in variables to cause the sendTime\n## to be set to 500ms. It creates a connection and then loops forever sending\n## messages.  Where for each message it creates sessions, destiation,\n## producer,etc. sends the message and then destructs all of those pieces.\n##\n## Now at 1775 messages the send times out. Moreover, the test moves on trying\n## more sends, and they all time out. After 10 failures the test exits. This\n## sender that causes the broker memory limmit to be reached never gets a\n## 'broker full' exception.\n##\n\n262(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\nSEND_TO set to 500\nSending message #2\nSEND_TO set to 500\nSending message #3\nSEND_TO set to 500\nSending message #4\n...\n...\n...\nSending message #1776\nException[1]: Error while sending message [No valid response received for command: Message { commandId = 8879, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1775:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882406582, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1776, check broker.]\nSEND_TO set to 500\nSending message #1777\n...\n...\n...\nSending message #1785\n\n\nException[10]: Error while sending message [No valid response received for command: Message { commandId = 8924, responseRequired = true, ProducerId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0, Destination = queue://c.c.p.v.ms.events, TransactionId = NULL, OriginalDestination = NULL, MessageId = ID:psbu-jrr-lnx-47169-1341882401921-0:0:1784:0:0:0, OriginalTransactionId = NULL, GroupID = , GroupSequence = 0, CorrelationId = , Persistent = false, Expiration = 0, Priority = 4, ReplyTo = NULL, Timestamp = 1341882411136, Type = TEST_TYPE, Content = [size=1045], MarshalledProperties = NULL, DataStructure = NULL, TargetConsumerId = NULL, Compressed = false, RedeliveryCounter = 0, BrokerPath = NULL, Arrival = 0, UserID = , RecievedByDFBridge = false, Droppable = false, Cluster = NULL, BrokerInTime = 0, BrokerOutTime = 0 }Text = 1024 characters folowed by a message.xxxxxxxx... world! 1785, check broker.]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n\n\n\n##\n##\n## View the ActiveMQ disk usage during the lock up\n##\n\nroot@psbu-jrr-lnx:#  !du\ndu -sh activemq-data/\n12M     activemq-data/\nroot@psbu-jrr-lnx:#  \n\n\n##\n## If we re-execute the test now that the broker is full, then this time it\n## will terminate with the expected broker full exception.\n##\n\n263(TEST)jrr@[SUSE10.1]>  env SEND_TO=500 simple_producer.exe\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSEND_TO set to 500\nSending message #1\nCreating connection for tcp://127.0.0.1:61616?connection.alwaysSyncSend=true&connection.sendTimeout=500\n\n\nException[1]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001622756f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:0:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\nSEND_TO set to 500\n...\n...\n...\nSEND_TO set to 500\nSending message #10\n\n\nException[10]: Error while sending message [*** BEGIN SERVER-SIDE STACK TRACE ***\nMessage: Usage Manager Temp Store is Full (01001623156f 1048576). Stopping producer (ID:psbu-jrr-lnx-32967-1341882542997-0:0:9:0) to prevent flooding queue://c.c.p.v.ms.events. See http://activemq.apache.org/producer-flow-control.html for more info\nException Class javax.jms.ResourceAllocationException\n        [FILE: BaseDestination.java, LINE: 579] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: BaseDestination.java, LINE: 573] occurred in: org.apache.activemq.broker.region.BaseDestination.waitForSpace\n        [FILE: Queue.java, LINE: 757] occurred in: org.apache.activemq.broker.region.Queue.checkUsage\n        [FILE: Queue.java, LINE: 674] occurred in: org.apache.activemq.broker.region.Queue.doMessageSend\n        [FILE: Queue.java, LINE: 653] occurred in: org.apache.activemq.broker.region.Queue.send\n        [FILE: AbstractRegion.java, LINE: 365] occurred in: org.apache.activemq.broker.region.AbstractRegion.send\n        [FILE: RegionBroker.java, LINE: 523] occurred in: org.apache.activemq.broker.region.RegionBroker.send\n        [FILE: BrokerFilter.java, LINE: 129] occurred in: org.apache.activemq.broker.BrokerFilter.send\n        [FILE: CompositeDestinationBroker.java, LINE: 96] occurred in: org.apache.activemq.broker.CompositeDestinationBroker.send\n        [FILE: TransactionBroker.java, LINE: 227] occurred in: org.apache.activemq.broker.TransactionBroker.send\n        [FILE: MutableBrokerFilter.java, LINE: 135] occurred in: org.apache.activemq.broker.MutableBrokerFilter.send\n        [FILE: TransportConnection.java, LINE: 458] occurred in: org.apache.activemq.broker.TransportConnection.processMessage\n        [FILE: ActiveMQMessage.java, LINE: 681] occurred in: org.apache.activemq.command.ActiveMQMessage.visit\n        [FILE: TransportConnection.java, LINE: 306] occurred in: org.apache.activemq.broker.TransportConnection.service\n        [FILE: TransportConnection.java, LINE: 179] occurred in: org.apache.activemq.broker.TransportConnection$1.onCommand\n        [FILE: TransportFilter.java, LINE: 69] occurred in: org.apache.activemq.transport.TransportFilter.onCommand\n        [FILE: WireFormatNegotiator.java, LINE: 113] occurred in: org.apache.activemq.transport.WireFormatNegotiator.onCommand\n        [FILE: InactivityMonitor.java, LINE: 227] occurred in: org.apache.activemq.transport.InactivityMonitor.onCommand\n        [FILE: TransportSupport.java, LINE: 83] occurred in: org.apache.activemq.transport.TransportSupport.doConsume\n        [FILE: TcpTransport.java, LINE: 220] occurred in: org.apache.activemq.transport.tcp.TcpTransport.doRun\n        [FILE: TcpTransport.java, LINE: 202] occurred in: org.apache.activemq.transport.tcp.TcpTransport.run\n        [FILE: , LINE: -1] occurred in: java.lang.Thread.run\n*** END SERVER-SIDE STACK TRACE ***]\n\n\nException limit (10) reached. Stopping test\n\n\n-----------------------------------------------------\nFinished with the example.\n=====================================================\nterminate called after throwing an instance of 'decaf::lang::exceptions::RuntimeException'\n  what():  Unlock Failed, this thread is not the Lock Owner!\nAbort\n264(TEST)jrr@[SUSE10.1]>  \n{noformat}\n\n\n\\\\\n\\\\\n----\n\\\\\n\\\\\n\n\n{code}\n//////////////////////////////////////////////////////////////////////\n// Not so simple producer.\n//\n// The Active MQ Client's simple producer code has been modified to allow for\n\n// investigation into client behaviour. I've integrated the products engine for\n// obtaining a connection, session, queue, destination, sender and message.\n//\n// The code basically does the following:\n//       - create a connection to be used over and over for the test\n//       - loop forever\n//         - create a session, queue, destination, sender and message\n//         - send the message\n//         - destroy the message, sender, destination, topic and session.\n//\n// ----------------------------------------\n// ENVIRONMENT VARIABLE OVERRIDES\n// ----------------------------------------\n//\n// SEND_TO : default is 0. If non-zero then it appends connection.sendTimeout\n//           to the destination URI using the value set for SEND_TO. Refer to\n//           the connection options at\n//           http://activemq.apache.org/cms/configuring.html for details\n//           regarding its values.\n//\n\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <decaf/lang/Thread.h>\n#include <decaf/lang/Runnable.h>\n#include <decaf/util/concurrent/CountDownLatch.h>\n#include <decaf/lang/Long.h>\n#include <decaf/util/Date.h>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <activemq/util/Config.h>\n#include <activemq/library/ActiveMQCPP.h>\n#include <cms/Connection.h>\n#include <cms/Session.h>\n#include <cms/TextMessage.h>\n#include <cms/BytesMessage.h>\n#include <cms/MapMessage.h>\n#include <cms/ExceptionListener.h>\n#include <cms/MessageListener.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <memory>\n#include <boost/scoped_ptr.hpp>\n#include <boost/thread/thread.hpp>\n#include <boost/lexical_cast.hpp>\n\n\nusing namespace activemq;\nusing namespace activemq::core;\nusing namespace decaf;\nusing namespace decaf::lang;\nusing namespace decaf::util;\nusing namespace decaf::util::concurrent;\nusing namespace cms;\nusing namespace std;\n\n\n\n\n\n//\n// Override values with environement values if they exist\n//\ntemplate <class DEST>\nbool GetEnv (const std::string    var,\n             DEST                 &dst,\n             const DEST           &def_value)\n{\n    const char *val(::getenv(var.c_str()));\n\n    dst = def_value;\n\n    if (NULL == val) {\n        return (false);\n    }\n\n    try {\n        dst = boost::lexical_cast<DEST>(val);\n        printf(\"%s set to %s\\n\", var.c_str(), val);\n        return(true);\n    }\n    catch (std::exception    &e) {\n        printf(\"%s\\n\", e.what());\n        printf(\"Cannot convert '%s' to the desired output format\\n\", val);\n    }\n\n    return(false);\n}\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// EventEngineUtil.hxx\n// ---------------------------------------------------------------------------\nclass ee_except : public std::exception\n{\npublic:\n    // ee_except(std::string)\n    //\n    //    Create an exception using the specified string\n    //\n    explicit ee_except (const std::string    &_msg) :\n        msg(_msg)\n        {};\n\n    explicit ee_except (const std::stringstream    &_msg) :\n        msg(_msg.str())\n        {};\n\n\n    // ee_except(std::string, errNum)\n    //\n    //    Create an excpetion using the specified string, and then append the\n    //    numeric and string representation of the specified errno\n    //\n    explicit ee_except (const std::string    &_msg,\n                        int                  errNum) {\n        ee_except_helper(_msg, errNum);\n    }\n\n\n    explicit ee_except (const std::stringstream    &_msg,\n                       int                         errNum) {\n        ee_except_helper(_msg.str(), errNum);\n    }\n\n\n\n    // destroy the exception\n    ~ee_except() throw() {};\n\n\n    // return the message, overloading the standard what method\n    virtual const char *what() const throw() {\n        return msg.c_str();\n    }\n\n\nprotected:\n\n    void ee_except_helper (const std::string    &_msg,\n                           int                  errNum) {\n        std::stringstream    ss_error;\n\n\n        if (errNum) {\n            ss_error << _msg << \", errno: \" << errNum\n                     << \", \" << strerror(errNum);\n            msg = ss_error.str(); \n\n        } else {\n            msg = _msg;\n        }\n    }\n\n\n\nprivate:\n\n    std::string msg;\n};\n\n\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// From EventEngineAMQProducer\n// ---------------------------------------------------------------------------\n#include <boost/thread/thread.hpp>\n#include <boost/shared_ptr.hpp>\n#include <cms/DeliveryMode.h>\n#include <cms/Connection.h>\n#include <activemq/library/ActiveMQCPP.h>\n\n\n\n\n\n// CLASS: ConnSessionManager\n//\n//    Singleton class to manage Active MQ (AMQ) connections.\n//\n// getConnSession():\n//\n//    This method gets a connection for the specified broker, creates a session\n//    with the specified ackMode and populates the connSesn parameter with\n//    shared pointers to the alloated resources.\n//\n//    If a connection already exists for the brokerURI, it creates a session\n//    for it and returns them, if the connection does not exist it makes one\n//    attaches a session and returns them. If it cannot create the connection\n//    (such as the broker is not up), it throws an exception.\n//\n//    The connection manager can manage multiple connections based on the\n//    brokerURI. Each unique broker URI will be a different connection managed\n//    by the connection manager.\n//\n//\nclass ConnSessionManager {\npublic:\n    typedef boost::shared_ptr<cms::Connection>    P_SHR_CONN_T;\n    typedef boost::shared_ptr<cms::Session>       P_SHR_SESSION_T;\n\n\n    struct ConnSession {\n        P_SHR_CONN_T       p_conn;\n        P_SHR_SESSION_T    p_session;\n    };\n\n\n    static void getConnSession(ConnSession                    &connSesn,\n                               const std::string              &brokerURI,\n                               cms::Session::AcknowledgeMode  ackMode);\n\n\nprotected:\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   V A R I A B L E S\n\n    typedef std::map<const std::string, P_SHR_CONN_T>     CM_MAP_T;\n\n    CM_MAP_T               cm_map;\n\n    static boost::mutex    access_mtx;\n\n\n    // ----------------------------------------------------------------------\n    // P R O T E C T E D   M E M B E R   F U N C T I O N\n\n    ConnSessionManager();\n\n    ~ConnSessionManager();\n\n    static ConnSessionManager &Singleton(void);\n\n    void addConnection(ConnSession                    &connSesn,\n                       const std::string              &brokerURI,\n                       cms::Session::AcknowledgeMode  ackMode);\n};\n\n\n\n\n\n// CLASS: AMQ_Producer\n//\n//    Active MQ (AMQ) message producer.\n//\n// The constructor creates an AMQ Producer object that has the ability to send\n// messages to the specified DESTination, HOST and PORT.\n//\n// The send() method causes the message to be sent. While creating the message,\n// the send() method will apply the properites (if any) that have been set.\n//\n// The initProperty() method clears the list of properties that have been\n// established for this producer. \n//\n// The setProperty() method sets an AMQ message property for the message to be\n// sent. A new property is added each time this command is invoked, unless it's\n// for an existing property, in which case the old property is overwritten with\n// the new property.\n//\nclass AMQ_Producer {\npublic:\n    AMQ_Producer(const std::string    &dest,\n                 const std::string    &host,\n                 const std::string    &port);\n\n    ~AMQ_Producer() {};\n\n    void send(const std::string    &msg,\n              const std::string    &type = \"\");\n\nprotected:\n\n    const std::string    m_dest;\n    std::string          m_broker_uri;\n\n    std::map<const std::string, std::string>    propertyInfo;\n\n    static const cms::DeliveryMode::DELIVERY_MODE    m_delivery_mode;\n};\n\n\n\n\n\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n\n#include <cms/ConnectionFactory.h>\n#include <boost/thread/once.hpp>\n\n\n\n\n\n// access control to the singleton.\nboost::mutex    ConnSessionManager::access_mtx;\n\nstatic boost::once_flag    init_flag = BOOST_ONCE_INIT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::ConnSessionManager\n**\n** Function:    Create the connection manage object (singleton) and initialize\n**              the Active MQ library that we use, once.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::ConnSessionManager () :\n    cm_map()\n{\n    // only call the library initialization ONCE.\n    boost::call_once(activemq::library::ActiveMQCPP::initializeLibrary,\n                     init_flag);\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::~ConnSessionManager\n**\n** Function:    Destroty the connection manager\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager::~ConnSessionManager ()\n{\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::Singleton\n**\n** Function:    Return a referece to our singleton.\n**\n** Input Parms: None\n**\n** Return Parm: None\n**\n****************************************************************************/\nConnSessionManager &\nConnSessionManager::Singleton (void)\n{\n    static ConnSessionManager    singleton;\n\n    return (singleton);\n}\n\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::addConnection\n**\n** Function:    Add, or re-add a connection to the connection manager.\n**              Create a session on the connection and return them.\n**\n**              An exception is thrown if we cannot get a connection.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nConnSessionManager::addConnection (ConnSessionManager::ConnSession  &connSesn,\n                                   const std::string                &brokerURI,\n                                   cms::Session::AcknowledgeMode    ackMode)\n{\n    CM_MAP_T           &map_ref = Singleton().cm_map;\n    P_SHR_CONN_T       &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T    &p_session(connSesn.p_session);\n\n\n    // Create a ConnectionFactory that we automatically dealloate itself\n    std::auto_ptr<cms::ConnectionFactory>\n        connectionFactory(cms::ConnectionFactory::\n                          createCMSConnectionFactory(brokerURI));\n\n    // Create the connection and attach to shared pointer\n    p_conn.reset(connectionFactory->createConnection());\n\n\n    // Start the connection\n    p_conn->start();\n\n\n    // Create the session\n    p_session.reset(p_conn->createSession(ackMode));\n\n\n    // Update the map\n    map_ref.erase(brokerURI);\n    map_ref[brokerURI] = p_conn;\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        ConnSessionManager::getConnSession\n**\n** Function:    Get a working Active MQ connection for the specified brokerURI\n**              and return it along with an allocated session or thrown an\n**              exception.\n**\n**              This finds the existing AMQ connection for the specified\n**              brokerURI, validates that it's still connected, creates a\n**              session on it and returns them. If the connection isn't valid\n**              anymore (i.e. the broker restarted) or if the connection\n**              doesn't exist yet, we create it.\n**\n**              If we cannot create the connection we throw an exception.\n**\n**              WHY DO WE ALLOCATE A SESSION TOO? Why don't we just get the\n**              conection and return it? It's possible that the connection was\n**              reset since the last time we used it (i.e the broker\n**              restarted). The only way we can tell this is if the\n**              createSession call fails. Since we have to create a session to\n**              prove that the connection works, lets use it. The caller would\n**              do it once it had a connection anyway!\n**\n**              Why don't we just return a shared pointer to the session, why\n**              do we also return a shared pointer to the connection? Sessions\n**              are built on top of connections. It would be BAD if the\n**              connection was deleted before the session. So we keep a shared\n**              pointer of both together to ensure that they have the same\n**              lifecycle.\n**\n** Input Parms: connSesn  - ConnSession reference that is populated with a\n**                          connections shared pointer and session shared\n**                          pointer.\n**\n**              brokerURI - The Active MQ broker URI string to use to create\n**                          the connection.\n**\n**                  http://activemq.apache.org/cms/cms-api-overview.html\n**                  http://activemq.apache.org/cms/configuring.html\n**\n**              ackMode - The kind of acknowledgement we want the session to\n**                         have\n**\n**                  http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185\n**\n**\n** Return Parm: P_SHR_CONN_T - A shared pointer to the connection to use\n**\n****************************************************************************/\nvoid\nConnSessionManager::getConnSession (ConnSessionManager::ConnSession &connSesn,\n                                    const std::string               &brokerURI,\n                                    cms::Session::AcknowledgeMode   ackMode)\n{\n    P_SHR_CONN_T          &p_conn(connSesn.p_conn);\n    P_SHR_SESSION_T       &p_session(connSesn.p_session);\n    ConnSessionManager    &me = Singleton();\n    CM_MAP_T              &map_ref = me.cm_map;\n\n\n    // restrict access\n    boost::lock_guard<boost::mutex>    lock(access_mtx);\n\n\n    // get the entry\n    p_conn = map_ref[brokerURI];\n\n\n    // if it's not allocated yet, then allocate it, attach it and return it\n    if (NULL == p_conn) {\n        printf(\"Creating connection for %s\\n\",\n               brokerURI.c_str());\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n\n\n    // Check if the broker restarted and reset our connection. If it has,\n    // then create session will generate an exception and we know we then\n    // need to make a new connection. If it it works then use the session,\n    // passing it back in the connSession\n    try {\n        p_session.reset(p_conn->createSession(ackMode));\n    }\n    catch (std::exception    &e) {\n        printf(\"Re-creating connection for %s: %s\\n\",\n               brokerURI.c_str(), e.what());\n\n        return (me.addConnection(connSesn, brokerURI, ackMode));\n    }\n}\n\n\n\n\n\n// **********************************************************************\n// **********************************************************************\n//                               AMQ_Producer\n// **********************************************************************\n// **********************************************************************\n\n\n// m_delivery_mode\n//\n//     The producer's delivery mode is set to NON_PERSISTENT. When persistent\n//     it causes the broker to save the message to disk so that it is available\n//     even if the broker restarts. However, this has a price, it greatly slows\n//     down the send (220,475 microseconds with persistance, vs. 226\n//     microseconds without.) These measurements where taken WITH synchronous\n//     sends. We could have investigated and used async sends to speed up the\n//     send call and keep persistence, however, this wasn't deemed necessary.\n//\n//     http://activemq.apache.org/cms/api_docs/activemqcpp-3.4.0/html/classcms_1_1_delivery_mode.html\n//\n//     http://activemq.apache.org/persistence-questions.html\n//\n//     http://activemq.apache.org/what-is-the-difference-between-persistent-and-non-persistent-delivery.html\n//\nconst cms::DeliveryMode::DELIVERY_MODE\nAMQ_Producer::m_delivery_mode = cms::DeliveryMode::NON_PERSISTENT;\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::AMQ_Producer\n**\n** Function:    Create the Active MQ Producer client object, storing the\n**              destination and creating the URI string from the provided host\n**              name and port number.\n**\n** Input Parms: dest: The destination queue/topic to communicate with\n**\n**              host: The host to communicate with\n**\n**              port: The port on the host to communicate with\n**\n** Return Parm: \n**\n****************************************************************************/\nAMQ_Producer::AMQ_Producer (const std::string    &dest,\n                            const std::string    &host,\n                            const std::string    &port) :\n    m_dest(dest),\n    m_broker_uri(\"tcp://\" + host + \":\" + port +\n                 \"?connection.alwaysSyncSend=true\")\n{\n\n\n    // add the send timeout if its environemtn varialbe is given and its a\n    // value other than the default, zero.\n    int    sendTimeout(0);\n\n    GetEnv(\"SEND_TO\", sendTimeout, 0);\n\n    if (sendTimeout) {\n        std::stringstream    ss_sto;\n\n        ss_sto << \"&connection.sendTimeout=\" << sendTimeout;\n\n        m_broker_uri += ss_sto.str();\n    }\n\n}\n\n\n\n\n\n\n\n/****************************************************************************\n**\n** Name:        AMQ_Producer::send\n**\n** Function:    Cause the message to be sent by this producer to the\n**              established message queue, host and port.\n**\n**              This gets a cached (or if needed new) connection which has a\n**              session created for it, it then creates the destination,\n**              producer and message. Finally it adds all of the properties\n**              that we want to the message and sends it.\n**\n**              This model is best explained at the Active MQ CPP example page\n**              at: http://activemq.apache.org/cms/cms-api-overview.html\n**\n** Input Parms: msg - The message to send with this producer\n**\n**              type - (optional) The CMSType/JMSType to set the message to. \n**\n** Return Parm: None\n**\n****************************************************************************/\nvoid\nAMQ_Producer::send (const std::string    &msg,\n                    const std::string    &type)\n{\n    std::string    s_where;\n\n\n    try {\n        ConnSessionManager::ConnSession    conSesn;\n\n\n        // Create the Connection + Session\n        s_where = \"creating connection/session\";\n        ConnSessionManager::getConnSession(conSesn, m_broker_uri,\n                                           cms::Session::AUTO_ACKNOWLEDGE);\n\n\n        // Create the Destination (queue/topic)\n        s_where = \"creating destination\";\n        boost::shared_ptr<cms::Destination>\n            p_destination(conSesn.p_session->createQueue(m_dest));\n\n\n        // Create the Producer\n        s_where = \"creating message producer\";\n        boost::shared_ptr<cms::MessageProducer>\n            p_producer(conSesn.p_session->createProducer(p_destination.get()));\n        p_producer->setDeliveryMode(m_delivery_mode);\n\n\n\n        // Create the Message\n        s_where = \"creating connection\";\n        boost::shared_ptr<cms::TextMessage>\n            p_msg(conSesn.p_session->createTextMessage(msg));\n\n\n        // Set the Message's JMSType/CMSType\n        if (!type.empty()) {\n            p_msg->setCMSType(type);\n        }\n\n\n        std::map<const std::string, std::string>::iterator it;\n\n        // run through all properties, adding them to the message\n        for (it = propertyInfo.begin(); it != propertyInfo.end(); ++it) {\n            s_where = \"adding property \" + (*it).first;\n            p_msg->setStringProperty((*it).first, (*it).second);\n        }\n\n\n        // Send it!\n        s_where = \"sending message\";\n        p_producer->send(p_msg.get());\n    }\n    catch (std::exception    &e) {\n        std::stringstream    ss_err;\n\n        ss_err << \"Error while \" << s_where << \" [\" << e.what() << \"]\";\n        throw ee_except(ss_err);\n    }\n}\n\n\n// ---------------------------------------------------------------------------\n\n\n\n\n\n\nconst std::string    base_msg(\"1024 characters folowed by a message.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxHello world! \");\n\n\n\n\n\n\nvoid run_test ()\n{\n    std::string     host(\"127.0.0.1\");\n    std::string     port(\"61616\");\n    std::string     destURI(\"c.c.p.v.ms.events\");\n    unsigned int    iteration(0);\n    unsigned int    ex_count(0);\n\n\n    // Loop, creating producers and sending the message\n    while (1) {\n        iteration++;\n        AMQ_Producer    producer(destURI, host, port);\n\n\n        std::stringstream    msg;\n\n        msg << base_msg << iteration;\n\n        printf(\"Sending message #%d\\n\", iteration);\n\n        try {\n            producer.send(msg.str(), \"TEST_TYPE\");\n        }\n        catch (std::exception    &e) {\n            ex_count++;\n\n            printf(\"\\n\\nException[%d]: %s\\n\", ex_count, e.what());\n\n            if (ex_count >= 10 ) {\n                printf(\"\\n\\nException limit (%d) reached. Stopping test\\n\\n\\n\",\n                       ex_count);\n                break;\n            }\n        }\n\n    }\n}\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\nint main(int, char*) {\n\n    activemq::library::ActiveMQCPP::initializeLibrary();\n\n    std::cout << \"=====================================================\\n\";\n    std::cout << \"Starting the example:\" << std::endl;\n    std::cout << \"-----------------------------------------------------\\n\";\n\n    run_test();   \n\n\n    std::cout << \"-----------------------------------------------------\\n\";\n    std::cout << \"Finished with the example.\" << std::endl;\n    std::cout << \"=====================================================\\n\";\n\n    activemq::library::ActiveMQCPP::shutdownLibrary();\n}\n{code}\n\nComments:\n", "classification": "Classify the issue 'Producer connection that causes broker to reach its memory/disk limits doesn't get the 'all full' exception even though the broker is configured to send it for Producer Flow Control.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-413?\nA: Producer connection that cause the broker to reach its memory/disk limits\ndoesn't get the 'all full' exception even though the broker is configured to\nsend it for Producer Flow Control.\n\n\n+Scenario #1+\n\n# Delete the broker data directory\\\\\n\\\\\n# Start the broker, that sends an exception if no space\\\\\n\\\\\n# DO *+NOT+* START A CONUMSER.\\\\\n\\\\\n# Run a producer that does synchronous sends, and has the de"}}
{"issue_key": "AMQCPP-412", "project": "AMQCPP", "title": "when trying to to close session or conenction when the producer is already down, close call hangs forever", "status": "Closed", "reporter": "sandeep jain", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["performance"], "created": "2012-06-12T09:12:50.000+0000", "updated": "2012-06-20T15:49:17.000+0000", "description": "when trying to close the session on connection when producer is already down, the close call hangs forever and neither come out of the call nor throw any ex ception.\n\nbacktrace for the same is:\n\n\n  0x28bb33ed in activemq::core::ActiveMQConnection::syncRequest ()\n   from libactivemq-cpp.so.1\n#1  0x28bb3949 in activemq::core::ActiveMQConnection::disposeOf ()\n   from libactivemq-cpp.so.1\n#2  0x28bb3ce4 in activemq::core::ActiveMQConnection::disconnect ()\n   from libactivemq-cpp.so.1\n#3  0x28bb7c9a in activemq::core::ActiveMQConnection::close ()\n   from libactivemq-cpp.so.1", "comments": [], "text": "when trying to to close session or conenction when the producer is already down, close call hangs forever\n\nDescription:\nwhen trying to close the session on connection when producer is already down, the close call hangs forever and neither come out of the call nor throw any ex ception.\n\nbacktrace for the same is:\n\n\n  0x28bb33ed in activemq::core::ActiveMQConnection::syncRequest ()\n   from libactivemq-cpp.so.1\n#1  0x28bb3949 in activemq::core::ActiveMQConnection::disposeOf ()\n   from libactivemq-cpp.so.1\n#2  0x28bb3ce4 in activemq::core::ActiveMQConnection::disconnect ()\n   from libactivemq-cpp.so.1\n#3  0x28bb7c9a in activemq::core::ActiveMQConnection::close ()\n   from libactivemq-cpp.so.1\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: when trying to to close session or conenction when the producer is already down, close call hangs forever\n\nDescription:\nwhen trying to close the session on connection when producer is already down, the close call hangs forever and neither come out of the call nor throw any ex ception.\n\nbacktrace for the same is:\n\n\n  0x28bb33ed in activemq::core::ActiveMQConnection::syncRequest ()\n   from libactivemq-cpp.so.1\n#1  0x28bb3949 in activemq::core::ActiveMQConnection::disposeOf ()\n   from libactivemq-cpp.so.1\n#2  0x28bb3ce4 in activemq::core::ActiveMQConnection::disconnect ()\n   from libactivemq-cpp.so.1\n#3  0x28bb7c9a in activemq::core::ActiveMQConnection::close ()\n   from libactivemq-cpp.so.1\n\n\nComments:\n", "classification": "Classify the issue 'when trying to to close session or conenction when the producer is already down, close call hangs forever' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-412?\nA: when trying to close the session on connection when producer is already down, the close call hangs forever and neither come out of the call nor throw any ex ception.\n\nbacktrace for the same is:\n\n\n  0x28bb33ed in activemq::core::ActiveMQConnection::syncRequest ()\n   from libactivemq-cpp.so.1\n#1  0x28bb3949 in activemq::core::ActiveMQConnection::disposeOf ()\n   from libactivemq-cpp.so.1\n#2  0x28bb3c"}}
{"issue_key": "AMQCPP-411", "project": "AMQCPP", "title": "Add new get method in StreamMessage to allow for checking the type of the next value", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-06-11T15:42:09.000+0000", "updated": "2012-06-11T15:46:27.000+0000", "description": "Add getter getNextValueType to the cms::StreamMessage to allow accessing the type information for the next value in the stream message.", "comments": [], "text": "Add new get method in StreamMessage to allow for checking the type of the next value\n\nDescription:\nAdd getter getNextValueType to the cms::StreamMessage to allow accessing the type information for the next value in the stream message.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add new get method in StreamMessage to allow for checking the type of the next value\n\nDescription:\nAdd getter getNextValueType to the cms::StreamMessage to allow accessing the type information for the next value in the stream message.  \n\nComments:\n", "classification": "Classify the issue 'Add new get method in StreamMessage to allow for checking the type of the next value' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-411?\nA: Add getter getNextValueType to the cms::StreamMessage to allow accessing the type information for the next value in the stream message.  "}}
{"issue_key": "AMQCPP-410", "project": "AMQCPP", "title": "prefetchSize=0 is ignored when set via PrefetchPolicy", "status": "Resolved", "reporter": "Thomas Riccardi", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-06-08T17:38:19.000+0000", "updated": "2012-06-08T20:38:52.000+0000", "description": "When setting the prefetchSize to 0 via PrefecthPolicy, the value seen by the broker is 1000.\n\nThe value is correctly set in ActiveMQConsumer constructor in consumerInfo, but is later overwritten to 1000 by applyDestinationOptions(), even if the option is not set in the destination options from the broker url.\n\napplyDestinationOptions() considers 0 as an invalid value, and then forces the reading of the value from the destination option, which has the default value of 1000.", "comments": [], "text": "prefetchSize=0 is ignored when set via PrefetchPolicy\n\nDescription:\nWhen setting the prefetchSize to 0 via PrefecthPolicy, the value seen by the broker is 1000.\n\nThe value is correctly set in ActiveMQConsumer constructor in consumerInfo, but is later overwritten to 1000 by applyDestinationOptions(), even if the option is not set in the destination options from the broker url.\n\napplyDestinationOptions() considers 0 as an invalid value, and then forces the reading of the value from the destination option, which has the default value of 1000.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: prefetchSize=0 is ignored when set via PrefetchPolicy\n\nDescription:\nWhen setting the prefetchSize to 0 via PrefecthPolicy, the value seen by the broker is 1000.\n\nThe value is correctly set in ActiveMQConsumer constructor in consumerInfo, but is later overwritten to 1000 by applyDestinationOptions(), even if the option is not set in the destination options from the broker url.\n\napplyDestinationOptions() considers 0 as an invalid value, and then forces the reading of the value from the destination option, which has the default value of 1000.\n\nComments:\n", "classification": "Classify the issue 'prefetchSize=0 is ignored when set via PrefetchPolicy' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-410?\nA: When setting the prefetchSize to 0 via PrefecthPolicy, the value seen by the broker is 1000.\n\nThe value is correctly set in ActiveMQConsumer constructor in consumerInfo, but is later overwritten to 1000 by applyDestinationOptions(), even if the option is not set in the destination options from the broker url.\n\napplyDestinationOptions() considers 0 as an invalid value, and then forces the reading o"}}
{"issue_key": "AMQCPP-408", "project": "AMQCPP", "title": "CMS opens a large number of threads", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-05-29T14:10:31.000+0000", "updated": "2012-06-20T15:47:32.000+0000", "description": "Sometimes the CMS libs would open a large number of threads and cause the system to shutdown. Attached please find a dump file that we collected.", "comments": [], "text": "CMS opens a large number of threads\n\nDescription:\nSometimes the CMS libs would open a large number of threads and cause the system to shutdown. Attached please find a dump file that we collected. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS opens a large number of threads\n\nDescription:\nSometimes the CMS libs would open a large number of threads and cause the system to shutdown. Attached please find a dump file that we collected. \n\nComments:\n", "classification": "Classify the issue 'CMS opens a large number of threads' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-408?\nA: Sometimes the CMS libs would open a large number of threads and cause the system to shutdown. Attached please find a dump file that we collected. "}}
{"issue_key": "AMQCPP-407", "project": "AMQCPP", "title": "Application crashes after stopping message broker", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2012-05-24T20:49:15.000+0000", "updated": "2012-06-20T15:47:32.000+0000", "description": "Stopping the message broker would crash our application. The following is the call stack of the fault thread. \n\nThread 0 - System ID 672\nEntry point   msvcr80!endthreadex+61 \nCreate time   5/24/2012 1:53:56 PM \nTime spent in user mode   0 Days 0:0:0.46 \nTime spent in kernel mode   0 Days 0:0:0.78 \n\n\n\n\n\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nkernel32!InterlockedDecrement+9     00000000     00000000     00242110    \nmsvcrt!cexit+f     77c10000     00000000     00000001    \nntdll!LdrInitializeThunk+24     77c1f2a1     77c10000     00000000    \nntdll!RtlDestroyEnvironment+178     00000000     0eec256d     00000001    \nkernel32!IsValidLocale+8eb     00000003     77e8f3b0     ffffffff    \nkernel32!ExitProcess+14     00000003     0ec21a04     00000003    \nmsvcr80!amsg_exit+5e     00000003     00000001     00000000    \nmsvcr80!exit+d     1795efe0     00000000     ffffffff    \nuser32!MessageBoxIndirectA+23a     00000001     7c91005d     13946b5e    \nuser32!MessageBoxIndirectA+254     13946b5e     00000000     00e30850    \nntdll!RtlFreeHeap+130     0468001b     00000202     1795f110    \nactivemq_cppu!activemq::core::ActiveMQConnection::onException+fd     1795fe24     7f427d47     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427d33     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427cef     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     1795f60c     0ef4a264    \nactivemq_cppu!activemq::transport::inactivity::InactivityMonitor::onException+33     1795fe24     7f427cd7     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427c83     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::fire+4b     1795fe24     0ec48ed7     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::run+15e     7f427107     7c809c65     12519500    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+82     7c936d80     04682060     0ec229bb    \nactivemq_cppu!`anonymous namespace'::threadWorker+20     04682060     0ec229bb     12519500    \nntdll!RtlRemoveVectoredExceptionHandler+2a2     04682060     7c80b729     1252f168    \nmsvcr80!endthreadex+c7     0ec229e1     1252f168     00000000    \n\n\n\n\nKERNEL32!INTERLOCKEDDECREMENT+9WARNING - DebugDiag was not able to locate debug symbols for kernel32.dll, so the information below may be incomplete.\n\n\n\nIn ScotAppU__PID__1168__Date__05_24_2012__Time_02_18_41PM__916__Second_Chance_Exception_C0000005.dmp the assembly instruction at kernel32!InterlockedDecrement+9 in C:\\WINDOWS\\system32\\kernel32.dll from Microsoft Corporation has caused an access violation exception (0xC0000005) when trying to write to memory location 0x014718e4 on thread 0", "comments": [], "text": "Application crashes after stopping message broker\n\nDescription:\nStopping the message broker would crash our application. The following is the call stack of the fault thread. \n\nThread 0 - System ID 672\nEntry point   msvcr80!endthreadex+61 \nCreate time   5/24/2012 1:53:56 PM \nTime spent in user mode   0 Days 0:0:0.46 \nTime spent in kernel mode   0 Days 0:0:0.78 \n\n\n\n\n\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nkernel32!InterlockedDecrement+9     00000000     00000000     00242110    \nmsvcrt!cexit+f     77c10000     00000000     00000001    \nntdll!LdrInitializeThunk+24     77c1f2a1     77c10000     00000000    \nntdll!RtlDestroyEnvironment+178     00000000     0eec256d     00000001    \nkernel32!IsValidLocale+8eb     00000003     77e8f3b0     ffffffff    \nkernel32!ExitProcess+14     00000003     0ec21a04     00000003    \nmsvcr80!amsg_exit+5e     00000003     00000001     00000000    \nmsvcr80!exit+d     1795efe0     00000000     ffffffff    \nuser32!MessageBoxIndirectA+23a     00000001     7c91005d     13946b5e    \nuser32!MessageBoxIndirectA+254     13946b5e     00000000     00e30850    \nntdll!RtlFreeHeap+130     0468001b     00000202     1795f110    \nactivemq_cppu!activemq::core::ActiveMQConnection::onException+fd     1795fe24     7f427d47     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427d33     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427cef     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     1795f60c     0ef4a264    \nactivemq_cppu!activemq::transport::inactivity::InactivityMonitor::onException+33     1795fe24     7f427cd7     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427c83     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::fire+4b     1795fe24     0ec48ed7     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::run+15e     7f427107     7c809c65     12519500    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+82     7c936d80     04682060     0ec229bb    \nactivemq_cppu!`anonymous namespace'::threadWorker+20     04682060     0ec229bb     12519500    \nntdll!RtlRemoveVectoredExceptionHandler+2a2     04682060     7c80b729     1252f168    \nmsvcr80!endthreadex+c7     0ec229e1     1252f168     00000000    \n\n\n\n\nKERNEL32!INTERLOCKEDDECREMENT+9WARNING - DebugDiag was not able to locate debug symbols for kernel32.dll, so the information below may be incomplete.\n\n\n\nIn ScotAppU__PID__1168__Date__05_24_2012__Time_02_18_41PM__916__Second_Chance_Exception_C0000005.dmp the assembly instruction at kernel32!InterlockedDecrement+9 in C:\\WINDOWS\\system32\\kernel32.dll from Microsoft Corporation has caused an access violation exception (0xC0000005) when trying to write to memory location 0x014718e4 on thread 0\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Application crashes after stopping message broker\n\nDescription:\nStopping the message broker would crash our application. The following is the call stack of the fault thread. \n\nThread 0 - System ID 672\nEntry point   msvcr80!endthreadex+61 \nCreate time   5/24/2012 1:53:56 PM \nTime spent in user mode   0 Days 0:0:0.46 \nTime spent in kernel mode   0 Days 0:0:0.78 \n\n\n\n\n\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nkernel32!InterlockedDecrement+9     00000000     00000000     00242110    \nmsvcrt!cexit+f     77c10000     00000000     00000001    \nntdll!LdrInitializeThunk+24     77c1f2a1     77c10000     00000000    \nntdll!RtlDestroyEnvironment+178     00000000     0eec256d     00000001    \nkernel32!IsValidLocale+8eb     00000003     77e8f3b0     ffffffff    \nkernel32!ExitProcess+14     00000003     0ec21a04     00000003    \nmsvcr80!amsg_exit+5e     00000003     00000001     00000000    \nmsvcr80!exit+d     1795efe0     00000000     ffffffff    \nuser32!MessageBoxIndirectA+23a     00000001     7c91005d     13946b5e    \nuser32!MessageBoxIndirectA+254     13946b5e     00000000     00e30850    \nntdll!RtlFreeHeap+130     0468001b     00000202     1795f110    \nactivemq_cppu!activemq::core::ActiveMQConnection::onException+fd     1795fe24     7f427d47     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427d33     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427cef     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     1795f60c     0ef4a264    \nactivemq_cppu!activemq::transport::inactivity::InactivityMonitor::onException+33     1795fe24     7f427cd7     1795fe18    \nactivemq_cppu!activemq::transport::TransportFilter::fire+44     1795fe24     7f427c83     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::fire+4b     1795fe24     0ec48ed7     1795fe18    \nactivemq_cppu!activemq::transport::IOTransport::run+15e     7f427107     7c809c65     12519500    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+82     7c936d80     04682060     0ec229bb    \nactivemq_cppu!`anonymous namespace'::threadWorker+20     04682060     0ec229bb     12519500    \nntdll!RtlRemoveVectoredExceptionHandler+2a2     04682060     7c80b729     1252f168    \nmsvcr80!endthreadex+c7     0ec229e1     1252f168     00000000    \n\n\n\n\nKERNEL32!INTERLOCKEDDECREMENT+9WARNING - DebugDiag was not able to locate debug symbols for kernel32.dll, so the information below may be incomplete.\n\n\n\nIn ScotAppU__PID__1168__Date__05_24_2012__Time_02_18_41PM__916__Second_Chance_Exception_C0000005.dmp the assembly instruction at kernel32!InterlockedDecrement+9 in C:\\WINDOWS\\system32\\kernel32.dll from Microsoft Corporation has caused an access violation exception (0xC0000005) when trying to write to memory location 0x014718e4 on thread 0\n\n\n\nComments:\n", "classification": "Classify the issue 'Application crashes after stopping message broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-407?\nA: Stopping the message broker would crash our application. The following is the call stack of the fault thread. \n\nThread 0 - System ID 672\nEntry point   msvcr80!endthreadex+61 \nCreate time   5/24/2012 1:53:56 PM \nTime spent in user mode   0 Days 0:0:0.46 \nTime spent in kernel mode   0 Days 0:0:0.78 \n\n\n\n\n\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nkernel32!InterlockedDecrement+9     00000000  "}}
{"issue_key": "AMQCPP-406", "project": "AMQCPP", "title": "TcpTransport can leak memory if the connect method fails midway through", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-05-24T14:57:01.000+0000", "updated": "2012-05-24T15:04:28.000+0000", "description": "the Input and OutputStream chains that are built inside TcpTransport connect can leak if an exception is thrown before the get assigned into the class level pointer instance.", "comments": [], "text": "TcpTransport can leak memory if the connect method fails midway through\n\nDescription:\nthe Input and OutputStream chains that are built inside TcpTransport connect can leak if an exception is thrown before the get assigned into the class level pointer instance.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: TcpTransport can leak memory if the connect method fails midway through\n\nDescription:\nthe Input and OutputStream chains that are built inside TcpTransport connect can leak if an exception is thrown before the get assigned into the class level pointer instance.\n\nComments:\n", "classification": "Classify the issue 'TcpTransport can leak memory if the connect method fails midway through' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-406?\nA: the Input and OutputStream chains that are built inside TcpTransport connect can leak if an exception is thrown before the get assigned into the class level pointer instance."}}
{"issue_key": "AMQCPP-405", "project": "AMQCPP", "title": "CMS sender thread hangs after restarting broker", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-05-23T22:01:19.000+0000", "updated": "2012-12-04T20:47:33.000+0000", "description": "The sender thread in CMS hangs after we retarted the message broker.\n\nThe thread is 548 in the attached dump file. \n\nThis is a critical issue that blocks the release of our product that is scheduled in a few days. We hope you can resolve it soon. Really appreciate your help!", "comments": [], "text": "CMS sender thread hangs after restarting broker\n\nDescription:\nThe sender thread in CMS hangs after we retarted the message broker.\n\nThe thread is 548 in the attached dump file. \n\nThis is a critical issue that blocks the release of our product that is scheduled in a few days. We hope you can resolve it soon. Really appreciate your help!\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS sender thread hangs after restarting broker\n\nDescription:\nThe sender thread in CMS hangs after we retarted the message broker.\n\nThe thread is 548 in the attached dump file. \n\nThis is a critical issue that blocks the release of our product that is scheduled in a few days. We hope you can resolve it soon. Really appreciate your help!\n\nComments:\n", "classification": "Classify the issue 'CMS sender thread hangs after restarting broker' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-405?\nA: The sender thread in CMS hangs after we retarted the message broker.\n\nThe thread is 548 in the attached dump file. \n\nThis is a critical issue that blocks the release of our product that is scheduled in a few days. We hope you can resolve it soon. Really appreciate your help!"}}
{"issue_key": "AMQCPP-404", "project": "AMQCPP", "title": "compilation errors on Windows because of Unicode set in project file", "status": "Resolved", "reporter": "Ivan Pechorin", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2012-05-18T15:16:13.000+0000", "updated": "2012-06-20T15:44:57.000+0000", "description": "There are compilation errors because of \"Unicode\" character set is set in Windows project files.\n\n1>System.cpp\n1>..\\src\\main\\decaf\\lang\\System.cpp(455) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n1>..\\src\\main\\decaf\\lang\\System.cpp(461) : error C2664: 'std::vector<_Ty>::push_back' : cannot convert parameter 1 from 'LPTSTR' to 'const std::string &'\n1>        with\n1>        [\n1>            _Ty=std::string\n1>        ]\n1>        Reason: cannot convert from 'LPTSTR' to 'const std::string'\n1>        No constructor could take the source type, or constructor overload resolution was ambiguous\n1>..\\src\\main\\decaf\\lang\\System.cpp(462) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n\n\nFixed trivially by changing from \"Unicode\" to \"Not set\".\n\nIs there any reason to ship the library with \"Unicode\" character set by default? I try to avoid the Unicode builds where possible, and don't see any reason why a messaging client (or any other infrastructure-type library) needs it.", "comments": [], "text": "compilation errors on Windows because of Unicode set in project file\n\nDescription:\nThere are compilation errors because of \"Unicode\" character set is set in Windows project files.\n\n1>System.cpp\n1>..\\src\\main\\decaf\\lang\\System.cpp(455) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n1>..\\src\\main\\decaf\\lang\\System.cpp(461) : error C2664: 'std::vector<_Ty>::push_back' : cannot convert parameter 1 from 'LPTSTR' to 'const std::string &'\n1>        with\n1>        [\n1>            _Ty=std::string\n1>        ]\n1>        Reason: cannot convert from 'LPTSTR' to 'const std::string'\n1>        No constructor could take the source type, or constructor overload resolution was ambiguous\n1>..\\src\\main\\decaf\\lang\\System.cpp(462) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n\n\nFixed trivially by changing from \"Unicode\" to \"Not set\".\n\nIs there any reason to ship the library with \"Unicode\" character set by default? I try to avoid the Unicode builds where possible, and don't see any reason why a messaging client (or any other infrastructure-type library) needs it.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: compilation errors on Windows because of Unicode set in project file\n\nDescription:\nThere are compilation errors because of \"Unicode\" character set is set in Windows project files.\n\n1>System.cpp\n1>..\\src\\main\\decaf\\lang\\System.cpp(455) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n1>..\\src\\main\\decaf\\lang\\System.cpp(461) : error C2664: 'std::vector<_Ty>::push_back' : cannot convert parameter 1 from 'LPTSTR' to 'const std::string &'\n1>        with\n1>        [\n1>            _Ty=std::string\n1>        ]\n1>        Reason: cannot convert from 'LPTSTR' to 'const std::string'\n1>        No constructor could take the source type, or constructor overload resolution was ambiguous\n1>..\\src\\main\\decaf\\lang\\System.cpp(462) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n\n\nFixed trivially by changing from \"Unicode\" to \"Not set\".\n\nIs there any reason to ship the library with \"Unicode\" character set by default? I try to avoid the Unicode builds where possible, and don't see any reason why a messaging client (or any other infrastructure-type library) needs it.\n\nComments:\n", "classification": "Classify the issue 'compilation errors on Windows because of Unicode set in project file' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-404?\nA: There are compilation errors because of \"Unicode\" character set is set in Windows project files.\n\n1>System.cpp\n1>..\\src\\main\\decaf\\lang\\System.cpp(455) : error C2664: 'strlen' : cannot convert parameter 1 from 'LPTSTR' to 'const char *'\n1>        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast\n1>..\\src\\main\\decaf\\lang\\System.cpp(461) : erro"}}
{"issue_key": "AMQCPP-403", "project": "AMQCPP", "title": "Possible for memory to leak when using transacted producer with failover", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-05-16T23:27:10.000+0000", "updated": "2012-05-16T23:29:15.000+0000", "description": "Its possible for a memory leak to occur when running a transacted producer and the failover transport is used.  If the TX commit is the last command when the failure occurs the TX needs to be rolled back since there's no way to know if the command made it or not.", "comments": [], "text": "Possible for memory to leak when using transacted producer with failover\n\nDescription:\nIts possible for a memory leak to occur when running a transacted producer and the failover transport is used.  If the TX commit is the last command when the failure occurs the TX needs to be rolled back since there's no way to know if the command made it or not.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Possible for memory to leak when using transacted producer with failover\n\nDescription:\nIts possible for a memory leak to occur when running a transacted producer and the failover transport is used.  If the TX commit is the last command when the failure occurs the TX needs to be rolled back since there's no way to know if the command made it or not.  \n\nComments:\n", "classification": "Classify the issue 'Possible for memory to leak when using transacted producer with failover' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-403?\nA: Its possible for a memory leak to occur when running a transacted producer and the failover transport is used.  If the TX commit is the last command when the failure occurs the TX needs to be rolled back since there's no way to know if the command made it or not.  "}}
{"issue_key": "AMQCPP-402", "project": "AMQCPP", "title": "Fix ConnectionStateTracker processMessageAck", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-05-16T15:03:58.000+0000", "updated": "2012-05-24T14:54:57.000+0000", "description": "In ConnectionStateTracker the method that processes message acks should not be processing anything, which it doesn't by accident.  Remove the code in the 3.4.x branch, and remove the method on trunk.  The acks will be stale so don't track them and let rollback deal with it.", "comments": [], "text": "Fix ConnectionStateTracker processMessageAck\n\nDescription:\nIn ConnectionStateTracker the method that processes message acks should not be processing anything, which it doesn't by accident.  Remove the code in the 3.4.x branch, and remove the method on trunk.  The acks will be stale so don't track them and let rollback deal with it.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Fix ConnectionStateTracker processMessageAck\n\nDescription:\nIn ConnectionStateTracker the method that processes message acks should not be processing anything, which it doesn't by accident.  Remove the code in the 3.4.x branch, and remove the method on trunk.  The acks will be stale so don't track them and let rollback deal with it.\n\nComments:\n", "classification": "Classify the issue 'Fix ConnectionStateTracker processMessageAck' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-402?\nA: In ConnectionStateTracker the method that processes message acks should not be processing anything, which it doesn't by accident.  Remove the code in the 3.4.x branch, and remove the method on trunk.  The acks will be stale so don't track them and let rollback deal with it."}}
{"issue_key": "AMQCPP-401", "project": "AMQCPP", "title": "Add get and set methods for ObjectMessage that grants access to the payload as bytes.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-05-15T23:01:22.000+0000", "updated": "2012-05-15T23:04:54.000+0000", "description": "Add methods to cms::ObjectMessage getObjectBytes and setObjectBytes.  This allows for bridging providers and propagating the Object bytes.", "comments": [], "text": "Add get and set methods for ObjectMessage that grants access to the payload as bytes.\n\nDescription:\nAdd methods to cms::ObjectMessage getObjectBytes and setObjectBytes.  This allows for bridging providers and propagating the Object bytes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add get and set methods for ObjectMessage that grants access to the payload as bytes.\n\nDescription:\nAdd methods to cms::ObjectMessage getObjectBytes and setObjectBytes.  This allows for bridging providers and propagating the Object bytes.\n\nComments:\n", "classification": "Classify the issue 'Add get and set methods for ObjectMessage that grants access to the payload as bytes.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-401?\nA: Add methods to cms::ObjectMessage getObjectBytes and setObjectBytes.  This allows for bridging providers and propagating the Object bytes."}}
{"issue_key": "AMQCPP-400", "project": "AMQCPP", "title": "Add new accessor in CMS Message types to get the type of a Property value or MapMessage value", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-05-15T21:07:37.000+0000", "updated": "2012-05-15T23:06:17.000+0000", "description": "Add a new accessor method in CMS Message to get the type of the value stored in a given property.  Also add this same functionality to MapMessage to allow the type of value in the mapping to be identified.  A new enumeration value in CMS Message called ValueType will be used for both.", "comments": [], "text": "Add new accessor in CMS Message types to get the type of a Property value or MapMessage value\n\nDescription:\nAdd a new accessor method in CMS Message to get the type of the value stored in a given property.  Also add this same functionality to MapMessage to allow the type of value in the mapping to be identified.  A new enumeration value in CMS Message called ValueType will be used for both.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add new accessor in CMS Message types to get the type of a Property value or MapMessage value\n\nDescription:\nAdd a new accessor method in CMS Message to get the type of the value stored in a given property.  Also add this same functionality to MapMessage to allow the type of value in the mapping to be identified.  A new enumeration value in CMS Message called ValueType will be used for both.\n\nComments:\n", "classification": "Classify the issue 'Add new accessor in CMS Message types to get the type of a Property value or MapMessage value' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-400?\nA: Add a new accessor method in CMS Message to get the type of the value stored in a given property.  Also add this same functionality to MapMessage to allow the type of value in the mapping to be identified.  A new enumeration value in CMS Message called ValueType will be used for both."}}
{"issue_key": "AMQCPP-399", "project": "AMQCPP", "title": "Add support for closing Session consumers with active transaction", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-05-04T21:00:52.000+0000", "updated": "2012-05-04T21:05:29.000+0000", "description": "Currently an exception is thrown if you close a consumer while a Session has an active transaction because there's no way to retain the consumer state should its object be deleted so we can't complete the transaction if commit is called later.", "comments": [], "text": "Add support for closing Session consumers with active transaction\n\nDescription:\nCurrently an exception is thrown if you close a consumer while a Session has an active transaction because there's no way to retain the consumer state should its object be deleted so we can't complete the transaction if commit is called later.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for closing Session consumers with active transaction\n\nDescription:\nCurrently an exception is thrown if you close a consumer while a Session has an active transaction because there's no way to retain the consumer state should its object be deleted so we can't complete the transaction if commit is called later.  \n\nComments:\n", "classification": "Classify the issue 'Add support for closing Session consumers with active transaction' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-399?\nA: Currently an exception is thrown if you close a consumer while a Session has an active transaction because there's no way to retain the consumer state should its object be deleted so we can't complete the transaction if commit is called later.  "}}
{"issue_key": "AMQCPP-398", "project": "AMQCPP", "title": "Add support for transforming cms::Message and cms::Destination from non activemq client implementations.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-05-04T20:56:44.000+0000", "updated": "2012-05-04T21:06:09.000+0000", "description": "Add support for the producer and session to accept Destination's and Message objects that implement cms::Message and cms::Destination types and transform them into the standard internal Message and Destination types.", "comments": [], "text": "Add support for transforming cms::Message and cms::Destination from non activemq client implementations.\n\nDescription:\nAdd support for the producer and session to accept Destination's and Message objects that implement cms::Message and cms::Destination types and transform them into the standard internal Message and Destination types.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for transforming cms::Message and cms::Destination from non activemq client implementations.\n\nDescription:\nAdd support for the producer and session to accept Destination's and Message objects that implement cms::Message and cms::Destination types and transform them into the standard internal Message and Destination types.  \n\nComments:\n", "classification": "Classify the issue 'Add support for transforming cms::Message and cms::Destination from non activemq client implementations.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-398?\nA: Add support for the producer and session to accept Destination's and Message objects that implement cms::Message and cms::Destination types and transform them into the standard internal Message and Destination types.  "}}
{"issue_key": "AMQCPP-397", "project": "AMQCPP", "title": "Add utility class for working with Advisory Topics", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-05-04T20:54:36.000+0000", "updated": "2012-05-04T21:05:56.000+0000", "description": "Add class AdvisorySupport in activemq::util to allow users to more easily create Advisory Topic destination.", "comments": [], "text": "Add utility class for working with Advisory Topics\n\nDescription:\nAdd class AdvisorySupport in activemq::util to allow users to more easily create Advisory Topic destination.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add utility class for working with Advisory Topics\n\nDescription:\nAdd class AdvisorySupport in activemq::util to allow users to more easily create Advisory Topic destination.\n\nComments:\n", "classification": "Classify the issue 'Add utility class for working with Advisory Topics' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-397?\nA: Add class AdvisorySupport in activemq::util to allow users to more easily create Advisory Topic destination."}}
{"issue_key": "AMQCPP-396", "project": "AMQCPP", "title": "Add method reset() to the cms::StreamMessage interface.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2012-04-28T21:52:55.000+0000", "updated": "2012-04-28T21:53:50.000+0000", "description": "Add in the missing cms::StreamMessage reset() method to the CMS API.", "comments": [], "text": "Add method reset() to the cms::StreamMessage interface.\n\nDescription:\nAdd in the missing cms::StreamMessage reset() method to the CMS API.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add method reset() to the cms::StreamMessage interface.\n\nDescription:\nAdd in the missing cms::StreamMessage reset() method to the CMS API.\n\nComments:\n", "classification": "Classify the issue 'Add method reset() to the cms::StreamMessage interface.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-396?\nA: Add in the missing cms::StreamMessage reset() method to the CMS API."}}
{"issue_key": "AMQCPP-395", "project": "AMQCPP", "title": "Add advisory message monitoring for Temp Destination create / destory", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-04-25T22:35:09.000+0000", "updated": "2012-05-04T21:05:43.000+0000", "description": "Add an AdvisoryConsumer implementation to allow the connection to monitor temp destination creating and deletion so that proper invalid destination exceptions can be thrown by the client.", "comments": [], "text": "Add advisory message monitoring for Temp Destination create / destory\n\nDescription:\nAdd an AdvisoryConsumer implementation to allow the connection to monitor temp destination creating and deletion so that proper invalid destination exceptions can be thrown by the client.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add advisory message monitoring for Temp Destination create / destory\n\nDescription:\nAdd an AdvisoryConsumer implementation to allow the connection to monitor temp destination creating and deletion so that proper invalid destination exceptions can be thrown by the client.\n\nComments:\n", "classification": "Classify the issue 'Add advisory message monitoring for Temp Destination create / destory' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-395?\nA: Add an AdvisoryConsumer implementation to allow the connection to monitor temp destination creating and deletion so that proper invalid destination exceptions can be thrown by the client."}}
{"issue_key": "AMQCPP-394", "project": "AMQCPP", "title": "Scotappu Crash", "status": "Closed", "reporter": "Leif Rey Bornales", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-04-18T23:22:05.000+0000", "updated": "2012-04-23T15:11:11.000+0000", "description": "Our application that uses activemq c++ client lib crashed with the following dump:\n\n--------------------------------------------------------\n\n*----> State Dump for Thread Id 0x520 <----*\n\neax=10af1b90 ebx=10aedbb8 ecx=10aedbb8 edx=00000000 esi=10ac87b0 edi=10aedbb8\neip=00000000 esp=1ac5ee30 ebp=10ad2408 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\n*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\scot\\bin\\scotappu.exe - \nfunction: <nosymbols>\nNo prior disassembly possible\n        :\n        00000000 ??               ???\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\nFAULT ->:\n00000000 ??               ???\nError 0x00000001\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\n        00000010 ??               ???\n        00000012 ??               ???\n        00000014 ??               ???\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n1ac5ee2c 0ef0a3dd 4b068273 10ae3528 1ac5eeac 0x0\n10ad2408 10aae520 00020002 040c0138 0f16def4 activemq-cppu!activemq__core__ActiveMQSessionExecutor__wakeup+0x17d\n10ae73d8 ffffffff 00000000 00000000 00000000 0x10aae520\n25f989b8 10ae73d8 25f9eb18 25f9a1d0 00000000 0xffffffff\n00000000 00000000 00000000 00000000 00000000 0x10ae73d8\n\n*----> Raw Stack Dump <----*\n000000001ac5ee30  dd a3 f0 0e 73 82 06 4b - 28 35 ae 10 ac ee c5 1a  ....s..K(5......\n000000001ac5ee40  b8 ee c5 1a 88 3f a9 10 - 88 87 ac 10 88 3f a9 10  .....?.......?..\n000000001ac5ee50  c8 d5 17 0f 00 ee c5 1a - 90 87 ac 10 78 6b 15 0f  ............xk..\n000000001ac5ee60  28 a3 aa 10 b8 db ae 10 - f0 ac f0 0e cb 82 06 4b  (..............K\n000000001ac5ee70  66 e1 09 0f c3 82 06 4b - 24 ee c5 1a a8 ee c5 1a  f......K$.......\n000000001ac5ee80  80 0f 10 0f 00 00 00 00 - 98 f1 c5 1a 3b 08 f1 0e  ............;...\n000000001ac5ee90  df 82 06 4b 28 35 ae 10 - 88 3f a9 10 c8 d5 17 0f  ...K(5...?......\n000000001ac5eea0  00 ff ff ff c8 3f a9 10 - 8c f1 c5 1a 8c f1 c5 1a  .....?..........\n000000001ac5eeb0  4b d4 13 0f 00 00 00 00 - 98 f1 c5 1a ba fe ef 0e  K...............\n000000001ac5eec0  d3 9d 06 4b 40 67 a7 10 - b0 f4 c5 1a 07 8a 06 0f  ...K@g..........\n000000001ac5eed0  c0 ee c5 1a a8 32 90 7c - b0 f4 c5 1a dc f3 c5 1a  .....2.|........\n000000001ac5eee0  ec ef c5 1a e0 ef c5 1a - dc f3 c5 1a e3 32 90 7c  .............2.|\n000000001ac5eef0  dc f3 c5 1a bc f2 c5 1a - 7a 32 90 7c b0 f4 c5 1a  ........z2.|....\n000000001ac5ef00  dc f3 c5 1a ec ef c5 1a - e0 ef c5 1a bc 32 90 7c  .............2.|\n000000001ac5ef10  01 00 00 00 b0 f4 c5 1a - dc f3 c5 1a 81 ab 92 7c  ...............|\n000000001ac5ef20  b0 f4 c5 1a 6a d0 90 7c - aa ab 92 7c ec ef c5 1a  ....j..|...|....\n000000001ac5ef30  00 00 00 00 70 69 1e 0f - 70 6a 1e 0f dc f3 c5 1a  ....pi..pj......\n000000001ac5ef40  ad 26 42 7c 88 d4 db 05 - 12 00 00 00 70 5a ae 10  .&B|........pZ..\n000000001ac5ef50  ff ff ff ff 4c fa c5 1a - 4c bf ae 10 28 bf ae 10  ....L...L...(...\n000000001ac5ef60  b5 2d 42 7c 33 83 06 4b - 98 ee c5 1a 54 f0 c5 1a  .-B|3..K....T...\n\n-------------------------------------------------------------------------------------", "comments": [], "text": "Scotappu Crash\n\nDescription:\nOur application that uses activemq c++ client lib crashed with the following dump:\n\n--------------------------------------------------------\n\n*----> State Dump for Thread Id 0x520 <----*\n\neax=10af1b90 ebx=10aedbb8 ecx=10aedbb8 edx=00000000 esi=10ac87b0 edi=10aedbb8\neip=00000000 esp=1ac5ee30 ebp=10ad2408 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\n*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\scot\\bin\\scotappu.exe - \nfunction: <nosymbols>\nNo prior disassembly possible\n        :\n        00000000 ??               ???\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\nFAULT ->:\n00000000 ??               ???\nError 0x00000001\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\n        00000010 ??               ???\n        00000012 ??               ???\n        00000014 ??               ???\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n1ac5ee2c 0ef0a3dd 4b068273 10ae3528 1ac5eeac 0x0\n10ad2408 10aae520 00020002 040c0138 0f16def4 activemq-cppu!activemq__core__ActiveMQSessionExecutor__wakeup+0x17d\n10ae73d8 ffffffff 00000000 00000000 00000000 0x10aae520\n25f989b8 10ae73d8 25f9eb18 25f9a1d0 00000000 0xffffffff\n00000000 00000000 00000000 00000000 00000000 0x10ae73d8\n\n*----> Raw Stack Dump <----*\n000000001ac5ee30  dd a3 f0 0e 73 82 06 4b - 28 35 ae 10 ac ee c5 1a  ....s..K(5......\n000000001ac5ee40  b8 ee c5 1a 88 3f a9 10 - 88 87 ac 10 88 3f a9 10  .....?.......?..\n000000001ac5ee50  c8 d5 17 0f 00 ee c5 1a - 90 87 ac 10 78 6b 15 0f  ............xk..\n000000001ac5ee60  28 a3 aa 10 b8 db ae 10 - f0 ac f0 0e cb 82 06 4b  (..............K\n000000001ac5ee70  66 e1 09 0f c3 82 06 4b - 24 ee c5 1a a8 ee c5 1a  f......K$.......\n000000001ac5ee80  80 0f 10 0f 00 00 00 00 - 98 f1 c5 1a 3b 08 f1 0e  ............;...\n000000001ac5ee90  df 82 06 4b 28 35 ae 10 - 88 3f a9 10 c8 d5 17 0f  ...K(5...?......\n000000001ac5eea0  00 ff ff ff c8 3f a9 10 - 8c f1 c5 1a 8c f1 c5 1a  .....?..........\n000000001ac5eeb0  4b d4 13 0f 00 00 00 00 - 98 f1 c5 1a ba fe ef 0e  K...............\n000000001ac5eec0  d3 9d 06 4b 40 67 a7 10 - b0 f4 c5 1a 07 8a 06 0f  ...K@g..........\n000000001ac5eed0  c0 ee c5 1a a8 32 90 7c - b0 f4 c5 1a dc f3 c5 1a  .....2.|........\n000000001ac5eee0  ec ef c5 1a e0 ef c5 1a - dc f3 c5 1a e3 32 90 7c  .............2.|\n000000001ac5eef0  dc f3 c5 1a bc f2 c5 1a - 7a 32 90 7c b0 f4 c5 1a  ........z2.|....\n000000001ac5ef00  dc f3 c5 1a ec ef c5 1a - e0 ef c5 1a bc 32 90 7c  .............2.|\n000000001ac5ef10  01 00 00 00 b0 f4 c5 1a - dc f3 c5 1a 81 ab 92 7c  ...............|\n000000001ac5ef20  b0 f4 c5 1a 6a d0 90 7c - aa ab 92 7c ec ef c5 1a  ....j..|...|....\n000000001ac5ef30  00 00 00 00 70 69 1e 0f - 70 6a 1e 0f dc f3 c5 1a  ....pi..pj......\n000000001ac5ef40  ad 26 42 7c 88 d4 db 05 - 12 00 00 00 70 5a ae 10  .&B|........pZ..\n000000001ac5ef50  ff ff ff ff 4c fa c5 1a - 4c bf ae 10 28 bf ae 10  ....L...L...(...\n000000001ac5ef60  b5 2d 42 7c 33 83 06 4b - 98 ee c5 1a 54 f0 c5 1a  .-B|3..K....T...\n\n-------------------------------------------------------------------------------------\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Scotappu Crash\n\nDescription:\nOur application that uses activemq c++ client lib crashed with the following dump:\n\n--------------------------------------------------------\n\n*----> State Dump for Thread Id 0x520 <----*\n\neax=10af1b90 ebx=10aedbb8 ecx=10aedbb8 edx=00000000 esi=10ac87b0 edi=10aedbb8\neip=00000000 esp=1ac5ee30 ebp=10ad2408 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\n\n*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\scot\\bin\\scotappu.exe - \nfunction: <nosymbols>\nNo prior disassembly possible\n        :\n        00000000 ??               ???\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\nFAULT ->:\n00000000 ??               ???\nError 0x00000001\n        00000002 ??               ???\n        00000004 ??               ???\n        00000006 ??               ???\n        00000008 ??               ???\n        0000000a ??               ???\n        0000000c ??               ???\n        0000000e ??               ???\n        00000010 ??               ???\n        00000012 ??               ???\n        00000014 ??               ???\n\n*----> Stack Back Trace <----*\nWARNING: Stack unwind information not available. Following frames may be wrong.\nChildEBP RetAddr  Args to Child              \n1ac5ee2c 0ef0a3dd 4b068273 10ae3528 1ac5eeac 0x0\n10ad2408 10aae520 00020002 040c0138 0f16def4 activemq-cppu!activemq__core__ActiveMQSessionExecutor__wakeup+0x17d\n10ae73d8 ffffffff 00000000 00000000 00000000 0x10aae520\n25f989b8 10ae73d8 25f9eb18 25f9a1d0 00000000 0xffffffff\n00000000 00000000 00000000 00000000 00000000 0x10ae73d8\n\n*----> Raw Stack Dump <----*\n000000001ac5ee30  dd a3 f0 0e 73 82 06 4b - 28 35 ae 10 ac ee c5 1a  ....s..K(5......\n000000001ac5ee40  b8 ee c5 1a 88 3f a9 10 - 88 87 ac 10 88 3f a9 10  .....?.......?..\n000000001ac5ee50  c8 d5 17 0f 00 ee c5 1a - 90 87 ac 10 78 6b 15 0f  ............xk..\n000000001ac5ee60  28 a3 aa 10 b8 db ae 10 - f0 ac f0 0e cb 82 06 4b  (..............K\n000000001ac5ee70  66 e1 09 0f c3 82 06 4b - 24 ee c5 1a a8 ee c5 1a  f......K$.......\n000000001ac5ee80  80 0f 10 0f 00 00 00 00 - 98 f1 c5 1a 3b 08 f1 0e  ............;...\n000000001ac5ee90  df 82 06 4b 28 35 ae 10 - 88 3f a9 10 c8 d5 17 0f  ...K(5...?......\n000000001ac5eea0  00 ff ff ff c8 3f a9 10 - 8c f1 c5 1a 8c f1 c5 1a  .....?..........\n000000001ac5eeb0  4b d4 13 0f 00 00 00 00 - 98 f1 c5 1a ba fe ef 0e  K...............\n000000001ac5eec0  d3 9d 06 4b 40 67 a7 10 - b0 f4 c5 1a 07 8a 06 0f  ...K@g..........\n000000001ac5eed0  c0 ee c5 1a a8 32 90 7c - b0 f4 c5 1a dc f3 c5 1a  .....2.|........\n000000001ac5eee0  ec ef c5 1a e0 ef c5 1a - dc f3 c5 1a e3 32 90 7c  .............2.|\n000000001ac5eef0  dc f3 c5 1a bc f2 c5 1a - 7a 32 90 7c b0 f4 c5 1a  ........z2.|....\n000000001ac5ef00  dc f3 c5 1a ec ef c5 1a - e0 ef c5 1a bc 32 90 7c  .............2.|\n000000001ac5ef10  01 00 00 00 b0 f4 c5 1a - dc f3 c5 1a 81 ab 92 7c  ...............|\n000000001ac5ef20  b0 f4 c5 1a 6a d0 90 7c - aa ab 92 7c ec ef c5 1a  ....j..|...|....\n000000001ac5ef30  00 00 00 00 70 69 1e 0f - 70 6a 1e 0f dc f3 c5 1a  ....pi..pj......\n000000001ac5ef40  ad 26 42 7c 88 d4 db 05 - 12 00 00 00 70 5a ae 10  .&B|........pZ..\n000000001ac5ef50  ff ff ff ff 4c fa c5 1a - 4c bf ae 10 28 bf ae 10  ....L...L...(...\n000000001ac5ef60  b5 2d 42 7c 33 83 06 4b - 98 ee c5 1a 54 f0 c5 1a  .-B|3..K....T...\n\n-------------------------------------------------------------------------------------\n\nComments:\n", "classification": "Classify the issue 'Scotappu Crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-394?\nA: Our application that uses activemq c++ client lib crashed with the following dump:\n\n--------------------------------------------------------\n\n*----> State Dump for Thread Id 0x520 <----*\n\neax=10af1b90 ebx=10aedbb8 ecx=10aedbb8 edx=00000000 esi=10ac87b0 edi=10aedbb8\neip=00000000 esp=1ac5ee30 ebp=10ad2408 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000    "}}
{"issue_key": "AMQCPP-393", "project": "AMQCPP", "title": "TimeToLive feature makes some messages disappear", "status": "Resolved", "reporter": "Thomas Riccardi", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-04-10T09:27:32.000+0000", "updated": "2012-04-17T15:10:55.000+0000", "description": "The following setup is run in one machine:\n\nActiveMQ Broker 5.5.0, with:\n{code:xml}\n                  <deadLetterStrategy>\n                    <sharedDeadLetterStrategy \n                        processExpired=\"true\"\n                        processNonPersistent=\"true\"\n                        />\n                  </deadLetterStrategy>\n{code}\n\nTwo C++ programs using CMS 3.4.0:\nProgram A produces messages to a \"request\" queue with a TTL of 1000ms.\nProgram B consumes messages from \"request\" queue with prefetch=0, process the messages, and posts a reply in \"reply\" queue.\n\nProgram A sends 222 messages to the \"request\" queue.\nProgram B process a message in about 250ms.\nProgram B has the time to process 4 messages from \"request\", and post the 4 replies to \"reply\".\nThen the broker moves to the \"DLQ\" queue the expired messages from the \"request\" queue.\n\nFinal state: \"request\" is empty, \"reply\" has 4 enqueued messages, and \"DLQ\" has 125 enqueued messages.\n\n*The bug*: the sum of messages counts from \"DLQ\" and \"reply\" is lower than the number of messages initially enqueued in \"request\": there are 93 messages missing.\n\nThe messages are not lost by the Program B: with traces on the receive() loop we confirm that it only got 4 messages.\n{code}\n      while (1)\n      {\n        cms::Message *message = _messageConsumer->receive();\n        if (! message)\n          continue;\n        _messageListener->onMessage(message);\n        delete message;\n      }\n{code}\n\n\nThe bug is reproducible, but the numbers vary. This happens less often if we increase the TTL to 10s, and this never happens with no TTL (TTL=0, default).", "comments": [], "text": "TimeToLive feature makes some messages disappear\n\nDescription:\nThe following setup is run in one machine:\n\nActiveMQ Broker 5.5.0, with:\n{code:xml}\n                  <deadLetterStrategy>\n                    <sharedDeadLetterStrategy \n                        processExpired=\"true\"\n                        processNonPersistent=\"true\"\n                        />\n                  </deadLetterStrategy>\n{code}\n\nTwo C++ programs using CMS 3.4.0:\nProgram A produces messages to a \"request\" queue with a TTL of 1000ms.\nProgram B consumes messages from \"request\" queue with prefetch=0, process the messages, and posts a reply in \"reply\" queue.\n\nProgram A sends 222 messages to the \"request\" queue.\nProgram B process a message in about 250ms.\nProgram B has the time to process 4 messages from \"request\", and post the 4 replies to \"reply\".\nThen the broker moves to the \"DLQ\" queue the expired messages from the \"request\" queue.\n\nFinal state: \"request\" is empty, \"reply\" has 4 enqueued messages, and \"DLQ\" has 125 enqueued messages.\n\n*The bug*: the sum of messages counts from \"DLQ\" and \"reply\" is lower than the number of messages initially enqueued in \"request\": there are 93 messages missing.\n\nThe messages are not lost by the Program B: with traces on the receive() loop we confirm that it only got 4 messages.\n{code}\n      while (1)\n      {\n        cms::Message *message = _messageConsumer->receive();\n        if (! message)\n          continue;\n        _messageListener->onMessage(message);\n        delete message;\n      }\n{code}\n\n\nThe bug is reproducible, but the numbers vary. This happens less often if we increase the TTL to 10s, and this never happens with no TTL (TTL=0, default).\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: TimeToLive feature makes some messages disappear\n\nDescription:\nThe following setup is run in one machine:\n\nActiveMQ Broker 5.5.0, with:\n{code:xml}\n                  <deadLetterStrategy>\n                    <sharedDeadLetterStrategy \n                        processExpired=\"true\"\n                        processNonPersistent=\"true\"\n                        />\n                  </deadLetterStrategy>\n{code}\n\nTwo C++ programs using CMS 3.4.0:\nProgram A produces messages to a \"request\" queue with a TTL of 1000ms.\nProgram B consumes messages from \"request\" queue with prefetch=0, process the messages, and posts a reply in \"reply\" queue.\n\nProgram A sends 222 messages to the \"request\" queue.\nProgram B process a message in about 250ms.\nProgram B has the time to process 4 messages from \"request\", and post the 4 replies to \"reply\".\nThen the broker moves to the \"DLQ\" queue the expired messages from the \"request\" queue.\n\nFinal state: \"request\" is empty, \"reply\" has 4 enqueued messages, and \"DLQ\" has 125 enqueued messages.\n\n*The bug*: the sum of messages counts from \"DLQ\" and \"reply\" is lower than the number of messages initially enqueued in \"request\": there are 93 messages missing.\n\nThe messages are not lost by the Program B: with traces on the receive() loop we confirm that it only got 4 messages.\n{code}\n      while (1)\n      {\n        cms::Message *message = _messageConsumer->receive();\n        if (! message)\n          continue;\n        _messageListener->onMessage(message);\n        delete message;\n      }\n{code}\n\n\nThe bug is reproducible, but the numbers vary. This happens less often if we increase the TTL to 10s, and this never happens with no TTL (TTL=0, default).\n\n\n\n\nComments:\n", "classification": "Classify the issue 'TimeToLive feature makes some messages disappear' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-393?\nA: The following setup is run in one machine:\n\nActiveMQ Broker 5.5.0, with:\n{code:xml}\n                  <deadLetterStrategy>\n                    <sharedDeadLetterStrategy \n                        processExpired=\"true\"\n                        processNonPersistent=\"true\"\n                        />\n                  </deadLetterStrategy>\n{code}\n\nTwo C++ programs using CMS 3.4.0:\nProgram A produces mess"}}
{"issue_key": "AMQCPP-392", "project": "AMQCPP", "title": "Class Priority Queue defines constant in non-spec complaint manner", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-04-06T20:42:06.000+0000", "updated": "2012-04-06T20:43:23.000+0000", "description": "Class PriorityQueue defines two constants in a non spec complaint manner and can cause link issues on some platforms.", "comments": [], "text": "Class Priority Queue defines constant in non-spec complaint manner\n\nDescription:\nClass PriorityQueue defines two constants in a non spec complaint manner and can cause link issues on some platforms.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Class Priority Queue defines constant in non-spec complaint manner\n\nDescription:\nClass PriorityQueue defines two constants in a non spec complaint manner and can cause link issues on some platforms.  \n\nComments:\n", "classification": "Classify the issue 'Class Priority Queue defines constant in non-spec complaint manner' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-392?\nA: Class PriorityQueue defines two constants in a non spec complaint manner and can cause link issues on some platforms.  "}}
{"issue_key": "AMQCPP-391", "project": "AMQCPP", "title": "Potential hang on connect if wireformatinfo response is not received before timeout and failover transport is in use.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2012-03-30T14:44:35.000+0000", "updated": "2012-03-30T14:45:42.000+0000", "description": "Possible to hang if the wireformatinfo from the broker doesn't arrive in time and the negotiator times out while the ActiveMQConnection is waiting for a response to the ConnectionInfo command.", "comments": [], "text": "Potential hang on connect if wireformatinfo response is not received before timeout and failover transport is in use.\n\nDescription:\nPossible to hang if the wireformatinfo from the broker doesn't arrive in time and the negotiator times out while the ActiveMQConnection is waiting for a response to the ConnectionInfo command.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Potential hang on connect if wireformatinfo response is not received before timeout and failover transport is in use.\n\nDescription:\nPossible to hang if the wireformatinfo from the broker doesn't arrive in time and the negotiator times out while the ActiveMQConnection is waiting for a response to the ConnectionInfo command.\n\nComments:\n", "classification": "Classify the issue 'Potential hang on connect if wireformatinfo response is not received before timeout and failover transport is in use.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-391?\nA: Possible to hang if the wireformatinfo from the broker doesn't arrive in time and the negotiator times out while the ActiveMQConnection is waiting for a response to the ConnectionInfo command."}}
{"issue_key": "AMQCPP-390", "project": "AMQCPP", "title": "Caught many CMS exceptions with the error message: Channel was inactive for too long", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-02-24T19:43:59.000+0000", "updated": "2012-02-24T22:01:32.000+0000", "description": "Our app getd CMS exceptions with the information \"Channel was inactive for too long\" every once in a while. The intervals between these exceptions are in the range of several minus to a few hours. We want to check what it means and if there is any problem with CMS when we get these exceptions. Thanks a lot for your help!\n\nerror message: Channel was inactive for too long: , stack trace: Channel was inactive for too long: \n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 324\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 344\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 351\n\tFILE: ..\\src\\main\\activemq\\wireformat\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 80\n\tFILE: ..\\src\\main\\activemq\\transport\\correlator\\ResponseCorrelator.cpp, LINE: 85\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQConnection.cpp, LINE: 750\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 751\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 221\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 142", "comments": [], "text": "Caught many CMS exceptions with the error message: Channel was inactive for too long\n\nDescription:\nOur app getd CMS exceptions with the information \"Channel was inactive for too long\" every once in a while. The intervals between these exceptions are in the range of several minus to a few hours. We want to check what it means and if there is any problem with CMS when we get these exceptions. Thanks a lot for your help!\n\nerror message: Channel was inactive for too long: , stack trace: Channel was inactive for too long: \n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 324\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 344\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 351\n\tFILE: ..\\src\\main\\activemq\\wireformat\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 80\n\tFILE: ..\\src\\main\\activemq\\transport\\correlator\\ResponseCorrelator.cpp, LINE: 85\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQConnection.cpp, LINE: 750\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 751\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 221\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 142\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Caught many CMS exceptions with the error message: Channel was inactive for too long\n\nDescription:\nOur app getd CMS exceptions with the information \"Channel was inactive for too long\" every once in a while. The intervals between these exceptions are in the range of several minus to a few hours. We want to check what it means and if there is any problem with CMS when we get these exceptions. Thanks a lot for your help!\n\nerror message: Channel was inactive for too long: , stack trace: Channel was inactive for too long: \n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 324\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 344\n\tFILE: ..\\src\\main\\activemq\\transport\\inactivity\\InactivityMonitor.cpp, LINE: 351\n\tFILE: ..\\src\\main\\activemq\\wireformat\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 80\n\tFILE: ..\\src\\main\\activemq\\transport\\correlator\\ResponseCorrelator.cpp, LINE: 85\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQConnection.cpp, LINE: 750\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 751\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 221\n\tFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 142\n\n\n\nComments:\n", "classification": "Classify the issue 'Caught many CMS exceptions with the error message: Channel was inactive for too long' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-390?\nA: Our app getd CMS exceptions with the information \"Channel was inactive for too long\" every once in a while. The intervals between these exceptions are in the range of several minus to a few hours. We want to check what it means and if there is any problem with CMS when we get these exceptions. Thanks a lot for your help!\n\nerror message: Channel was inactive for too long: , stack trace: Channel was"}}
{"issue_key": "AMQCPP-389", "project": "AMQCPP", "title": "activemq-cpp build fails with gcc 4.7", "status": "Resolved", "reporter": "Steve Traylen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": ["build"], "created": "2012-02-19T19:48:35.000+0000", "updated": "2012-02-25T20:00:35.000+0000", "description": "Building \n\nactivemq-cpp-library-3.4.1-src.tar.gz\n\nwith\n\ngcc-c++ 4.7.0\n\nresults in \n\n{noformat}\n./decaf/util/AbstractQueue.h:63:13: error: 'offer' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n./decaf/util/AbstractQueue.h:63:13: note: declarations in dependent base 'decaf::util::Queue<decaf::lang::Runnable*>' are not found by unqualified lookup\n./decaf/util/AbstractQueue.h:63:13: note: use 'this->offer' instead\n{noformat}\n\nFrom: https://lists.fedoraproject.org/pipermail/devel/2011-December/160723.html\n\nC++ lookup fixes, the C++ FE no longer performs an extra unqualified\nlookup that it (incorrectly) performed in the past.  In some cases the\ndiagnostics includes hints how to fix the bugs, for PR24163 the\ndiagnostics looks like:\nerror: 'something' was not declared in this scope, and no \ndeclarations were found by argument-dependent lookup at \nthe point of instantiation [-fpermissive] note: declarations in \ndependent base 'someclass<somearg>' are not found by unqualified lookup\nnote: use 'this->something' instead\n\nhttp://gcc.gnu.org/PR24163\n\nThe trivial attached patch with solution recomended above corrects the \nproblem.", "comments": [], "text": "activemq-cpp build fails with gcc 4.7\n\nDescription:\nBuilding \n\nactivemq-cpp-library-3.4.1-src.tar.gz\n\nwith\n\ngcc-c++ 4.7.0\n\nresults in \n\n{noformat}\n./decaf/util/AbstractQueue.h:63:13: error: 'offer' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n./decaf/util/AbstractQueue.h:63:13: note: declarations in dependent base 'decaf::util::Queue<decaf::lang::Runnable*>' are not found by unqualified lookup\n./decaf/util/AbstractQueue.h:63:13: note: use 'this->offer' instead\n{noformat}\n\nFrom: https://lists.fedoraproject.org/pipermail/devel/2011-December/160723.html\n\nC++ lookup fixes, the C++ FE no longer performs an extra unqualified\nlookup that it (incorrectly) performed in the past.  In some cases the\ndiagnostics includes hints how to fix the bugs, for PR24163 the\ndiagnostics looks like:\nerror: 'something' was not declared in this scope, and no \ndeclarations were found by argument-dependent lookup at \nthe point of instantiation [-fpermissive] note: declarations in \ndependent base 'someclass<somearg>' are not found by unqualified lookup\nnote: use 'this->something' instead\n\nhttp://gcc.gnu.org/PR24163\n\nThe trivial attached patch with solution recomended above corrects the \nproblem.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cpp build fails with gcc 4.7\n\nDescription:\nBuilding \n\nactivemq-cpp-library-3.4.1-src.tar.gz\n\nwith\n\ngcc-c++ 4.7.0\n\nresults in \n\n{noformat}\n./decaf/util/AbstractQueue.h:63:13: error: 'offer' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n./decaf/util/AbstractQueue.h:63:13: note: declarations in dependent base 'decaf::util::Queue<decaf::lang::Runnable*>' are not found by unqualified lookup\n./decaf/util/AbstractQueue.h:63:13: note: use 'this->offer' instead\n{noformat}\n\nFrom: https://lists.fedoraproject.org/pipermail/devel/2011-December/160723.html\n\nC++ lookup fixes, the C++ FE no longer performs an extra unqualified\nlookup that it (incorrectly) performed in the past.  In some cases the\ndiagnostics includes hints how to fix the bugs, for PR24163 the\ndiagnostics looks like:\nerror: 'something' was not declared in this scope, and no \ndeclarations were found by argument-dependent lookup at \nthe point of instantiation [-fpermissive] note: declarations in \ndependent base 'someclass<somearg>' are not found by unqualified lookup\nnote: use 'this->something' instead\n\nhttp://gcc.gnu.org/PR24163\n\nThe trivial attached patch with solution recomended above corrects the \nproblem.\n\n\n\nComments:\n", "classification": "Classify the issue 'activemq-cpp build fails with gcc 4.7' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-389?\nA: Building \n\nactivemq-cpp-library-3.4.1-src.tar.gz\n\nwith\n\ngcc-c++ 4.7.0\n\nresults in \n\n{noformat}\n./decaf/util/AbstractQueue.h:63:13: error: 'offer' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n./decaf/util/AbstractQueue.h:63:13: note: declarations in dependent base 'decaf::util::Queue<decaf::lang::Runnable*>'"}}
{"issue_key": "AMQCPP-388", "project": "AMQCPP", "title": "AprPool::getAprPool() returns NULL, causing access violation and application crash", "status": "Resolved", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2012-02-17T21:34:55.000+0000", "updated": "2012-04-16T20:02:41.000+0000", "description": "Our application that uses activemq c++ client lib crashed with the following dump:\n\n----------------------------------------------------------------------------------------------------------------------\nThread 87 - System ID 3780\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nlibapr_1!apr_pvsprintf+8     00000000     0642a188     180eeb94    \nactivemq_cppu!decaf::lang::Exception::buildMessage+71     0642a188     180eeb74     180eee2c    \nactivemq_cppu!decaf::lang::exceptions::RuntimeException::RuntimeException+4d     180efeec     0642a160     00000097    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+125     180eee2c     180efee0     00000001    \nmsvcr80!CatchIt+5c     00000000     00000000     00000000\n\nLIBAPR_1!APR_PVSPRINTF+8In scotapp.dmp the assembly instruction at libapr_1!apr_pvsprintf+8 in C:\\scot\\dll\\libapr-1.dll has caused an access violation exception (0xC0000005) when trying to read from memory location 0x0000002c on thread 87\n--------------------------------------------------------------------------------------------------------------------\n\nOn the call stack, we saw that following function from class decaf::lang::Exception was called:\nvoid Exception::buildMessage( const char* format, va_list& vargs ) {\n\n    // Allocate buffer with a guess of it's size\n    AprPool pool;\n\n    // Allocate a buffer of the specified size.\n    char* buffer = apr_pvsprintf( pool.getAprPool(), format, vargs );\n\n    // Guessed size was enough. Assign the string.\n    message.assign( buffer, strlen( buffer ) );\n}\n\nThe first parameter passed into apr_pvsprintf was NULL, causing the crash. Could you please take a look and see if there is any bug in the activemqcpp code that could cause the problem. Thanks!", "comments": [], "text": "AprPool::getAprPool() returns NULL, causing access violation and application crash\n\nDescription:\nOur application that uses activemq c++ client lib crashed with the following dump:\n\n----------------------------------------------------------------------------------------------------------------------\nThread 87 - System ID 3780\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nlibapr_1!apr_pvsprintf+8     00000000     0642a188     180eeb94    \nactivemq_cppu!decaf::lang::Exception::buildMessage+71     0642a188     180eeb74     180eee2c    \nactivemq_cppu!decaf::lang::exceptions::RuntimeException::RuntimeException+4d     180efeec     0642a160     00000097    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+125     180eee2c     180efee0     00000001    \nmsvcr80!CatchIt+5c     00000000     00000000     00000000\n\nLIBAPR_1!APR_PVSPRINTF+8In scotapp.dmp the assembly instruction at libapr_1!apr_pvsprintf+8 in C:\\scot\\dll\\libapr-1.dll has caused an access violation exception (0xC0000005) when trying to read from memory location 0x0000002c on thread 87\n--------------------------------------------------------------------------------------------------------------------\n\nOn the call stack, we saw that following function from class decaf::lang::Exception was called:\nvoid Exception::buildMessage( const char* format, va_list& vargs ) {\n\n    // Allocate buffer with a guess of it's size\n    AprPool pool;\n\n    // Allocate a buffer of the specified size.\n    char* buffer = apr_pvsprintf( pool.getAprPool(), format, vargs );\n\n    // Guessed size was enough. Assign the string.\n    message.assign( buffer, strlen( buffer ) );\n}\n\nThe first parameter passed into apr_pvsprintf was NULL, causing the crash. Could you please take a look and see if there is any bug in the activemqcpp code that could cause the problem. Thanks!\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AprPool::getAprPool() returns NULL, causing access violation and application crash\n\nDescription:\nOur application that uses activemq c++ client lib crashed with the following dump:\n\n----------------------------------------------------------------------------------------------------------------------\nThread 87 - System ID 3780\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nlibapr_1!apr_pvsprintf+8     00000000     0642a188     180eeb94    \nactivemq_cppu!decaf::lang::Exception::buildMessage+71     0642a188     180eeb74     180eee2c    \nactivemq_cppu!decaf::lang::exceptions::RuntimeException::RuntimeException+4d     180efeec     0642a160     00000097    \nactivemq_cppu!decaf::lang::ThreadProperties::runCallback+125     180eee2c     180efee0     00000001    \nmsvcr80!CatchIt+5c     00000000     00000000     00000000\n\nLIBAPR_1!APR_PVSPRINTF+8In scotapp.dmp the assembly instruction at libapr_1!apr_pvsprintf+8 in C:\\scot\\dll\\libapr-1.dll has caused an access violation exception (0xC0000005) when trying to read from memory location 0x0000002c on thread 87\n--------------------------------------------------------------------------------------------------------------------\n\nOn the call stack, we saw that following function from class decaf::lang::Exception was called:\nvoid Exception::buildMessage( const char* format, va_list& vargs ) {\n\n    // Allocate buffer with a guess of it's size\n    AprPool pool;\n\n    // Allocate a buffer of the specified size.\n    char* buffer = apr_pvsprintf( pool.getAprPool(), format, vargs );\n\n    // Guessed size was enough. Assign the string.\n    message.assign( buffer, strlen( buffer ) );\n}\n\nThe first parameter passed into apr_pvsprintf was NULL, causing the crash. Could you please take a look and see if there is any bug in the activemqcpp code that could cause the problem. Thanks!\n\nComments:\n", "classification": "Classify the issue 'AprPool::getAprPool() returns NULL, causing access violation and application crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-388?\nA: Our application that uses activemq c++ client lib crashed with the following dump:\n\n----------------------------------------------------------------------------------------------------------------------\nThread 87 - System ID 3780\n\nFunction     Arg 1     Arg 2     Arg 3   Source \nlibapr_1!apr_pvsprintf+8     00000000     0642a188     180eeb94    \nactivemq_cppu!decaf::lang::Exception::buildMessage+7"}}
{"issue_key": "AMQCPP-387", "project": "AMQCPP", "title": "Credentials are not propagated correctly when passed through the ActiveMQConnectionFactory constructor in the CPP client API (However, it works correctly when passed through the createConnection method)", "status": "Resolved", "reporter": "Bhooshan Mogal", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2012-02-09T17:20:52.000+0000", "updated": "2012-04-14T19:50:13.000+0000", "description": "I tried to connect to the an ActiveMQ server using the C++ client API. However, when I pass the credentials (username and password) only through the ActiveMQConnectionFactory  constructor and not through the createConnection method, the password is not shows up as null in the server logs.\nSo,\n\n auto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection();\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\nresults in the server receiving the password as null. However, when the credentials are passed through the createConnection method as well, like - \nauto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection(\"username\", \"password\");\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\n\nthe server receives the password correctly.", "comments": [], "text": "Credentials are not propagated correctly when passed through the ActiveMQConnectionFactory constructor in the CPP client API (However, it works correctly when passed through the createConnection method)\n\nDescription:\nI tried to connect to the an ActiveMQ server using the C++ client API. However, when I pass the credentials (username and password) only through the ActiveMQConnectionFactory  constructor and not through the createConnection method, the password is not shows up as null in the server logs.\nSo,\n\n auto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection();\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\nresults in the server receiving the password as null. However, when the credentials are passed through the createConnection method as well, like - \nauto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection(\"username\", \"password\");\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\n\nthe server receives the password correctly.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Credentials are not propagated correctly when passed through the ActiveMQConnectionFactory constructor in the CPP client API (However, it works correctly when passed through the createConnection method)\n\nDescription:\nI tried to connect to the an ActiveMQ server using the C++ client API. However, when I pass the credentials (username and password) only through the ActiveMQConnectionFactory  constructor and not through the createConnection method, the password is not shows up as null in the server logs.\nSo,\n\n auto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection();\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\nresults in the server receiving the password as null. However, when the credentials are passed through the createConnection method as well, like - \nauto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( brokerURI, \"username\", \"password\" ) );\n            try{\n                connection = connectionFactory->createConnection(\"username\", \"password\");\n                connection->start();\n            } catch( CMSException& e ) {\n                e.printStackTrace();\n                throw e;\n            }\n\nthe server receives the password correctly.\n\nComments:\n", "classification": "Classify the issue 'Credentials are not propagated correctly when passed through the ActiveMQConnectionFactory constructor in the CPP client API (However, it works correctly when passed through the createConnection method)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-387?\nA: I tried to connect to the an ActiveMQ server using the C++ client API. However, when I pass the credentials (username and password) only through the ActiveMQConnectionFactory  constructor and not through the createConnection method, the password is not shows up as null in the server logs.\nSo,\n\n auto_ptr<ActiveMQConnectionFactory> connectionFactory(\n                new ActiveMQConnectionFactory( br"}}
{"issue_key": "AMQCPP-386", "project": "AMQCPP", "title": "Run-time Setting of Destination Prefix", "status": "Resolved", "reporter": "Mark Rappoport", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["patch"], "created": "2012-02-08T20:56:38.000+0000", "updated": "2012-11-28T21:55:50.000+0000", "description": "Some STOMP-aware message brokers (such as HornetQ) want their destinations prefixed in a manner different from \"/queue/\" or \"/topic/\". HornetQ, for example, wants it to be \"jms.queue.\" or \"jms.topic.\".\n\nTo address this, I've made some changes to StompHelper, adding the following URI parameters:\n\n* wireFormat.queuePrefix - defaults to \"/queue/\"\n* wireFormat.topicPrefix - defaults to \"/topic/\"\n* wireFormat.tempQueuePrefix - defaults to \"/temp-queue/\"\n* wireFormat.tempTopicPrefix - defaults to \"/temp-topic/\"\n\nMy patch, however, fails to utilize the framework laid out by the StompWireformatProperties class, as the current code structure makes it very hard. Regardless, I've tested it with the SimpleProducer example (make sure you provide guest/guest as auth params if you're running a vanilla HornetQ) and it seems to work fine.\n\nThe patch is against the activemq-cpp-3.4.1 tag as trunk wouldn't compile; some formatting issues may be present as well.", "comments": [], "text": "Run-time Setting of Destination Prefix\n\nDescription:\nSome STOMP-aware message brokers (such as HornetQ) want their destinations prefixed in a manner different from \"/queue/\" or \"/topic/\". HornetQ, for example, wants it to be \"jms.queue.\" or \"jms.topic.\".\n\nTo address this, I've made some changes to StompHelper, adding the following URI parameters:\n\n* wireFormat.queuePrefix - defaults to \"/queue/\"\n* wireFormat.topicPrefix - defaults to \"/topic/\"\n* wireFormat.tempQueuePrefix - defaults to \"/temp-queue/\"\n* wireFormat.tempTopicPrefix - defaults to \"/temp-topic/\"\n\nMy patch, however, fails to utilize the framework laid out by the StompWireformatProperties class, as the current code structure makes it very hard. Regardless, I've tested it with the SimpleProducer example (make sure you provide guest/guest as auth params if you're running a vanilla HornetQ) and it seems to work fine.\n\nThe patch is against the activemq-cpp-3.4.1 tag as trunk wouldn't compile; some formatting issues may be present as well.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Run-time Setting of Destination Prefix\n\nDescription:\nSome STOMP-aware message brokers (such as HornetQ) want their destinations prefixed in a manner different from \"/queue/\" or \"/topic/\". HornetQ, for example, wants it to be \"jms.queue.\" or \"jms.topic.\".\n\nTo address this, I've made some changes to StompHelper, adding the following URI parameters:\n\n* wireFormat.queuePrefix - defaults to \"/queue/\"\n* wireFormat.topicPrefix - defaults to \"/topic/\"\n* wireFormat.tempQueuePrefix - defaults to \"/temp-queue/\"\n* wireFormat.tempTopicPrefix - defaults to \"/temp-topic/\"\n\nMy patch, however, fails to utilize the framework laid out by the StompWireformatProperties class, as the current code structure makes it very hard. Regardless, I've tested it with the SimpleProducer example (make sure you provide guest/guest as auth params if you're running a vanilla HornetQ) and it seems to work fine.\n\nThe patch is against the activemq-cpp-3.4.1 tag as trunk wouldn't compile; some formatting issues may be present as well.\n\n\nComments:\n", "classification": "Classify the issue 'Run-time Setting of Destination Prefix' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-386?\nA: Some STOMP-aware message brokers (such as HornetQ) want their destinations prefixed in a manner different from \"/queue/\" or \"/topic/\". HornetQ, for example, wants it to be \"jms.queue.\" or \"jms.topic.\".\n\nTo address this, I've made some changes to StompHelper, adding the following URI parameters:\n\n* wireFormat.queuePrefix - defaults to \"/queue/\"\n* wireFormat.topicPrefix - defaults to \"/topic/\"\n* wir"}}
{"issue_key": "AMQCPP-385", "project": "AMQCPP", "title": "Compilation errors with Sun Studio 12 / libCstd", "status": "Resolved", "reporter": "Ivan Pechorin", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-11-27T11:44:35.000+0000", "updated": "2011-12-12T20:27:50.000+0000", "description": "I get a trivial compilation error in few places when compiling ActiveMQ-C++ 3.4.0 release tarball using SunCC configured with libCstd instead of stlport4:\n\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQBytesMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQBytesMessage.o\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 599: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 615: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQMapMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQMapMessage.o\n\"activemq/commands/ActiveMQMapMessage.cpp\", line 122: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n1 Error(s) detected.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQStreamMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQStreamMessage.o\n\"activemq/commands/ActiveMQStreamMessage.cpp\", line 848: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQTextMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQTextMessage.o\n\"activemq/commands/ActiveMQTextMessage.cpp\", line 142: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.", "comments": [], "text": "Compilation errors with Sun Studio 12 / libCstd\n\nDescription:\nI get a trivial compilation error in few places when compiling ActiveMQ-C++ 3.4.0 release tarball using SunCC configured with libCstd instead of stlport4:\n\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQBytesMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQBytesMessage.o\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 599: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 615: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQMapMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQMapMessage.o\n\"activemq/commands/ActiveMQMapMessage.cpp\", line 122: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n1 Error(s) detected.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQStreamMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQStreamMessage.o\n\"activemq/commands/ActiveMQStreamMessage.cpp\", line 848: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQTextMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQTextMessage.o\n\"activemq/commands/ActiveMQTextMessage.cpp\", line 142: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation errors with Sun Studio 12 / libCstd\n\nDescription:\nI get a trivial compilation error in few places when compiling ActiveMQ-C++ 3.4.0 release tarball using SunCC configured with libCstd instead of stlport4:\n\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQBytesMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQBytesMessage.o\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 599: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\"activemq/commands/ActiveMQBytesMessage.cpp\", line 615: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQMapMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQMapMessage.o\n\"activemq/commands/ActiveMQMapMessage.cpp\", line 122: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n1 Error(s) detected.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQStreamMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQStreamMessage.o\n\"activemq/commands/ActiveMQStreamMessage.cpp\", line 848: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -g -m32 -xO3 -xregs=no%frameptr -xtarget=generic -xarch=sse2 -KPIC -mt -c activemq/commands/ActiveMQTextMessage.cpp  -KPIC -DPIC -o activemq/commands/.libs/libactivemq_cpp_la-ActiveMQTextMessage.o\n\"activemq/commands/ActiveMQTextMessage.cpp\", line 142: Error: Cannot use std::pair<unsigned char*, int> to initialize std::pair<const unsigned char*, int>.\n\nComments:\n", "classification": "Classify the issue 'Compilation errors with Sun Studio 12 / libCstd' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-385?\nA: I get a trivial compilation error in few places when compiling ActiveMQ-C++ 3.4.0 release tarball using SunCC configured with libCstd instead of stlport4:\n\n\nlibtool: compile:  CC -DHAVE_CONFIG_H -I. -I../.. -mt -w -O5 -library=Cstd -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/cma/dev/pie/activemq/dist/include/apr-1 -I/cma/dev/pie/activemq/dist/include/apr-1 -PIC -"}}
{"issue_key": "AMQCPP-384", "project": "AMQCPP", "title": "Failover and prefetch=0 can result in hung consumers if the MessagePull command is lost", "status": "Resolved", "reporter": "Daniel LaÃ¼gt", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-11-09T14:58:16.000+0000", "updated": "2011-11-09T22:00:13.000+0000", "description": "The problem has been fixed in ActiveMQ Java Client with the issue AMQ-2877:\nhttps://issues.apache.org/jira/browse/AMQ-2877\n\nI've attached a patch that backport the fix done in java to C++. It can be probably used as suggestion...\n\nWith prefetch=0, a consumer that has no messages sends an async message to the broker to have it dispatch a single message and waits for the dispatch to ocurr. prefetch=0 makes the consumer a pull consumer, in that it has to ask for a message each time.\n\nthere is a possibility that failover occurs just after the send of the messagePull command such that the consumer is blocked waiting for a message but a failover connection or broker does not know about the outstanding pull command. The connection state tracker is the normal mechanism for command replay after failover. This needs to be extended to track messagePull commands, keeping one outstanding reference for each consumer/destination pair that can be replayed after failover.\nIt makes sense to reuse the messageCache for this.", "comments": [], "text": "Failover and prefetch=0 can result in hung consumers if the MessagePull command is lost\n\nDescription:\nThe problem has been fixed in ActiveMQ Java Client with the issue AMQ-2877:\nhttps://issues.apache.org/jira/browse/AMQ-2877\n\nI've attached a patch that backport the fix done in java to C++. It can be probably used as suggestion...\n\nWith prefetch=0, a consumer that has no messages sends an async message to the broker to have it dispatch a single message and waits for the dispatch to ocurr. prefetch=0 makes the consumer a pull consumer, in that it has to ask for a message each time.\n\nthere is a possibility that failover occurs just after the send of the messagePull command such that the consumer is blocked waiting for a message but a failover connection or broker does not know about the outstanding pull command. The connection state tracker is the normal mechanism for command replay after failover. This needs to be extended to track messagePull commands, keeping one outstanding reference for each consumer/destination pair that can be replayed after failover.\nIt makes sense to reuse the messageCache for this.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover and prefetch=0 can result in hung consumers if the MessagePull command is lost\n\nDescription:\nThe problem has been fixed in ActiveMQ Java Client with the issue AMQ-2877:\nhttps://issues.apache.org/jira/browse/AMQ-2877\n\nI've attached a patch that backport the fix done in java to C++. It can be probably used as suggestion...\n\nWith prefetch=0, a consumer that has no messages sends an async message to the broker to have it dispatch a single message and waits for the dispatch to ocurr. prefetch=0 makes the consumer a pull consumer, in that it has to ask for a message each time.\n\nthere is a possibility that failover occurs just after the send of the messagePull command such that the consumer is blocked waiting for a message but a failover connection or broker does not know about the outstanding pull command. The connection state tracker is the normal mechanism for command replay after failover. This needs to be extended to track messagePull commands, keeping one outstanding reference for each consumer/destination pair that can be replayed after failover.\nIt makes sense to reuse the messageCache for this.\n\n\nComments:\n", "classification": "Classify the issue 'Failover and prefetch=0 can result in hung consumers if the MessagePull command is lost' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-384?\nA: The problem has been fixed in ActiveMQ Java Client with the issue AMQ-2877:\nhttps://issues.apache.org/jira/browse/AMQ-2877\n\nI've attached a patch that backport the fix done in java to C++. It can be probably used as suggestion...\n\nWith prefetch=0, a consumer that has no messages sends an async message to the broker to have it dispatch a single message and waits for the dispatch to ocurr. prefetch="}}
{"issue_key": "AMQCPP-383", "project": "AMQCPP", "title": "Implement the Session recover method.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-11-03T19:43:51.000+0000", "updated": "2011-11-07T21:55:52.000+0000", "description": "Add implementation and tests for the Session recover method.", "comments": [], "text": "Implement the Session recover method.\n\nDescription:\nAdd implementation and tests for the Session recover method.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement the Session recover method.\n\nDescription:\nAdd implementation and tests for the Session recover method.\n\nComments:\n", "classification": "Classify the issue 'Implement the Session recover method.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-383?\nA: Add implementation and tests for the Session recover method."}}
{"issue_key": "AMQCPP-382", "project": "AMQCPP", "title": "Spurious error messages printed by consumer when no messages available to consumer", "status": "Resolved", "reporter": "Roddie Kieley", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-10-28T19:09:02.000+0000", "updated": "2011-11-09T21:17:31.000+0000", "description": "Getting the following output for each null returned by consumer->receive(timeout):\n\n{code:xml}\nPointer operator-> - Pointee is NULL.\n        FILE: ./decaf/lang/Pointer.h, LINE: 257\n        FILE: activemq/core/ActiveMQConsumer.cpp, LINE: 1165\n        FILE: activemq/core/ActiveMQSessionExecutor.cpp, LINE: 141\n{code}\n\nWhen I connect the simple consumer to a broker with no messages available. Note simple consumer modified to use receive(long timeout) instead of setMessageListener(this) with a timeout of 6000.", "comments": [], "text": "Spurious error messages printed by consumer when no messages available to consumer\n\nDescription:\nGetting the following output for each null returned by consumer->receive(timeout):\n\n{code:xml}\nPointer operator-> - Pointee is NULL.\n        FILE: ./decaf/lang/Pointer.h, LINE: 257\n        FILE: activemq/core/ActiveMQConsumer.cpp, LINE: 1165\n        FILE: activemq/core/ActiveMQSessionExecutor.cpp, LINE: 141\n{code}\n\nWhen I connect the simple consumer to a broker with no messages available. Note simple consumer modified to use receive(long timeout) instead of setMessageListener(this) with a timeout of 6000.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Spurious error messages printed by consumer when no messages available to consumer\n\nDescription:\nGetting the following output for each null returned by consumer->receive(timeout):\n\n{code:xml}\nPointer operator-> - Pointee is NULL.\n        FILE: ./decaf/lang/Pointer.h, LINE: 257\n        FILE: activemq/core/ActiveMQConsumer.cpp, LINE: 1165\n        FILE: activemq/core/ActiveMQSessionExecutor.cpp, LINE: 141\n{code}\n\nWhen I connect the simple consumer to a broker with no messages available. Note simple consumer modified to use receive(long timeout) instead of setMessageListener(this) with a timeout of 6000.\n\n\n\nComments:\n", "classification": "Classify the issue 'Spurious error messages printed by consumer when no messages available to consumer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-382?\nA: Getting the following output for each null returned by consumer->receive(timeout):\n\n{code:xml}\nPointer operator-> - Pointee is NULL.\n        FILE: ./decaf/lang/Pointer.h, LINE: 257\n        FILE: activemq/core/ActiveMQConsumer.cpp, LINE: 1165\n        FILE: activemq/core/ActiveMQSessionExecutor.cpp, LINE: 141\n{code}\n\nWhen I connect the simple consumer to a broker with no messages available. Note sim"}}
{"issue_key": "AMQCPP-381", "project": "AMQCPP", "title": "Cannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. ", "status": "Closed", "reporter": "Suresh Velupula", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-10-14T22:25:26.000+0000", "updated": "2011-10-14T23:14:39.000+0000", "description": "Downloaded source from: http://archive.apache.org/dist/activemq/activemq-cpp/source/activemq-cpp-library-3.2.4-src.tar.gz \n\nCannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. Need clear documentation on what compilers and platforms it can be compiled and installed on. If these are already already documented can you please provide it.\n\nErrors:\n---\nmake  all-recursive\nmake[1]: Entering directory `/suresh/build/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/build/activemq-cpp/src/main'\n/bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/suresh/build/apr/include   -I/suresh/build/apr-util/include  -I/usr/kerberos/include   -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/suresh/build/apr/include -I/suresh/build/apr-util/include -I/usr/kerberos/include -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c activemq/cmsutil/CmsAccessor.cpp  -fPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h:114: syntax error before `__attribute__'\ndecaf/util/AbstractCollection.h:147: warning: `virtual' is not at beginning of\n   declaration\ndecaf/util/AbstractCollection.h:150: warning: ISO C++ forbids defining types\n   within return type\ndecaf/util/AbstractCollection.h:150: `bool' is now a keyword\ndecaf/util/AbstractCollection.h:150: virtual outside class declaration\ndecaf/util/AbstractCollection.h:150: semicolon missing after declaration of `\n   class decaf::util::AbstractCollection<E>'\ndecaf/util/AbstractCollection.h: In function `int decaf::util::addAll(const\n   decaf::util::Collection<E>&)':\ndecaf/util/AbstractCollection.h:155: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:177: virtual outside class declaration\ndecaf/util/AbstractCollection.h: In function `void decaf::util::clear()':\ndecaf/util/AbstractCollection.h:179: `E' undeclared (first use this function)\ndecaf/util/AbstractCollection.h:179: (Each undeclared identifier is reported\n   only once for each function it appears in.)\ndecaf/util/AbstractCollection.h:179: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:179: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:179: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:180: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:181: request for member `next' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:182: request for member `remove' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:194: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:194: virtual outside class declaration\ndecaf/util/AbstractCollection.h:194: warning: ISO C++ forbids declaration of `\n   collection' with no type\ndecaf/util/AbstractCollection.h: In function `void decaf::util::copy(const\n   int&)':\ndecaf/util/AbstractCollection.h:195: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:197: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:197: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:197: request for member `iterator' in `\n   collection', which is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:198: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\n\n---", "comments": [], "text": "Cannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. \n\nDescription:\nDownloaded source from: http://archive.apache.org/dist/activemq/activemq-cpp/source/activemq-cpp-library-3.2.4-src.tar.gz \n\nCannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. Need clear documentation on what compilers and platforms it can be compiled and installed on. If these are already already documented can you please provide it.\n\nErrors:\n---\nmake  all-recursive\nmake[1]: Entering directory `/suresh/build/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/build/activemq-cpp/src/main'\n/bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/suresh/build/apr/include   -I/suresh/build/apr-util/include  -I/usr/kerberos/include   -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/suresh/build/apr/include -I/suresh/build/apr-util/include -I/usr/kerberos/include -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c activemq/cmsutil/CmsAccessor.cpp  -fPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h:114: syntax error before `__attribute__'\ndecaf/util/AbstractCollection.h:147: warning: `virtual' is not at beginning of\n   declaration\ndecaf/util/AbstractCollection.h:150: warning: ISO C++ forbids defining types\n   within return type\ndecaf/util/AbstractCollection.h:150: `bool' is now a keyword\ndecaf/util/AbstractCollection.h:150: virtual outside class declaration\ndecaf/util/AbstractCollection.h:150: semicolon missing after declaration of `\n   class decaf::util::AbstractCollection<E>'\ndecaf/util/AbstractCollection.h: In function `int decaf::util::addAll(const\n   decaf::util::Collection<E>&)':\ndecaf/util/AbstractCollection.h:155: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:177: virtual outside class declaration\ndecaf/util/AbstractCollection.h: In function `void decaf::util::clear()':\ndecaf/util/AbstractCollection.h:179: `E' undeclared (first use this function)\ndecaf/util/AbstractCollection.h:179: (Each undeclared identifier is reported\n   only once for each function it appears in.)\ndecaf/util/AbstractCollection.h:179: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:179: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:179: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:180: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:181: request for member `next' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:182: request for member `remove' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:194: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:194: virtual outside class declaration\ndecaf/util/AbstractCollection.h:194: warning: ISO C++ forbids declaration of `\n   collection' with no type\ndecaf/util/AbstractCollection.h: In function `void decaf::util::copy(const\n   int&)':\ndecaf/util/AbstractCollection.h:195: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:197: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:197: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:197: request for member `iterator' in `\n   collection', which is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:198: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\n\n---\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Cannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. \n\nDescription:\nDownloaded source from: http://archive.apache.org/dist/activemq/activemq-cpp/source/activemq-cpp-library-3.2.4-src.tar.gz \n\nCannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. Need clear documentation on what compilers and platforms it can be compiled and installed on. If these are already already documented can you please provide it.\n\nErrors:\n---\nmake  all-recursive\nmake[1]: Entering directory `/suresh/build/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/suresh/build/activemq-cpp/src/main'\n/bin/sh ../../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../..    -ansi -pedantic   -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE  -I/suresh/build/apr/include   -I/suresh/build/apr-util/include  -I/usr/kerberos/include   -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c -o activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo `test -f 'activemq/cmsutil/CmsAccessor.cpp' || echo './'`activemq/cmsutil/CmsAccessor.cpp\nlibtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../.. -ansi -pedantic -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE -D_LARGEFILE64_SOURCE -I/suresh/build/apr/include -I/suresh/build/apr-util/include -I/usr/kerberos/include -W -Wall -Wconversion -fPIC -fstrict-aliasing -Wno-long-long -g -O2 -pthread -MT activemq/cmsutil/libactivemq_cpp_la-CmsAccessor.lo -MD -MP -MF activemq/cmsutil/.deps/libactivemq_cpp_la-CmsAccessor.Tpo -c activemq/cmsutil/CmsAccessor.cpp  -fPIC -DPIC -o activemq/cmsutil/.libs/libactivemq_cpp_la-CmsAccessor.o\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h:114: syntax error before `__attribute__'\ndecaf/util/AbstractCollection.h:147: warning: `virtual' is not at beginning of\n   declaration\ndecaf/util/AbstractCollection.h:150: warning: ISO C++ forbids defining types\n   within return type\ndecaf/util/AbstractCollection.h:150: `bool' is now a keyword\ndecaf/util/AbstractCollection.h:150: virtual outside class declaration\ndecaf/util/AbstractCollection.h:150: semicolon missing after declaration of `\n   class decaf::util::AbstractCollection<E>'\ndecaf/util/AbstractCollection.h: In function `int decaf::util::addAll(const\n   decaf::util::Collection<E>&)':\ndecaf/util/AbstractCollection.h:155: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:177: virtual outside class declaration\ndecaf/util/AbstractCollection.h: In function `void decaf::util::clear()':\ndecaf/util/AbstractCollection.h:179: `E' undeclared (first use this function)\ndecaf/util/AbstractCollection.h:179: (Each undeclared identifier is reported\n   only once for each function it appears in.)\ndecaf/util/AbstractCollection.h:179: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:179: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:179: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:180: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:181: request for member `next' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:182: request for member `remove' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\nIn file included from decaf/util/List.h:26,\n                 from decaf/util/StlList.h:32,\n                 from activemq/cmsutil/ResourceLifecycleManager.h:27,\n                 from activemq/cmsutil/CmsAccessor.h:21,\n                 from activemq/cmsutil/CmsAccessor.cpp:18:\ndecaf/util/AbstractCollection.h: At global scope:\ndecaf/util/AbstractCollection.h:194: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:194: virtual outside class declaration\ndecaf/util/AbstractCollection.h:194: warning: ISO C++ forbids declaration of `\n   collection' with no type\ndecaf/util/AbstractCollection.h: In function `void decaf::util::copy(const\n   int&)':\ndecaf/util/AbstractCollection.h:195: invalid use of `this' in non-member\n   function\ndecaf/util/AbstractCollection.h:197: template argument 1 is invalid\ndecaf/util/AbstractCollection.h:197: warning: ISO C++ forbids declaration of `\n   type name' with no type\ndecaf/util/AbstractCollection.h:197: request for member `iterator' in `\n   collection', which is of non-aggregate type `int'\ndecaf/util/AbstractCollection.h:198: request for member `hasNext' in `\n   *(&iter)->std::auto_ptr<_Tp>::operator->() const [with _Tp = int]()', which\n   is of non-aggregate type `int'\n\n---\n\n\nComments:\n", "classification": "Classify the issue 'Cannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-381?\nA: Downloaded source from: http://archive.apache.org/dist/activemq/activemq-cpp/source/activemq-cpp-library-3.2.4-src.tar.gz \n\nCannot build activemq-cpp 3.2.4 library on RH AS 3.0 with gcc 3.2.3. Need clear documentation on what compilers and platforms it can be compiled and installed on. If these are already already documented can you please provide it.\n\nErrors:\n---\nmake  all-recursive\nmake[1]: Ente"}}
{"issue_key": "AMQCPP-380", "project": "AMQCPP", "title": "Static library doesn't link correctly", "status": "Resolved", "reporter": "Nicolas A. Barriga", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2011-10-04T14:03:23.000+0000", "updated": "2011-10-26T22:56:34.000+0000", "description": "I'm trying to use the static library for activemq-cpp, as the dynamic one doesn't work (AMQCPP-298).\n\nWhen linking my project against libactivemq-cpp.a I get the following errors:\nUndefined symbols:\n  \"_apr_uuid_format\", referenced from:\n      decaf::util::UUID::toString() constin libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_md5\", referenced from:\n      decaf::util::UUID::nameUUIDFromBytes(char const*, unsigned long)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_parse\", referenced from:\n      decaf::util::UUID::fromString(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_get\", referenced from:\n      decaf::util::UUID::randomUUID()    in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\nld: symbol(s) not found\n\nI'm using apr-1.3.9 and apr-util 1.3.12, which work without problems on Linux with dynamic libraries.", "comments": [], "text": "Static library doesn't link correctly\n\nDescription:\nI'm trying to use the static library for activemq-cpp, as the dynamic one doesn't work (AMQCPP-298).\n\nWhen linking my project against libactivemq-cpp.a I get the following errors:\nUndefined symbols:\n  \"_apr_uuid_format\", referenced from:\n      decaf::util::UUID::toString() constin libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_md5\", referenced from:\n      decaf::util::UUID::nameUUIDFromBytes(char const*, unsigned long)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_parse\", referenced from:\n      decaf::util::UUID::fromString(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_get\", referenced from:\n      decaf::util::UUID::randomUUID()    in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\nld: symbol(s) not found\n\nI'm using apr-1.3.9 and apr-util 1.3.12, which work without problems on Linux with dynamic libraries.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Static library doesn't link correctly\n\nDescription:\nI'm trying to use the static library for activemq-cpp, as the dynamic one doesn't work (AMQCPP-298).\n\nWhen linking my project against libactivemq-cpp.a I get the following errors:\nUndefined symbols:\n  \"_apr_uuid_format\", referenced from:\n      decaf::util::UUID::toString() constin libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_md5\", referenced from:\n      decaf::util::UUID::nameUUIDFromBytes(char const*, unsigned long)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_parse\", referenced from:\n      decaf::util::UUID::fromString(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_uuid_get\", referenced from:\n      decaf::util::UUID::randomUUID()    in libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\nld: symbol(s) not found\n\nI'm using apr-1.3.9 and apr-util 1.3.12, which work without problems on Linux with dynamic libraries.\n\nComments:\n", "classification": "Classify the issue 'Static library doesn't link correctly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-380?\nA: I'm trying to use the static library for activemq-cpp, as the dynamic one doesn't work (AMQCPP-298).\n\nWhen linking my project against libactivemq-cpp.a I get the following errors:\nUndefined symbols:\n  \"_apr_uuid_format\", referenced from:\n      decaf::util::UUID::toString() constin libactivemq-cpp.a(libactivemq_cpp_la-UUID.o)\n  \"_apr_md5\", referenced from:\n      decaf::util::UUID::nameUUIDFromBytes"}}
{"issue_key": "AMQCPP-379", "project": "AMQCPP", "title": "CMS: invalid build with native AIX compiler - \"-PIC\" is passed instead of \"-qpic\"", "status": "Closed", "reporter": "Yakov Dekel", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2011-08-01T06:53:07.000+0000", "updated": "2011-10-26T22:54:19.000+0000", "description": "When building under AIX, the configure script generates \"-PIC\" as a parameter to the compiler. Since -P is a directive telling the compiler to do just preprocessiong, the build failes. The correct parameter should be -qpic. \nAn ugly bypass is to edit all generated Makefiles and replace the parameters.", "comments": [], "text": "CMS: invalid build with native AIX compiler - \"-PIC\" is passed instead of \"-qpic\"\n\nDescription:\nWhen building under AIX, the configure script generates \"-PIC\" as a parameter to the compiler. Since -P is a directive telling the compiler to do just preprocessiong, the build failes. The correct parameter should be -qpic. \nAn ugly bypass is to edit all generated Makefiles and replace the parameters.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS: invalid build with native AIX compiler - \"-PIC\" is passed instead of \"-qpic\"\n\nDescription:\nWhen building under AIX, the configure script generates \"-PIC\" as a parameter to the compiler. Since -P is a directive telling the compiler to do just preprocessiong, the build failes. The correct parameter should be -qpic. \nAn ugly bypass is to edit all generated Makefiles and replace the parameters.\n\nComments:\n", "classification": "Classify the issue 'CMS: invalid build with native AIX compiler - \"-PIC\" is passed instead of \"-qpic\"' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-379?\nA: When building under AIX, the configure script generates \"-PIC\" as a parameter to the compiler. Since -P is a directive telling the compiler to do just preprocessiong, the build failes. The correct parameter should be -qpic. \nAn ugly bypass is to edit all generated Makefiles and replace the parameters."}}
{"issue_key": "AMQCPP-378", "project": "AMQCPP", "title": "CMS: invalid static library created", "status": "Closed", "reporter": "Yakov Dekel", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2011-08-01T06:59:28.000+0000", "updated": "2011-10-26T22:55:31.000+0000", "description": "When building cpp-cms, the resulting static library is useless. Instead of archiving the entire cast of objects, the shared library is archived as a single entity:\n$ ar -vt -Xany libactivemq-cpp.a\nrwxr-xr-x  1048/100   60870613 Jul 21 14:04 2011 libactivemq-cpp.so.14\n\nObviously this is wrong. The archive should contain the raw objects. Statically linking against such an archive is meaningless.", "comments": [], "text": "CMS: invalid static library created\n\nDescription:\nWhen building cpp-cms, the resulting static library is useless. Instead of archiving the entire cast of objects, the shared library is archived as a single entity:\n$ ar -vt -Xany libactivemq-cpp.a\nrwxr-xr-x  1048/100   60870613 Jul 21 14:04 2011 libactivemq-cpp.so.14\n\nObviously this is wrong. The archive should contain the raw objects. Statically linking against such an archive is meaningless. \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS: invalid static library created\n\nDescription:\nWhen building cpp-cms, the resulting static library is useless. Instead of archiving the entire cast of objects, the shared library is archived as a single entity:\n$ ar -vt -Xany libactivemq-cpp.a\nrwxr-xr-x  1048/100   60870613 Jul 21 14:04 2011 libactivemq-cpp.so.14\n\nObviously this is wrong. The archive should contain the raw objects. Statically linking against such an archive is meaningless. \n\n\nComments:\n", "classification": "Classify the issue 'CMS: invalid static library created' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-378?\nA: When building cpp-cms, the resulting static library is useless. Instead of archiving the entire cast of objects, the shared library is archived as a single entity:\n$ ar -vt -Xany libactivemq-cpp.a\nrwxr-xr-x  1048/100   60870613 Jul 21 14:04 2011 libactivemq-cpp.so.14\n\nObviously this is wrong. The archive should contain the raw objects. Statically linking against such an archive is meaningless. \n"}}
{"issue_key": "AMQCPP-377", "project": "AMQCPP", "title": "Does not detect broken connection on Windows", "status": "Closed", "reporter": "Pavel Jaoshvili", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-07-15T06:18:43.000+0000", "updated": "2012-03-20T21:49:53.000+0000", "description": "Inactivity monitor does not detect broken connection.\ntransportInterrupted and transportResumed not called.", "comments": [], "text": "Does not detect broken connection on Windows\n\nDescription:\nInactivity monitor does not detect broken connection.\ntransportInterrupted and transportResumed not called.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Does not detect broken connection on Windows\n\nDescription:\nInactivity monitor does not detect broken connection.\ntransportInterrupted and transportResumed not called.\n\nComments:\n", "classification": "Classify the issue 'Does not detect broken connection on Windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-377?\nA: Inactivity monitor does not detect broken connection.\ntransportInterrupted and transportResumed not called."}}
{"issue_key": "AMQCPP-376", "project": "AMQCPP", "title": "Deadlock in IOTransport when network of brokers restart and failover is used. ", "status": "Resolved", "reporter": "igor khaustov", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-07-04T12:18:32.000+0000", "updated": "2012-04-18T21:14:53.000+0000", "description": "The problem description:\nWe  run Network of brokers ( 4 in number ) . \nBroker URI : broker URI 'failover://(tcp://10.10.13.20:61616,tcp://10.10.13.22:61616,tcp://10.10.13.24:61616,tcp://10.10.13.26:61616)?randomize=true&connection.closeTimeout=10000&transport.soTimeout=3000&timeout=3000&connection.useAsyncSend=true&connection.alwaysSyncSend=false'\n\nProducer loads broker with 1000 message/sec . We testing the producer behavior while failover by  restarting all brokers in row ( all 4 ) while sending the messages and get deadlock as shown below .\n\nNote: the problem tested only with network on brokers .\n\nThe backtrace ( only relevant threads ):\n\n+Thread 16 (process 26892):+\n*#0  0x00000032ef00ce74 in __lll_lock_wait () from /lib64/libpthread.so.0*\n#1  0x00000032ef008874 in _L_lock_106 () from /lib64/libpthread.so.0\n#2  0x00000032ef0082e0 in pthread_mutex_lock () from /lib64/libpthread.so.0\n#3  0x0000000000dc5a04 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0xfefdd38) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:77\n#4  0x0000000000bd9092 in decaf::util::concurrent::Mutex::lock (this=0xff54100) at decaf/util/concurrent/Mutex.cpp:111\n#5  0x0000000000d51f3f in decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0xff540f8) at ./decaf/util/AbstractCollection.h:331\n#6  0x0000000000bd86c9 in decaf::util::concurrent::Lock::lock (this=0x4c7b9c90) at decaf/util/concurrent/Lock.cpp:54\n#7  0x0000000000bd883a in Lock (this=0x4c7b9c90, object=0xff54188, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n*#8  0x0000000000d47a77 in activemq::transport::failover::CloseTransportsTask::add (this=0xff540e8, transport=@0x4c7b9cf0) at activemq/transport/failover/CloseTransportsTask.cpp:46*\n#9  0x0000000000b1b748 in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0xffed498, error=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransport.cpp:483\n#10 0x0000000000b41a06 in activemq::transport::failover::FailoverTransportListener::onException (this=0xfde2e58, ex=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransportListener.cpp:76\n#11 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#12 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#13 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#14 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#15 0x0000000000d554c8 in activemq::transport::inactivity::InactivityMonitor::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/inactivity/InactivityMonitor.cpp:312\n#16 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#17 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#18 0x0000000000d326f2 in activemq::transport::IOTransport::fire (this=0xdce10b8, ex=@0x4c7b9ee0) at activemq/transport/IOTransport.cpp:87\n#19 0x0000000000d32982 in activemq::transport::IOTransport::run (this=0xdce10b8) at activemq/transport/IOTransport.cpp:264\n#20 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0x105871d8) at decaf/lang/Thread.cpp:137\n#21 0x0000000000ba9068 in threadWorker (arg=0x105871d8) at decaf/lang/Thread.cpp:190\n#22 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#23 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\n+Thread 9 (process 14470):+\n*#0  0x00000032ef00a899 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0*\n#1  0x0000000000dc54b3 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x1072d2b8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x0000000000bd9033 in decaf::util::concurrent::Mutex::wait (this=0x105871d8) at decaf/util/concurrent/Mutex.cpp:126\n#3  0x0000000000ba8538 in decaf::lang::Thread::join (this=0x12a4a418) at decaf/lang/Thread.cpp:452\n#4  0x0000000000d32c28 in activemq::transport::IOTransport::close (this=0xdce10b8) at activemq/transport/IOTransport.cpp:222\n#5  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0x1020c118) at activemq/transport/TransportFilter.cpp:106\n#6  0x0000000000b47d3a in activemq::transport::tcp::TcpTransport::close (this=0x1020c118) at activemq/transport/tcp/TcpTransport.cpp:74\n#7  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0xfeeb558) at activemq/transport/TransportFilter.cpp:106\n#8  0x0000000000d554ec in activemq::transport::inactivity::InactivityMonitor::close (this=0xfeeb558) at activemq/transport/inactivity/InactivityMonitor.cpp:300\n#9  0x0000000000d77867 in activemq::wireformat::openwire::OpenWireFormatNegotiator::close (this=0x10627498) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:248\n*#10 0x0000000000d478ff in activemq::transport::failover::CloseTransportsTask::iterate (this=0xff540e8) at activemq/transport/failover/CloseTransportsTask.cpp:75*\n#11 0x0000000000d25891 in activemq::threads::CompositeTaskRunner::iterate (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:173\n#12 0x0000000000d25ae4 in activemq::threads::CompositeTaskRunner::run (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:107\n#13 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0xfeeb2b8) at decaf/lang/Thread.cpp:137\n#14 0x0000000000ba9068 in threadWorker (arg=0xfeeb2b8) at decaf/lang/Thread.cpp:190\n#15 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#16 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\nAs you can see +Thread 16+ is on lock_wait for *_synchronized( &transports )_* in activemq::transport::failover::CloseTransportsTask::add .\n\nThe *_synchronized( &transports )_* in locked by +Thread 9+ in activemq::threads::CompositeTaskRunner::iterate . But  +Thread 9+ is on pthread_cond_wait which has to be signalled by the +Thread 16+.\n\nKind regards .\nIgor.", "comments": [], "text": "Deadlock in IOTransport when network of brokers restart and failover is used. \n\nDescription:\nThe problem description:\nWe  run Network of brokers ( 4 in number ) . \nBroker URI : broker URI 'failover://(tcp://10.10.13.20:61616,tcp://10.10.13.22:61616,tcp://10.10.13.24:61616,tcp://10.10.13.26:61616)?randomize=true&connection.closeTimeout=10000&transport.soTimeout=3000&timeout=3000&connection.useAsyncSend=true&connection.alwaysSyncSend=false'\n\nProducer loads broker with 1000 message/sec . We testing the producer behavior while failover by  restarting all brokers in row ( all 4 ) while sending the messages and get deadlock as shown below .\n\nNote: the problem tested only with network on brokers .\n\nThe backtrace ( only relevant threads ):\n\n+Thread 16 (process 26892):+\n*#0  0x00000032ef00ce74 in __lll_lock_wait () from /lib64/libpthread.so.0*\n#1  0x00000032ef008874 in _L_lock_106 () from /lib64/libpthread.so.0\n#2  0x00000032ef0082e0 in pthread_mutex_lock () from /lib64/libpthread.so.0\n#3  0x0000000000dc5a04 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0xfefdd38) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:77\n#4  0x0000000000bd9092 in decaf::util::concurrent::Mutex::lock (this=0xff54100) at decaf/util/concurrent/Mutex.cpp:111\n#5  0x0000000000d51f3f in decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0xff540f8) at ./decaf/util/AbstractCollection.h:331\n#6  0x0000000000bd86c9 in decaf::util::concurrent::Lock::lock (this=0x4c7b9c90) at decaf/util/concurrent/Lock.cpp:54\n#7  0x0000000000bd883a in Lock (this=0x4c7b9c90, object=0xff54188, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n*#8  0x0000000000d47a77 in activemq::transport::failover::CloseTransportsTask::add (this=0xff540e8, transport=@0x4c7b9cf0) at activemq/transport/failover/CloseTransportsTask.cpp:46*\n#9  0x0000000000b1b748 in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0xffed498, error=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransport.cpp:483\n#10 0x0000000000b41a06 in activemq::transport::failover::FailoverTransportListener::onException (this=0xfde2e58, ex=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransportListener.cpp:76\n#11 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#12 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#13 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#14 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#15 0x0000000000d554c8 in activemq::transport::inactivity::InactivityMonitor::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/inactivity/InactivityMonitor.cpp:312\n#16 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#17 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#18 0x0000000000d326f2 in activemq::transport::IOTransport::fire (this=0xdce10b8, ex=@0x4c7b9ee0) at activemq/transport/IOTransport.cpp:87\n#19 0x0000000000d32982 in activemq::transport::IOTransport::run (this=0xdce10b8) at activemq/transport/IOTransport.cpp:264\n#20 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0x105871d8) at decaf/lang/Thread.cpp:137\n#21 0x0000000000ba9068 in threadWorker (arg=0x105871d8) at decaf/lang/Thread.cpp:190\n#22 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#23 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\n+Thread 9 (process 14470):+\n*#0  0x00000032ef00a899 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0*\n#1  0x0000000000dc54b3 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x1072d2b8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x0000000000bd9033 in decaf::util::concurrent::Mutex::wait (this=0x105871d8) at decaf/util/concurrent/Mutex.cpp:126\n#3  0x0000000000ba8538 in decaf::lang::Thread::join (this=0x12a4a418) at decaf/lang/Thread.cpp:452\n#4  0x0000000000d32c28 in activemq::transport::IOTransport::close (this=0xdce10b8) at activemq/transport/IOTransport.cpp:222\n#5  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0x1020c118) at activemq/transport/TransportFilter.cpp:106\n#6  0x0000000000b47d3a in activemq::transport::tcp::TcpTransport::close (this=0x1020c118) at activemq/transport/tcp/TcpTransport.cpp:74\n#7  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0xfeeb558) at activemq/transport/TransportFilter.cpp:106\n#8  0x0000000000d554ec in activemq::transport::inactivity::InactivityMonitor::close (this=0xfeeb558) at activemq/transport/inactivity/InactivityMonitor.cpp:300\n#9  0x0000000000d77867 in activemq::wireformat::openwire::OpenWireFormatNegotiator::close (this=0x10627498) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:248\n*#10 0x0000000000d478ff in activemq::transport::failover::CloseTransportsTask::iterate (this=0xff540e8) at activemq/transport/failover/CloseTransportsTask.cpp:75*\n#11 0x0000000000d25891 in activemq::threads::CompositeTaskRunner::iterate (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:173\n#12 0x0000000000d25ae4 in activemq::threads::CompositeTaskRunner::run (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:107\n#13 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0xfeeb2b8) at decaf/lang/Thread.cpp:137\n#14 0x0000000000ba9068 in threadWorker (arg=0xfeeb2b8) at decaf/lang/Thread.cpp:190\n#15 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#16 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\nAs you can see +Thread 16+ is on lock_wait for *_synchronized( &transports )_* in activemq::transport::failover::CloseTransportsTask::add .\n\nThe *_synchronized( &transports )_* in locked by +Thread 9+ in activemq::threads::CompositeTaskRunner::iterate . But  +Thread 9+ is on pthread_cond_wait which has to be signalled by the +Thread 16+.\n\nKind regards .\nIgor.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock in IOTransport when network of brokers restart and failover is used. \n\nDescription:\nThe problem description:\nWe  run Network of brokers ( 4 in number ) . \nBroker URI : broker URI 'failover://(tcp://10.10.13.20:61616,tcp://10.10.13.22:61616,tcp://10.10.13.24:61616,tcp://10.10.13.26:61616)?randomize=true&connection.closeTimeout=10000&transport.soTimeout=3000&timeout=3000&connection.useAsyncSend=true&connection.alwaysSyncSend=false'\n\nProducer loads broker with 1000 message/sec . We testing the producer behavior while failover by  restarting all brokers in row ( all 4 ) while sending the messages and get deadlock as shown below .\n\nNote: the problem tested only with network on brokers .\n\nThe backtrace ( only relevant threads ):\n\n+Thread 16 (process 26892):+\n*#0  0x00000032ef00ce74 in __lll_lock_wait () from /lib64/libpthread.so.0*\n#1  0x00000032ef008874 in _L_lock_106 () from /lib64/libpthread.so.0\n#2  0x00000032ef0082e0 in pthread_mutex_lock () from /lib64/libpthread.so.0\n#3  0x0000000000dc5a04 in decaf::internal::util::concurrent::MutexImpl::lock (handle=0xfefdd38) at decaf/internal/util/concurrent/unix/MutexImpl.cpp:77\n#4  0x0000000000bd9092 in decaf::util::concurrent::Mutex::lock (this=0xff54100) at decaf/util/concurrent/Mutex.cpp:111\n#5  0x0000000000d51f3f in decaf::util::AbstractCollection<decaf::lang::Pointer<activemq::transport::Transport, decaf::util::concurrent::atomic::AtomicRefCounter> >::lock (this=0xff540f8) at ./decaf/util/AbstractCollection.h:331\n#6  0x0000000000bd86c9 in decaf::util::concurrent::Lock::lock (this=0x4c7b9c90) at decaf/util/concurrent/Lock.cpp:54\n#7  0x0000000000bd883a in Lock (this=0x4c7b9c90, object=0xff54188, intiallyLocked=true) at decaf/util/concurrent/Lock.cpp:32\n*#8  0x0000000000d47a77 in activemq::transport::failover::CloseTransportsTask::add (this=0xff540e8, transport=@0x4c7b9cf0) at activemq/transport/failover/CloseTransportsTask.cpp:46*\n#9  0x0000000000b1b748 in activemq::transport::failover::FailoverTransport::handleTransportFailure (this=0xffed498, error=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransport.cpp:483\n#10 0x0000000000b41a06 in activemq::transport::failover::FailoverTransportListener::onException (this=0xfde2e58, ex=@0x4c7b9ee0) at activemq/transport/failover/FailoverTransportListener.cpp:76\n#11 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#12 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x10627498, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#13 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#14 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#15 0x0000000000d554c8 in activemq::transport::inactivity::InactivityMonitor::onException (this=0xfeeb558, ex=@0x4c7b9ee0) at activemq/transport/inactivity/InactivityMonitor.cpp:312\n#16 0x0000000000d34813 in activemq::transport::TransportFilter::fire (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:54\n#17 0x0000000000d34841 in activemq::transport::TransportFilter::onException (this=0x1020c118, ex=@0x4c7b9ee0) at activemq/transport/TransportFilter.cpp:46\n#18 0x0000000000d326f2 in activemq::transport::IOTransport::fire (this=0xdce10b8, ex=@0x4c7b9ee0) at activemq/transport/IOTransport.cpp:87\n#19 0x0000000000d32982 in activemq::transport::IOTransport::run (this=0xdce10b8) at activemq/transport/IOTransport.cpp:264\n#20 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0x105871d8) at decaf/lang/Thread.cpp:137\n#21 0x0000000000ba9068 in threadWorker (arg=0x105871d8) at decaf/lang/Thread.cpp:190\n#22 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#23 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\n+Thread 9 (process 14470):+\n*#0  0x00000032ef00a899 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0*\n#1  0x0000000000dc54b3 in decaf::internal::util::concurrent::ConditionImpl::wait (condition=0x1072d2b8) at decaf/internal/util/concurrent/unix/ConditionImpl.cpp:101\n#2  0x0000000000bd9033 in decaf::util::concurrent::Mutex::wait (this=0x105871d8) at decaf/util/concurrent/Mutex.cpp:126\n#3  0x0000000000ba8538 in decaf::lang::Thread::join (this=0x12a4a418) at decaf/lang/Thread.cpp:452\n#4  0x0000000000d32c28 in activemq::transport::IOTransport::close (this=0xdce10b8) at activemq/transport/IOTransport.cpp:222\n#5  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0x1020c118) at activemq/transport/TransportFilter.cpp:106\n#6  0x0000000000b47d3a in activemq::transport::tcp::TcpTransport::close (this=0x1020c118) at activemq/transport/tcp/TcpTransport.cpp:74\n#7  0x0000000000d34bfe in activemq::transport::TransportFilter::close (this=0xfeeb558) at activemq/transport/TransportFilter.cpp:106\n#8  0x0000000000d554ec in activemq::transport::inactivity::InactivityMonitor::close (this=0xfeeb558) at activemq/transport/inactivity/InactivityMonitor.cpp:300\n#9  0x0000000000d77867 in activemq::wireformat::openwire::OpenWireFormatNegotiator::close (this=0x10627498) at activemq/wireformat/openwire/OpenWireFormatNegotiator.cpp:248\n*#10 0x0000000000d478ff in activemq::transport::failover::CloseTransportsTask::iterate (this=0xff540e8) at activemq/transport/failover/CloseTransportsTask.cpp:75*\n#11 0x0000000000d25891 in activemq::threads::CompositeTaskRunner::iterate (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:173\n#12 0x0000000000d25ae4 in activemq::threads::CompositeTaskRunner::run (this=0xddc0108) at activemq/threads/CompositeTaskRunner.cpp:107\n#13 0x0000000000baad49 in decaf::lang::ThreadProperties::runCallback (properties=0xfeeb2b8) at decaf/lang/Thread.cpp:137\n#14 0x0000000000ba9068 in threadWorker (arg=0xfeeb2b8) at decaf/lang/Thread.cpp:190\n#15 0x00000032ef006367 in start_thread () from /lib64/libpthread.so.0\n#16 0x00000032ee4d30ad in clone () from /lib64/libc.so.6\n\n\nAs you can see +Thread 16+ is on lock_wait for *_synchronized( &transports )_* in activemq::transport::failover::CloseTransportsTask::add .\n\nThe *_synchronized( &transports )_* in locked by +Thread 9+ in activemq::threads::CompositeTaskRunner::iterate . But  +Thread 9+ is on pthread_cond_wait which has to be signalled by the +Thread 16+.\n\nKind regards .\nIgor.\n\n\nComments:\n", "classification": "Classify the issue 'Deadlock in IOTransport when network of brokers restart and failover is used. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-376?\nA: The problem description:\nWe  run Network of brokers ( 4 in number ) . \nBroker URI : broker URI 'failover://(tcp://10.10.13.20:61616,tcp://10.10.13.22:61616,tcp://10.10.13.24:61616,tcp://10.10.13.26:61616)?randomize=true&connection.closeTimeout=10000&transport.soTimeout=3000&timeout=3000&connection.useAsyncSend=true&connection.alwaysSyncSend=false'\n\nProducer loads broker with 1000 message/sec . We "}}
{"issue_key": "AMQCPP-375", "project": "AMQCPP", "title": "decaf::lang::Long::to{Hex,Binary,Octal}String problems", "status": "Resolved", "reporter": "Bob Wiegand", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2011-06-06T13:55:56.000+0000", "updated": "2012-04-13T22:03:08.000+0000", "description": "decaf::lang::Long::to{Hex,Binary,Octal}String return the wrong result for numbers less than -2^32 (on platforms with 64 bit long long): the returned string only represents the low 32 bits.\nA separate problem causes decaf::lang::{Integer,Long}::toOctalString to return the wrong result for negative numbers because there are not an even multiple of 3 bits.\n\nThis test program demonstrates the problems\n$ cat test.cpp \n\n#include <iostream>\n\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/Long.h>\n\nusing namespace std;\nusing namespace decaf::lang;\n\n\n\nvoid testLong (long long value)\n{\n        cout << \"testLong(\" << dec << value << \"LL)\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Long::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Long::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Long::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Long::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Long::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\nvoid testInteger (int value)\n{\n        cout << \"testInteger(\" << dec << value << \")\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Integer::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Integer::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Integer::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Integer::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Integer::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\n\nint main (int argc, char **argv)\n{\n        testLong(-1LL);\n        testLong(-0xFF00000000LL);\n\n        testInteger(-1);\n        testInteger(0xDFFF0000);\n\n        return 0;\n}\n\n\n$\n\n\n$ ./a.out \ntestLong(-1LL)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffffffffffff\ntoHex:  ffffffff\noct:    1777777777777777777777\ntoOct:  77777777777\noct:    1777777777777777777777\ntoB8:   -1\nhex:    ffffffffffffffff\ntoBin:  11111111111111111111111111111111\n\ntestLong(-1095216660480LL)\n\ndec:    -1095216660480\ntoB10:  -1095216660480\nhex:    ffffff0100000000\ntoHex:  00000000\noct:    1777777760040000000000\ntoOct:  40000000000\noct:    1777777760040000000000\ntoB8:   -17740000000000\nhex:    ffffff0100000000\ntoBin:  00000000000000000000000000000000\n\ntestInteger(-1)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffff\ntoHex:  ffffffff\noct:    37777777777\ntoOct:  77777777777\noct:    37777777777\ntoB8:   -1\nhex:    ffffffff\ntoBin:  11111111111111111111111111111111\n\ntestInteger(-536936448)\n\ndec:    -536936448\ntoB10:  -536936448\nhex:    dfff0000\ntoHex:  dfff0000\noct:    33777600000\ntoOct:  73777600000\noct:    33777600000\ntoB8:   -4000200000\nhex:    dfff0000\ntoBin:  11011111111111110000000000000000\n\n$", "comments": [], "text": "decaf::lang::Long::to{Hex,Binary,Octal}String problems\n\nDescription:\ndecaf::lang::Long::to{Hex,Binary,Octal}String return the wrong result for numbers less than -2^32 (on platforms with 64 bit long long): the returned string only represents the low 32 bits.\nA separate problem causes decaf::lang::{Integer,Long}::toOctalString to return the wrong result for negative numbers because there are not an even multiple of 3 bits.\n\nThis test program demonstrates the problems\n$ cat test.cpp \n\n#include <iostream>\n\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/Long.h>\n\nusing namespace std;\nusing namespace decaf::lang;\n\n\n\nvoid testLong (long long value)\n{\n        cout << \"testLong(\" << dec << value << \"LL)\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Long::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Long::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Long::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Long::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Long::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\nvoid testInteger (int value)\n{\n        cout << \"testInteger(\" << dec << value << \")\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Integer::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Integer::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Integer::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Integer::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Integer::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\n\nint main (int argc, char **argv)\n{\n        testLong(-1LL);\n        testLong(-0xFF00000000LL);\n\n        testInteger(-1);\n        testInteger(0xDFFF0000);\n\n        return 0;\n}\n\n\n$\n\n\n$ ./a.out \ntestLong(-1LL)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffffffffffff\ntoHex:  ffffffff\noct:    1777777777777777777777\ntoOct:  77777777777\noct:    1777777777777777777777\ntoB8:   -1\nhex:    ffffffffffffffff\ntoBin:  11111111111111111111111111111111\n\ntestLong(-1095216660480LL)\n\ndec:    -1095216660480\ntoB10:  -1095216660480\nhex:    ffffff0100000000\ntoHex:  00000000\noct:    1777777760040000000000\ntoOct:  40000000000\noct:    1777777760040000000000\ntoB8:   -17740000000000\nhex:    ffffff0100000000\ntoBin:  00000000000000000000000000000000\n\ntestInteger(-1)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffff\ntoHex:  ffffffff\noct:    37777777777\ntoOct:  77777777777\noct:    37777777777\ntoB8:   -1\nhex:    ffffffff\ntoBin:  11111111111111111111111111111111\n\ntestInteger(-536936448)\n\ndec:    -536936448\ntoB10:  -536936448\nhex:    dfff0000\ntoHex:  dfff0000\noct:    33777600000\ntoOct:  73777600000\noct:    33777600000\ntoB8:   -4000200000\nhex:    dfff0000\ntoBin:  11011111111111110000000000000000\n\n$\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf::lang::Long::to{Hex,Binary,Octal}String problems\n\nDescription:\ndecaf::lang::Long::to{Hex,Binary,Octal}String return the wrong result for numbers less than -2^32 (on platforms with 64 bit long long): the returned string only represents the low 32 bits.\nA separate problem causes decaf::lang::{Integer,Long}::toOctalString to return the wrong result for negative numbers because there are not an even multiple of 3 bits.\n\nThis test program demonstrates the problems\n$ cat test.cpp \n\n#include <iostream>\n\n#include <decaf/lang/Integer.h>\n#include <decaf/lang/Long.h>\n\nusing namespace std;\nusing namespace decaf::lang;\n\n\n\nvoid testLong (long long value)\n{\n        cout << \"testLong(\" << dec << value << \"LL)\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Long::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Long::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Long::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Long::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Long::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\nvoid testInteger (int value)\n{\n        cout << \"testInteger(\" << dec << value << \")\\n\"\n                << \"\\ndec:\\t\" << dec << value << \"\\ntoB10:\\t\" << Integer::toString(value, 10)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoHex:\\t\" << Integer::toHexString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoOct:\\t\" << Integer::toOctalString(value)\n                << \"\\noct:\\t\" << oct << value << \"\\ntoB8:\\t\" << Integer::toString(value, 8)\n                << \"\\nhex:\\t\" << hex << value << \"\\ntoBin:\\t\" << Integer::toBinaryString(value)\n                << \"\\n\\n\";\n}\n\n\n\nint main (int argc, char **argv)\n{\n        testLong(-1LL);\n        testLong(-0xFF00000000LL);\n\n        testInteger(-1);\n        testInteger(0xDFFF0000);\n\n        return 0;\n}\n\n\n$\n\n\n$ ./a.out \ntestLong(-1LL)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffffffffffff\ntoHex:  ffffffff\noct:    1777777777777777777777\ntoOct:  77777777777\noct:    1777777777777777777777\ntoB8:   -1\nhex:    ffffffffffffffff\ntoBin:  11111111111111111111111111111111\n\ntestLong(-1095216660480LL)\n\ndec:    -1095216660480\ntoB10:  -1095216660480\nhex:    ffffff0100000000\ntoHex:  00000000\noct:    1777777760040000000000\ntoOct:  40000000000\noct:    1777777760040000000000\ntoB8:   -17740000000000\nhex:    ffffff0100000000\ntoBin:  00000000000000000000000000000000\n\ntestInteger(-1)\n\ndec:    -1\ntoB10:  -1\nhex:    ffffffff\ntoHex:  ffffffff\noct:    37777777777\ntoOct:  77777777777\noct:    37777777777\ntoB8:   -1\nhex:    ffffffff\ntoBin:  11111111111111111111111111111111\n\ntestInteger(-536936448)\n\ndec:    -536936448\ntoB10:  -536936448\nhex:    dfff0000\ntoHex:  dfff0000\noct:    33777600000\ntoOct:  73777600000\noct:    33777600000\ntoB8:   -4000200000\nhex:    dfff0000\ntoBin:  11011111111111110000000000000000\n\n$\n\n\nComments:\n", "classification": "Classify the issue 'decaf::lang::Long::to{Hex,Binary,Octal}String problems' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-375?\nA: decaf::lang::Long::to{Hex,Binary,Octal}String return the wrong result for numbers less than -2^32 (on platforms with 64 bit long long): the returned string only represents the low 32 bits.\nA separate problem causes decaf::lang::{Integer,Long}::toOctalString to return the wrong result for negative numbers because there are not an even multiple of 3 bits.\n\nThis test program demonstrates the problems"}}
{"issue_key": "AMQCPP-374", "project": "AMQCPP", "title": "BaseDataStreamMarshaller::tightUnmarshalByteArray crashes", "status": "Resolved", "reporter": "Thomas Krammer", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-06-04T15:26:48.000+0000", "updated": "2011-11-07T22:20:32.000+0000", "description": "This issue is very similar to the one described in AMQCPP-353: \n\nBaseDataStreamMarshaller::tightUnmarshalByteArray() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1", "comments": [], "text": "BaseDataStreamMarshaller::tightUnmarshalByteArray crashes\n\nDescription:\nThis issue is very similar to the one described in AMQCPP-353: \n\nBaseDataStreamMarshaller::tightUnmarshalByteArray() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: BaseDataStreamMarshaller::tightUnmarshalByteArray crashes\n\nDescription:\nThis issue is very similar to the one described in AMQCPP-353: \n\nBaseDataStreamMarshaller::tightUnmarshalByteArray() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1\n\nComments:\n", "classification": "Classify the issue 'BaseDataStreamMarshaller::tightUnmarshalByteArray crashes' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-374?\nA: This issue is very similar to the one described in AMQCPP-353: \n\nBaseDataStreamMarshaller::tightUnmarshalByteArray() tries to reference the first element of an empty vector, which calls terminate() when _SECURE_SCL = 1"}}
{"issue_key": "AMQCPP-373", "project": "AMQCPP", "title": "AMQ_CATCH_RETHROW upcasts the re-thrown exception", "status": "Resolved", "reporter": "Martin Lepage", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": ["exception", "exception_handling"], "created": "2011-05-26T13:30:09.000+0000", "updated": "2011-11-07T21:58:09.000+0000", "description": "AMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW as defined in {{activemq/exceptions/ExceptionDefines.h}} and {{decaf/lang/exceptions/ExceptionDefines.h}} upcast the exceptions when they rethrow it, which results in loss of information (but not of data) along the way. \n\nTake for example the following c++ code fragment, which mimics the way AMQ_CATCH_RETHROW is used throughout the code :\n\n{code:title=Exception handling|borderStyle=solid}\n#include <iostream>\n#include <typeinfo>\n#include <activemq/exceptions/ExceptionDefines.h>\n#include <activemq/exceptions/BrokerException.h>\n\nint main()\n{\n    try\n    {\n        try\n        {\n            try\n            {\n                throw activemq::exceptions::BrokerException(\n                        __FILE__, __LINE__, \"Testing\");\n            }\n            AMQ_CATCH_RETHROW(activemq::exceptions::BrokerException)\n        }\n        AMQ_CATCH_RETHROW(activemq::exceptions::ActiveMQException)\n    }\n    catch (decaf::lang::Throwable &e)\n    {\n        std::cout.flags(std::ios_base::boolalpha);\n\n        std::cout << \"Broker exception : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::BrokerException).name()) << \"\\n\";\n\n        std::cout << \"ActiveMQException : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::ActiveMQException).name()) << \"\\n\";\n        \n        decaf::lang::Throwable *convertedException =\n            dynamic_cast<activemq::exceptions::BrokerException *>(&e);\n\n        std::cout << \"Conversion failed : \" << (convertedException == NULL)\n                  << \"\\n\";\n    }\n    return 0;\n}\n{code} \n\nwhich returns :\n\n{code:xml} \nBroker exception : false\nActiveMQException : true\nConversion failed : true\n{code} \n\nThe solution is to replace '{{throw e;}}' by '{{throw;}}' in the definitions of AMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW.", "comments": [], "text": "AMQ_CATCH_RETHROW upcasts the re-thrown exception\n\nDescription:\nAMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW as defined in {{activemq/exceptions/ExceptionDefines.h}} and {{decaf/lang/exceptions/ExceptionDefines.h}} upcast the exceptions when they rethrow it, which results in loss of information (but not of data) along the way. \n\nTake for example the following c++ code fragment, which mimics the way AMQ_CATCH_RETHROW is used throughout the code :\n\n{code:title=Exception handling|borderStyle=solid}\n#include <iostream>\n#include <typeinfo>\n#include <activemq/exceptions/ExceptionDefines.h>\n#include <activemq/exceptions/BrokerException.h>\n\nint main()\n{\n    try\n    {\n        try\n        {\n            try\n            {\n                throw activemq::exceptions::BrokerException(\n                        __FILE__, __LINE__, \"Testing\");\n            }\n            AMQ_CATCH_RETHROW(activemq::exceptions::BrokerException)\n        }\n        AMQ_CATCH_RETHROW(activemq::exceptions::ActiveMQException)\n    }\n    catch (decaf::lang::Throwable &e)\n    {\n        std::cout.flags(std::ios_base::boolalpha);\n\n        std::cout << \"Broker exception : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::BrokerException).name()) << \"\\n\";\n\n        std::cout << \"ActiveMQException : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::ActiveMQException).name()) << \"\\n\";\n        \n        decaf::lang::Throwable *convertedException =\n            dynamic_cast<activemq::exceptions::BrokerException *>(&e);\n\n        std::cout << \"Conversion failed : \" << (convertedException == NULL)\n                  << \"\\n\";\n    }\n    return 0;\n}\n{code} \n\nwhich returns :\n\n{code:xml} \nBroker exception : false\nActiveMQException : true\nConversion failed : true\n{code} \n\nThe solution is to replace '{{throw e;}}' by '{{throw;}}' in the definitions of AMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: AMQ_CATCH_RETHROW upcasts the re-thrown exception\n\nDescription:\nAMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW as defined in {{activemq/exceptions/ExceptionDefines.h}} and {{decaf/lang/exceptions/ExceptionDefines.h}} upcast the exceptions when they rethrow it, which results in loss of information (but not of data) along the way. \n\nTake for example the following c++ code fragment, which mimics the way AMQ_CATCH_RETHROW is used throughout the code :\n\n{code:title=Exception handling|borderStyle=solid}\n#include <iostream>\n#include <typeinfo>\n#include <activemq/exceptions/ExceptionDefines.h>\n#include <activemq/exceptions/BrokerException.h>\n\nint main()\n{\n    try\n    {\n        try\n        {\n            try\n            {\n                throw activemq::exceptions::BrokerException(\n                        __FILE__, __LINE__, \"Testing\");\n            }\n            AMQ_CATCH_RETHROW(activemq::exceptions::BrokerException)\n        }\n        AMQ_CATCH_RETHROW(activemq::exceptions::ActiveMQException)\n    }\n    catch (decaf::lang::Throwable &e)\n    {\n        std::cout.flags(std::ios_base::boolalpha);\n\n        std::cout << \"Broker exception : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::BrokerException).name()) << \"\\n\";\n\n        std::cout << \"ActiveMQException : \" << (typeid(e).name() == \n                typeid(activemq::exceptions::ActiveMQException).name()) << \"\\n\";\n        \n        decaf::lang::Throwable *convertedException =\n            dynamic_cast<activemq::exceptions::BrokerException *>(&e);\n\n        std::cout << \"Conversion failed : \" << (convertedException == NULL)\n                  << \"\\n\";\n    }\n    return 0;\n}\n{code} \n\nwhich returns :\n\n{code:xml} \nBroker exception : false\nActiveMQException : true\nConversion failed : true\n{code} \n\nThe solution is to replace '{{throw e;}}' by '{{throw;}}' in the definitions of AMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW.\n\n\n\nComments:\n", "classification": "Classify the issue 'AMQ_CATCH_RETHROW upcasts the re-thrown exception' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-373?\nA: AMQ_CATCH_RETHROW and DECAF_CATCH_RETHROW as defined in {{activemq/exceptions/ExceptionDefines.h}} and {{decaf/lang/exceptions/ExceptionDefines.h}} upcast the exceptions when they rethrow it, which results in loss of information (but not of data) along the way. \n\nTake for example the following c++ code fragment, which mimics the way AMQ_CATCH_RETHROW is used throughout the code :\n\n{code:title=Exce"}}
{"issue_key": "AMQCPP-372", "project": "AMQCPP", "title": "if compression is enabled for producer but disabled for consumer,  the consumer is memory leaking", "status": "Closed", "reporter": "é±æ¿", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-05-07T01:33:34.000+0000", "updated": "2011-07-02T23:55:16.000+0000", "description": "If compression is enabled for producer but disabled for consumer,  the consumer will be memory leaking. If enable compression for consumer the leaking disappears.", "comments": [], "text": "if compression is enabled for producer but disabled for consumer,  the consumer is memory leaking\n\nDescription:\nIf compression is enabled for producer but disabled for consumer,  the consumer will be memory leaking. If enable compression for consumer the leaking disappears.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: if compression is enabled for producer but disabled for consumer,  the consumer is memory leaking\n\nDescription:\nIf compression is enabled for producer but disabled for consumer,  the consumer will be memory leaking. If enable compression for consumer the leaking disappears.\n\nComments:\n", "classification": "Classify the issue 'if compression is enabled for producer but disabled for consumer,  the consumer is memory leaking' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-372?\nA: If compression is enabled for producer but disabled for consumer,  the consumer will be memory leaking. If enable compression for consumer the leaking disappears."}}
{"issue_key": "AMQCPP-371", "project": "AMQCPP", "title": "bytesmessages's size  doubled If Message body compression enabled", "status": "Resolved", "reporter": "é±æ¿", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-05-05T03:34:45.000+0000", "updated": "2011-11-07T22:13:29.000+0000", "description": "If the URI option connection.useCompression=true, an ActiveMQBytesMessage's size will always become doubled. I changed the ActiveMQByteMessage.cpp as follow, the problem seems been solved.\n\n{code}\n\nclass ByteCounterOutputStream : public FilterOutputStream {\nprivate:\n\nint* length;\n\nprivate:\n\nByteCounterOutputStream( const ByteCounterOutputStream& );\nByteCounterOutputStream operator= ( const ByteCounterOutputStream& );\n\npublic:\n\nByteCounterOutputStream( int* length, OutputStream* stream, bool own = false )\n: FilterOutputStream( stream, own ), length( length ) {\n}\n\nvirtual ~ByteCounterOutputStream() {}\n\nprotected:\n\nvirtual void doWriteByte( unsigned char value ) {\n(*length)++;\nFilterOutputStream::doWriteByte( value );\n}\n\nvirtual void doWriteArray( const unsigned char* buffer, int size ) {\n\n//(*length) += size; removed because of length has been double sized\nFilterOutputStream::doWriteArray( buffer, size );\n}\n\nvirtual void doWriteArrayBounded( const unsigned char* buffer, int size, int offset, int length ) {\n\n//(*this->length) += length; removed because of length has been double sized\nFilterOutputStream::doWriteArrayBounded( buffer, size, offset, length );\n}\n\n};\n\n{code}", "comments": [], "text": "bytesmessages's size  doubled If Message body compression enabled\n\nDescription:\nIf the URI option connection.useCompression=true, an ActiveMQBytesMessage's size will always become doubled. I changed the ActiveMQByteMessage.cpp as follow, the problem seems been solved.\n\n{code}\n\nclass ByteCounterOutputStream : public FilterOutputStream {\nprivate:\n\nint* length;\n\nprivate:\n\nByteCounterOutputStream( const ByteCounterOutputStream& );\nByteCounterOutputStream operator= ( const ByteCounterOutputStream& );\n\npublic:\n\nByteCounterOutputStream( int* length, OutputStream* stream, bool own = false )\n: FilterOutputStream( stream, own ), length( length ) {\n}\n\nvirtual ~ByteCounterOutputStream() {}\n\nprotected:\n\nvirtual void doWriteByte( unsigned char value ) {\n(*length)++;\nFilterOutputStream::doWriteByte( value );\n}\n\nvirtual void doWriteArray( const unsigned char* buffer, int size ) {\n\n//(*length) += size; removed because of length has been double sized\nFilterOutputStream::doWriteArray( buffer, size );\n}\n\nvirtual void doWriteArrayBounded( const unsigned char* buffer, int size, int offset, int length ) {\n\n//(*this->length) += length; removed because of length has been double sized\nFilterOutputStream::doWriteArrayBounded( buffer, size, offset, length );\n}\n\n};\n\n{code}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: bytesmessages's size  doubled If Message body compression enabled\n\nDescription:\nIf the URI option connection.useCompression=true, an ActiveMQBytesMessage's size will always become doubled. I changed the ActiveMQByteMessage.cpp as follow, the problem seems been solved.\n\n{code}\n\nclass ByteCounterOutputStream : public FilterOutputStream {\nprivate:\n\nint* length;\n\nprivate:\n\nByteCounterOutputStream( const ByteCounterOutputStream& );\nByteCounterOutputStream operator= ( const ByteCounterOutputStream& );\n\npublic:\n\nByteCounterOutputStream( int* length, OutputStream* stream, bool own = false )\n: FilterOutputStream( stream, own ), length( length ) {\n}\n\nvirtual ~ByteCounterOutputStream() {}\n\nprotected:\n\nvirtual void doWriteByte( unsigned char value ) {\n(*length)++;\nFilterOutputStream::doWriteByte( value );\n}\n\nvirtual void doWriteArray( const unsigned char* buffer, int size ) {\n\n//(*length) += size; removed because of length has been double sized\nFilterOutputStream::doWriteArray( buffer, size );\n}\n\nvirtual void doWriteArrayBounded( const unsigned char* buffer, int size, int offset, int length ) {\n\n//(*this->length) += length; removed because of length has been double sized\nFilterOutputStream::doWriteArrayBounded( buffer, size, offset, length );\n}\n\n};\n\n{code}\n\nComments:\n", "classification": "Classify the issue 'bytesmessages's size  doubled If Message body compression enabled' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-371?\nA: If the URI option connection.useCompression=true, an ActiveMQBytesMessage's size will always become doubled. I changed the ActiveMQByteMessage.cpp as follow, the problem seems been solved.\n\n{code}\n\nclass ByteCounterOutputStream : public FilterOutputStream {\nprivate:\n\nint* length;\n\nprivate:\n\nByteCounterOutputStream( const ByteCounterOutputStream& );\nByteCounterOutputStream operator= ( const ByteCou"}}
{"issue_key": "AMQCPP-370", "project": "AMQCPP", "title": "pkg-config does not properly indicate static dependencies", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-05-02T17:22:35.000+0000", "updated": "2011-11-07T22:15:15.000+0000", "description": "The output from pkg-config does not properly indicate the full dependency requirements for static linking.  For example, if configured --with-openssl=... then the pkg-config --static output should reflect this.\n\nHere's an example from libcurl demonstrating this:\ncurl-7.21.6 $ ./configure\ncurl-7.21.6 $ cp libcurl.pc libcurl-plain.pc\ncurl-7.21.6 $ ./configure --with-ssl\ncurl-7.21.6 $ diff libcurl-plain.pc libcurl.pc\n38c38\n< Libs.private: -lrt \n---\n> Libs.private: -lssl -lcrypto -lrt -lssl -lcrypto -ldl \ncurl-7.21.6 $ pkg-config --libs libcurl\n-lcurl\ncurl-7.21.6 $ pkg-config --libs --static libcurl\n-lcurl -lssh2 -lssl -lcrypto -lrt -lz\ncurl-7.21.6 $ \n\nThis can be (crudely) fixed by adding the following to activemq-cpp.pc.in:\n\nLibs.private = @AMQ_LIBS@\n\n[A cleaner solution would require updates of configure.ac for a more precise specification.]", "comments": [], "text": "pkg-config does not properly indicate static dependencies\n\nDescription:\nThe output from pkg-config does not properly indicate the full dependency requirements for static linking.  For example, if configured --with-openssl=... then the pkg-config --static output should reflect this.\n\nHere's an example from libcurl demonstrating this:\ncurl-7.21.6 $ ./configure\ncurl-7.21.6 $ cp libcurl.pc libcurl-plain.pc\ncurl-7.21.6 $ ./configure --with-ssl\ncurl-7.21.6 $ diff libcurl-plain.pc libcurl.pc\n38c38\n< Libs.private: -lrt \n---\n> Libs.private: -lssl -lcrypto -lrt -lssl -lcrypto -ldl \ncurl-7.21.6 $ pkg-config --libs libcurl\n-lcurl\ncurl-7.21.6 $ pkg-config --libs --static libcurl\n-lcurl -lssh2 -lssl -lcrypto -lrt -lz\ncurl-7.21.6 $ \n\nThis can be (crudely) fixed by adding the following to activemq-cpp.pc.in:\n\nLibs.private = @AMQ_LIBS@\n\n[A cleaner solution would require updates of configure.ac for a more precise specification.]\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: pkg-config does not properly indicate static dependencies\n\nDescription:\nThe output from pkg-config does not properly indicate the full dependency requirements for static linking.  For example, if configured --with-openssl=... then the pkg-config --static output should reflect this.\n\nHere's an example from libcurl demonstrating this:\ncurl-7.21.6 $ ./configure\ncurl-7.21.6 $ cp libcurl.pc libcurl-plain.pc\ncurl-7.21.6 $ ./configure --with-ssl\ncurl-7.21.6 $ diff libcurl-plain.pc libcurl.pc\n38c38\n< Libs.private: -lrt \n---\n> Libs.private: -lssl -lcrypto -lrt -lssl -lcrypto -ldl \ncurl-7.21.6 $ pkg-config --libs libcurl\n-lcurl\ncurl-7.21.6 $ pkg-config --libs --static libcurl\n-lcurl -lssh2 -lssl -lcrypto -lrt -lz\ncurl-7.21.6 $ \n\nThis can be (crudely) fixed by adding the following to activemq-cpp.pc.in:\n\nLibs.private = @AMQ_LIBS@\n\n[A cleaner solution would require updates of configure.ac for a more precise specification.]\n\n\nComments:\n", "classification": "Classify the issue 'pkg-config does not properly indicate static dependencies' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-370?\nA: The output from pkg-config does not properly indicate the full dependency requirements for static linking.  For example, if configured --with-openssl=... then the pkg-config --static output should reflect this.\n\nHere's an example from libcurl demonstrating this:\ncurl-7.21.6 $ ./configure\ncurl-7.21.6 $ cp libcurl.pc libcurl-plain.pc\ncurl-7.21.6 $ ./configure --with-ssl\ncurl-7.21.6 $ diff libcurl-pl"}}
{"issue_key": "AMQCPP-369", "project": "AMQCPP", "title": "dynamic library segfaults on load under Mac OS/X", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-05-02T14:51:52.000+0000", "updated": "2011-11-28T02:24:07.000+0000", "description": "On Mac the library segfaults during load.", "comments": [], "text": "dynamic library segfaults on load under Mac OS/X\n\nDescription:\nOn Mac the library segfaults during load.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: dynamic library segfaults on load under Mac OS/X\n\nDescription:\nOn Mac the library segfaults during load.\n\nComments:\n", "classification": "Classify the issue 'dynamic library segfaults on load under Mac OS/X' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-369?\nA: On Mac the library segfaults during load."}}
{"issue_key": "AMQCPP-368", "project": "AMQCPP", "title": "Core dump in exception message formatting", "status": "Resolved", "reporter": "Carl Nygard", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-27T15:58:54.000+0000", "updated": "2011-04-27T18:20:36.000+0000", "description": "SIGSEGV while trying to format output when negotiating openwire format.  Problem seemed to be triggered by issues in activemq when message store was full.  Under normal conditions the client works fine.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000032952797c0 in strlen () from /lib64/libc.so.6\n(gdb) where\n#0  0x00000032952797c0 in strlen () from /lib64/libc.so.6\n#1  0x0000003295246b69 in vfprintf () from /lib64/libc.so.6\n#2  0x000000329526988a in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaec10bef in activemq::exceptions::ActiveMQException::buildMessage\n    (this=<value optimized out>, \n    format=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>)\n    at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaec236a8 in activemq::transport::CommandIOException::CommandIOException (this=0x6f5b10, \n    file=0x2aaaaed419e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", \n    lineNumber=146, \n    msg=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\") at activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaec72612 in activemq::transport::filters::ResponseCorrelator::request (this=<value optimized out>, command=0x94db38)\n    at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaec48c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x921380, command=0x94db38)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaec4fe9f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=<value optimized out>, command=0x2aaaaed41a40)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaec51581 in activemq::connector::openwire::OpenWireConnector::send (this=0x6fd560, message=<value optimized out>, \n    producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaebe970c in activemq::core::ActiveMQSession::send (\n    this=<value optimized out>, message=0x94db30, producer=0x6a8600)\n    at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaebf5130 in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, destination=<value optimized out>, message=0x94db30, \n    deliveryMode=-1754409308, priority=4, timeToLive=0)\n    at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaebf4c4a in activemq::core::ActiveMQProducer::send (\n    this=0x101010101010101, destination=0x2aaaaed41a40, message=0x7fffffffb0b8)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaebf4f6b in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, message=0x94db30) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000038b6c04832 in ActiveMQ::Client::Send (this=0x6d84d0, msg=...)\n    at client.cpp:50\n#14 0x00002aaab0692b9d in CAmqforwarderMsgHandler::OnMessage (this=0xc01e70, \n    vFields=..., pDB=<value optimized out>, oLogHandler=..., \n    oEventHandler=<value optimized out>) at AmqforwarderMsgHandler.cpp:203\n#15 0x00002aaab0692dda in CAmqforwarderMsgHandler::OnReceived (this=0xc01e70, \n    pMHInfo=0x7fffffffba00, pMHRet=0x7fffffffba40, oLogHandler=..., \n    oEventHandler=...) at AmqforwarderMsgHandler.cpp:135\n#16 0x00002aaaab8f87ea in CMsgDef::OnReceived(zMSGHANDLER_PARAMS*, zMSGHANDLER_RETURN*, CSOObjectPtr<CLogHandler>, CSOObjectPtr<CEventHandler>) ()\n   from /usr/lib64/libcommcore-msgdef.so.2\n#17 0x000000000043a28d in CInterface::OnReceived (this=0xaa3ac0, \n---Type <return> to continue, or q <return> to quit---q\npoMsgDef=0xbebfQuit\n(gdb) quit", "comments": [], "text": "Core dump in exception message formatting\n\nDescription:\nSIGSEGV while trying to format output when negotiating openwire format.  Problem seemed to be triggered by issues in activemq when message store was full.  Under normal conditions the client works fine.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000032952797c0 in strlen () from /lib64/libc.so.6\n(gdb) where\n#0  0x00000032952797c0 in strlen () from /lib64/libc.so.6\n#1  0x0000003295246b69 in vfprintf () from /lib64/libc.so.6\n#2  0x000000329526988a in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaec10bef in activemq::exceptions::ActiveMQException::buildMessage\n    (this=<value optimized out>, \n    format=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>)\n    at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaec236a8 in activemq::transport::CommandIOException::CommandIOException (this=0x6f5b10, \n    file=0x2aaaaed419e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", \n    lineNumber=146, \n    msg=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\") at activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaec72612 in activemq::transport::filters::ResponseCorrelator::request (this=<value optimized out>, command=0x94db38)\n    at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaec48c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x921380, command=0x94db38)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaec4fe9f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=<value optimized out>, command=0x2aaaaed41a40)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaec51581 in activemq::connector::openwire::OpenWireConnector::send (this=0x6fd560, message=<value optimized out>, \n    producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaebe970c in activemq::core::ActiveMQSession::send (\n    this=<value optimized out>, message=0x94db30, producer=0x6a8600)\n    at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaebf5130 in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, destination=<value optimized out>, message=0x94db30, \n    deliveryMode=-1754409308, priority=4, timeToLive=0)\n    at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaebf4c4a in activemq::core::ActiveMQProducer::send (\n    this=0x101010101010101, destination=0x2aaaaed41a40, message=0x7fffffffb0b8)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaebf4f6b in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, message=0x94db30) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000038b6c04832 in ActiveMQ::Client::Send (this=0x6d84d0, msg=...)\n    at client.cpp:50\n#14 0x00002aaab0692b9d in CAmqforwarderMsgHandler::OnMessage (this=0xc01e70, \n    vFields=..., pDB=<value optimized out>, oLogHandler=..., \n    oEventHandler=<value optimized out>) at AmqforwarderMsgHandler.cpp:203\n#15 0x00002aaab0692dda in CAmqforwarderMsgHandler::OnReceived (this=0xc01e70, \n    pMHInfo=0x7fffffffba00, pMHRet=0x7fffffffba40, oLogHandler=..., \n    oEventHandler=...) at AmqforwarderMsgHandler.cpp:135\n#16 0x00002aaaab8f87ea in CMsgDef::OnReceived(zMSGHANDLER_PARAMS*, zMSGHANDLER_RETURN*, CSOObjectPtr<CLogHandler>, CSOObjectPtr<CEventHandler>) ()\n   from /usr/lib64/libcommcore-msgdef.so.2\n#17 0x000000000043a28d in CInterface::OnReceived (this=0xaa3ac0, \n---Type <return> to continue, or q <return> to quit---q\npoMsgDef=0xbebfQuit\n(gdb) quit\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Core dump in exception message formatting\n\nDescription:\nSIGSEGV while trying to format output when negotiating openwire format.  Problem seemed to be triggered by issues in activemq when message store was full.  Under normal conditions the client works fine.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000032952797c0 in strlen () from /lib64/libc.so.6\n(gdb) where\n#0  0x00000032952797c0 in strlen () from /lib64/libc.so.6\n#1  0x0000003295246b69 in vfprintf () from /lib64/libc.so.6\n#2  0x000000329526988a in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaec10bef in activemq::exceptions::ActiveMQException::buildMessage\n    (this=<value optimized out>, \n    format=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\", vargs=<value optimized out>)\n    at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaec236a8 in activemq::transport::CommandIOException::CommandIOException (this=0x6f5b10, \n    file=0x2aaaaed419e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", \n    lineNumber=146, \n    msg=0x2aaaaed41a18 \"No valid response received for command: %s, check broker.\") at activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaec72612 in activemq::transport::filters::ResponseCorrelator::request (this=<value optimized out>, command=0x94db38)\n    at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaec48c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x921380, command=0x94db38)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaec4fe9f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=<value optimized out>, command=0x2aaaaed41a40)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaec51581 in activemq::connector::openwire::OpenWireConnector::send (this=0x6fd560, message=<value optimized out>, \n    producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaebe970c in activemq::core::ActiveMQSession::send (\n    this=<value optimized out>, message=0x94db30, producer=0x6a8600)\n    at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaebf5130 in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, destination=<value optimized out>, message=0x94db30, \n    deliveryMode=-1754409308, priority=4, timeToLive=0)\n    at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaebf4c4a in activemq::core::ActiveMQProducer::send (\n    this=0x101010101010101, destination=0x2aaaaed41a40, message=0x7fffffffb0b8)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaebf4f6b in activemq::core::ActiveMQProducer::send (\n    this=0x6a8600, message=0x94db30) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000038b6c04832 in ActiveMQ::Client::Send (this=0x6d84d0, msg=...)\n    at client.cpp:50\n#14 0x00002aaab0692b9d in CAmqforwarderMsgHandler::OnMessage (this=0xc01e70, \n    vFields=..., pDB=<value optimized out>, oLogHandler=..., \n    oEventHandler=<value optimized out>) at AmqforwarderMsgHandler.cpp:203\n#15 0x00002aaab0692dda in CAmqforwarderMsgHandler::OnReceived (this=0xc01e70, \n    pMHInfo=0x7fffffffba00, pMHRet=0x7fffffffba40, oLogHandler=..., \n    oEventHandler=...) at AmqforwarderMsgHandler.cpp:135\n#16 0x00002aaaab8f87ea in CMsgDef::OnReceived(zMSGHANDLER_PARAMS*, zMSGHANDLER_RETURN*, CSOObjectPtr<CLogHandler>, CSOObjectPtr<CEventHandler>) ()\n   from /usr/lib64/libcommcore-msgdef.so.2\n#17 0x000000000043a28d in CInterface::OnReceived (this=0xaa3ac0, \n---Type <return> to continue, or q <return> to quit---q\npoMsgDef=0xbebfQuit\n(gdb) quit\n\n\nComments:\n", "classification": "Classify the issue 'Core dump in exception message formatting' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-368?\nA: SIGSEGV while trying to format output when negotiating openwire format.  Problem seemed to be triggered by issues in activemq when message store was full.  Under normal conditions the client works fine.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000032952797c0 in strlen () from /lib64/libc.so.6\n(gdb) where\n#0  0x00000032952797c0 in strlen () from /lib64/libc.so.6\n#1  0x0000003295246"}}
{"issue_key": "AMQCPP-367", "project": "AMQCPP", "title": "failover: receiving duplicate messages after a broker restart", "status": "Resolved", "reporter": "Chris Hoffmann", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-26T16:01:49.000+0000", "updated": "2013-04-03T22:43:44.000+0000", "description": "When testing AMQCPP-364/AMQCPP-363, we noticed that on broker shutdown, a listener receives a message twice through onMessage callbacks. \n\nTestcase for a 5.3 broker\n1) In the onMessage before acknowledging the message, shutdown the broker. \n2) Then acknowledge the message while broker is still off. \n3) Bring the broker back up and you see the message delivered again to the onMessage () callback.\n\nWith a 5.5 broker, the problem also happens when ack'ing the message when the broker is back alive. When ack'ing the firs message, you see an error messag in the broker log:\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:HOSTNAME-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\ndestination = queue://TESTQUEUE, transactionId = null, messageCount = 1, poisonCause = null}\n\nA java test program (e.g. the ones in the activeMQ examples directory) work fine: no message duplicates there. When the message gets redelivered to a different client, the second ack'ing results in an exception raised to the java client.\n\nKind regards,\nChris", "comments": [], "text": "failover: receiving duplicate messages after a broker restart\n\nDescription:\nWhen testing AMQCPP-364/AMQCPP-363, we noticed that on broker shutdown, a listener receives a message twice through onMessage callbacks. \n\nTestcase for a 5.3 broker\n1) In the onMessage before acknowledging the message, shutdown the broker. \n2) Then acknowledge the message while broker is still off. \n3) Bring the broker back up and you see the message delivered again to the onMessage () callback.\n\nWith a 5.5 broker, the problem also happens when ack'ing the message when the broker is back alive. When ack'ing the firs message, you see an error messag in the broker log:\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:HOSTNAME-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\ndestination = queue://TESTQUEUE, transactionId = null, messageCount = 1, poisonCause = null}\n\nA java test program (e.g. the ones in the activeMQ examples directory) work fine: no message duplicates there. When the message gets redelivered to a different client, the second ack'ing results in an exception raised to the java client.\n\nKind regards,\nChris\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: failover: receiving duplicate messages after a broker restart\n\nDescription:\nWhen testing AMQCPP-364/AMQCPP-363, we noticed that on broker shutdown, a listener receives a message twice through onMessage callbacks. \n\nTestcase for a 5.3 broker\n1) In the onMessage before acknowledging the message, shutdown the broker. \n2) Then acknowledge the message while broker is still off. \n3) Bring the broker back up and you see the message delivered again to the onMessage () callback.\n\nWith a 5.5 broker, the problem also happens when ack'ing the message when the broker is back alive. When ack'ing the firs message, you see an error messag in the broker log:\n WARN | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. \nIgnored ack: MessageAck {commandId = 22, responseRequired = false, ackType = 2, consumerId = ID:HOSTNAME-44923-1303316424844-0:0:0:0,\nfirstMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\nlastMessageId = ID:HOSTNAME-58084-1303317597544-0:0:0:0:0,\ndestination = queue://TESTQUEUE, transactionId = null, messageCount = 1, poisonCause = null}\n\nA java test program (e.g. the ones in the activeMQ examples directory) work fine: no message duplicates there. When the message gets redelivered to a different client, the second ack'ing results in an exception raised to the java client.\n\nKind regards,\nChris\n\nComments:\n", "classification": "Classify the issue 'failover: receiving duplicate messages after a broker restart' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-367?\nA: When testing AMQCPP-364/AMQCPP-363, we noticed that on broker shutdown, a listener receives a message twice through onMessage callbacks. \n\nTestcase for a 5.3 broker\n1) In the onMessage before acknowledging the message, shutdown the broker. \n2) Then acknowledge the message while broker is still off. \n3) Bring the broker back up and you see the message delivered again to the onMessage () callback.\n\n"}}
{"issue_key": "AMQCPP-366", "project": "AMQCPP", "title": "createConnection() fails if given an ip address", "status": "Resolved", "reporter": "Eddie Fast", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-22T21:59:52.000+0000", "updated": "2011-04-23T15:49:10.000+0000", "description": "If I pass an ip address to createConnection(), it fails with this exception message:\n\nInput: 172.16.1.1:61616, Index 0 resulted in this error: Schema must start with a Letter.The program '[3144] testd.exe: Native' has exited with code -1 (0xffffffff).\n\nMy relevant code snippet looks like:\n\n{noformat}\n   string brokerURI = \"tcp://172.16.1.1:61616\";\n\n   activemq::core::ActiveMQConnectionFactory * connectionFactory = NULL;\n\n   try\n   {\n      // Create a ConnectionFactory\n      connectionFactory = new activemq::core::ActiveMQConnectionFactory( brokerURI );\n\n      // Create a Connection\n      pimpl->m_connection = connectionFactory->createConnection();  // exception here\n      pimpl->m_connection->start();\n\n      ...\n   }\n{noformat}", "comments": [], "text": "createConnection() fails if given an ip address\n\nDescription:\nIf I pass an ip address to createConnection(), it fails with this exception message:\n\nInput: 172.16.1.1:61616, Index 0 resulted in this error: Schema must start with a Letter.The program '[3144] testd.exe: Native' has exited with code -1 (0xffffffff).\n\nMy relevant code snippet looks like:\n\n{noformat}\n   string brokerURI = \"tcp://172.16.1.1:61616\";\n\n   activemq::core::ActiveMQConnectionFactory * connectionFactory = NULL;\n\n   try\n   {\n      // Create a ConnectionFactory\n      connectionFactory = new activemq::core::ActiveMQConnectionFactory( brokerURI );\n\n      // Create a Connection\n      pimpl->m_connection = connectionFactory->createConnection();  // exception here\n      pimpl->m_connection->start();\n\n      ...\n   }\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: createConnection() fails if given an ip address\n\nDescription:\nIf I pass an ip address to createConnection(), it fails with this exception message:\n\nInput: 172.16.1.1:61616, Index 0 resulted in this error: Schema must start with a Letter.The program '[3144] testd.exe: Native' has exited with code -1 (0xffffffff).\n\nMy relevant code snippet looks like:\n\n{noformat}\n   string brokerURI = \"tcp://172.16.1.1:61616\";\n\n   activemq::core::ActiveMQConnectionFactory * connectionFactory = NULL;\n\n   try\n   {\n      // Create a ConnectionFactory\n      connectionFactory = new activemq::core::ActiveMQConnectionFactory( brokerURI );\n\n      // Create a Connection\n      pimpl->m_connection = connectionFactory->createConnection();  // exception here\n      pimpl->m_connection->start();\n\n      ...\n   }\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'createConnection() fails if given an ip address' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-366?\nA: If I pass an ip address to createConnection(), it fails with this exception message:\n\nInput: 172.16.1.1:61616, Index 0 resulted in this error: Schema must start with a Letter.The program '[3144] testd.exe: Native' has exited with code -1 (0xffffffff).\n\nMy relevant code snippet looks like:\n\n{noformat}\n   string brokerURI = \"tcp://172.16.1.1:61616\";\n\n   activemq::core::ActiveMQConnectionFactory * co"}}
{"issue_key": "AMQCPP-365", "project": "AMQCPP", "title": "3.3.0 - compiler errors in Windows", "status": "Resolved", "reporter": "Eddie Fast", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2011-04-22T21:54:33.000+0000", "updated": "2011-04-22T22:01:09.000+0000", "description": "Getting compiler errors with 3.3.0.  Didn't get these errors with 3.2.5.\n\nHere's a snippet:\n\n{noformat}\n1>OpenWireResponseBuilder.cpp\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n{noformat}\n\n\ngetting 54 errors, but most look like the above.", "comments": [], "text": "3.3.0 - compiler errors in Windows\n\nDescription:\nGetting compiler errors with 3.3.0.  Didn't get these errors with 3.2.5.\n\nHere's a snippet:\n\n{noformat}\n1>OpenWireResponseBuilder.cpp\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n{noformat}\n\n\ngetting 54 errors, but most look like the above.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: 3.3.0 - compiler errors in Windows\n\nDescription:\nGetting compiler errors with 3.3.0.  Didn't get these errors with 3.2.5.\n\nHere's a snippet:\n\n{noformat}\n1>OpenWireResponseBuilder.cpp\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::add' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractList<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq::util::PrimitiveValueNode\n1>        ]\n{noformat}\n\n\ngetting 54 errors, but most look like the above.\n\nComments:\n", "classification": "Classify the issue '3.3.0 - compiler errors in Windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-365?\nA: Getting compiler errors with 3.3.0.  Didn't get these errors with 3.2.5.\n\nHere's a snippet:\n\n{noformat}\n1>OpenWireResponseBuilder.cpp\n1>d:\\edwork\\vh\\lib\\activemq\\activemq-cpp\\src\\main\\activemq/util/PrimitiveList.h(36) : error C2487: 'decaf::util::AbstractCollection<E>::addAll' : member of dll interface class may not be declared with dll interface\n1>        with\n1>        [\n1>            E=activemq"}}
{"issue_key": "AMQCPP-364", "project": "AMQCPP", "title": "Dont perform two phase consumer recover when openwire version is not six or higher", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2011-04-21T15:10:42.000+0000", "updated": "2011-04-26T15:46:33.000+0000", "description": "When connected to a broker using openwire version 5 or less we shouldn't send a ConsumerInfo with prefetch of zero when the connection interrupt processing isn't complete because we can't later send the consumer control command to restore the prefetch.", "comments": [], "text": "Dont perform two phase consumer recover when openwire version is not six or higher\n\nDescription:\nWhen connected to a broker using openwire version 5 or less we shouldn't send a ConsumerInfo with prefetch of zero when the connection interrupt processing isn't complete because we can't later send the consumer control command to restore the prefetch.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Dont perform two phase consumer recover when openwire version is not six or higher\n\nDescription:\nWhen connected to a broker using openwire version 5 or less we shouldn't send a ConsumerInfo with prefetch of zero when the connection interrupt processing isn't complete because we can't later send the consumer control command to restore the prefetch.  \n\nComments:\n", "classification": "Classify the issue 'Dont perform two phase consumer recover when openwire version is not six or higher' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-364?\nA: When connected to a broker using openwire version 5 or less we shouldn't send a ConsumerInfo with prefetch of zero when the connection interrupt processing isn't complete because we can't later send the consumer control command to restore the prefetch.  "}}
{"issue_key": "AMQCPP-313", "project": "AMQCPP", "title": "many Exceptions at startup when using failover", "status": "Closed", "reporter": "SÃ¸ren GrÃ¸nbech", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-08-19T09:01:43.000+0000", "updated": "2010-08-24T19:36:18.000+0000", "description": "If I configure: \ntcp://myserver.com:61616 \nthen no problem \n\nbut \nfailover:(tcp://myserver.com:61616)?wireFormat.maxInactivityDuration=0&keepAlive=true \nthen I got a lot of exceptions at start. Everthing seems to work fine, but I do get 30-40 exceptions (can see them in output area in VS) \n\nFirst-chance exception at 0x758cb727 in myserver_debug.exe: Microsoft C++ exception: decaf::io::EOFException at memory location 0x0575f710.. \n\nhigh level is : FailoverTransportListener::onCommand \n\ndo you need more info ?", "comments": [], "text": "many Exceptions at startup when using failover\n\nDescription:\nIf I configure: \ntcp://myserver.com:61616 \nthen no problem \n\nbut \nfailover:(tcp://myserver.com:61616)?wireFormat.maxInactivityDuration=0&keepAlive=true \nthen I got a lot of exceptions at start. Everthing seems to work fine, but I do get 30-40 exceptions (can see them in output area in VS) \n\nFirst-chance exception at 0x758cb727 in myserver_debug.exe: Microsoft C++ exception: decaf::io::EOFException at memory location 0x0575f710.. \n\nhigh level is : FailoverTransportListener::onCommand \n\ndo you need more info ?\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: many Exceptions at startup when using failover\n\nDescription:\nIf I configure: \ntcp://myserver.com:61616 \nthen no problem \n\nbut \nfailover:(tcp://myserver.com:61616)?wireFormat.maxInactivityDuration=0&keepAlive=true \nthen I got a lot of exceptions at start. Everthing seems to work fine, but I do get 30-40 exceptions (can see them in output area in VS) \n\nFirst-chance exception at 0x758cb727 in myserver_debug.exe: Microsoft C++ exception: decaf::io::EOFException at memory location 0x0575f710.. \n\nhigh level is : FailoverTransportListener::onCommand \n\ndo you need more info ?\n\n\nComments:\n", "classification": "Classify the issue 'many Exceptions at startup when using failover' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-313?\nA: If I configure: \ntcp://myserver.com:61616 \nthen no problem \n\nbut \nfailover:(tcp://myserver.com:61616)?wireFormat.maxInactivityDuration=0&keepAlive=true \nthen I got a lot of exceptions at start. Everthing seems to work fine, but I do get 30-40 exceptions (can see them in output area in VS) \n\nFirst-chance exception at 0x758cb727 in myserver_debug.exe: Microsoft C++ exception: decaf::io::EOFException"}}
{"issue_key": "AMQCPP-312", "project": "AMQCPP", "title": "exception when bytearray is 0 length", "status": "Resolved", "reporter": "SÃ¸ren GrÃ¸nbech", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-08-18T11:07:08.000+0000", "updated": "2010-08-18T14:23:56.000+0000", "description": "If I set a bytearray to zero lenght, I get an exception:\n\nvector<unsigned char> blist; \nmap->setBytes(name,blist); \n\nBOOM (since blist is empty, but is blist is at least 1 byte, then everything is fine) \n\nsetBytes does not throw, but when its trying to send it...\n\nserver_debug.exe!std::_Debug_message(const wchar_t * message, const wchar_t * file, unsigned int line)  Line 15 C++ \nserver_debug.exe!std::vector<unsigned char,std::allocator<unsigned char> >::operator[](unsigned int _Pos)  Line 932 + 0x14 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitive(decaf::io::DataOutputStream & dataOut, const activemq::util::PrimitiveValueNode & value)  Line 289 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitiveMap(decaf::io::DataOutputStream & dataOut, const decaf::util::Map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & map)  Line 209 + 0x10 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalMap(const activemq::util::PrimitiveMap * map, decaf::io::DataOutputStream & dataOut)  Line 141 + 0xd bytes C++ \nserver_debug.exe!activemq::commands::ActiveMQMapMessage::beforeMarshal(activemq::wireformat::WireFormat * wireFormat)  Line 117 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::v5::ActiveMQMapMessageMarshaller::tightMarshal1(activemq::wireformat::openwire::OpenWireFormat * wireFormat, activemq::commands::DataStructure * dataStructure, activemq::wireformat::openwire::utils::BooleanStream * bs)  Line 81 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormat::marshal(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command, const activemq::transport::Transport * transport, decaf::io::DataOutputStream * dataOut)  Line 206 + 0x28 bytes C++ \nserver_debug.exe!activemq::transport::IOTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 131 C++ \nserver_debug.exe!activemq::transport::TransportFilter::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 121 C++ \nserver_debug.exe!activemq::transport::inactivity::InactivityMonitor::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 337 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormatNegotiator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 78 C++ \nserver_debug.exe!activemq::transport::failover::FailoverTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 266 C++ \nserver_debug.exe!activemq::transport::correlator::ResponseCorrelator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 83 C++ \nserver_debug.exe!activemq::core::ActiveMQConnection::oneway(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command)  Line 739 C++ \nserver_debug.exe!activemq::core::ActiveMQSession::send(cms::Message * message, activemq::core::ActiveMQProducer * producer, activemq::util::Usage * usage)  Line 745 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message, int deliveryMode, int priority, __int64 timeToLive)  Line 220 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message)  Line 157 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(cms::Message * message)  Line 125 C++ \nserver_debug.exe!FW_JMSQueue::Process()  Line 143 + 0x2d bytes C++ \nserver_debug.exe!FW_JMSHandler::Process()  Line 189 + 0x19 bytes C++ \nserver_debug.exe!FW_JMSHandler_Thread(void * FWJMSHANDLER)  Line 20 + 0x8 bytes C++", "comments": [], "text": "exception when bytearray is 0 length\n\nDescription:\nIf I set a bytearray to zero lenght, I get an exception:\n\nvector<unsigned char> blist; \nmap->setBytes(name,blist); \n\nBOOM (since blist is empty, but is blist is at least 1 byte, then everything is fine) \n\nsetBytes does not throw, but when its trying to send it...\n\nserver_debug.exe!std::_Debug_message(const wchar_t * message, const wchar_t * file, unsigned int line)  Line 15 C++ \nserver_debug.exe!std::vector<unsigned char,std::allocator<unsigned char> >::operator[](unsigned int _Pos)  Line 932 + 0x14 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitive(decaf::io::DataOutputStream & dataOut, const activemq::util::PrimitiveValueNode & value)  Line 289 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitiveMap(decaf::io::DataOutputStream & dataOut, const decaf::util::Map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & map)  Line 209 + 0x10 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalMap(const activemq::util::PrimitiveMap * map, decaf::io::DataOutputStream & dataOut)  Line 141 + 0xd bytes C++ \nserver_debug.exe!activemq::commands::ActiveMQMapMessage::beforeMarshal(activemq::wireformat::WireFormat * wireFormat)  Line 117 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::v5::ActiveMQMapMessageMarshaller::tightMarshal1(activemq::wireformat::openwire::OpenWireFormat * wireFormat, activemq::commands::DataStructure * dataStructure, activemq::wireformat::openwire::utils::BooleanStream * bs)  Line 81 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormat::marshal(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command, const activemq::transport::Transport * transport, decaf::io::DataOutputStream * dataOut)  Line 206 + 0x28 bytes C++ \nserver_debug.exe!activemq::transport::IOTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 131 C++ \nserver_debug.exe!activemq::transport::TransportFilter::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 121 C++ \nserver_debug.exe!activemq::transport::inactivity::InactivityMonitor::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 337 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormatNegotiator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 78 C++ \nserver_debug.exe!activemq::transport::failover::FailoverTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 266 C++ \nserver_debug.exe!activemq::transport::correlator::ResponseCorrelator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 83 C++ \nserver_debug.exe!activemq::core::ActiveMQConnection::oneway(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command)  Line 739 C++ \nserver_debug.exe!activemq::core::ActiveMQSession::send(cms::Message * message, activemq::core::ActiveMQProducer * producer, activemq::util::Usage * usage)  Line 745 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message, int deliveryMode, int priority, __int64 timeToLive)  Line 220 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message)  Line 157 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(cms::Message * message)  Line 125 C++ \nserver_debug.exe!FW_JMSQueue::Process()  Line 143 + 0x2d bytes C++ \nserver_debug.exe!FW_JMSHandler::Process()  Line 189 + 0x19 bytes C++ \nserver_debug.exe!FW_JMSHandler_Thread(void * FWJMSHANDLER)  Line 20 + 0x8 bytes C++ \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: exception when bytearray is 0 length\n\nDescription:\nIf I set a bytearray to zero lenght, I get an exception:\n\nvector<unsigned char> blist; \nmap->setBytes(name,blist); \n\nBOOM (since blist is empty, but is blist is at least 1 byte, then everything is fine) \n\nsetBytes does not throw, but when its trying to send it...\n\nserver_debug.exe!std::_Debug_message(const wchar_t * message, const wchar_t * file, unsigned int line)  Line 15 C++ \nserver_debug.exe!std::vector<unsigned char,std::allocator<unsigned char> >::operator[](unsigned int _Pos)  Line 932 + 0x14 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitive(decaf::io::DataOutputStream & dataOut, const activemq::util::PrimitiveValueNode & value)  Line 289 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalPrimitiveMap(decaf::io::DataOutputStream & dataOut, const decaf::util::Map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > & map)  Line 209 + 0x10 bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::PrimitiveTypesMarshaller::marshalMap(const activemq::util::PrimitiveMap * map, decaf::io::DataOutputStream & dataOut)  Line 141 + 0xd bytes C++ \nserver_debug.exe!activemq::commands::ActiveMQMapMessage::beforeMarshal(activemq::wireformat::WireFormat * wireFormat)  Line 117 + 0x1e bytes C++ \nserver_debug.exe!activemq::wireformat::openwire::marshal::v5::ActiveMQMapMessageMarshaller::tightMarshal1(activemq::wireformat::openwire::OpenWireFormat * wireFormat, activemq::commands::DataStructure * dataStructure, activemq::wireformat::openwire::utils::BooleanStream * bs)  Line 81 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormat::marshal(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command, const activemq::transport::Transport * transport, decaf::io::DataOutputStream * dataOut)  Line 206 + 0x28 bytes C++ \nserver_debug.exe!activemq::transport::IOTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 131 C++ \nserver_debug.exe!activemq::transport::TransportFilter::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 121 C++ \nserver_debug.exe!activemq::transport::inactivity::InactivityMonitor::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 337 C++ \nserver_debug.exe!activemq::wireformat::openwire::OpenWireFormatNegotiator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 78 C++ \nserver_debug.exe!activemq::transport::failover::FailoverTransport::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 266 C++ \nserver_debug.exe!activemq::transport::correlator::ResponseCorrelator::oneway(const decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> & command)  Line 83 C++ \nserver_debug.exe!activemq::core::ActiveMQConnection::oneway(decaf::lang::Pointer<activemq::commands::Command,decaf::util::concurrent::atomic::AtomicRefCounter> command)  Line 739 C++ \nserver_debug.exe!activemq::core::ActiveMQSession::send(cms::Message * message, activemq::core::ActiveMQProducer * producer, activemq::util::Usage * usage)  Line 745 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message, int deliveryMode, int priority, __int64 timeToLive)  Line 220 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(const cms::Destination * destination, cms::Message * message)  Line 157 C++ \nserver_debug.exe!activemq::core::ActiveMQProducer::send(cms::Message * message)  Line 125 C++ \nserver_debug.exe!FW_JMSQueue::Process()  Line 143 + 0x2d bytes C++ \nserver_debug.exe!FW_JMSHandler::Process()  Line 189 + 0x19 bytes C++ \nserver_debug.exe!FW_JMSHandler_Thread(void * FWJMSHANDLER)  Line 20 + 0x8 bytes C++ \n\n\n\nComments:\n", "classification": "Classify the issue 'exception when bytearray is 0 length' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-312?\nA: If I set a bytearray to zero lenght, I get an exception:\n\nvector<unsigned char> blist; \nmap->setBytes(name,blist); \n\nBOOM (since blist is empty, but is blist is at least 1 byte, then everything is fine) \n\nsetBytes does not throw, but when its trying to send it...\n\nserver_debug.exe!std::_Debug_message(const wchar_t * message, const wchar_t * file, unsigned int line)  Line 15 C++ \nserver_debug.exe!s"}}
{"issue_key": "AMQCPP-311", "project": "AMQCPP", "title": "The worker threads in the threadpool seem to sleep when a receiver waits for messages from the broker. ", "status": "Closed", "reporter": "Huang Hua", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2010-08-17T15:25:29.000+0000", "updated": "2010-08-17T17:50:37.000+0000", "description": "In our application, we are using a CmsTemplate (activemq::cmsutil::CmsTemplate)  to receive messages. For each received message, we first create a task then put it into the threadpool (decaf::util::concurrent::ThreadPool) for processing. We expect the worker threads are independent from the receiving functionality of the CmsTemplate. While a receiver is waiting for new messages, the worker threads should be able to process the messages that have been received already. However, that is not we observed. The worker threads seem to be put into sleep until the receiver timeouts. \n\nThe following is the log we have created. you will see that we received five messages. The last message was received and enqueued at 14:13:20 (by thread 0BB0), It was only processed at 14:13:30 (by thread 0FDC), at/after a receive timeout (on thread 0BB0) . The waiting time seems to be equal to the receive timeout which was 10 seconds. We have repeated the test by setting the receive timeout to 200ms,1s, 3s, 5s, and 10s. We observed the same behavior with each test. The configuration for the threadpool was: MaxThreads 20, BockSize 5, ReservedThreads 10. This is a critical issue for our application. Hope you will be able to look into it soon. Your help is highly appreciated!\n\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,656 0FAC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0730> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0F98> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,703 0E08> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:21     1,995,906 0FAC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,995,906 0FAC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,995,906 0FAC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,140 0730> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,156 0730> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,156 0730> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,375 0F98> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,390 0F98> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,390 0F98> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,609 0E08> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,625 0E08> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,625 0E08> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:30     2,005,703 0FDC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:30     2,005,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:31     2,005,921 0FDC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:31     2,005,921 0FDC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:31     2,005,921 0FDC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:40     2,015,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:50     2,025,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:14:00     2,035,703 0BB0> Receiver::ReceiveMessage() - receive timed out", "comments": [], "text": "The worker threads in the threadpool seem to sleep when a receiver waits for messages from the broker. \n\nDescription:\nIn our application, we are using a CmsTemplate (activemq::cmsutil::CmsTemplate)  to receive messages. For each received message, we first create a task then put it into the threadpool (decaf::util::concurrent::ThreadPool) for processing. We expect the worker threads are independent from the receiving functionality of the CmsTemplate. While a receiver is waiting for new messages, the worker threads should be able to process the messages that have been received already. However, that is not we observed. The worker threads seem to be put into sleep until the receiver timeouts. \n\nThe following is the log we have created. you will see that we received five messages. The last message was received and enqueued at 14:13:20 (by thread 0BB0), It was only processed at 14:13:30 (by thread 0FDC), at/after a receive timeout (on thread 0BB0) . The waiting time seems to be equal to the receive timeout which was 10 seconds. We have repeated the test by setting the receive timeout to 200ms,1s, 3s, 5s, and 10s. We observed the same behavior with each test. The configuration for the threadpool was: MaxThreads 20, BockSize 5, ReservedThreads 10. This is a critical issue for our application. Hope you will be able to look into it soon. Your help is highly appreciated!\n\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,656 0FAC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0730> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0F98> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,703 0E08> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:21     1,995,906 0FAC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,995,906 0FAC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,995,906 0FAC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,140 0730> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,156 0730> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,156 0730> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,375 0F98> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,390 0F98> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,390 0F98> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,609 0E08> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,625 0E08> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,625 0E08> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:30     2,005,703 0FDC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:30     2,005,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:31     2,005,921 0FDC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:31     2,005,921 0FDC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:31     2,005,921 0FDC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:40     2,015,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:50     2,025,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:14:00     2,035,703 0BB0> Receiver::ReceiveMessage() - receive timed out\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The worker threads in the threadpool seem to sleep when a receiver waits for messages from the broker. \n\nDescription:\nIn our application, we are using a CmsTemplate (activemq::cmsutil::CmsTemplate)  to receive messages. For each received message, we first create a task then put it into the threadpool (decaf::util::concurrent::ThreadPool) for processing. We expect the worker threads are independent from the receiving functionality of the CmsTemplate. While a receiver is waiting for new messages, the worker threads should be able to process the messages that have been received already. However, that is not we observed. The worker threads seem to be put into sleep until the receiver timeouts. \n\nThe following is the log we have created. you will see that we received five messages. The last message was received and enqueued at 14:13:20 (by thread 0BB0), It was only processed at 14:13:30 (by thread 0FDC), at/after a receive timeout (on thread 0BB0) . The waiting time seems to be equal to the receive timeout which was 10 seconds. We have repeated the test by setting the receive timeout to 200ms,1s, 3s, 5s, and 10s. We observed the same behavior with each test. The configuration for the threadpool was: MaxThreads 20, BockSize 5, ReservedThreads 10. This is a critical issue for our application. Hope you will be able to look into it soon. Your help is highly appreciated!\n\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,656 0FAC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,656 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0730> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,687 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,687 0F98> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:20     1,995,703 0E08> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - received a cms message.\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::ReceiveMessage() - The payload of the cms message is: <?xml version=\"1.0\" encoding=\"UTF-8\"?><itemPolicy><upc>000671115010</upc><returnAllRecords>0</returnAllRecords></itemPolicy>\nSAServer08/16 14:13:20     1,995,703 0BB0> Receiver::run() - enqueued a messaging task\nSAServer08/16 14:13:21     1,995,906 0FAC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,995,906 0FAC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,995,906 0FAC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,140 0730> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,156 0730> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,156 0730> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,375 0F98> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,390 0F98> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,390 0F98> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:21     1,996,609 0E08> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:21     1,996,625 0E08> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:21     1,996,625 0E08> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:30     2,005,703 0FDC> Receiver::ExecuteMessagingTask() - calling the message listener function for a received message\nSAServer08/16 14:13:30     2,005,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:31     2,005,921 0FDC> Enter CCmsMessageHandlerAPI::SendMessage(), clientName:SAServer, destName:Response\nSAServer08/16 14:13:31     2,005,921 0FDC> Sender::SendMessage() - sent message <itemPolicy>\n\t<upc>000671115010</upc>\n\t<returnAllRecords>0</returnAllRecords>\n\t<weightEntries>\n\t\t<weightEntry>\n\t\t\t<initialWeight>290</initialWeight>\n\t\t\t<averageWeight>260</averageWeight>\n\t\t\t<weightTally>3</weightTally>\n\t\t\t<lastDate>2145934800</lastDate>\n\t\t\t<isApproved>1</isApproved>\n\t\t\t<isPPWU>0</isPPWU>\n\t\t\t<standardDev>-1</standardDev>\n\t\t\t<weightTolerance>-999</weightTolerance>\n\t\t</weightEntry>\n\t</weightEntries>\n</itemPolicy> successfully to cms\nSAServer08/16 14:13:31     2,005,921 0FDC> Exit CCmsMessageHandlerAPI::SendMessage() - Success\nSAServer08/16 14:13:40     2,015,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:13:50     2,025,703 0BB0> Receiver::ReceiveMessage() - receive timed out\nSAServer08/16 14:14:00     2,035,703 0BB0> Receiver::ReceiveMessage() - receive timed out\n\n\n\nComments:\n", "classification": "Classify the issue 'The worker threads in the threadpool seem to sleep when a receiver waits for messages from the broker. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-311?\nA: In our application, we are using a CmsTemplate (activemq::cmsutil::CmsTemplate)  to receive messages. For each received message, we first create a task then put it into the threadpool (decaf::util::concurrent::ThreadPool) for processing. We expect the worker threads are independent from the receiving functionality of the CmsTemplate. While a receiver is waiting for new messages, the worker threads"}}
{"issue_key": "AMQCPP-310", "project": "AMQCPP", "title": "Add support for Message Priority Dispatching to CMS", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-08-13T22:52:15.000+0000", "updated": "2010-08-16T14:45:01.000+0000", "description": "Port the changes for the client to support Message dispatch with regard for set Priority added in ActiveMQ 5.4 to the C++ client.", "comments": [], "text": "Add support for Message Priority Dispatching to CMS\n\nDescription:\nPort the changes for the client to support Message dispatch with regard for set Priority added in ActiveMQ 5.4 to the C++ client.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for Message Priority Dispatching to CMS\n\nDescription:\nPort the changes for the client to support Message dispatch with regard for set Priority added in ActiveMQ 5.4 to the C++ client.\n\nComments:\n", "classification": "Classify the issue 'Add support for Message Priority Dispatching to CMS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-310?\nA: Port the changes for the client to support Message dispatch with regard for set Priority added in ActiveMQ 5.4 to the C++ client."}}
{"issue_key": "AMQCPP-309", "project": "AMQCPP", "title": "pkg-config library version mismatch", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-08-11T00:45:55.000+0000", "updated": "2010-08-18T14:44:17.000+0000", "description": "The activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.", "comments": [], "text": "pkg-config library version mismatch\n\nDescription:\nThe activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: pkg-config library version mismatch\n\nDescription:\nThe activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a result, pkg-config requests a link against a non-existent library.  This should be fixed so that the generated version and the indicated link version match.\n\nThis can be patched post-install, but it's messy.\n\nComments:\n", "classification": "Classify the issue 'pkg-config library version mismatch' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-309?\nA: The activemq-cpp.pc.in file specifies the installed library linking as \"-l@ACTIVEMQ_LIBRARY_NAME@-@ACTIVEMQ_API_VERSION@\" which results in (for example) -lactivemq-cpp-3.2.1, but the actual library files generated in src/main/.libs are:\n\n$ ls src/main/.libs/\nlibactivemq-cpp.a  libactivemq-cpp.la  libactivemq-cpp.lai  libactivemq-cpp.so  libactivemq-cpp.so.11  libactivemq-cpp.so.11.1.0\n$\n\nAs a resu"}}
{"issue_key": "AMQCPP-308", "project": "AMQCPP", "title": "Update Redelivery policy to better handle initial redelivery delay processing.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-08-06T14:26:58.000+0000", "updated": "2010-08-06T14:28:14.000+0000", "description": "Recent changes in trunk for the Java client added better handling of the Redelivery policy in regards to handling initial vs ongoing redelivery delay processing.  These changes should be ported to the CMS client.", "comments": [], "text": "Update Redelivery policy to better handle initial redelivery delay processing.\n\nDescription:\nRecent changes in trunk for the Java client added better handling of the Redelivery policy in regards to handling initial vs ongoing redelivery delay processing.  These changes should be ported to the CMS client.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update Redelivery policy to better handle initial redelivery delay processing.\n\nDescription:\nRecent changes in trunk for the Java client added better handling of the Redelivery policy in regards to handling initial vs ongoing redelivery delay processing.  These changes should be ported to the CMS client.\n\nComments:\n", "classification": "Classify the issue 'Update Redelivery policy to better handle initial redelivery delay processing.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-308?\nA: Recent changes in trunk for the Java client added better handling of the Redelivery policy in regards to handling initial vs ongoing redelivery delay processing.  These changes should be ported to the CMS client."}}
{"issue_key": "AMQCPP-307", "project": "AMQCPP", "title": "Port Update of Connection URI from AMQ to AMQCPP", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-07-26T20:43:53.000+0000", "updated": "2010-07-27T22:59:38.000+0000", "description": "Port the changes made for AMQ-2632 to allow the ConnectionControl command to update the client with new or removed broker connection URIs.", "comments": [], "text": "Port Update of Connection URI from AMQ to AMQCPP\n\nDescription:\nPort the changes made for AMQ-2632 to allow the ConnectionControl command to update the client with new or removed broker connection URIs.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Port Update of Connection URI from AMQ to AMQCPP\n\nDescription:\nPort the changes made for AMQ-2632 to allow the ConnectionControl command to update the client with new or removed broker connection URIs.\n\nComments:\n", "classification": "Classify the issue 'Port Update of Connection URI from AMQ to AMQCPP' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-307?\nA: Port the changes made for AMQ-2632 to allow the ConnectionControl command to update the client with new or removed broker connection URIs."}}
{"issue_key": "AMQCPP-306", "project": "AMQCPP", "title": "CMS 3.2.1 - Trouble reading empty strings from MapMessage fields", "status": "Closed", "reporter": "Evan Kuhn", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-07-26T17:44:53.000+0000", "updated": "2010-09-03T20:12:30.000+0000", "description": "Hi,\n\nI just upgraded from ActiveMQ CMS 3.1.3 to 3.2.1, and I'm having some trouble reading\nempty strings out of MapMessage fields after sending them through the broker. When I\ntry to do so, MapMessage::getString() throws the exception \"Unsupported Type Conversion\".\n\nTo explain, here's what I do:\n- Open a connection with my ActiveMQ broker\n- Create a MapMessage. Set two string fields, one empty, one non-empty:\n  - request->setString(\"STR_FIELD_1\", \"\");\n  - request->setString(\"STR_FIELD_2\", \"asdf\");\n- Send the message to a queue\n- Read the message from the queue\n- Read the two string fields from the response:\n  - response->getString(\"STR_FIELD_1\", \"\");\n  - response->getString(\"STR_FIELD_2\", \"asdf\");\n \nReading the non-empty string field works fine. Reading the empty one, however,\nresults in the exception \"Unsupported Type Conversion\".\n\nAny idea why this is happening? I did not experience this with CMS 3.1.3.\n\nFor reference, I'm using:\n- CMS 3.2.1 on Windows XP\n- ActiveMQ 5.3.0 and Java 1.6.0 on Red Hat Enterprise Linux Server release 5.3 (Tikanga)\n- Sending messages to a queue, using persistent messaging (via KahaDB)\n\nI'll post a small C++ program I'm using to reproduce the problem.\n\nThank you very much for your help\n-- Evan Kuhn", "comments": [], "text": "CMS 3.2.1 - Trouble reading empty strings from MapMessage fields\n\nDescription:\nHi,\n\nI just upgraded from ActiveMQ CMS 3.1.3 to 3.2.1, and I'm having some trouble reading\nempty strings out of MapMessage fields after sending them through the broker. When I\ntry to do so, MapMessage::getString() throws the exception \"Unsupported Type Conversion\".\n\nTo explain, here's what I do:\n- Open a connection with my ActiveMQ broker\n- Create a MapMessage. Set two string fields, one empty, one non-empty:\n  - request->setString(\"STR_FIELD_1\", \"\");\n  - request->setString(\"STR_FIELD_2\", \"asdf\");\n- Send the message to a queue\n- Read the message from the queue\n- Read the two string fields from the response:\n  - response->getString(\"STR_FIELD_1\", \"\");\n  - response->getString(\"STR_FIELD_2\", \"asdf\");\n \nReading the non-empty string field works fine. Reading the empty one, however,\nresults in the exception \"Unsupported Type Conversion\".\n\nAny idea why this is happening? I did not experience this with CMS 3.1.3.\n\nFor reference, I'm using:\n- CMS 3.2.1 on Windows XP\n- ActiveMQ 5.3.0 and Java 1.6.0 on Red Hat Enterprise Linux Server release 5.3 (Tikanga)\n- Sending messages to a queue, using persistent messaging (via KahaDB)\n\nI'll post a small C++ program I'm using to reproduce the problem.\n\nThank you very much for your help\n-- Evan Kuhn \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS 3.2.1 - Trouble reading empty strings from MapMessage fields\n\nDescription:\nHi,\n\nI just upgraded from ActiveMQ CMS 3.1.3 to 3.2.1, and I'm having some trouble reading\nempty strings out of MapMessage fields after sending them through the broker. When I\ntry to do so, MapMessage::getString() throws the exception \"Unsupported Type Conversion\".\n\nTo explain, here's what I do:\n- Open a connection with my ActiveMQ broker\n- Create a MapMessage. Set two string fields, one empty, one non-empty:\n  - request->setString(\"STR_FIELD_1\", \"\");\n  - request->setString(\"STR_FIELD_2\", \"asdf\");\n- Send the message to a queue\n- Read the message from the queue\n- Read the two string fields from the response:\n  - response->getString(\"STR_FIELD_1\", \"\");\n  - response->getString(\"STR_FIELD_2\", \"asdf\");\n \nReading the non-empty string field works fine. Reading the empty one, however,\nresults in the exception \"Unsupported Type Conversion\".\n\nAny idea why this is happening? I did not experience this with CMS 3.1.3.\n\nFor reference, I'm using:\n- CMS 3.2.1 on Windows XP\n- ActiveMQ 5.3.0 and Java 1.6.0 on Red Hat Enterprise Linux Server release 5.3 (Tikanga)\n- Sending messages to a queue, using persistent messaging (via KahaDB)\n\nI'll post a small C++ program I'm using to reproduce the problem.\n\nThank you very much for your help\n-- Evan Kuhn \n\nComments:\n", "classification": "Classify the issue 'CMS 3.2.1 - Trouble reading empty strings from MapMessage fields' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-306?\nA: Hi,\n\nI just upgraded from ActiveMQ CMS 3.1.3 to 3.2.1, and I'm having some trouble reading\nempty strings out of MapMessage fields after sending them through the broker. When I\ntry to do so, MapMessage::getString() throws the exception \"Unsupported Type Conversion\".\n\nTo explain, here's what I do:\n- Open a connection with my ActiveMQ broker\n- Create a MapMessage. Set two string fields, one empty, on"}}
{"issue_key": "AMQCPP-305", "project": "AMQCPP", "title": "Add option to set the level of Compressiion for Message Body Compression", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-07-21T19:50:17.000+0000", "updated": "2010-07-21T19:52:17.000+0000", "description": "Add a new option to the ActiveMQConnectionFactory and ActiveMQConnection to allow the level of compression used in the Message Body Compression to be set.  \n\nCompression is set via URI as:  tcp://127.0.0.1:61616?connection.useCompression=true&connection.compressionLevel=9\n\nThe level of compression matches that of zlib that is:\n\n-1 means use default level\n0 means no compression\n1-9 sets the level 1 being fastest, 9 being highest compression.", "comments": [], "text": "Add option to set the level of Compressiion for Message Body Compression\n\nDescription:\nAdd a new option to the ActiveMQConnectionFactory and ActiveMQConnection to allow the level of compression used in the Message Body Compression to be set.  \n\nCompression is set via URI as:  tcp://127.0.0.1:61616?connection.useCompression=true&connection.compressionLevel=9\n\nThe level of compression matches that of zlib that is:\n\n-1 means use default level\n0 means no compression\n1-9 sets the level 1 being fastest, 9 being highest compression.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add option to set the level of Compressiion for Message Body Compression\n\nDescription:\nAdd a new option to the ActiveMQConnectionFactory and ActiveMQConnection to allow the level of compression used in the Message Body Compression to be set.  \n\nCompression is set via URI as:  tcp://127.0.0.1:61616?connection.useCompression=true&connection.compressionLevel=9\n\nThe level of compression matches that of zlib that is:\n\n-1 means use default level\n0 means no compression\n1-9 sets the level 1 being fastest, 9 being highest compression.\n\nComments:\n", "classification": "Classify the issue 'Add option to set the level of Compressiion for Message Body Compression' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-305?\nA: Add a new option to the ActiveMQConnectionFactory and ActiveMQConnection to allow the level of compression used in the Message Body Compression to be set.  \n\nCompression is set via URI as:  tcp://127.0.0.1:61616?connection.useCompression=true&connection.compressionLevel=9\n\nThe level of compression matches that of zlib that is:\n\n-1 means use default level\n0 means no compression\n1-9 sets the level 1"}}
{"issue_key": "AMQCPP-304", "project": "AMQCPP", "title": "SEGFAULT on shutdown", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-07-16T19:00:04.000+0000", "updated": "2011-04-05T19:29:41.000+0000", "description": "If application does not initialize (or use) ActiveMQ-CPP before exiting, global static elements will call apr functionality without initialization of same, resulting in a segfault.\n\nSimilar issue to AMQCPP-303.  This global static element is:\n\n   activemq/commands/ActiveMQDestination.cpp:\n   ...\n   util::ActiveMQProperties options;\n\n\nTest file (mqtest.cpp):\n\n   #include <iostream>\n\n   // Normally comes from library include: explicit here facilitate problem demonstration\n   #include <activemq/commands/ActiveMQDestination.cpp>\n\n   int main(int, char**)\n   {\n     std::cout << \"Hello\" << std::endl;\n   }\n\nTo reproduce:\n\n$ gdb mqtest\n...\n(gdb) r\nStarting program: /Mount/Work/per_mbus/persephone_trunk/pjs/nexus_handlers/mbus/mqtest \n[Thread debugging using libthread_db enabled]\nHello\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n#1  0x080c0864 in apr_atomic_add32 (mem=0x80e386c, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0808630c in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x80e3868) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x08056e86 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0x80e285c)\n    at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x0808450d in ~Pointer (this=0x80e285c, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:143\n#5  0x0808151e in ~Properties (this=0x80e2854, __in_chrg=<value optimized out>) at decaf/util/Properties.cpp:133\n#6  0x0805cae1 in ~ActiveMQProperties (this=0x80e2850, __in_chrg=<value optimized out>) at activemq/util/ActiveMQProperties.cpp:31\n#7  0x08054c00 in __tcf_17 () at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/activemq/commands/ActiveMQDestination.cpp:59\n#8  0xb7b2b529 in exit () from /System/Links/Libraries/libc.so.6\n(gdb)", "comments": [], "text": "SEGFAULT on shutdown\n\nDescription:\nIf application does not initialize (or use) ActiveMQ-CPP before exiting, global static elements will call apr functionality without initialization of same, resulting in a segfault.\n\nSimilar issue to AMQCPP-303.  This global static element is:\n\n   activemq/commands/ActiveMQDestination.cpp:\n   ...\n   util::ActiveMQProperties options;\n\n\nTest file (mqtest.cpp):\n\n   #include <iostream>\n\n   // Normally comes from library include: explicit here facilitate problem demonstration\n   #include <activemq/commands/ActiveMQDestination.cpp>\n\n   int main(int, char**)\n   {\n     std::cout << \"Hello\" << std::endl;\n   }\n\nTo reproduce:\n\n$ gdb mqtest\n...\n(gdb) r\nStarting program: /Mount/Work/per_mbus/persephone_trunk/pjs/nexus_handlers/mbus/mqtest \n[Thread debugging using libthread_db enabled]\nHello\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n#1  0x080c0864 in apr_atomic_add32 (mem=0x80e386c, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0808630c in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x80e3868) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x08056e86 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0x80e285c)\n    at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x0808450d in ~Pointer (this=0x80e285c, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:143\n#5  0x0808151e in ~Properties (this=0x80e2854, __in_chrg=<value optimized out>) at decaf/util/Properties.cpp:133\n#6  0x0805cae1 in ~ActiveMQProperties (this=0x80e2850, __in_chrg=<value optimized out>) at activemq/util/ActiveMQProperties.cpp:31\n#7  0x08054c00 in __tcf_17 () at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/activemq/commands/ActiveMQDestination.cpp:59\n#8  0xb7b2b529 in exit () from /System/Links/Libraries/libc.so.6\n(gdb) \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SEGFAULT on shutdown\n\nDescription:\nIf application does not initialize (or use) ActiveMQ-CPP before exiting, global static elements will call apr functionality without initialization of same, resulting in a segfault.\n\nSimilar issue to AMQCPP-303.  This global static element is:\n\n   activemq/commands/ActiveMQDestination.cpp:\n   ...\n   util::ActiveMQProperties options;\n\n\nTest file (mqtest.cpp):\n\n   #include <iostream>\n\n   // Normally comes from library include: explicit here facilitate problem demonstration\n   #include <activemq/commands/ActiveMQDestination.cpp>\n\n   int main(int, char**)\n   {\n     std::cout << \"Hello\" << std::endl;\n   }\n\nTo reproduce:\n\n$ gdb mqtest\n...\n(gdb) r\nStarting program: /Mount/Work/per_mbus/persephone_trunk/pjs/nexus_handlers/mbus/mqtest \n[Thread debugging using libthread_db enabled]\nHello\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x080c0835 in mutex_hash (mem=0x80e386c) at atomic/unix/mutex.c:78\n#1  0x080c0864 in apr_atomic_add32 (mem=0x80e386c, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0808630c in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x80e3868) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x08056e86 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0x80e285c)\n    at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x0808450d in ~Pointer (this=0x80e285c, __in_chrg=<value optimized out>) at ./decaf/lang/Pointer.h:143\n#5  0x0808151e in ~Properties (this=0x80e2854, __in_chrg=<value optimized out>) at decaf/util/Properties.cpp:133\n#6  0x0805cae1 in ~ActiveMQProperties (this=0x80e2850, __in_chrg=<value optimized out>) at activemq/util/ActiveMQProperties.cpp:31\n#7  0x08054c00 in __tcf_17 () at /Files/Compile/Sources/activemq-cpp-library-3.2.1/src/main/activemq/commands/ActiveMQDestination.cpp:59\n#8  0xb7b2b529 in exit () from /System/Links/Libraries/libc.so.6\n(gdb) \n\n\nComments:\n", "classification": "Classify the issue 'SEGFAULT on shutdown' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-304?\nA: If application does not initialize (or use) ActiveMQ-CPP before exiting, global static elements will call apr functionality without initialization of same, resulting in a segfault.\n\nSimilar issue to AMQCPP-303.  This global static element is:\n\n   activemq/commands/ActiveMQDestination.cpp:\n   ...\n   util::ActiveMQProperties options;\n\n\nTest file (mqtest.cpp):\n\n   #include <iostream>\n\n   // Normally "}}
{"issue_key": "AMQCPP-303", "project": "AMQCPP", "title": "SEGFAULT on startup (before main)", "status": "Resolved", "reporter": "Kevin Quick", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2010-07-16T15:05:20.000+0000", "updated": "2010-09-16T23:46:42.000+0000", "description": "Application linked with activemq-cpp library crashes on startup before reaching main.\n\nThe issue is that static globals are being initialized and calling apr library functions during that initialization before apr initialization is called (via DecafRuntime()).  The DecafRuntime object has a singleton initialization pattern which appears to be invoked from Runtime::initializeRuntime(), which is invoked from ActiveMQCPP::initializeLibrary() in turn from the main routine with stdargs.\n\nTo fix this, static initializers should contrive to call at least Runtime::getRuntime() (and possibly other initializers invoked by initializeRuntime()) before internally initializing.  Alternatively, static const elements could be handled via the singleton initialization pattern as well such that they aren't initialized until needed... presumably after ActiveMQCPP::initializeLibrary() has been invoked in a deterministic manner.\n\nThe offending static initializers in this case are from decaf/net/InetAddress.cpp:\n\nconst InetAddress InetAddress::LOOPBACK( Inet4Address( \"localhost\", InetAddress::loopbackBytes, 4 ) );\nconst InetAddress InetAddress::ANY( Inet4Address( InetAddress::anyBytes, 4 ) );\n\nThe corresponding traceback showing this error:\n\n$ gdb mqtest\nGNU gdb (GDB) 7.0\n...\n(gdb) b main\nBreakpoint 1 at 0x8085286: file mqtest.cpp line 83\n(gdb) r\nStarting program: mqtest \n[Thread debugging using libthread_db enabled]\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n#1  0x08567984 in apr_atomic_add32 (mem=0x86c7a64, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0814c9a8 in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x86c7a60) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x080e3094 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0xbfffaed4) at ./decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x082af1bd in ~ArrayPointer (this=0xbfffaed4, __in_chrg=<value optimized out>) at ./decaf/lang/ArrayPointer.h:154\n#5  0x082afbd6 in decaf::lang::ArrayPointer<unsigned char, decaf::util::concurrent::atomic::AtomicRefCounter>::reset (this=0xbfffaf7c, value=0x86c8400 \"\\177\", size=4)\n    at ./decaf/lang/ArrayPointer.h:171\n#6  0x082aec27 in InetAddress (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/InetAddress.cpp:79\n#7  0x084dbf54 in Inet4Address (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/Inet4Address.cpp:34\n#8  0x082adec3 in __static_initialization_and_destruction_0 (__initialize_p=1, __priority=65535) at decaf/net/InetAddress.cpp:39\n#9  0x082ae005 in global constructors keyed to _ZN5decaf3net11InetAddress13loopbackBytesE () at decaf/net/InetAddress.cpp:191\n#10 0x0856b445 in __do_global_ctors_aux ()\n#11 0x080746e5 in _init ()\n#12 0x0856b2d7 in __libc_csu_init ()\n(gdb)", "comments": [], "text": "SEGFAULT on startup (before main)\n\nDescription:\nApplication linked with activemq-cpp library crashes on startup before reaching main.\n\nThe issue is that static globals are being initialized and calling apr library functions during that initialization before apr initialization is called (via DecafRuntime()).  The DecafRuntime object has a singleton initialization pattern which appears to be invoked from Runtime::initializeRuntime(), which is invoked from ActiveMQCPP::initializeLibrary() in turn from the main routine with stdargs.\n\nTo fix this, static initializers should contrive to call at least Runtime::getRuntime() (and possibly other initializers invoked by initializeRuntime()) before internally initializing.  Alternatively, static const elements could be handled via the singleton initialization pattern as well such that they aren't initialized until needed... presumably after ActiveMQCPP::initializeLibrary() has been invoked in a deterministic manner.\n\nThe offending static initializers in this case are from decaf/net/InetAddress.cpp:\n\nconst InetAddress InetAddress::LOOPBACK( Inet4Address( \"localhost\", InetAddress::loopbackBytes, 4 ) );\nconst InetAddress InetAddress::ANY( Inet4Address( InetAddress::anyBytes, 4 ) );\n\nThe corresponding traceback showing this error:\n\n$ gdb mqtest\nGNU gdb (GDB) 7.0\n...\n(gdb) b main\nBreakpoint 1 at 0x8085286: file mqtest.cpp line 83\n(gdb) r\nStarting program: mqtest \n[Thread debugging using libthread_db enabled]\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n#1  0x08567984 in apr_atomic_add32 (mem=0x86c7a64, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0814c9a8 in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x86c7a60) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x080e3094 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0xbfffaed4) at ./decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x082af1bd in ~ArrayPointer (this=0xbfffaed4, __in_chrg=<value optimized out>) at ./decaf/lang/ArrayPointer.h:154\n#5  0x082afbd6 in decaf::lang::ArrayPointer<unsigned char, decaf::util::concurrent::atomic::AtomicRefCounter>::reset (this=0xbfffaf7c, value=0x86c8400 \"\\177\", size=4)\n    at ./decaf/lang/ArrayPointer.h:171\n#6  0x082aec27 in InetAddress (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/InetAddress.cpp:79\n#7  0x084dbf54 in Inet4Address (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/Inet4Address.cpp:34\n#8  0x082adec3 in __static_initialization_and_destruction_0 (__initialize_p=1, __priority=65535) at decaf/net/InetAddress.cpp:39\n#9  0x082ae005 in global constructors keyed to _ZN5decaf3net11InetAddress13loopbackBytesE () at decaf/net/InetAddress.cpp:191\n#10 0x0856b445 in __do_global_ctors_aux ()\n#11 0x080746e5 in _init ()\n#12 0x0856b2d7 in __libc_csu_init ()\n(gdb) \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SEGFAULT on startup (before main)\n\nDescription:\nApplication linked with activemq-cpp library crashes on startup before reaching main.\n\nThe issue is that static globals are being initialized and calling apr library functions during that initialization before apr initialization is called (via DecafRuntime()).  The DecafRuntime object has a singleton initialization pattern which appears to be invoked from Runtime::initializeRuntime(), which is invoked from ActiveMQCPP::initializeLibrary() in turn from the main routine with stdargs.\n\nTo fix this, static initializers should contrive to call at least Runtime::getRuntime() (and possibly other initializers invoked by initializeRuntime()) before internally initializing.  Alternatively, static const elements could be handled via the singleton initialization pattern as well such that they aren't initialized until needed... presumably after ActiveMQCPP::initializeLibrary() has been invoked in a deterministic manner.\n\nThe offending static initializers in this case are from decaf/net/InetAddress.cpp:\n\nconst InetAddress InetAddress::LOOPBACK( Inet4Address( \"localhost\", InetAddress::loopbackBytes, 4 ) );\nconst InetAddress InetAddress::ANY( Inet4Address( InetAddress::anyBytes, 4 ) );\n\nThe corresponding traceback showing this error:\n\n$ gdb mqtest\nGNU gdb (GDB) 7.0\n...\n(gdb) b main\nBreakpoint 1 at 0x8085286: file mqtest.cpp line 83\n(gdb) r\nStarting program: mqtest \n[Thread debugging using libthread_db enabled]\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n78          apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\nCurrent language:  auto\nThe current source language is \"auto; currently c\".\n(gdb) bt\n#0  0x08567955 in mutex_hash (mem=0x86c7a64) at atomic/unix/mutex.c:78\n#1  0x08567984 in apr_atomic_add32 (mem=0x86c7a64, val=4294967295) at atomic/unix/mutex.c:113\n#2  0x0814c9a8 in decaf::util::concurrent::atomic::AtomicInteger::decrementAndGet (this=0x86c7a60) at decaf/util/concurrent/atomic/AtomicInteger.cpp:69\n#3  0x080e3094 in decaf::util::concurrent::atomic::AtomicRefCounter::release (this=0xbfffaed4) at ./decaf/util/concurrent/atomic/AtomicRefCounter.h:68\n#4  0x082af1bd in ~ArrayPointer (this=0xbfffaed4, __in_chrg=<value optimized out>) at ./decaf/lang/ArrayPointer.h:154\n#5  0x082afbd6 in decaf::lang::ArrayPointer<unsigned char, decaf::util::concurrent::atomic::AtomicRefCounter>::reset (this=0xbfffaf7c, value=0x86c8400 \"\\177\", size=4)\n    at ./decaf/lang/ArrayPointer.h:171\n#6  0x082aec27 in InetAddress (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/InetAddress.cpp:79\n#7  0x084dbf54 in Inet4Address (this=0xbfffaf70, hostname=..., ipAddress=0x8585c01 \"\\177\", numBytes=4) at decaf/net/Inet4Address.cpp:34\n#8  0x082adec3 in __static_initialization_and_destruction_0 (__initialize_p=1, __priority=65535) at decaf/net/InetAddress.cpp:39\n#9  0x082ae005 in global constructors keyed to _ZN5decaf3net11InetAddress13loopbackBytesE () at decaf/net/InetAddress.cpp:191\n#10 0x0856b445 in __do_global_ctors_aux ()\n#11 0x080746e5 in _init ()\n#12 0x0856b2d7 in __libc_csu_init ()\n(gdb) \n\n\nComments:\n", "classification": "Classify the issue 'SEGFAULT on startup (before main)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-303?\nA: Application linked with activemq-cpp library crashes on startup before reaching main.\n\nThe issue is that static globals are being initialized and calling apr library functions during that initialization before apr initialization is called (via DecafRuntime()).  The DecafRuntime object has a singleton initialization pattern which appears to be invoked from Runtime::initializeRuntime(), which is inv"}}
{"issue_key": "AMQCPP-302", "project": "AMQCPP", "title": "Compilation issue with older GCC versions in MessageCompressionTest.cpp", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-07-16T11:04:10.000+0000", "updated": "2010-07-16T11:06:09.000+0000", "description": "Constant value not tagged with the 'LL' marker to indicate it should be a long causes the error:\n\nnteger constant is too large for 'long' type", "comments": [], "text": "Compilation issue with older GCC versions in MessageCompressionTest.cpp\n\nDescription:\nConstant value not tagged with the 'LL' marker to indicate it should be a long causes the error:\n\nnteger constant is too large for 'long' type\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation issue with older GCC versions in MessageCompressionTest.cpp\n\nDescription:\nConstant value not tagged with the 'LL' marker to indicate it should be a long causes the error:\n\nnteger constant is too large for 'long' type\n\nComments:\n", "classification": "Classify the issue 'Compilation issue with older GCC versions in MessageCompressionTest.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-302?\nA: Constant value not tagged with the 'LL' marker to indicate it should be a long causes the error:\n\nnteger constant is too large for 'long' type"}}
{"issue_key": "AMQCPP-301", "project": "AMQCPP", "title": "Unmarshal of an empty byte array in a MapMessage segfaults on Windows ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-06-30T13:21:27.000+0000", "updated": "2010-06-30T14:16:11.000+0000", "description": "On windows the code that unmarshals byte arrays stored in a MapMessage will segfault if an empty byte array has zero size.", "comments": [], "text": "Unmarshal of an empty byte array in a MapMessage segfaults on Windows \n\nDescription:\nOn windows the code that unmarshals byte arrays stored in a MapMessage will segfault if an empty byte array has zero size.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unmarshal of an empty byte array in a MapMessage segfaults on Windows \n\nDescription:\nOn windows the code that unmarshals byte arrays stored in a MapMessage will segfault if an empty byte array has zero size.\n\nComments:\n", "classification": "Classify the issue 'Unmarshal of an empty byte array in a MapMessage segfaults on Windows ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-301?\nA: On windows the code that unmarshals byte arrays stored in a MapMessage will segfault if an empty byte array has zero size."}}
{"issue_key": "AMQCPP-300", "project": "AMQCPP", "title": "Add new method to CMS MapMessage - \"isEmpty\"", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-06-28T21:59:40.000+0000", "updated": "2010-06-28T22:00:13.000+0000", "description": "Add a new method to the CMS MapMessage interface to check if the Map in the MapMessage is empty, allows for much faster check than using the getMapNames method.", "comments": [], "text": "Add new method to CMS MapMessage - \"isEmpty\"\n\nDescription:\nAdd a new method to the CMS MapMessage interface to check if the Map in the MapMessage is empty, allows for much faster check than using the getMapNames method.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add new method to CMS MapMessage - \"isEmpty\"\n\nDescription:\nAdd a new method to the CMS MapMessage interface to check if the Map in the MapMessage is empty, allows for much faster check than using the getMapNames method.\n\n\n\nComments:\n", "classification": "Classify the issue 'Add new method to CMS MapMessage - \"isEmpty\"' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-300?\nA: Add a new method to the CMS MapMessage interface to check if the Map in the MapMessage is empty, allows for much faster check than using the getMapNames method.\n\n"}}
{"issue_key": "AMQCPP-299", "project": "AMQCPP", "title": "Link weirdness from main ActiveMQ main site", "status": "Resolved", "reporter": "Grant Birchmeier", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-06-28T19:37:29.000+0000", "updated": "2010-06-28T19:59:00.000+0000", "description": "The ActiveMQ page http://activemq.apache.org/javadocs.html links to the bad URL http://activemq.apache.org/cms/html/ (instead of http://activemq.apache.org/cms/).\n\nAll relative URLs from that bad URL are bad, so that clicking on any of those many many links just redirects you back to the page you are already on.  It's quite annoying and it was quite some time before I figured out the proper URL I needed to be at.\n\nI suggest that the redirect instead go to the proper page http://activemq.apache.org/cms/.\n\nObviously the ActiveMQ page needs to be fixed too; I created https://issues.apache.org/activemq/browse/AMQ-2805 for that.", "comments": [], "text": "Link weirdness from main ActiveMQ main site\n\nDescription:\nThe ActiveMQ page http://activemq.apache.org/javadocs.html links to the bad URL http://activemq.apache.org/cms/html/ (instead of http://activemq.apache.org/cms/).\n\nAll relative URLs from that bad URL are bad, so that clicking on any of those many many links just redirects you back to the page you are already on.  It's quite annoying and it was quite some time before I figured out the proper URL I needed to be at.\n\nI suggest that the redirect instead go to the proper page http://activemq.apache.org/cms/.\n\nObviously the ActiveMQ page needs to be fixed too; I created https://issues.apache.org/activemq/browse/AMQ-2805 for that.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Link weirdness from main ActiveMQ main site\n\nDescription:\nThe ActiveMQ page http://activemq.apache.org/javadocs.html links to the bad URL http://activemq.apache.org/cms/html/ (instead of http://activemq.apache.org/cms/).\n\nAll relative URLs from that bad URL are bad, so that clicking on any of those many many links just redirects you back to the page you are already on.  It's quite annoying and it was quite some time before I figured out the proper URL I needed to be at.\n\nI suggest that the redirect instead go to the proper page http://activemq.apache.org/cms/.\n\nObviously the ActiveMQ page needs to be fixed too; I created https://issues.apache.org/activemq/browse/AMQ-2805 for that.\n\n\nComments:\n", "classification": "Classify the issue 'Link weirdness from main ActiveMQ main site' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-299?\nA: The ActiveMQ page http://activemq.apache.org/javadocs.html links to the bad URL http://activemq.apache.org/cms/html/ (instead of http://activemq.apache.org/cms/).\n\nAll relative URLs from that bad URL are bad, so that clicking on any of those many many links just redirects you back to the page you are already on.  It's quite annoying and it was quite some time before I figured out the proper URL I "}}
{"issue_key": "AMQCPP-298", "project": "AMQCPP", "title": "Example code crashes in 3.2.0 on MacOSX", "status": "Resolved", "reporter": "Sidney Fong", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-06-28T14:18:40.000+0000", "updated": "2011-11-07T22:40:05.000+0000", "description": "This happens for all programs in src/examples. The examples in 3.1.3 runs fine without this problem.\n\n~/devel/activemq-cpp-library-3.2.0/src/examples> gdb ./.libs/chat \nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries ........... done\n\n(gdb) r\nStarting program: activemq-cpp-library-3.2.0/src/examples/.libs/chat \nReading symbols for shared libraries .++++++++++.. done\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xfffffffffffffff8\n0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n(gdb) bt\n#0  0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n#1  0x00007fff85f4c171 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string ()\n#2  0x000000010001e475 in Level [inlined] () at decaf/util/logging/Handler.cpp:31\n#3  0x000000010001e475 in Level [inlined] () at activemq-cpp-library-3.2.0/src/main/decaf/util/logging/Level.h:56\n#4  0x000000010001e475 in __static_initialization_and_destruction_0 (__initialize_p=<value temporarily unavailable, due to optimizations>, __priority=<value temporarily unavailable, due to optimizations>) at decaf/util/logging/Handler.cpp:31\n#5  0x00007fff5fc0d500 in __dyld__ZN16ImageLoaderMachO18doModInitFunctionsERKN11ImageLoader11LinkContextE ()\n#6  0x00007fff5fc0bcec in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#7  0x00007fff5fc0bc9d in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#8  0x00007fff5fc0bda6 in __dyld__ZN11ImageLoader15runInitializersERKNS_11LinkContextE ()\n#9  0x00007fff5fc0210e in __dyld__ZN4dyld24initializeMainExecutableEv ()\n#10 0x00007fff5fc06981 in __dyld__ZN4dyld5_mainEPK12macho_headermiPPKcS5_S5_ ()\n#11 0x00007fff5fc016d2 in __dyld__ZN13dyldbootstrap5startEPK12macho_headeriPPKcl ()\n#12 0x00007fff5fc01052 in __dyld__dyld_start ()", "comments": [], "text": "Example code crashes in 3.2.0 on MacOSX\n\nDescription:\nThis happens for all programs in src/examples. The examples in 3.1.3 runs fine without this problem.\n\n~/devel/activemq-cpp-library-3.2.0/src/examples> gdb ./.libs/chat \nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries ........... done\n\n(gdb) r\nStarting program: activemq-cpp-library-3.2.0/src/examples/.libs/chat \nReading symbols for shared libraries .++++++++++.. done\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xfffffffffffffff8\n0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n(gdb) bt\n#0  0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n#1  0x00007fff85f4c171 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string ()\n#2  0x000000010001e475 in Level [inlined] () at decaf/util/logging/Handler.cpp:31\n#3  0x000000010001e475 in Level [inlined] () at activemq-cpp-library-3.2.0/src/main/decaf/util/logging/Level.h:56\n#4  0x000000010001e475 in __static_initialization_and_destruction_0 (__initialize_p=<value temporarily unavailable, due to optimizations>, __priority=<value temporarily unavailable, due to optimizations>) at decaf/util/logging/Handler.cpp:31\n#5  0x00007fff5fc0d500 in __dyld__ZN16ImageLoaderMachO18doModInitFunctionsERKN11ImageLoader11LinkContextE ()\n#6  0x00007fff5fc0bcec in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#7  0x00007fff5fc0bc9d in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#8  0x00007fff5fc0bda6 in __dyld__ZN11ImageLoader15runInitializersERKNS_11LinkContextE ()\n#9  0x00007fff5fc0210e in __dyld__ZN4dyld24initializeMainExecutableEv ()\n#10 0x00007fff5fc06981 in __dyld__ZN4dyld5_mainEPK12macho_headermiPPKcS5_S5_ ()\n#11 0x00007fff5fc016d2 in __dyld__ZN13dyldbootstrap5startEPK12macho_headeriPPKcl ()\n#12 0x00007fff5fc01052 in __dyld__dyld_start ()\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Example code crashes in 3.2.0 on MacOSX\n\nDescription:\nThis happens for all programs in src/examples. The examples in 3.1.3 runs fine without this problem.\n\n~/devel/activemq-cpp-library-3.2.0/src/examples> gdb ./.libs/chat \nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries ........... done\n\n(gdb) r\nStarting program: activemq-cpp-library-3.2.0/src/examples/.libs/chat \nReading symbols for shared libraries .++++++++++.. done\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xfffffffffffffff8\n0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n(gdb) bt\n#0  0x00007fff85f4c0aa in std::string::_Rep::_M_grab ()\n#1  0x00007fff85f4c171 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string ()\n#2  0x000000010001e475 in Level [inlined] () at decaf/util/logging/Handler.cpp:31\n#3  0x000000010001e475 in Level [inlined] () at activemq-cpp-library-3.2.0/src/main/decaf/util/logging/Level.h:56\n#4  0x000000010001e475 in __static_initialization_and_destruction_0 (__initialize_p=<value temporarily unavailable, due to optimizations>, __priority=<value temporarily unavailable, due to optimizations>) at decaf/util/logging/Handler.cpp:31\n#5  0x00007fff5fc0d500 in __dyld__ZN16ImageLoaderMachO18doModInitFunctionsERKN11ImageLoader11LinkContextE ()\n#6  0x00007fff5fc0bcec in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#7  0x00007fff5fc0bc9d in __dyld__ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEj ()\n#8  0x00007fff5fc0bda6 in __dyld__ZN11ImageLoader15runInitializersERKNS_11LinkContextE ()\n#9  0x00007fff5fc0210e in __dyld__ZN4dyld24initializeMainExecutableEv ()\n#10 0x00007fff5fc06981 in __dyld__ZN4dyld5_mainEPK12macho_headermiPPKcS5_S5_ ()\n#11 0x00007fff5fc016d2 in __dyld__ZN13dyldbootstrap5startEPK12macho_headeriPPKcl ()\n#12 0x00007fff5fc01052 in __dyld__dyld_start ()\n\n\nComments:\n", "classification": "Classify the issue 'Example code crashes in 3.2.0 on MacOSX' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-298?\nA: This happens for all programs in src/examples. The examples in 3.1.3 runs fine without this problem.\n\n~/devel/activemq-cpp-library-3.2.0/src/examples> gdb ./.libs/chat \nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the"}}
{"issue_key": "AMQCPP-297", "project": "AMQCPP", "title": "Deadlock in ActiveMQSession::close", "status": "Closed", "reporter": "Harry Storbacka", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-06-22T14:53:20.000+0000", "updated": "2010-07-16T21:47:53.000+0000", "description": "There seems to be a deadlock when closing a session. This can be reproduced using the SimpleAsyncProducer example from version 3.1.2, with the following loop added to main():\n\nfor (int i=0; i<10000; i++)\n{\n    consumer.runConsumer();\n    std::cout << \"i = \" << i << std::endl;\n    consumer.close();\n} \n\nAnd the used broker URI was as follows:\n\nstd::string brokerURI =\n \t\"failover:(tcp://192.168.0.23:61616\"\n \t\"?wireFormat=openwire\";\n \t\"&transport.useAsyncSend=true\"\n\t// \"&transport.commandTracingEnabled=true\"\n \t// \"&transport.tcpTracingEnabled=true\";\n \t\"&wireFormat.tightEncodingEnabled=true\"\n       \")\";\n\nThe deadlock has usually appeared before the counter reaches 150. No messages are sent while the example runs. \n\nI'll try this again with version 3.2.1 when the windows build files are included. This example also reproduces the setMessageListener deadlock reported in another bug for version 3.1.2, except with only one message listener being set.\n\nBelow are the callstacks of the threads when it's locked. \n\n\n---------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d6718, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join()  Line 421\tC++\n \tAsyncConsumer.exe!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n>\tAsyncConsumer.exe!activemq::core::ActiveMQSession::close()  Line 126\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::cleanup()  Line 198\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::close()  Line 86\tC++\n \tAsyncConsumer.exe!main(int argc=1, char * * argv=0x01036618)  Line 280\tC++\n \tAsyncConsumer.exe!__tmainCRTStartup()  Line 586 + 0x19 bytes\tC\n \tAsyncConsumer.exe!mainCRTStartup()  Line 403\tC\n\n\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d0578)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d0578)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d0c90)  Line 331\tC\n\n---------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7932)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0103ffb0, __int64 mills=30000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=30000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x0103fd68)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x0103fd68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1810)  Line 331\tC\n \tkernel32.dll!7c80b729() \n\n--------------------------\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7056)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d1648, __int64 mills=10000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=10000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d1790)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d1790)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1dd0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n\t\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tmswsock.dll!71a5402b() \t\n \tmswsock.dll!71a557c9() \t\n \tws2_32.dll!71ab4d16() \t\n \tlibapr-1.dll!6eecad09() \t\n>\tmsvcp90d.dll!std::_Container_base_secure::_Orphan_all()  Line 226 + 0x8 bytes\tC++\n \tmsvcp90d.dll!std::_Container_base_secure::~_Container_base_secure()  Line 115\tC++\n \tAsyncConsumer.exe!std::_Container_base_aux_alloc_empty<std::allocator<unsigned char> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned char> >()  Line 627 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >()  + 0xf bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::getId()  Line 530 + 0x6 bytes\tC++\n \t498c18a2()\t\n\n--------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d3370)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d3370)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d3910)  Line 331\tC\n \tkernel32.dll!7c80b729()", "comments": [], "text": "Deadlock in ActiveMQSession::close\n\nDescription:\nThere seems to be a deadlock when closing a session. This can be reproduced using the SimpleAsyncProducer example from version 3.1.2, with the following loop added to main():\n\nfor (int i=0; i<10000; i++)\n{\n    consumer.runConsumer();\n    std::cout << \"i = \" << i << std::endl;\n    consumer.close();\n} \n\nAnd the used broker URI was as follows:\n\nstd::string brokerURI =\n \t\"failover:(tcp://192.168.0.23:61616\"\n \t\"?wireFormat=openwire\";\n \t\"&transport.useAsyncSend=true\"\n\t// \"&transport.commandTracingEnabled=true\"\n \t// \"&transport.tcpTracingEnabled=true\";\n \t\"&wireFormat.tightEncodingEnabled=true\"\n       \")\";\n\nThe deadlock has usually appeared before the counter reaches 150. No messages are sent while the example runs. \n\nI'll try this again with version 3.2.1 when the windows build files are included. This example also reproduces the setMessageListener deadlock reported in another bug for version 3.1.2, except with only one message listener being set.\n\nBelow are the callstacks of the threads when it's locked. \n\n\n---------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d6718, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join()  Line 421\tC++\n \tAsyncConsumer.exe!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n>\tAsyncConsumer.exe!activemq::core::ActiveMQSession::close()  Line 126\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::cleanup()  Line 198\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::close()  Line 86\tC++\n \tAsyncConsumer.exe!main(int argc=1, char * * argv=0x01036618)  Line 280\tC++\n \tAsyncConsumer.exe!__tmainCRTStartup()  Line 586 + 0x19 bytes\tC\n \tAsyncConsumer.exe!mainCRTStartup()  Line 403\tC\n\n\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d0578)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d0578)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d0c90)  Line 331\tC\n\n---------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7932)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0103ffb0, __int64 mills=30000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=30000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x0103fd68)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x0103fd68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1810)  Line 331\tC\n \tkernel32.dll!7c80b729() \n\n--------------------------\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7056)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d1648, __int64 mills=10000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=10000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d1790)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d1790)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1dd0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n\t\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tmswsock.dll!71a5402b() \t\n \tmswsock.dll!71a557c9() \t\n \tws2_32.dll!71ab4d16() \t\n \tlibapr-1.dll!6eecad09() \t\n>\tmsvcp90d.dll!std::_Container_base_secure::_Orphan_all()  Line 226 + 0x8 bytes\tC++\n \tmsvcp90d.dll!std::_Container_base_secure::~_Container_base_secure()  Line 115\tC++\n \tAsyncConsumer.exe!std::_Container_base_aux_alloc_empty<std::allocator<unsigned char> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned char> >()  Line 627 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >()  + 0xf bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::getId()  Line 530 + 0x6 bytes\tC++\n \t498c18a2()\t\n\n--------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d3370)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d3370)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d3910)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock in ActiveMQSession::close\n\nDescription:\nThere seems to be a deadlock when closing a session. This can be reproduced using the SimpleAsyncProducer example from version 3.1.2, with the following loop added to main():\n\nfor (int i=0; i<10000; i++)\n{\n    consumer.runConsumer();\n    std::cout << \"i = \" << i << std::endl;\n    consumer.close();\n} \n\nAnd the used broker URI was as follows:\n\nstd::string brokerURI =\n \t\"failover:(tcp://192.168.0.23:61616\"\n \t\"?wireFormat=openwire\";\n \t\"&transport.useAsyncSend=true\"\n\t// \"&transport.commandTracingEnabled=true\"\n \t// \"&transport.tcpTracingEnabled=true\";\n \t\"&wireFormat.tightEncodingEnabled=true\"\n       \")\";\n\nThe deadlock has usually appeared before the counter reaches 150. No messages are sent while the example runs. \n\nI'll try this again with version 3.2.1 when the windows build files are included. This example also reproduces the setMessageListener deadlock reported in another bug for version 3.1.2, except with only one message listener being set.\n\nBelow are the callstacks of the threads when it's locked. \n\n\n---------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d6718, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::join()  Line 421\tC++\n \tAsyncConsumer.exe!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tAsyncConsumer.exe!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n>\tAsyncConsumer.exe!activemq::core::ActiveMQSession::close()  Line 126\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::cleanup()  Line 198\tC++\n \tAsyncConsumer.exe!SimpleAsyncConsumer::close()  Line 86\tC++\n \tAsyncConsumer.exe!main(int argc=1, char * * argv=0x01036618)  Line 280\tC++\n \tAsyncConsumer.exe!__tmainCRTStartup()  Line 586 + 0x19 bytes\tC\n \tAsyncConsumer.exe!mainCRTStartup()  Line 403\tC\n\n\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d0430)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d0578)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d0578)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d0c90)  Line 331\tC\n\n---------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7932)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0103ffb0, __int64 mills=30000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=30000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=30000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x0103fd68)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x0103fd68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1810)  Line 331\tC\n \tkernel32.dll!7c80b729() \n\n--------------------------\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n>\tmsvcr90d.dll!_unlock(int locknum=7056)  Line 376\tC\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d1648, __int64 mills=10000, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait(__int64 millisecs=10000)  Line 105\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::SynchronizableImpl::wait(__int64 millisecs=10000)  Line 60\tC++\n \tAsyncConsumer.exe!decaf::util::TimerImpl::run()  Line 101 + 0x1f bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d1790)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d1790)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d1dd0)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n\t\n----------------------------\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tmswsock.dll!71a5402b() \t\n \tmswsock.dll!71a557c9() \t\n \tws2_32.dll!71ab4d16() \t\n \tlibapr-1.dll!6eecad09() \t\n>\tmsvcp90d.dll!std::_Container_base_secure::_Orphan_all()  Line 226 + 0x8 bytes\tC++\n \tmsvcp90d.dll!std::_Container_base_secure::~_Container_base_secure()  Line 115\tC++\n \tAsyncConsumer.exe!std::_Container_base_aux_alloc_empty<std::allocator<unsigned char> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned char> >()  Line 627 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >()  + 0xf bytes\tC++\n \tAsyncConsumer.exe!decaf::lang::Thread::getId()  Line 530 + 0x6 bytes\tC++\n \t498c18a2()\t\n\n--------------------------\n\n\n \tntdll.dll!7c90e514() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!7c90df5a() \t\n \tkernel32.dll!7c8025db() \t\n \tkernel32.dll!7c802542() \t\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tAsyncConsumer.exe!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x011d3228)  Line 71 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!decaf::util::concurrent::Mutex::wait()  Line 95 + 0xf bytes\tC++\n \tAsyncConsumer.exe!activemq::threads::CompositeTaskRunner::run()  Line 119\tC++\n \tAsyncConsumer.exe!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x011d3370)  Line 133 + 0x11 bytes\tC++\n \tAsyncConsumer.exe!`anonymous namespace'::threadWorker(void * arg=0x011d3370)  Line 204 + 0x9 bytes\tC++\n>\tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x011d3910)  Line 331\tC\n \tkernel32.dll!7c80b729() \t\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Deadlock in ActiveMQSession::close' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-297?\nA: There seems to be a deadlock when closing a session. This can be reproduced using the SimpleAsyncProducer example from version 3.1.2, with the following loop added to main():\n\nfor (int i=0; i<10000; i++)\n{\n    consumer.runConsumer();\n    std::cout << \"i = \" << i << std::endl;\n    consumer.close();\n} \n\nAnd the used broker URI was as follows:\n\nstd::string brokerURI =\n \t\"failover:(tcp://192.168.0.23:"}}
{"issue_key": "AMQCPP-296", "project": "AMQCPP", "title": "vs2008 project files are missing in the download-package", "status": "Resolved", "reporter": "lars geidel", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-06-21T07:59:34.000+0000", "updated": "2010-06-21T12:55:58.000+0000", "description": "see summary", "comments": [], "text": "vs2008 project files are missing in the download-package\n\nDescription:\nsee summary\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: vs2008 project files are missing in the download-package\n\nDescription:\nsee summary\n\nComments:\n", "classification": "Classify the issue 'vs2008 project files are missing in the download-package' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-296?\nA: see summary"}}
{"issue_key": "AMQCPP-295", "project": "AMQCPP", "title": "Build Error on windows machines due to missing/wrong ifdef", "status": "Resolved", "reporter": "Michael Musenbrock", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-06-10T09:27:05.000+0000", "updated": "2010-06-21T13:39:20.000+0000", "description": "It seems that the ConditionObject::awaitNanos methos in decaf/util/concurrent/locks/ReentrantLock.cpp has a missing ifdef-statement (HAVE_PTHREAD_H) because even on Windows machines the codeblock with pthread_cond_timedwait in it is compiled, and of course fails. In all other methods in that sourcefile this call is surrounded by the already mentioned ifdef.", "comments": [], "text": "Build Error on windows machines due to missing/wrong ifdef\n\nDescription:\nIt seems that the ConditionObject::awaitNanos methos in decaf/util/concurrent/locks/ReentrantLock.cpp has a missing ifdef-statement (HAVE_PTHREAD_H) because even on Windows machines the codeblock with pthread_cond_timedwait in it is compiled, and of course fails. In all other methods in that sourcefile this call is surrounded by the already mentioned ifdef.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Build Error on windows machines due to missing/wrong ifdef\n\nDescription:\nIt seems that the ConditionObject::awaitNanos methos in decaf/util/concurrent/locks/ReentrantLock.cpp has a missing ifdef-statement (HAVE_PTHREAD_H) because even on Windows machines the codeblock with pthread_cond_timedwait in it is compiled, and of course fails. In all other methods in that sourcefile this call is surrounded by the already mentioned ifdef.\n\nComments:\n", "classification": "Classify the issue 'Build Error on windows machines due to missing/wrong ifdef' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-295?\nA: It seems that the ConditionObject::awaitNanos methos in decaf/util/concurrent/locks/ReentrantLock.cpp has a missing ifdef-statement (HAVE_PTHREAD_H) because even on Windows machines the codeblock with pthread_cond_timedwait in it is compiled, and of course fails. In all other methods in that sourcefile this call is surrounded by the already mentioned ifdef."}}
{"issue_key": "AMQCPP-294", "project": "AMQCPP", "title": "RemoveInfo Segmentation Fault", "status": "Resolved", "reporter": "Steve Pietrowicz", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2010-06-08T23:47:06.000+0000", "updated": "2011-01-31T14:02:42.000+0000", "description": "We're running a pretty complex software stack that uses ActiveMQCPP 3.1.2 on Mac OS/X 10.5, and seeing the following when we run tests against a remote broker (version 5.3.2).   The same tests run property under Linux.   It appears this is occurring because the broker isn't responding promptly, but it's hard for me to tell.   Tests done locally (under Linux) to the same broker pass without error.\n\nNo valid response received for command: Begin Class = RemoveInfo\n Value of RemoveInfo::ID_REMOVEINFO = 12\n Value of ObjectId is Below:\nBegin Class = ConnectionId\n Value of ConnectionId::ID_CONNECTIONID = 120\n Value of Value = 704fedd0-1e65-2300-3503-bb2230cd0086\nNo Data for Class BaseDataStructure\nEnd Class = ConnectionId\n\n Value of LastDeliveredSequenceId = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 6\nEnd Class = BaseCommand\nEnd Class = RemoveInfo\n, check broker.\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 168\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 176\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 348\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 255\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xb0185048\n[Switching to process 6402 thread 0x11b]\n0x9148dc7f in pthread_mutex_lock ()\n(gdb) bt\n#0  0x9148dc7f in pthread_mutex_lock ()\n#1  0x9148eb90 in _keymgr_get_and_lock_processwide_ptr_2 ()\n#2  0x914d9451 in _keymgr_get_and_lock_processwide_ptr ()\n#3  0x97b4ceea in _Unwind_Find_FDE ()\n#4  0x97b4a21e in _Unwind_GetIPInfo ()\n#5  0x97b4b729 in _Unwind_RaiseException ()\n#6  0x90049254 in __cxa_throw ()\n#7  0x00b1aade in decaf::net::SocketInputStream::read ()\n#8  0x00afaf89 in decaf::io::BufferedInputStream::bufferData ()\n#9  0x00afb5f1 in decaf::io::BufferedInputStream::read ()\n#10 0x00b05488 in decaf::io::DataInputStream::readInt ()\n#11 0x008e5da8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal ()\n#12 0x0087b8f9 in activemq::transport::IOTransport::run ()\n#13 0x00b163be in decaf::lang::ThreadProperties::runCallback ()\n#14 0x00b142f2 in (anonymous namespace)::threadWorker ()\n#15 0x914b7155 in _pthread_start ()\n#16 0x914b7012 in thread_start ()\n(gdb)", "comments": [], "text": "RemoveInfo Segmentation Fault\n\nDescription:\nWe're running a pretty complex software stack that uses ActiveMQCPP 3.1.2 on Mac OS/X 10.5, and seeing the following when we run tests against a remote broker (version 5.3.2).   The same tests run property under Linux.   It appears this is occurring because the broker isn't responding promptly, but it's hard for me to tell.   Tests done locally (under Linux) to the same broker pass without error.\n\nNo valid response received for command: Begin Class = RemoveInfo\n Value of RemoveInfo::ID_REMOVEINFO = 12\n Value of ObjectId is Below:\nBegin Class = ConnectionId\n Value of ConnectionId::ID_CONNECTIONID = 120\n Value of Value = 704fedd0-1e65-2300-3503-bb2230cd0086\nNo Data for Class BaseDataStructure\nEnd Class = ConnectionId\n\n Value of LastDeliveredSequenceId = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 6\nEnd Class = BaseCommand\nEnd Class = RemoveInfo\n, check broker.\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 168\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 176\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 348\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 255\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xb0185048\n[Switching to process 6402 thread 0x11b]\n0x9148dc7f in pthread_mutex_lock ()\n(gdb) bt\n#0  0x9148dc7f in pthread_mutex_lock ()\n#1  0x9148eb90 in _keymgr_get_and_lock_processwide_ptr_2 ()\n#2  0x914d9451 in _keymgr_get_and_lock_processwide_ptr ()\n#3  0x97b4ceea in _Unwind_Find_FDE ()\n#4  0x97b4a21e in _Unwind_GetIPInfo ()\n#5  0x97b4b729 in _Unwind_RaiseException ()\n#6  0x90049254 in __cxa_throw ()\n#7  0x00b1aade in decaf::net::SocketInputStream::read ()\n#8  0x00afaf89 in decaf::io::BufferedInputStream::bufferData ()\n#9  0x00afb5f1 in decaf::io::BufferedInputStream::read ()\n#10 0x00b05488 in decaf::io::DataInputStream::readInt ()\n#11 0x008e5da8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal ()\n#12 0x0087b8f9 in activemq::transport::IOTransport::run ()\n#13 0x00b163be in decaf::lang::ThreadProperties::runCallback ()\n#14 0x00b142f2 in (anonymous namespace)::threadWorker ()\n#15 0x914b7155 in _pthread_start ()\n#16 0x914b7012 in thread_start ()\n(gdb) \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: RemoveInfo Segmentation Fault\n\nDescription:\nWe're running a pretty complex software stack that uses ActiveMQCPP 3.1.2 on Mac OS/X 10.5, and seeing the following when we run tests against a remote broker (version 5.3.2).   The same tests run property under Linux.   It appears this is occurring because the broker isn't responding promptly, but it's hard for me to tell.   Tests done locally (under Linux) to the same broker pass without error.\n\nNo valid response received for command: Begin Class = RemoveInfo\n Value of RemoveInfo::ID_REMOVEINFO = 12\n Value of ObjectId is Below:\nBegin Class = ConnectionId\n Value of ConnectionId::ID_CONNECTIONID = 120\n Value of Value = 704fedd0-1e65-2300-3503-bb2230cd0086\nNo Data for Class BaseDataStructure\nEnd Class = ConnectionId\n\n Value of LastDeliveredSequenceId = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 6\nEnd Class = BaseCommand\nEnd Class = RemoveInfo\n, check broker.\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 168\n\tFILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 176\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 348\n\tFILE: activemq/core/ActiveMQConnection.cpp, LINE: 255\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xb0185048\n[Switching to process 6402 thread 0x11b]\n0x9148dc7f in pthread_mutex_lock ()\n(gdb) bt\n#0  0x9148dc7f in pthread_mutex_lock ()\n#1  0x9148eb90 in _keymgr_get_and_lock_processwide_ptr_2 ()\n#2  0x914d9451 in _keymgr_get_and_lock_processwide_ptr ()\n#3  0x97b4ceea in _Unwind_Find_FDE ()\n#4  0x97b4a21e in _Unwind_GetIPInfo ()\n#5  0x97b4b729 in _Unwind_RaiseException ()\n#6  0x90049254 in __cxa_throw ()\n#7  0x00b1aade in decaf::net::SocketInputStream::read ()\n#8  0x00afaf89 in decaf::io::BufferedInputStream::bufferData ()\n#9  0x00afb5f1 in decaf::io::BufferedInputStream::read ()\n#10 0x00b05488 in decaf::io::DataInputStream::readInt ()\n#11 0x008e5da8 in activemq::wireformat::openwire::OpenWireFormat::unmarshal ()\n#12 0x0087b8f9 in activemq::transport::IOTransport::run ()\n#13 0x00b163be in decaf::lang::ThreadProperties::runCallback ()\n#14 0x00b142f2 in (anonymous namespace)::threadWorker ()\n#15 0x914b7155 in _pthread_start ()\n#16 0x914b7012 in thread_start ()\n(gdb) \n\nComments:\n", "classification": "Classify the issue 'RemoveInfo Segmentation Fault' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-294?\nA: We're running a pretty complex software stack that uses ActiveMQCPP 3.1.2 on Mac OS/X 10.5, and seeing the following when we run tests against a remote broker (version 5.3.2).   The same tests run property under Linux.   It appears this is occurring because the broker isn't responding promptly, but it's hard for me to tell.   Tests done locally (under Linux) to the same broker pass without error.\n"}}
{"issue_key": "AMQCPP-293", "project": "AMQCPP", "title": "Add configuration options to ActiveMQConnectionFactory class", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-04-21T14:41:14.000+0000", "updated": "2010-06-04T20:13:49.000+0000", "description": "Add the ability to programatically configure the ActiveMQConnectionFactory to set options on the ActiveMQConnection objects it creates.  This should allow for setting the ExceptionListener that should be set on a Connection before create as well as adding in Policy objects for Prefectch and Redelivery options.", "comments": [], "text": "Add configuration options to ActiveMQConnectionFactory class\n\nDescription:\nAdd the ability to programatically configure the ActiveMQConnectionFactory to set options on the ActiveMQConnection objects it creates.  This should allow for setting the ExceptionListener that should be set on a Connection before create as well as adding in Policy objects for Prefectch and Redelivery options.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add configuration options to ActiveMQConnectionFactory class\n\nDescription:\nAdd the ability to programatically configure the ActiveMQConnectionFactory to set options on the ActiveMQConnection objects it creates.  This should allow for setting the ExceptionListener that should be set on a Connection before create as well as adding in Policy objects for Prefectch and Redelivery options.  \n\nComments:\n", "classification": "Classify the issue 'Add configuration options to ActiveMQConnectionFactory class' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-293?\nA: Add the ability to programatically configure the ActiveMQConnectionFactory to set options on the ActiveMQConnection objects it creates.  This should allow for setting the ExceptionListener that should be set on a Connection before create as well as adding in Policy objects for Prefectch and Redelivery options.  "}}
{"issue_key": "AMQCPP-292", "project": "AMQCPP", "title": "transacted sessions over shared failover connection throws exceptions", "status": "Resolved", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-03-22T14:11:38.000+0000", "updated": "2010-03-22T15:35:20.000+0000", "description": "Interleaved transacted sessions over single failover connection throw exceptions, as shown by the modified simple producer example.  It works fine without failover.\n\nStarting the example:\n-----------------------------------------------------\nSent message #1\nSent message #1\nKey does not exist in map\n        FILE: ./decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 647\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 92\n        FILE: activemq/transport/failover/FailoverTransport.cpp, LINE: 254\n        FILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 131\n        FILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n        FILE: activemq/core/ActiveMQTransactionContext.cpp, LINE: 148\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 189\n-----------------------------------------------------\nFinished with the example.", "comments": [], "text": "transacted sessions over shared failover connection throws exceptions\n\nDescription:\nInterleaved transacted sessions over single failover connection throw exceptions, as shown by the modified simple producer example.  It works fine without failover.\n\nStarting the example:\n-----------------------------------------------------\nSent message #1\nSent message #1\nKey does not exist in map\n        FILE: ./decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 647\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 92\n        FILE: activemq/transport/failover/FailoverTransport.cpp, LINE: 254\n        FILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 131\n        FILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n        FILE: activemq/core/ActiveMQTransactionContext.cpp, LINE: 148\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 189\n-----------------------------------------------------\nFinished with the example.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: transacted sessions over shared failover connection throws exceptions\n\nDescription:\nInterleaved transacted sessions over single failover connection throw exceptions, as shown by the modified simple producer example.  It works fine without failover.\n\nStarting the example:\n-----------------------------------------------------\nSent message #1\nSent message #1\nKey does not exist in map\n        FILE: ./decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 647\n        FILE: activemq/state/ConnectionStateTracker.cpp, LINE: 92\n        FILE: activemq/transport/failover/FailoverTransport.cpp, LINE: 254\n        FILE: activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 131\n        FILE: activemq/core/ActiveMQConnection.cpp, LINE: 629\n        FILE: activemq/core/ActiveMQTransactionContext.cpp, LINE: 148\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 189\n-----------------------------------------------------\nFinished with the example.\n\n\nComments:\n", "classification": "Classify the issue 'transacted sessions over shared failover connection throws exceptions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-292?\nA: Interleaved transacted sessions over single failover connection throw exceptions, as shown by the modified simple producer example.  It works fine without failover.\n\nStarting the example:\n-----------------------------------------------------\nSent message #1\nSent message #1\nKey does not exist in map\n        FILE: ./decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n        FILE: activemq/state/Con"}}
{"issue_key": "AMQCPP-291", "project": "AMQCPP", "title": "Crash on sending a message with length = 0", "status": "Resolved", "reporter": "Christian Warmuth", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-03-10T09:52:02.000+0000", "updated": "2010-03-10T16:31:23.000+0000", "description": "When you send a message with length: 0 (not NULL)  the program will crash.\n\nI think the problem is here:\n\nOpenWireStringSupport.cpp\n\nvoid OpenwireStringSupport::writeString( decaf::io::DataOutputStream& dataOut,\n                                         const std::string* str )\n                                         throw ( decaf::io::IOException ) {\n\n    try \n    {\n\n        if( str != NULL  )    <-- I think the problem is here it should be:  if( str != NULL && str->length()>0 )\n\n       ....", "comments": [], "text": "Crash on sending a message with length = 0\n\nDescription:\nWhen you send a message with length: 0 (not NULL)  the program will crash.\n\nI think the problem is here:\n\nOpenWireStringSupport.cpp\n\nvoid OpenwireStringSupport::writeString( decaf::io::DataOutputStream& dataOut,\n                                         const std::string* str )\n                                         throw ( decaf::io::IOException ) {\n\n    try \n    {\n\n        if( str != NULL  )    <-- I think the problem is here it should be:  if( str != NULL && str->length()>0 )\n\n       ....\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash on sending a message with length = 0\n\nDescription:\nWhen you send a message with length: 0 (not NULL)  the program will crash.\n\nI think the problem is here:\n\nOpenWireStringSupport.cpp\n\nvoid OpenwireStringSupport::writeString( decaf::io::DataOutputStream& dataOut,\n                                         const std::string* str )\n                                         throw ( decaf::io::IOException ) {\n\n    try \n    {\n\n        if( str != NULL  )    <-- I think the problem is here it should be:  if( str != NULL && str->length()>0 )\n\n       ....\n\n\nComments:\n", "classification": "Classify the issue 'Crash on sending a message with length = 0' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-291?\nA: When you send a message with length: 0 (not NULL)  the program will crash.\n\nI think the problem is here:\n\nOpenWireStringSupport.cpp\n\nvoid OpenwireStringSupport::writeString( decaf::io::DataOutputStream& dataOut,\n                                         const std::string* str )\n                                         throw ( decaf::io::IOException ) {\n\n    try \n    {\n\n        if( str != NULL  )   "}}
{"issue_key": "AMQCPP-290", "project": "AMQCPP", "title": "Authentication error leads to pure virtual call/kaboom in CMS 3.1.1", "status": "Resolved", "reporter": "Michael J. Kitchin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-03-01T22:18:44.000+0000", "updated": "2010-03-04T20:17:47.000+0000", "description": "Hi there,\n\nWe have a large, vertical C++ application with ActiveMQ connectivity added about a year ago, steadily upgrading the CMS interface until current (v3.1.1) and, beginning before 3.0.1, we noticed after consecutive login failures -- within our app, it takes from 3-10 actual retries -- we find a pure virtual function call somewhere in the AMQ thread pool, triggering our built-in crashdump mechanism and shutting things down.\n\nAn exception that's at least cosmetically similar may be reproduced with the SimpleProducer, as I've doctored it and attached to this email (not sure if attachments make it to the list...), along with the thread stacks/traces witnessed at the time. Start SimpleProducer and, after an indeterminate number of retries -- in this example, it could take several hundred -- the circumstance should arise. The test is performed between two hosts, using AMQ broker v5.3 and CMS 3.1.1 and ought to manifest in either debug/release build.\n\nSimpleProducer has been altered to:\n===================================\n- Provide username/password (in our test case, the username \"foo\" is incorrect)\n- Connect to a remote v5.3 AMQ broker\n- Loop the example indefinitely with a short delay between retries until (in a debug build) a pure virtual assert should trip in the standard library\n\nOur application is built unusually in the following ways:\n=========================================================\n- AMQ CMS and APR are all reconfigured and built __stdcall, since our main application is that way and name mangling won't otherwise match at link time\n- We don't have STL debug iterators enabled, so key AMQ CMS/APR headers are prepended with (more or less):\n\n#ifdef _HAS_ITERATOR_DEBUGGING\n#undef _HAS_ITERATOR_DEBUGGING\n#endif\n\n#define _HAS_ITERATOR_DEBUGGING 0\n\n...This may seem like an odd circumstance, but we function in enterprises where AMQ connectivity is only part of what our application is responsible for and, occasionally (for example) brokers may be misconfigured and remain so for notable periods before changes make their way to all of the clients, during which time we must remain operational in other regards. In practice, as I've said, our application will experience the pure virtual call within a few minutes.\n\nThank you for your time/assistance, in advance, and we otherwise very much appreciate the functionality AMQ/CMS provides us.\n\nPlease let me know if I may provide any additional information. Thanks.", "comments": [], "text": "Authentication error leads to pure virtual call/kaboom in CMS 3.1.1\n\nDescription:\nHi there,\n\nWe have a large, vertical C++ application with ActiveMQ connectivity added about a year ago, steadily upgrading the CMS interface until current (v3.1.1) and, beginning before 3.0.1, we noticed after consecutive login failures -- within our app, it takes from 3-10 actual retries -- we find a pure virtual function call somewhere in the AMQ thread pool, triggering our built-in crashdump mechanism and shutting things down.\n\nAn exception that's at least cosmetically similar may be reproduced with the SimpleProducer, as I've doctored it and attached to this email (not sure if attachments make it to the list...), along with the thread stacks/traces witnessed at the time. Start SimpleProducer and, after an indeterminate number of retries -- in this example, it could take several hundred -- the circumstance should arise. The test is performed between two hosts, using AMQ broker v5.3 and CMS 3.1.1 and ought to manifest in either debug/release build.\n\nSimpleProducer has been altered to:\n===================================\n- Provide username/password (in our test case, the username \"foo\" is incorrect)\n- Connect to a remote v5.3 AMQ broker\n- Loop the example indefinitely with a short delay between retries until (in a debug build) a pure virtual assert should trip in the standard library\n\nOur application is built unusually in the following ways:\n=========================================================\n- AMQ CMS and APR are all reconfigured and built __stdcall, since our main application is that way and name mangling won't otherwise match at link time\n- We don't have STL debug iterators enabled, so key AMQ CMS/APR headers are prepended with (more or less):\n\n#ifdef _HAS_ITERATOR_DEBUGGING\n#undef _HAS_ITERATOR_DEBUGGING\n#endif\n\n#define _HAS_ITERATOR_DEBUGGING 0\n\n...This may seem like an odd circumstance, but we function in enterprises where AMQ connectivity is only part of what our application is responsible for and, occasionally (for example) brokers may be misconfigured and remain so for notable periods before changes make their way to all of the clients, during which time we must remain operational in other regards. In practice, as I've said, our application will experience the pure virtual call within a few minutes.\n\nThank you for your time/assistance, in advance, and we otherwise very much appreciate the functionality AMQ/CMS provides us.\n\nPlease let me know if I may provide any additional information. Thanks.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Authentication error leads to pure virtual call/kaboom in CMS 3.1.1\n\nDescription:\nHi there,\n\nWe have a large, vertical C++ application with ActiveMQ connectivity added about a year ago, steadily upgrading the CMS interface until current (v3.1.1) and, beginning before 3.0.1, we noticed after consecutive login failures -- within our app, it takes from 3-10 actual retries -- we find a pure virtual function call somewhere in the AMQ thread pool, triggering our built-in crashdump mechanism and shutting things down.\n\nAn exception that's at least cosmetically similar may be reproduced with the SimpleProducer, as I've doctored it and attached to this email (not sure if attachments make it to the list...), along with the thread stacks/traces witnessed at the time. Start SimpleProducer and, after an indeterminate number of retries -- in this example, it could take several hundred -- the circumstance should arise. The test is performed between two hosts, using AMQ broker v5.3 and CMS 3.1.1 and ought to manifest in either debug/release build.\n\nSimpleProducer has been altered to:\n===================================\n- Provide username/password (in our test case, the username \"foo\" is incorrect)\n- Connect to a remote v5.3 AMQ broker\n- Loop the example indefinitely with a short delay between retries until (in a debug build) a pure virtual assert should trip in the standard library\n\nOur application is built unusually in the following ways:\n=========================================================\n- AMQ CMS and APR are all reconfigured and built __stdcall, since our main application is that way and name mangling won't otherwise match at link time\n- We don't have STL debug iterators enabled, so key AMQ CMS/APR headers are prepended with (more or less):\n\n#ifdef _HAS_ITERATOR_DEBUGGING\n#undef _HAS_ITERATOR_DEBUGGING\n#endif\n\n#define _HAS_ITERATOR_DEBUGGING 0\n\n...This may seem like an odd circumstance, but we function in enterprises where AMQ connectivity is only part of what our application is responsible for and, occasionally (for example) brokers may be misconfigured and remain so for notable periods before changes make their way to all of the clients, during which time we must remain operational in other regards. In practice, as I've said, our application will experience the pure virtual call within a few minutes.\n\nThank you for your time/assistance, in advance, and we otherwise very much appreciate the functionality AMQ/CMS provides us.\n\nPlease let me know if I may provide any additional information. Thanks.\n\n\nComments:\n", "classification": "Classify the issue 'Authentication error leads to pure virtual call/kaboom in CMS 3.1.1' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-290?\nA: Hi there,\n\nWe have a large, vertical C++ application with ActiveMQ connectivity added about a year ago, steadily upgrading the CMS interface until current (v3.1.1) and, beginning before 3.0.1, we noticed after consecutive login failures -- within our app, it takes from 3-10 actual retries -- we find a pure virtual function call somewhere in the AMQ thread pool, triggering our built-in crashdump me"}}
{"issue_key": "AMQCPP-289", "project": "AMQCPP", "title": "decaf.lang.Thread doesn't free memory when phtreads used", "status": "Closed", "reporter": "Christian Warmuth", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-02-26T14:48:03.000+0000", "updated": "2010-02-26T15:08:16.000+0000", "description": "If you run the following program:\n\n\nint main (int argc, char *argv[])\n{\n  \n   ConnectionFactory* connectionFactory;\n   Connection *connection;\n\n   activemq::library::ActiveMQCPP::initializeLibrary();\n    \n   std::string brokerURI =\n        \"tcp://127.1.0.1:61616\"\n        \"?wireFormat=openwire\";\n\t\n   connectionFactory = ConnectionFactory::createCMSConnectionFactory( brokerURI );\n\n   for (int i=0;i<1000;i++)\n   {\n      connection = connectionFactory->createConnection();\n      connection->start();\n      connection->stop();\n      connection->close();\n      delete connection;\n      printf(\"Count %ld\\r\\n\",i);\n   }\n     \n   delete connectionFactory;\n    \n   activemq::library::ActiveMQCPP::shutdownLibrary();\n   return 0;\n}\n\n\nthe consumption of memory grows on every new connection, but the memory is never freed.\nAfter about 180 connections the maximum virtual memory (about 3GB on 32bit Linux) of the process is reached and its impossible\nto create a new thread for the client. I saw that the destructor of the Thread class is called, but the memory of the created threads\nis not freed.\n\nIf I add the line:\n\n\n#ifdef HAVE_PTHREAD_H\n        pthread_detach(properties->handle);\n#endif\n\n\nto the destructor of de decaf/ang/Thread class the memory is freed after destroying the connection.\n\nThis is a quick and dirty fix, but I think somewhat is going wrong here.", "comments": [], "text": "decaf.lang.Thread doesn't free memory when phtreads used\n\nDescription:\nIf you run the following program:\n\n\nint main (int argc, char *argv[])\n{\n  \n   ConnectionFactory* connectionFactory;\n   Connection *connection;\n\n   activemq::library::ActiveMQCPP::initializeLibrary();\n    \n   std::string brokerURI =\n        \"tcp://127.1.0.1:61616\"\n        \"?wireFormat=openwire\";\n\t\n   connectionFactory = ConnectionFactory::createCMSConnectionFactory( brokerURI );\n\n   for (int i=0;i<1000;i++)\n   {\n      connection = connectionFactory->createConnection();\n      connection->start();\n      connection->stop();\n      connection->close();\n      delete connection;\n      printf(\"Count %ld\\r\\n\",i);\n   }\n     \n   delete connectionFactory;\n    \n   activemq::library::ActiveMQCPP::shutdownLibrary();\n   return 0;\n}\n\n\nthe consumption of memory grows on every new connection, but the memory is never freed.\nAfter about 180 connections the maximum virtual memory (about 3GB on 32bit Linux) of the process is reached and its impossible\nto create a new thread for the client. I saw that the destructor of the Thread class is called, but the memory of the created threads\nis not freed.\n\nIf I add the line:\n\n\n#ifdef HAVE_PTHREAD_H\n        pthread_detach(properties->handle);\n#endif\n\n\nto the destructor of de decaf/ang/Thread class the memory is freed after destroying the connection.\n\nThis is a quick and dirty fix, but I think somewhat is going wrong here.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf.lang.Thread doesn't free memory when phtreads used\n\nDescription:\nIf you run the following program:\n\n\nint main (int argc, char *argv[])\n{\n  \n   ConnectionFactory* connectionFactory;\n   Connection *connection;\n\n   activemq::library::ActiveMQCPP::initializeLibrary();\n    \n   std::string brokerURI =\n        \"tcp://127.1.0.1:61616\"\n        \"?wireFormat=openwire\";\n\t\n   connectionFactory = ConnectionFactory::createCMSConnectionFactory( brokerURI );\n\n   for (int i=0;i<1000;i++)\n   {\n      connection = connectionFactory->createConnection();\n      connection->start();\n      connection->stop();\n      connection->close();\n      delete connection;\n      printf(\"Count %ld\\r\\n\",i);\n   }\n     \n   delete connectionFactory;\n    \n   activemq::library::ActiveMQCPP::shutdownLibrary();\n   return 0;\n}\n\n\nthe consumption of memory grows on every new connection, but the memory is never freed.\nAfter about 180 connections the maximum virtual memory (about 3GB on 32bit Linux) of the process is reached and its impossible\nto create a new thread for the client. I saw that the destructor of the Thread class is called, but the memory of the created threads\nis not freed.\n\nIf I add the line:\n\n\n#ifdef HAVE_PTHREAD_H\n        pthread_detach(properties->handle);\n#endif\n\n\nto the destructor of de decaf/ang/Thread class the memory is freed after destroying the connection.\n\nThis is a quick and dirty fix, but I think somewhat is going wrong here.\n\n\nComments:\n", "classification": "Classify the issue 'decaf.lang.Thread doesn't free memory when phtreads used' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-289?\nA: If you run the following program:\n\n\nint main (int argc, char *argv[])\n{\n  \n   ConnectionFactory* connectionFactory;\n   Connection *connection;\n\n   activemq::library::ActiveMQCPP::initializeLibrary();\n    \n   std::string brokerURI =\n        \"tcp://127.1.0.1:61616\"\n        \"?wireFormat=openwire\";\n\t\n   connectionFactory = ConnectionFactory::createCMSConnectionFactory( brokerURI );\n\n   for (int i=0;i<"}}
{"issue_key": "AMQCPP-288", "project": "AMQCPP", "title": "ResourceLifecycleManager needs to be thread-safe", "status": "Resolved", "reporter": "Ivan Pechorin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-02-24T08:25:55.000+0000", "updated": "2010-02-24T13:46:23.000+0000", "description": "We use ActiveMQ C++ 3.x client in a multi-threaded application. In particular, we use activemq::cmsutil::SessionPool and activemq::cmsutil::PooledSession. \nMethods createCachedProducer and createCachedConsumer of class PooledSession do not synchronize access to their shared ResourceLifecycleManager, and ResourceLifecycleManager itself is not thread-safe. Therefore, it is not safe to use pooled session from multiple threads, even if we guarantee that each PooledSession is used from one thread at any given time.\n\nTo resolve this issue, ResourceLifecycleManager needs to be thread-safe, i.e. we need to add synchronization to all of its add* methods.", "comments": [], "text": "ResourceLifecycleManager needs to be thread-safe\n\nDescription:\nWe use ActiveMQ C++ 3.x client in a multi-threaded application. In particular, we use activemq::cmsutil::SessionPool and activemq::cmsutil::PooledSession. \nMethods createCachedProducer and createCachedConsumer of class PooledSession do not synchronize access to their shared ResourceLifecycleManager, and ResourceLifecycleManager itself is not thread-safe. Therefore, it is not safe to use pooled session from multiple threads, even if we guarantee that each PooledSession is used from one thread at any given time.\n\nTo resolve this issue, ResourceLifecycleManager needs to be thread-safe, i.e. we need to add synchronization to all of its add* methods. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ResourceLifecycleManager needs to be thread-safe\n\nDescription:\nWe use ActiveMQ C++ 3.x client in a multi-threaded application. In particular, we use activemq::cmsutil::SessionPool and activemq::cmsutil::PooledSession. \nMethods createCachedProducer and createCachedConsumer of class PooledSession do not synchronize access to their shared ResourceLifecycleManager, and ResourceLifecycleManager itself is not thread-safe. Therefore, it is not safe to use pooled session from multiple threads, even if we guarantee that each PooledSession is used from one thread at any given time.\n\nTo resolve this issue, ResourceLifecycleManager needs to be thread-safe, i.e. we need to add synchronization to all of its add* methods. \n\nComments:\n", "classification": "Classify the issue 'ResourceLifecycleManager needs to be thread-safe' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-288?\nA: We use ActiveMQ C++ 3.x client in a multi-threaded application. In particular, we use activemq::cmsutil::SessionPool and activemq::cmsutil::PooledSession. \nMethods createCachedProducer and createCachedConsumer of class PooledSession do not synchronize access to their shared ResourceLifecycleManager, and ResourceLifecycleManager itself is not thread-safe. Therefore, it is not safe to use pooled ses"}}
{"issue_key": "AMQCPP-287", "project": "AMQCPP", "title": "Implement Message Body Compression that works with Java and .NET clients", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-02-16T20:53:22.000+0000", "updated": "2010-03-07T18:19:02.000+0000", "description": "Implement ZLib compatible compression support in the Decaf library and add the option in the ConnectionFactory and Connection to enable message body compression.  Update Message classes to use this compression streams when compression is enabled.", "comments": [], "text": "Implement Message Body Compression that works with Java and .NET clients\n\nDescription:\nImplement ZLib compatible compression support in the Decaf library and add the option in the ConnectionFactory and Connection to enable message body compression.  Update Message classes to use this compression streams when compression is enabled.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement Message Body Compression that works with Java and .NET clients\n\nDescription:\nImplement ZLib compatible compression support in the Decaf library and add the option in the ConnectionFactory and Connection to enable message body compression.  Update Message classes to use this compression streams when compression is enabled.\n\nComments:\n", "classification": "Classify the issue 'Implement Message Body Compression that works with Java and .NET clients' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-287?\nA: Implement ZLib compatible compression support in the Decaf library and add the option in the ConnectionFactory and Connection to enable message body compression.  Update Message classes to use this compression streams when compression is enabled."}}
{"issue_key": "AMQCPP-286", "project": "AMQCPP", "title": "Memory leak when adding connection.sendTimeout=3000 to a failover transport", "status": "Resolved", "reporter": "Martin Carpella", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-02-12T13:02:58.000+0000", "updated": "2010-02-12T14:32:26.000+0000", "description": "When adding a connection.sendTimeout to a failover transport, a memory leak will occur. \n\nIn the sample program provided on the homepage, the following broker caused the problem:\nstd::string brokerURI = \"failover://(tcp://localhost:61616)?connection.sendTimeout=3000\";\n\nValgrind reports the following losses (only parts with \"definitely lost\" included):\n==20454== 800 bytes in 100 blocks are definitely lost in loss record 26 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4317196: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (Pointer.h:45)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\n\n==20454== 86,887 (35,600 direct, 51,287 indirect) bytes in 100 blocks are definitely lost in loss record 39 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4281245: activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:54)\n==20454==    by 0x42840A0: covariant return thunk to activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:189)\n==20454==    by 0x4317188: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (ActiveMQSession.cpp:708)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\nUsing the URI\nstd::string brokerURI = \"failover://(tcp://localhost:61616)\";\ndoesn't produce any \"definitly lost\" or \"indirectly lost\" records.", "comments": [], "text": "Memory leak when adding connection.sendTimeout=3000 to a failover transport\n\nDescription:\nWhen adding a connection.sendTimeout to a failover transport, a memory leak will occur. \n\nIn the sample program provided on the homepage, the following broker caused the problem:\nstd::string brokerURI = \"failover://(tcp://localhost:61616)?connection.sendTimeout=3000\";\n\nValgrind reports the following losses (only parts with \"definitely lost\" included):\n==20454== 800 bytes in 100 blocks are definitely lost in loss record 26 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4317196: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (Pointer.h:45)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\n\n==20454== 86,887 (35,600 direct, 51,287 indirect) bytes in 100 blocks are definitely lost in loss record 39 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4281245: activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:54)\n==20454==    by 0x42840A0: covariant return thunk to activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:189)\n==20454==    by 0x4317188: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (ActiveMQSession.cpp:708)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\nUsing the URI\nstd::string brokerURI = \"failover://(tcp://localhost:61616)\";\ndoesn't produce any \"definitly lost\" or \"indirectly lost\" records.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak when adding connection.sendTimeout=3000 to a failover transport\n\nDescription:\nWhen adding a connection.sendTimeout to a failover transport, a memory leak will occur. \n\nIn the sample program provided on the homepage, the following broker caused the problem:\nstd::string brokerURI = \"failover://(tcp://localhost:61616)?connection.sendTimeout=3000\";\n\nValgrind reports the following losses (only parts with \"definitely lost\" included):\n==20454== 800 bytes in 100 blocks are definitely lost in loss record 26 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4317196: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (Pointer.h:45)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\n\n==20454== 86,887 (35,600 direct, 51,287 indirect) bytes in 100 blocks are definitely lost in loss record 39 of 39\n==20454==    at 0x4025390: operator new(unsigned int) (vg_replace_malloc.c:214)\n==20454==    by 0x4281245: activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:54)\n==20454==    by 0x42840A0: covariant return thunk to activemq::commands::ActiveMQTextMessage::cloneDataStructure() const (ActiveMQTextMessage.cpp:189)\n==20454==    by 0x4317188: activemq::core::ActiveMQSession::send(cms::Message*, activemq::core::ActiveMQProducer*, activemq::util::Usage*) (ActiveMQSession.cpp:708)\n==20454==    by 0x430BBBE: activemq::core::ActiveMQProducer::send(cms::Destination const*, cms::Message*, int, int, long long) (ActiveMQProducer.cpp:197)\n==20454==    by 0x430A512: activemq::core::ActiveMQProducer::send(cms::Message*, int, int, long long) (ActiveMQProducer.cpp:118)\n==20454==    by 0x8049CB2: SimpleProducer::run() (main.cpp:139)\n==20454==    by 0x80492FE: main (main.cpp:264)\n\nUsing the URI\nstd::string brokerURI = \"failover://(tcp://localhost:61616)\";\ndoesn't produce any \"definitly lost\" or \"indirectly lost\" records.\n\nComments:\n", "classification": "Classify the issue 'Memory leak when adding connection.sendTimeout=3000 to a failover transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-286?\nA: When adding a connection.sendTimeout to a failover transport, a memory leak will occur. \n\nIn the sample program provided on the homepage, the following broker caused the problem:\nstd::string brokerURI = \"failover://(tcp://localhost:61616)?connection.sendTimeout=3000\";\n\nValgrind reports the following losses (only parts with \"definitely lost\" included):\n==20454== 800 bytes in 100 blocks are definite"}}
{"issue_key": "AMQCPP-285", "project": "AMQCPP", "title": "If brokerURI is ipv4 format(127.0.0.1),  createConnection will throw decaf::lang::exceptions::NumberFormatException.", "status": "Resolved", "reporter": "yojay.li", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-02-09T01:52:28.000+0000", "updated": "2010-02-09T15:48:23.000+0000", "description": "file: \n  activemq-cpp-library-3.1.0\\src\\main\\decaf\\internal\\net\\URIHelper.cpp\nfunciton: \n  bool URIHelper::isValidIPv4Address( const std::string& host )\ncause:\n  The paramters of std::string.substr() is (start_pos, length) but not (start_pos, end_pos).\n  Interger::parseInt(host.substr(..., ...)) will throw NumberFormatException.\n\nfixed code:\n\nbool URIHelper::isValidIPv4Address( const std::string& host ) {\n\n    std::size_t index;\n    std::size_t index2;\n\n    try {\n\n        int num;\n        index = host.find( '.' );\n\t\tnum = decaf::lang::Integer::parseInt( host.substr( 0, index ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index2 = host.find( '.', index + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, index2 - index - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index = host.find( '.', index2 + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index2 + 1, index - index2 - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, std::string::npos ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n\t} catch( decaf::lang::Exception& e ) {\n        return false;\n    }\n\n    return true;\n}", "comments": [], "text": "If brokerURI is ipv4 format(127.0.0.1),  createConnection will throw decaf::lang::exceptions::NumberFormatException.\n\nDescription:\nfile: \n  activemq-cpp-library-3.1.0\\src\\main\\decaf\\internal\\net\\URIHelper.cpp\nfunciton: \n  bool URIHelper::isValidIPv4Address( const std::string& host )\ncause:\n  The paramters of std::string.substr() is (start_pos, length) but not (start_pos, end_pos).\n  Interger::parseInt(host.substr(..., ...)) will throw NumberFormatException.\n\nfixed code:\n\nbool URIHelper::isValidIPv4Address( const std::string& host ) {\n\n    std::size_t index;\n    std::size_t index2;\n\n    try {\n\n        int num;\n        index = host.find( '.' );\n\t\tnum = decaf::lang::Integer::parseInt( host.substr( 0, index ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index2 = host.find( '.', index + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, index2 - index - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index = host.find( '.', index2 + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index2 + 1, index - index2 - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, std::string::npos ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n\t} catch( decaf::lang::Exception& e ) {\n        return false;\n    }\n\n    return true;\n}\n  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: If brokerURI is ipv4 format(127.0.0.1),  createConnection will throw decaf::lang::exceptions::NumberFormatException.\n\nDescription:\nfile: \n  activemq-cpp-library-3.1.0\\src\\main\\decaf\\internal\\net\\URIHelper.cpp\nfunciton: \n  bool URIHelper::isValidIPv4Address( const std::string& host )\ncause:\n  The paramters of std::string.substr() is (start_pos, length) but not (start_pos, end_pos).\n  Interger::parseInt(host.substr(..., ...)) will throw NumberFormatException.\n\nfixed code:\n\nbool URIHelper::isValidIPv4Address( const std::string& host ) {\n\n    std::size_t index;\n    std::size_t index2;\n\n    try {\n\n        int num;\n        index = host.find( '.' );\n\t\tnum = decaf::lang::Integer::parseInt( host.substr( 0, index ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index2 = host.find( '.', index + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, index2 - index - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        index = host.find( '.', index2 + 1 );\n        num = decaf::lang::Integer::parseInt( host.substr( index2 + 1, index - index2 - 1) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n        num = decaf::lang::Integer::parseInt( host.substr( index + 1, std::string::npos ) );\n        if( num < 0 || num > 255 ) {\n            return false;\n        }\n\n\t} catch( decaf::lang::Exception& e ) {\n        return false;\n    }\n\n    return true;\n}\n  \n\nComments:\n", "classification": "Classify the issue 'If brokerURI is ipv4 format(127.0.0.1),  createConnection will throw decaf::lang::exceptions::NumberFormatException.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-285?\nA: file: \n  activemq-cpp-library-3.1.0\\src\\main\\decaf\\internal\\net\\URIHelper.cpp\nfunciton: \n  bool URIHelper::isValidIPv4Address( const std::string& host )\ncause:\n  The paramters of std::string.substr() is (start_pos, length) but not (start_pos, end_pos).\n  Interger::parseInt(host.substr(..., ...)) will throw NumberFormatException.\n\nfixed code:\n\nbool URIHelper::isValidIPv4Address( const std::string& "}}
{"issue_key": "AMQCPP-284", "project": "AMQCPP", "title": "Generate Openwire 6 commands and marshalers to keep pace with the AMQ 5.4 broker.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-01-27T14:01:23.000+0000", "updated": "2010-08-18T14:45:22.000+0000", "description": "The 5.4 broker will introduce openwire 6 as its preferred wireformat.  We need to generate new marshalers and commands to use the new features of the v6 wireformat.", "comments": [], "text": "Generate Openwire 6 commands and marshalers to keep pace with the AMQ 5.4 broker.\n\nDescription:\nThe 5.4 broker will introduce openwire 6 as its preferred wireformat.  We need to generate new marshalers and commands to use the new features of the v6 wireformat.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Generate Openwire 6 commands and marshalers to keep pace with the AMQ 5.4 broker.\n\nDescription:\nThe 5.4 broker will introduce openwire 6 as its preferred wireformat.  We need to generate new marshalers and commands to use the new features of the v6 wireformat.  \n\nComments:\n", "classification": "Classify the issue 'Generate Openwire 6 commands and marshalers to keep pace with the AMQ 5.4 broker.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-284?\nA: The 5.4 broker will introduce openwire 6 as its preferred wireformat.  We need to generate new marshalers and commands to use the new features of the v6 wireformat.  "}}
{"issue_key": "AMQCPP-283", "project": "AMQCPP", "title": "Update Visual Studio projects to VS2008 format.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2010-01-27T13:59:36.000+0000", "updated": "2010-05-26T22:41:59.000+0000", "description": "Currently the projects are in VS2005 format.  VS2008 is now the platform of choice for the AMQCPP project so the project files should be migrated.", "comments": [], "text": "Update Visual Studio projects to VS2008 format.\n\nDescription:\nCurrently the projects are in VS2005 format.  VS2008 is now the platform of choice for the AMQCPP project so the project files should be migrated.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update Visual Studio projects to VS2008 format.\n\nDescription:\nCurrently the projects are in VS2005 format.  VS2008 is now the platform of choice for the AMQCPP project so the project files should be migrated.\n\nComments:\n", "classification": "Classify the issue 'Update Visual Studio projects to VS2008 format.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-283?\nA: Currently the projects are in VS2005 format.  VS2008 is now the platform of choice for the AMQCPP project so the project files should be migrated."}}
{"issue_key": "AMQCPP-282", "project": "AMQCPP", "title": "deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called", "status": "Closed", "reporter": "Ivan Pechorin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-01-26T17:46:49.000+0000", "updated": "2010-01-27T16:37:41.000+0000", "description": "ActiveMQ C++ client gives the C4150 warning \"deletion of pointer to incomplete type; no destructor called\" multiple times when compiling it with Visual C++ 2008 SP1 on Win32.\n\nThere are two different places that generate this warning:\n\n1) decaf::lang::ThreadProperties\n\n1>SimpleLogger.cpp\n1>c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(358) : warning C4150: deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(39) : see declaration of 'decaf::lang::ThreadProperties'\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(357) : while compiling class template member function 'void decaf::lang::Pointer<T>::onDeleteFunc(T *)'\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(73) : see reference to class template instantiation 'decaf::lang::Pointer<T>' being compiled\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n\n\n2) decaf::internal::RuntimeData\n\n1>Thread.cpp\n1>C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(721) : warning C4150: deletion of pointer to incomplete type 'decaf::internal::RuntimeData'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(30) : see declaration of 'decaf::internal::RuntimeData'\n1>        C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(720) : while compiling class template member function 'std::auto_ptr<_Ty>::~auto_ptr(void)'\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(38) : see reference to class template instantiation 'std::auto_ptr<_Ty>' being compiled\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n\nThe warning affects both version 3.1.0 and the trunk.\n\nI was able to resolve the warning by moving declarations of these two classes from the cpp files to the corresponding header files. I'm not proficient enough in C++ to provide solution that keeps these classes encapsulated.\n\nIt is unlikely that these two particular warnings could lead to memory leaks on Win32:\n - RuntimeData's only member  is managed from outside, destructor is trivial (empty); \n - ThreadProperties's destructor is trivial (empty) on Win32, and non-trivial on platforms with pthreads.", "comments": [], "text": "deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called\n\nDescription:\nActiveMQ C++ client gives the C4150 warning \"deletion of pointer to incomplete type; no destructor called\" multiple times when compiling it with Visual C++ 2008 SP1 on Win32.\n\nThere are two different places that generate this warning:\n\n1) decaf::lang::ThreadProperties\n\n1>SimpleLogger.cpp\n1>c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(358) : warning C4150: deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(39) : see declaration of 'decaf::lang::ThreadProperties'\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(357) : while compiling class template member function 'void decaf::lang::Pointer<T>::onDeleteFunc(T *)'\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(73) : see reference to class template instantiation 'decaf::lang::Pointer<T>' being compiled\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n\n\n2) decaf::internal::RuntimeData\n\n1>Thread.cpp\n1>C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(721) : warning C4150: deletion of pointer to incomplete type 'decaf::internal::RuntimeData'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(30) : see declaration of 'decaf::internal::RuntimeData'\n1>        C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(720) : while compiling class template member function 'std::auto_ptr<_Ty>::~auto_ptr(void)'\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(38) : see reference to class template instantiation 'std::auto_ptr<_Ty>' being compiled\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n\nThe warning affects both version 3.1.0 and the trunk.\n\nI was able to resolve the warning by moving declarations of these two classes from the cpp files to the corresponding header files. I'm not proficient enough in C++ to provide solution that keeps these classes encapsulated.\n\nIt is unlikely that these two particular warnings could lead to memory leaks on Win32:\n - RuntimeData's only member  is managed from outside, destructor is trivial (empty); \n - ThreadProperties's destructor is trivial (empty) on Win32, and non-trivial on platforms with pthreads.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called\n\nDescription:\nActiveMQ C++ client gives the C4150 warning \"deletion of pointer to incomplete type; no destructor called\" multiple times when compiling it with Visual C++ 2008 SP1 on Win32.\n\nThere are two different places that generate this warning:\n\n1) decaf::lang::ThreadProperties\n\n1>SimpleLogger.cpp\n1>c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(358) : warning C4150: deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(39) : see declaration of 'decaf::lang::ThreadProperties'\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(357) : while compiling class template member function 'void decaf::lang::Pointer<T>::onDeleteFunc(T *)'\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Thread.h(73) : see reference to class template instantiation 'decaf::lang::Pointer<T>' being compiled\n1>        with\n1>        [\n1>            T=decaf::lang::ThreadProperties\n1>        ]\n\n\n2) decaf::internal::RuntimeData\n\n1>Thread.cpp\n1>C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(721) : warning C4150: deletion of pointer to incomplete type 'decaf::internal::RuntimeData'; no destructor called\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(30) : see declaration of 'decaf::internal::RuntimeData'\n1>        C:\\tools\\Microsoft Visual Studio 9.0\\VC\\include\\memory(720) : while compiling class template member function 'std::auto_ptr<_Ty>::~auto_ptr(void)'\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n1>        c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/internal/DecafRuntime.h(38) : see reference to class template instantiation 'std::auto_ptr<_Ty>' being compiled\n1>        with\n1>        [\n1>            _Ty=decaf::internal::RuntimeData\n1>        ]\n\nThe warning affects both version 3.1.0 and the trunk.\n\nI was able to resolve the warning by moving declarations of these two classes from the cpp files to the corresponding header files. I'm not proficient enough in C++ to provide solution that keeps these classes encapsulated.\n\nIt is unlikely that these two particular warnings could lead to memory leaks on Win32:\n - RuntimeData's only member  is managed from outside, destructor is trivial (empty); \n - ThreadProperties's destructor is trivial (empty) on Win32, and non-trivial on platforms with pthreads.\n\nComments:\n", "classification": "Classify the issue 'deletion of pointer to incomplete type 'decaf::lang::ThreadProperties'; no destructor called' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-282?\nA: ActiveMQ C++ client gives the C4150 warning \"deletion of pointer to incomplete type; no destructor called\" multiple times when compiling it with Visual C++ 2008 SP1 on Win32.\n\nThere are two different places that generate this warning:\n\n1) decaf::lang::ThreadProperties\n\n1>SimpleLogger.cpp\n1>c:\\dev_vc9\\activemq\\activemq-cpp-trunk\\src\\main\\decaf/lang/Pointer.h(358) : warning C4150: deletion of pointe"}}
{"issue_key": "AMQCPP-281", "project": "AMQCPP", "title": "Memory Leak in Pointer class Constructor when dynamic cast fails.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-01-22T20:22:08.000+0000", "updated": "2010-01-22T21:06:16.000+0000", "description": "If the Pointer class has its dynamicCast method invoked and the cast fails in the Constructor of the new Pointer instance then there is a leak since the ref counter is not released before the ClassCastException is thrown.", "comments": [], "text": "Memory Leak in Pointer class Constructor when dynamic cast fails.\n\nDescription:\nIf the Pointer class has its dynamicCast method invoked and the cast fails in the Constructor of the new Pointer instance then there is a leak since the ref counter is not released before the ClassCastException is thrown.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory Leak in Pointer class Constructor when dynamic cast fails.\n\nDescription:\nIf the Pointer class has its dynamicCast method invoked and the cast fails in the Constructor of the new Pointer instance then there is a leak since the ref counter is not released before the ClassCastException is thrown.\n\nComments:\n", "classification": "Classify the issue 'Memory Leak in Pointer class Constructor when dynamic cast fails.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-281?\nA: If the Pointer class has its dynamicCast method invoked and the cast fails in the Constructor of the new Pointer instance then there is a leak since the ref counter is not released before the ClassCastException is thrown."}}
{"issue_key": "AMQCPP-280", "project": "AMQCPP", "title": "Missing call to pthread_detach on linux causes temporary resource leak.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-01-22T16:41:49.000+0000", "updated": "2010-01-22T19:33:59.000+0000", "description": "The thread function in Decaf should be calling pthread_detach on the thread to ensure that thread resources are reclaimed as soon as the thread dies instead of waiting until the application terminates.  Any thread that is not joined before shutting down would not have its pthread internal data structures reclaimed until exit.", "comments": [], "text": "Missing call to pthread_detach on linux causes temporary resource leak.\n\nDescription:\nThe thread function in Decaf should be calling pthread_detach on the thread to ensure that thread resources are reclaimed as soon as the thread dies instead of waiting until the application terminates.  Any thread that is not joined before shutting down would not have its pthread internal data structures reclaimed until exit.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Missing call to pthread_detach on linux causes temporary resource leak.\n\nDescription:\nThe thread function in Decaf should be calling pthread_detach on the thread to ensure that thread resources are reclaimed as soon as the thread dies instead of waiting until the application terminates.  Any thread that is not joined before shutting down would not have its pthread internal data structures reclaimed until exit.  \n\nComments:\n", "classification": "Classify the issue 'Missing call to pthread_detach on linux causes temporary resource leak.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-280?\nA: The thread function in Decaf should be calling pthread_detach on the thread to ensure that thread resources are reclaimed as soon as the thread dies instead of waiting until the application terminates.  Any thread that is not joined before shutting down would not have its pthread internal data structures reclaimed until exit.  "}}
{"issue_key": "AMQCPP-279", "project": "AMQCPP", "title": "Does not detect broken connection when using stomp", "status": "Closed", "reporter": "Pavel Jaoshvili", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-01-18T12:09:33.000+0000", "updated": "2010-01-18T13:46:04.000+0000", "description": "If I run simple_async_consumer from example directory and use following syntax for brokenURI\nstd::string brokerURI =\n        \"failover:(tcp://192.168.1.13:61613\"\n        \"?wireFormat=stomp\"\n        \")\";\nthen ActiveMQ-CPP does not detect broken connection (when network cable is unplugged). But if I use openwire transport all work good.", "comments": [], "text": "Does not detect broken connection when using stomp\n\nDescription:\nIf I run simple_async_consumer from example directory and use following syntax for brokenURI\nstd::string brokerURI =\n        \"failover:(tcp://192.168.1.13:61613\"\n        \"?wireFormat=stomp\"\n        \")\";\nthen ActiveMQ-CPP does not detect broken connection (when network cable is unplugged). But if I use openwire transport all work good.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Does not detect broken connection when using stomp\n\nDescription:\nIf I run simple_async_consumer from example directory and use following syntax for brokenURI\nstd::string brokerURI =\n        \"failover:(tcp://192.168.1.13:61613\"\n        \"?wireFormat=stomp\"\n        \")\";\nthen ActiveMQ-CPP does not detect broken connection (when network cable is unplugged). But if I use openwire transport all work good.\n\nComments:\n", "classification": "Classify the issue 'Does not detect broken connection when using stomp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-279?\nA: If I run simple_async_consumer from example directory and use following syntax for brokenURI\nstd::string brokerURI =\n        \"failover:(tcp://192.168.1.13:61613\"\n        \"?wireFormat=stomp\"\n        \")\";\nthen ActiveMQ-CPP does not detect broken connection (when network cable is unplugged). But if I use openwire transport all work good."}}
{"issue_key": "AMQCPP-278", "project": "AMQCPP", "title": "minor problem with the new failover syntax and uri params", "status": "Closed", "reporter": "lars geidel", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-01-14T15:08:43.000+0000", "updated": "2010-01-18T23:28:35.000+0000", "description": "i played around a little with persistent messages and connection loss\nthe default behavior for that situation is that the producer blocks\nwhat i want to achieve is that any problem while sending persistent messages leads to an exception, but reconnects should be possible\nso i tried the following uri:\nfailover:(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\nwhich enables reconnects, but the producer-thread still blocks (multithreaded program)\n\nafter some debugging i found that the uri parameters are ignored if the new failover syntax (as stated above) is used:\nurihelper.cpp line 115 -> query is not set -> connection properties stay empty\n\nso the working uri is:\nfailover://(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\n(double slash after \"failover:\" - old syntax - see http://activemq.apache.org/failover-transport-reference.html)\n\nand one question:\ncould it be that:\n\"failover:(uri1,...,uriN)?transportOptions\"\nindicates that the following uri is legal:\nfailover:(tcp://localhost:61616?connection.sendTimeout=1000,tcp://{some-other-host}:61616?connection.sendTimeout=2000)?timeout=1000\n?\nif yes, than there's a lot more to do ... (query-parsing - e.g. urisupport.cpp line 122 will cut the query; cast-exception at \"2000)\"; ...)\n\nanyway, keep up the good work\n\nwith kind regards\n\nlars geidel\n\n\nbtw.:\nthe parameter in FailoverTransport.cpp line 231 should be \"timeout\", not \"timedout\" :-)", "comments": [], "text": "minor problem with the new failover syntax and uri params\n\nDescription:\ni played around a little with persistent messages and connection loss\nthe default behavior for that situation is that the producer blocks\nwhat i want to achieve is that any problem while sending persistent messages leads to an exception, but reconnects should be possible\nso i tried the following uri:\nfailover:(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\nwhich enables reconnects, but the producer-thread still blocks (multithreaded program)\n\nafter some debugging i found that the uri parameters are ignored if the new failover syntax (as stated above) is used:\nurihelper.cpp line 115 -> query is not set -> connection properties stay empty\n\nso the working uri is:\nfailover://(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\n(double slash after \"failover:\" - old syntax - see http://activemq.apache.org/failover-transport-reference.html)\n\nand one question:\ncould it be that:\n\"failover:(uri1,...,uriN)?transportOptions\"\nindicates that the following uri is legal:\nfailover:(tcp://localhost:61616?connection.sendTimeout=1000,tcp://{some-other-host}:61616?connection.sendTimeout=2000)?timeout=1000\n?\nif yes, than there's a lot more to do ... (query-parsing - e.g. urisupport.cpp line 122 will cut the query; cast-exception at \"2000)\"; ...)\n\nanyway, keep up the good work\n\nwith kind regards\n\nlars geidel\n\n\nbtw.:\nthe parameter in FailoverTransport.cpp line 231 should be \"timeout\", not \"timedout\" :-)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: minor problem with the new failover syntax and uri params\n\nDescription:\ni played around a little with persistent messages and connection loss\nthe default behavior for that situation is that the producer blocks\nwhat i want to achieve is that any problem while sending persistent messages leads to an exception, but reconnects should be possible\nso i tried the following uri:\nfailover:(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\nwhich enables reconnects, but the producer-thread still blocks (multithreaded program)\n\nafter some debugging i found that the uri parameters are ignored if the new failover syntax (as stated above) is used:\nurihelper.cpp line 115 -> query is not set -> connection properties stay empty\n\nso the working uri is:\nfailover://(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\n(double slash after \"failover:\" - old syntax - see http://activemq.apache.org/failover-transport-reference.html)\n\nand one question:\ncould it be that:\n\"failover:(uri1,...,uriN)?transportOptions\"\nindicates that the following uri is legal:\nfailover:(tcp://localhost:61616?connection.sendTimeout=1000,tcp://{some-other-host}:61616?connection.sendTimeout=2000)?timeout=1000\n?\nif yes, than there's a lot more to do ... (query-parsing - e.g. urisupport.cpp line 122 will cut the query; cast-exception at \"2000)\"; ...)\n\nanyway, keep up the good work\n\nwith kind regards\n\nlars geidel\n\n\nbtw.:\nthe parameter in FailoverTransport.cpp line 231 should be \"timeout\", not \"timedout\" :-)\n\nComments:\n", "classification": "Classify the issue 'minor problem with the new failover syntax and uri params' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-278?\nA: i played around a little with persistent messages and connection loss\nthe default behavior for that situation is that the producer blocks\nwhat i want to achieve is that any problem while sending persistent messages leads to an exception, but reconnects should be possible\nso i tried the following uri:\nfailover:(tcp://localhost:61616)?connection.sendTimeout=1000&timeout=1000\nwhich enables reconnects"}}
{"issue_key": "AMQCPP-277", "project": "AMQCPP", "title": "Freeze when creating multiple Consumers", "status": "Resolved", "reporter": "Eddie Fast", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2010-01-12T05:22:27.000+0000", "updated": "2010-06-24T03:54:31.000+0000", "description": "We create multiple MessageConsumers with different selectors.  This can be upwards of 50 or so consumers per client.\n\nWe recently upgraded to 3.1 from 2.2.2.    We also upgraded our ActiveMQ Server to 5.3 from 5.2.\n\nAfter upgrading, we've been seeing random, but frequent freezing in our clients.  I've narrowed it down to where it creates the MessageConsumer and calls setMessageListener();\n\nIt seems to be stuck, waiting for a thread to join.\n\nI've modified the main.cpp to exhibit this behavior, but I've only been able to reproduce it randomly.   It seems to happen more frequently if you stick a breakpoint on this line in Thread.cpp,  Thread::join():\n\nThread::join( INFINITE, 0 );\n\n\nHere's the callstack where it freezes, which is consistent in our clients as well as the main.cpp example:\n\n \tntdll.dll!76fff871() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!76fff871() \t\n \tKernelBase.dll!75e20816() \t\n \tkernel32.dll!755b1138() \t\n \tactivemq-cppd.dll!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0239e0e0, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join()  Line 421\tC++\n>\tactivemq-cppd.dll!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener * listener=0x0018fe0c)  Line 523\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::run()  Line 247 + 0x5b bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x01df7f68)  Line 133 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadWorker(void * arg=0x01df7f68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x01dfafd8)  Line 331\tC\n\n\n\nTo modify main.cpp, it's pretty simple.  Instead of creating 1 MessageConsumer in HelloWorldConsumer::run(), I've created 50:\n\n{quote}\n// put this line with the class variables\nstd::vector<MessageConsumer*> consumers;\n\nfor ( int i = 0; i < 50; i++ )\n{{\n         // Create a MessageConsumer from the Session to the Topic or Queue\n         consumers.push_back( session->createConsumer( destination ) );\n         consumers.back()->setMessageListener( this );\n}}\n{quote}\n\nI'm using the standard .conf for the server.    I've reverted to 2.2.2 and have no issues.\n\nAny ideas?", "comments": [], "text": "Freeze when creating multiple Consumers\n\nDescription:\nWe create multiple MessageConsumers with different selectors.  This can be upwards of 50 or so consumers per client.\n\nWe recently upgraded to 3.1 from 2.2.2.    We also upgraded our ActiveMQ Server to 5.3 from 5.2.\n\nAfter upgrading, we've been seeing random, but frequent freezing in our clients.  I've narrowed it down to where it creates the MessageConsumer and calls setMessageListener();\n\nIt seems to be stuck, waiting for a thread to join.\n\nI've modified the main.cpp to exhibit this behavior, but I've only been able to reproduce it randomly.   It seems to happen more frequently if you stick a breakpoint on this line in Thread.cpp,  Thread::join():\n\nThread::join( INFINITE, 0 );\n\n\nHere's the callstack where it freezes, which is consistent in our clients as well as the main.cpp example:\n\n \tntdll.dll!76fff871() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!76fff871() \t\n \tKernelBase.dll!75e20816() \t\n \tkernel32.dll!755b1138() \t\n \tactivemq-cppd.dll!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0239e0e0, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join()  Line 421\tC++\n>\tactivemq-cppd.dll!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener * listener=0x0018fe0c)  Line 523\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::run()  Line 247 + 0x5b bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x01df7f68)  Line 133 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadWorker(void * arg=0x01df7f68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x01dfafd8)  Line 331\tC\n\n\n\nTo modify main.cpp, it's pretty simple.  Instead of creating 1 MessageConsumer in HelloWorldConsumer::run(), I've created 50:\n\n{quote}\n// put this line with the class variables\nstd::vector<MessageConsumer*> consumers;\n\nfor ( int i = 0; i < 50; i++ )\n{{\n         // Create a MessageConsumer from the Session to the Topic or Queue\n         consumers.push_back( session->createConsumer( destination ) );\n         consumers.back()->setMessageListener( this );\n}}\n{quote}\n\nI'm using the standard .conf for the server.    I've reverted to 2.2.2 and have no issues.\n\nAny ideas?\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Freeze when creating multiple Consumers\n\nDescription:\nWe create multiple MessageConsumers with different selectors.  This can be upwards of 50 or so consumers per client.\n\nWe recently upgraded to 3.1 from 2.2.2.    We also upgraded our ActiveMQ Server to 5.3 from 5.2.\n\nAfter upgrading, we've been seeing random, but frequent freezing in our clients.  I've narrowed it down to where it creates the MessageConsumer and calls setMessageListener();\n\nIt seems to be stuck, waiting for a thread to join.\n\nI've modified the main.cpp to exhibit this behavior, but I've only been able to reproduce it randomly.   It seems to happen more frequently if you stick a breakpoint on this line in Thread.cpp,  Thread::join():\n\nThread::join( INFINITE, 0 );\n\n\nHere's the callstack where it freezes, which is consistent in our clients as well as the main.cpp example:\n\n \tntdll.dll!76fff871() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]\t\n \tntdll.dll!76fff871() \t\n \tKernelBase.dll!75e20816() \t\n \tkernel32.dll!755b1138() \t\n \tactivemq-cppd.dll!decaf::internal::util::concurrent::ConditionImpl::wait(decaf::util::concurrent::ConditionHandle * condition=0x0239e0e0, __int64 mills=4294967295, __int64 nanos=0)  Line 110 + 0x10 bytes\tC++\n \tactivemq-cppd.dll!decaf::util::concurrent::Mutex::wait(__int64 millisecs=4294967295, int nanos=0)  Line 124 + 0x20 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join(__int64 millisecs=4294967295, unsigned int nanos=0)  Line 464 + 0x36 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::join()  Line 421\tC++\n>\tactivemq-cppd.dll!activemq::threads::DedicatedTaskRunner::shutdown()  Line 83\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSessionExecutor::stop()  Line 110\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQSession::stop()  Line 807\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConsumer::setMessageListener(cms::MessageListener * listener=0x0018fe0c)  Line 523\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::run()  Line 247 + 0x5b bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::ThreadProperties::runCallback(decaf::lang::ThreadProperties * properties=0x01df7f68)  Line 133 + 0x11 bytes\tC++\n \tactivemq-cppd.dll!`anonymous namespace'::threadWorker(void * arg=0x01df7f68)  Line 204 + 0x9 bytes\tC++\n \tmsvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr90d.dll!_threadstartex(void * ptd=0x01dfafd8)  Line 331\tC\n\n\n\nTo modify main.cpp, it's pretty simple.  Instead of creating 1 MessageConsumer in HelloWorldConsumer::run(), I've created 50:\n\n{quote}\n// put this line with the class variables\nstd::vector<MessageConsumer*> consumers;\n\nfor ( int i = 0; i < 50; i++ )\n{{\n         // Create a MessageConsumer from the Session to the Topic or Queue\n         consumers.push_back( session->createConsumer( destination ) );\n         consumers.back()->setMessageListener( this );\n}}\n{quote}\n\nI'm using the standard .conf for the server.    I've reverted to 2.2.2 and have no issues.\n\nAny ideas?\n\n\nComments:\n", "classification": "Classify the issue 'Freeze when creating multiple Consumers' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-277?\nA: We create multiple MessageConsumers with different selectors.  This can be upwards of 50 or so consumers per client.\n\nWe recently upgraded to 3.1 from 2.2.2.    We also upgraded our ActiveMQ Server to 5.3 from 5.2.\n\nAfter upgrading, we've been seeing random, but frequent freezing in our clients.  I've narrowed it down to where it creates the MessageConsumer and calls setMessageListener();\n\nIt seem"}}
{"issue_key": "AMQCPP-276", "project": "AMQCPP", "title": "Please declare destructor to be protected in UncaughtExceptionHandler", "status": "Closed", "reporter": "Jim Lloyd", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-01-08T16:57:55.000+0000", "updated": "2010-01-08T18:44:49.000+0000", "description": "Please consider adding a protected destructor to UncaughtExceptionHandler. In source file src/main/decaf/lang/Thread.h, add the two lines highlighted with 'TO BE ADDED' below:\n\n        class UncaughtExceptionHandler {\n        public:\n\n            /**\n             * Method invoked when the given thread terminates due to the given uncaught exception.\n             *\n             * This method is defined to indicate that it will not throw an exception, throwing\n             * and exception from this method will on most systems result in a segmentation fault.\n             */\n            virtual void uncaughtException( const Thread* thread, const Throwable& error ) throw() = 0;\n        protected:                                                      // TO BE ADDED\n            ~UncaughtExceptionHandler() {}         // TO BE ADDED\n        };\n\nI compile with -Wall -Wextra -Werror and was getting compile errors because UncaughtExceptionHandler had a virtual method without a virtual destructor. It looks like a protected nonvirtual dtor is sufficient to eliminate that warning (with gcc 4.1.2)", "comments": [], "text": "Please declare destructor to be protected in UncaughtExceptionHandler\n\nDescription:\nPlease consider adding a protected destructor to UncaughtExceptionHandler. In source file src/main/decaf/lang/Thread.h, add the two lines highlighted with 'TO BE ADDED' below:\n\n        class UncaughtExceptionHandler {\n        public:\n\n            /**\n             * Method invoked when the given thread terminates due to the given uncaught exception.\n             *\n             * This method is defined to indicate that it will not throw an exception, throwing\n             * and exception from this method will on most systems result in a segmentation fault.\n             */\n            virtual void uncaughtException( const Thread* thread, const Throwable& error ) throw() = 0;\n        protected:                                                      // TO BE ADDED\n            ~UncaughtExceptionHandler() {}         // TO BE ADDED\n        };\n\nI compile with -Wall -Wextra -Werror and was getting compile errors because UncaughtExceptionHandler had a virtual method without a virtual destructor. It looks like a protected nonvirtual dtor is sufficient to eliminate that warning (with gcc 4.1.2)\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Please declare destructor to be protected in UncaughtExceptionHandler\n\nDescription:\nPlease consider adding a protected destructor to UncaughtExceptionHandler. In source file src/main/decaf/lang/Thread.h, add the two lines highlighted with 'TO BE ADDED' below:\n\n        class UncaughtExceptionHandler {\n        public:\n\n            /**\n             * Method invoked when the given thread terminates due to the given uncaught exception.\n             *\n             * This method is defined to indicate that it will not throw an exception, throwing\n             * and exception from this method will on most systems result in a segmentation fault.\n             */\n            virtual void uncaughtException( const Thread* thread, const Throwable& error ) throw() = 0;\n        protected:                                                      // TO BE ADDED\n            ~UncaughtExceptionHandler() {}         // TO BE ADDED\n        };\n\nI compile with -Wall -Wextra -Werror and was getting compile errors because UncaughtExceptionHandler had a virtual method without a virtual destructor. It looks like a protected nonvirtual dtor is sufficient to eliminate that warning (with gcc 4.1.2)\n\n\nComments:\n", "classification": "Classify the issue 'Please declare destructor to be protected in UncaughtExceptionHandler' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-276?\nA: Please consider adding a protected destructor to UncaughtExceptionHandler. In source file src/main/decaf/lang/Thread.h, add the two lines highlighted with 'TO BE ADDED' below:\n\n        class UncaughtExceptionHandler {\n        public:\n\n            /**\n             * Method invoked when the given thread terminates due to the given uncaught exception.\n             *\n             * This method is defi"}}
{"issue_key": "AMQCPP-275", "project": "AMQCPP", "title": "Thread::UncaughtExceptionHandler missing virtual destructor", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2010-01-08T13:56:32.000+0000", "updated": "2010-01-08T13:59:18.000+0000", "description": "Add a virtual destructor to remove warnings.", "comments": [], "text": "Thread::UncaughtExceptionHandler missing virtual destructor\n\nDescription:\nAdd a virtual destructor to remove warnings.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Thread::UncaughtExceptionHandler missing virtual destructor\n\nDescription:\nAdd a virtual destructor to remove warnings.\n\nComments:\n", "classification": "Classify the issue 'Thread::UncaughtExceptionHandler missing virtual destructor' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-275?\nA: Add a virtual destructor to remove warnings."}}
{"issue_key": "AMQCPP-274", "project": "AMQCPP", "title": "Refactor Commands toString methods and Logging Transport to make debugging easier", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-12-30T23:12:51.000+0000", "updated": "2009-12-30T23:14:43.000+0000", "description": "Update the Command object's toString methods to make debugging problems with the client easier.  Reduce the overall data output and make it write to only one line per Command.", "comments": [], "text": "Refactor Commands toString methods and Logging Transport to make debugging easier\n\nDescription:\nUpdate the Command object's toString methods to make debugging problems with the client easier.  Reduce the overall data output and make it write to only one line per Command.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Refactor Commands toString methods and Logging Transport to make debugging easier\n\nDescription:\nUpdate the Command object's toString methods to make debugging problems with the client easier.  Reduce the overall data output and make it write to only one line per Command.\n\nComments:\n", "classification": "Classify the issue 'Refactor Commands toString methods and Logging Transport to make debugging easier' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-274?\nA: Update the Command object's toString methods to make debugging problems with the client easier.  Reduce the overall data output and make it write to only one line per Command."}}
{"issue_key": "AMQCPP-273", "project": "AMQCPP", "title": "Segmentation violation after pure virtual method called in tempdest_advisory_producer example", "status": "Resolved", "reporter": "Arjan van den Berg", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-12-22T13:25:53.000+0000", "updated": "2010-03-08T13:56:18.000+0000", "description": "To reproduce:\nmake check\ncd src/examples\nrun tempdest_advisory_producer.\nResult:\n=====================================================\nStarting the example:\n-----------------------------------------------------\n-----------------------------------------------------\nFinished with the example.\n=====================================================\npure virtual method called\nterminate called without an active exception\nAborted\n\nSometimes also the following is printed:\npure virtual method called\nterminate called after throwing an instance of 'decaf::io::IOException'\n  what():  DataInputStream::readLong - Reached EOF\n\ngdb backtrace (generated with libtool gdb tempdest_advisory_producer):\n(gdb) bt\n#0  0x00002b9159a6855a in Lock (this=0x44bc9080, object=0x747d510,\n    intiallyLocked=true) at ./decaf/util/concurrent/Lock.h:96\n#1  0x00002b9159da8558 in decaf::lang::ThreadProperties::runCallback (\n    properties=0x747d4b0) at decaf/lang/Thread.cpp:157\n#2  0x00002b9159da5d2b in threadWorker (arg=0x747d4b0)\n    at decaf/lang/Thread.cpp:186\n#3  0x00002b915ae15617 in start_thread () from /lib64/libpthread.so.0\n#4  0x00002b915b590c2d in clone () from /lib64/libc.so.6", "comments": [], "text": "Segmentation violation after pure virtual method called in tempdest_advisory_producer example\n\nDescription:\nTo reproduce:\nmake check\ncd src/examples\nrun tempdest_advisory_producer.\nResult:\n=====================================================\nStarting the example:\n-----------------------------------------------------\n-----------------------------------------------------\nFinished with the example.\n=====================================================\npure virtual method called\nterminate called without an active exception\nAborted\n\nSometimes also the following is printed:\npure virtual method called\nterminate called after throwing an instance of 'decaf::io::IOException'\n  what():  DataInputStream::readLong - Reached EOF\n\ngdb backtrace (generated with libtool gdb tempdest_advisory_producer):\n(gdb) bt\n#0  0x00002b9159a6855a in Lock (this=0x44bc9080, object=0x747d510,\n    intiallyLocked=true) at ./decaf/util/concurrent/Lock.h:96\n#1  0x00002b9159da8558 in decaf::lang::ThreadProperties::runCallback (\n    properties=0x747d4b0) at decaf/lang/Thread.cpp:157\n#2  0x00002b9159da5d2b in threadWorker (arg=0x747d4b0)\n    at decaf/lang/Thread.cpp:186\n#3  0x00002b915ae15617 in start_thread () from /lib64/libpthread.so.0\n#4  0x00002b915b590c2d in clone () from /lib64/libc.so.6\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation violation after pure virtual method called in tempdest_advisory_producer example\n\nDescription:\nTo reproduce:\nmake check\ncd src/examples\nrun tempdest_advisory_producer.\nResult:\n=====================================================\nStarting the example:\n-----------------------------------------------------\n-----------------------------------------------------\nFinished with the example.\n=====================================================\npure virtual method called\nterminate called without an active exception\nAborted\n\nSometimes also the following is printed:\npure virtual method called\nterminate called after throwing an instance of 'decaf::io::IOException'\n  what():  DataInputStream::readLong - Reached EOF\n\ngdb backtrace (generated with libtool gdb tempdest_advisory_producer):\n(gdb) bt\n#0  0x00002b9159a6855a in Lock (this=0x44bc9080, object=0x747d510,\n    intiallyLocked=true) at ./decaf/util/concurrent/Lock.h:96\n#1  0x00002b9159da8558 in decaf::lang::ThreadProperties::runCallback (\n    properties=0x747d4b0) at decaf/lang/Thread.cpp:157\n#2  0x00002b9159da5d2b in threadWorker (arg=0x747d4b0)\n    at decaf/lang/Thread.cpp:186\n#3  0x00002b915ae15617 in start_thread () from /lib64/libpthread.so.0\n#4  0x00002b915b590c2d in clone () from /lib64/libc.so.6\n\nComments:\n", "classification": "Classify the issue 'Segmentation violation after pure virtual method called in tempdest_advisory_producer example' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-273?\nA: To reproduce:\nmake check\ncd src/examples\nrun tempdest_advisory_producer.\nResult:\n=====================================================\nStarting the example:\n-----------------------------------------------------\n-----------------------------------------------------\nFinished with the example.\n=====================================================\npure virtual method called\nterminate called without an"}}
{"issue_key": "AMQCPP-272", "project": "AMQCPP", "title": "MessageProducer doesn't throw correct exception when send method used incorrectly.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-12-15T19:29:13.000+0000", "updated": "2009-12-15T21:01:00.000+0000", "description": "When the send method is called the client code should be checking to ensure that a destination isn't specified that is different from the default destination if one was used to create the producer.  The code should be checking the various condition and throwing the correct exceptions.\n\nThe CMS documentation should also be updated to be more explicit about what exceptions are thrown from the send method.", "comments": [], "text": "MessageProducer doesn't throw correct exception when send method used incorrectly.\n\nDescription:\nWhen the send method is called the client code should be checking to ensure that a destination isn't specified that is different from the default destination if one was used to create the producer.  The code should be checking the various condition and throwing the correct exceptions.\n\nThe CMS documentation should also be updated to be more explicit about what exceptions are thrown from the send method.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: MessageProducer doesn't throw correct exception when send method used incorrectly.\n\nDescription:\nWhen the send method is called the client code should be checking to ensure that a destination isn't specified that is different from the default destination if one was used to create the producer.  The code should be checking the various condition and throwing the correct exceptions.\n\nThe CMS documentation should also be updated to be more explicit about what exceptions are thrown from the send method.\n\nComments:\n", "classification": "Classify the issue 'MessageProducer doesn't throw correct exception when send method used incorrectly.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-272?\nA: When the send method is called the client code should be checking to ensure that a destination isn't specified that is different from the default destination if one was used to create the producer.  The code should be checking the various condition and throwing the correct exceptions.\n\nThe CMS documentation should also be updated to be more explicit about what exceptions are thrown from the send m"}}
{"issue_key": "AMQCPP-271", "project": "AMQCPP", "title": "Connection shutdown crashes if the server went down", "status": "Resolved", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-12-04T20:59:51.000+0000", "updated": "2009-12-06T18:36:44.000+0000", "description": "If the activemq server is brought down while a consumer is active and not using failover transport, the connection close will result in a pure virtual method call, and if using valgrind many errors are reported.\n\nThe problem can be easily shown with the modified example SimpleAsyncConsumer.cpp, by commenting out the exit call in onException method and by not using failover transport.\n\nOnce modified, start the example, shutdown the activemq server and press quit in the example.  \n\nThis has worked fine at least in version 2.2.2, I did not test 3.0.1.", "comments": [], "text": "Connection shutdown crashes if the server went down\n\nDescription:\nIf the activemq server is brought down while a consumer is active and not using failover transport, the connection close will result in a pure virtual method call, and if using valgrind many errors are reported.\n\nThe problem can be easily shown with the modified example SimpleAsyncConsumer.cpp, by commenting out the exit call in onException method and by not using failover transport.\n\nOnce modified, start the example, shutdown the activemq server and press quit in the example.  \n\nThis has worked fine at least in version 2.2.2, I did not test 3.0.1.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Connection shutdown crashes if the server went down\n\nDescription:\nIf the activemq server is brought down while a consumer is active and not using failover transport, the connection close will result in a pure virtual method call, and if using valgrind many errors are reported.\n\nThe problem can be easily shown with the modified example SimpleAsyncConsumer.cpp, by commenting out the exit call in onException method and by not using failover transport.\n\nOnce modified, start the example, shutdown the activemq server and press quit in the example.  \n\nThis has worked fine at least in version 2.2.2, I did not test 3.0.1.\n\n\nComments:\n", "classification": "Classify the issue 'Connection shutdown crashes if the server went down' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-271?\nA: If the activemq server is brought down while a consumer is active and not using failover transport, the connection close will result in a pure virtual method call, and if using valgrind many errors are reported.\n\nThe problem can be easily shown with the modified example SimpleAsyncConsumer.cpp, by commenting out the exit call in onException method and by not using failover transport.\n\nOnce modifie"}}
{"issue_key": "AMQCPP-270", "project": "AMQCPP", "title": "Broker exception on message Ack, ", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-11-23T19:33:44.000+0000", "updated": "2009-11-23T19:33:59.000+0000", "description": "Certain cases that involved acknowledging a message from the async callback of a MessageListener when in Client or Individual Ack modes can result in this error from the broker: \"Could not correlate acknowledgment with dispatched message\"\n\nThis is the same situation as documented in AMQ-2489", "comments": [], "text": "Broker exception on message Ack, \n\nDescription:\nCertain cases that involved acknowledging a message from the async callback of a MessageListener when in Client or Individual Ack modes can result in this error from the broker: \"Could not correlate acknowledgment with dispatched message\"\n\nThis is the same situation as documented in AMQ-2489\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Broker exception on message Ack, \n\nDescription:\nCertain cases that involved acknowledging a message from the async callback of a MessageListener when in Client or Individual Ack modes can result in this error from the broker: \"Could not correlate acknowledgment with dispatched message\"\n\nThis is the same situation as documented in AMQ-2489\n\nComments:\n", "classification": "Classify the issue 'Broker exception on message Ack, ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-270?\nA: Certain cases that involved acknowledging a message from the async callback of a MessageListener when in Client or Individual Ack modes can result in this error from the broker: \"Could not correlate acknowledgment with dispatched message\"\n\nThis is the same situation as documented in AMQ-2489"}}
{"issue_key": "AMQCPP-269", "project": "AMQCPP", "title": "Update CMS API to include the proper exceptions in the Message interfaces throw declarations", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-11-19T21:43:32.000+0000", "updated": "2009-11-20T00:16:26.000+0000", "description": "CMS now includes several exception types:\n\nMessageFormatException\nMessageEOFException\nMessageNotReadableException\n\netc...\n\nThe CMS Message interfaces should be updated to indicate which of these is thrown from the various methods in the Message classes.  The ActiveMQ implementation of the CMS interface will need to be updated as well to actually throw these types.", "comments": [], "text": "Update CMS API to include the proper exceptions in the Message interfaces throw declarations\n\nDescription:\nCMS now includes several exception types:\n\nMessageFormatException\nMessageEOFException\nMessageNotReadableException\n\netc...\n\nThe CMS Message interfaces should be updated to indicate which of these is thrown from the various methods in the Message classes.  The ActiveMQ implementation of the CMS interface will need to be updated as well to actually throw these types.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update CMS API to include the proper exceptions in the Message interfaces throw declarations\n\nDescription:\nCMS now includes several exception types:\n\nMessageFormatException\nMessageEOFException\nMessageNotReadableException\n\netc...\n\nThe CMS Message interfaces should be updated to indicate which of these is thrown from the various methods in the Message classes.  The ActiveMQ implementation of the CMS interface will need to be updated as well to actually throw these types.\n\n\n\nComments:\n", "classification": "Classify the issue 'Update CMS API to include the proper exceptions in the Message interfaces throw declarations' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-269?\nA: CMS now includes several exception types:\n\nMessageFormatException\nMessageEOFException\nMessageNotReadableException\n\netc...\n\nThe CMS Message interfaces should be updated to indicate which of these is thrown from the various methods in the Message classes.  The ActiveMQ implementation of the CMS interface will need to be updated as well to actually throw these types.\n\n"}}
{"issue_key": "AMQCPP-268", "project": "AMQCPP", "title": "Unspecified exception can be thrown from decaf::io::ByteArrayOutputStream::write( const unsigned char* buffer,  std::size_t offset,  std::size_t len )", "status": "Resolved", "reporter": "Olivier Langlois", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-11-17T19:38:35.000+0000", "updated": "2009-11-17T20:26:21.000+0000", "description": "std::bad_alloc can be thrown when appending data to the STL vector.\n\nThe proposed fix is to replace:\n\n    std::back_insert_iterator< std::vector<unsigned char> > iter( *activeBuffer );\n    std::copy( buffer + offset, buffer + offset + len, iter );\n\nwith\n\ntry\n{\n    activeBuffer->insert( activeBuffer->end(), buffer + offset, buffer + offset + len );\n}\nDECAF_CATCHALL_THROW( IOException )\n\nNote that the proposition is getting rid of the std::back_insert_iterator which is calling push_back() method as many times as there is chars to copy vs a single call to insert().\n\nIf proposition is accepted then you could also remove:\n\n#include <algorithm>", "comments": [], "text": "Unspecified exception can be thrown from decaf::io::ByteArrayOutputStream::write( const unsigned char* buffer,  std::size_t offset,  std::size_t len )\n\nDescription:\nstd::bad_alloc can be thrown when appending data to the STL vector.\n\nThe proposed fix is to replace:\n\n    std::back_insert_iterator< std::vector<unsigned char> > iter( *activeBuffer );\n    std::copy( buffer + offset, buffer + offset + len, iter );\n\nwith\n\ntry\n{\n    activeBuffer->insert( activeBuffer->end(), buffer + offset, buffer + offset + len );\n}\nDECAF_CATCHALL_THROW( IOException )\n\nNote that the proposition is getting rid of the std::back_insert_iterator which is calling push_back() method as many times as there is chars to copy vs a single call to insert().\n\nIf proposition is accepted then you could also remove:\n\n#include <algorithm>\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unspecified exception can be thrown from decaf::io::ByteArrayOutputStream::write( const unsigned char* buffer,  std::size_t offset,  std::size_t len )\n\nDescription:\nstd::bad_alloc can be thrown when appending data to the STL vector.\n\nThe proposed fix is to replace:\n\n    std::back_insert_iterator< std::vector<unsigned char> > iter( *activeBuffer );\n    std::copy( buffer + offset, buffer + offset + len, iter );\n\nwith\n\ntry\n{\n    activeBuffer->insert( activeBuffer->end(), buffer + offset, buffer + offset + len );\n}\nDECAF_CATCHALL_THROW( IOException )\n\nNote that the proposition is getting rid of the std::back_insert_iterator which is calling push_back() method as many times as there is chars to copy vs a single call to insert().\n\nIf proposition is accepted then you could also remove:\n\n#include <algorithm>\n\n\nComments:\n", "classification": "Classify the issue 'Unspecified exception can be thrown from decaf::io::ByteArrayOutputStream::write( const unsigned char* buffer,  std::size_t offset,  std::size_t len )' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-268?\nA: std::bad_alloc can be thrown when appending data to the STL vector.\n\nThe proposed fix is to replace:\n\n    std::back_insert_iterator< std::vector<unsigned char> > iter( *activeBuffer );\n    std::copy( buffer + offset, buffer + offset + len, iter );\n\nwith\n\ntry\n{\n    activeBuffer->insert( activeBuffer->end(), buffer + offset, buffer + offset + len );\n}\nDECAF_CATCHALL_THROW( IOException )\n\nNote that t"}}
{"issue_key": "AMQCPP-267", "project": "AMQCPP", "title": "ResponseCorrelator::request() exception safety concern", "status": "Resolved", "reporter": "Olivier Langlois", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2009-11-17T15:37:14.000+0000", "updated": "2009-11-17T21:14:05.000+0000", "description": "It seems to me that since the function oneway() and futureResponse::getResponse() can throw exceptions, the code should make sure that the requestMap is cleared in all cases.\n\nThis risk is low but nevertheless I would not rely on an external software component good behavior to ensure the client invariants. This is especially true since the precaution is extremely simple.\n\nI would propose something like:\n\ntry\n{\n        // Send the request.\n        next->oneway( command );\n\n        // Get the response.\n        response = futureResponse->getResponse( timeout );\n}\ncatch(...)\n{\n        // Perform cleanup on the map.\n        synchronized( &mapMutex )\n       {\n\n            // We do not want memory corruption by accessing freed\n            // futureResponse objects by accident in onCommand() - get this thing out\n            // of the map.\n            requestMap.erase( command->getCommandId() );\n        }\n       throw;\n}\nsynchronized( &mapMutex ){\n\n    // We've done our waiting - get this thing out\n    // of the map.\n    requestMap.erase( command->getCommandId() );\n}", "comments": [], "text": "ResponseCorrelator::request() exception safety concern\n\nDescription:\nIt seems to me that since the function oneway() and futureResponse::getResponse() can throw exceptions, the code should make sure that the requestMap is cleared in all cases.\n\nThis risk is low but nevertheless I would not rely on an external software component good behavior to ensure the client invariants. This is especially true since the precaution is extremely simple.\n\nI would propose something like:\n\ntry\n{\n        // Send the request.\n        next->oneway( command );\n\n        // Get the response.\n        response = futureResponse->getResponse( timeout );\n}\ncatch(...)\n{\n        // Perform cleanup on the map.\n        synchronized( &mapMutex )\n       {\n\n            // We do not want memory corruption by accessing freed\n            // futureResponse objects by accident in onCommand() - get this thing out\n            // of the map.\n            requestMap.erase( command->getCommandId() );\n        }\n       throw;\n}\nsynchronized( &mapMutex ){\n\n    // We've done our waiting - get this thing out\n    // of the map.\n    requestMap.erase( command->getCommandId() );\n}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ResponseCorrelator::request() exception safety concern\n\nDescription:\nIt seems to me that since the function oneway() and futureResponse::getResponse() can throw exceptions, the code should make sure that the requestMap is cleared in all cases.\n\nThis risk is low but nevertheless I would not rely on an external software component good behavior to ensure the client invariants. This is especially true since the precaution is extremely simple.\n\nI would propose something like:\n\ntry\n{\n        // Send the request.\n        next->oneway( command );\n\n        // Get the response.\n        response = futureResponse->getResponse( timeout );\n}\ncatch(...)\n{\n        // Perform cleanup on the map.\n        synchronized( &mapMutex )\n       {\n\n            // We do not want memory corruption by accessing freed\n            // futureResponse objects by accident in onCommand() - get this thing out\n            // of the map.\n            requestMap.erase( command->getCommandId() );\n        }\n       throw;\n}\nsynchronized( &mapMutex ){\n\n    // We've done our waiting - get this thing out\n    // of the map.\n    requestMap.erase( command->getCommandId() );\n}\n\n\nComments:\n", "classification": "Classify the issue 'ResponseCorrelator::request() exception safety concern' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-267?\nA: It seems to me that since the function oneway() and futureResponse::getResponse() can throw exceptions, the code should make sure that the requestMap is cleared in all cases.\n\nThis risk is low but nevertheless I would not rely on an external software component good behavior to ensure the client invariants. This is especially true since the precaution is extremely simple.\n\nI would propose something"}}
{"issue_key": "AMQCPP-266", "project": "AMQCPP", "title": "Client Ack is not applied across the session", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-11-12T16:34:37.000+0000", "updated": "2009-11-13T14:14:07.000+0000", "description": "When a Session is in Client Ack it should apply the ack to all the consumers in the Session not just the one that the message came from.", "comments": [], "text": "Client Ack is not applied across the session\n\nDescription:\nWhen a Session is in Client Ack it should apply the ack to all the consumers in the Session not just the one that the message came from.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Client Ack is not applied across the session\n\nDescription:\nWhen a Session is in Client Ack it should apply the ack to all the consumers in the Session not just the one that the message came from.\n\nComments:\n", "classification": "Classify the issue 'Client Ack is not applied across the session' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-266?\nA: When a Session is in Client Ack it should apply the ack to all the consumers in the Session not just the one that the message came from."}}
{"issue_key": "AMQCPP-265", "project": "AMQCPP", "title": "The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.", "status": "Resolved", "reporter": "Jeremy Judeaux", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-11-09T17:33:09.000+0000", "updated": "2009-11-11T19:32:55.000+0000", "description": "The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\nCMS uses a list to implement the StreamMessage, JMS does not. This list (de)serializes its size before (de)serializing its content.\n\nTested with CMS 3.0.1 and JMS 5.2.0.\n\nMay the both implementations work together ?\n\nPS : is there any specification about how a StreamMessage should be implemented ?", "comments": [], "text": "The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\n\nDescription:\nThe C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\nCMS uses a list to implement the StreamMessage, JMS does not. This list (de)serializes its size before (de)serializing its content.\n\nTested with CMS 3.0.1 and JMS 5.2.0.\n\nMay the both implementations work together ?\n\nPS : is there any specification about how a StreamMessage should be implemented ?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\n\nDescription:\nThe C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\nCMS uses a list to implement the StreamMessage, JMS does not. This list (de)serializes its size before (de)serializing its content.\n\nTested with CMS 3.0.1 and JMS 5.2.0.\n\nMay the both implementations work together ?\n\nPS : is there any specification about how a StreamMessage should be implemented ?\n\nComments:\n", "classification": "Classify the issue 'The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-265?\nA: The C++ ActiveMQ StreamMessage and the Java ActiveMQ StreamMessage are not compatible.\nCMS uses a list to implement the StreamMessage, JMS does not. This list (de)serializes its size before (de)serializing its content.\n\nTested with CMS 3.0.1 and JMS 5.2.0.\n\nMay the both implementations work together ?\n\nPS : is there any specification about how a StreamMessage should be implemented ?"}}
{"issue_key": "AMQCPP-264", "project": "AMQCPP", "title": "Added what() to CMSException", "status": "Resolved", "reporter": "Brian McKinnon", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-10-20T16:27:40.000+0000", "updated": "2009-10-20T18:05:33.000+0000", "description": "While trying to track down an error I noticed that the exceptions kept returning \"Unknown Exception\".  The CMSException was inheriting std::exception but not overloading the what() operator, so no information could be extracted without knowing about CMSException.  To fix the issue and return useful error messages I overloaded the what() function inside CMSException.", "comments": [], "text": "Added what() to CMSException\n\nDescription:\nWhile trying to track down an error I noticed that the exceptions kept returning \"Unknown Exception\".  The CMSException was inheriting std::exception but not overloading the what() operator, so no information could be extracted without knowing about CMSException.  To fix the issue and return useful error messages I overloaded the what() function inside CMSException.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Added what() to CMSException\n\nDescription:\nWhile trying to track down an error I noticed that the exceptions kept returning \"Unknown Exception\".  The CMSException was inheriting std::exception but not overloading the what() operator, so no information could be extracted without knowing about CMSException.  To fix the issue and return useful error messages I overloaded the what() function inside CMSException.\n\nComments:\n", "classification": "Classify the issue 'Added what() to CMSException' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-264?\nA: While trying to track down an error I noticed that the exceptions kept returning \"Unknown Exception\".  The CMSException was inheriting std::exception but not overloading the what() operator, so no information could be extracted without knowing about CMSException.  To fix the issue and return useful error messages I overloaded the what() function inside CMSException."}}
{"issue_key": "AMQCPP-263", "project": "AMQCPP", "title": "Use of in-class static const variables in cms/DeliveryMode.h results in crash while linking with --no-undefined option", "status": "Resolved", "reporter": "Romain Chanu", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2009-09-29T03:26:17.000+0000", "updated": "2009-09-29T13:23:52.000+0000", "description": "The constants variables defined in cms/DeliveryMode.h (i.e static const int PERSISTENT = 0 and static const int NON_PERSISTENT = 1;) are not defined out off the class. \n\nIn the following cases:\n\n- If you try to take the address of this constant variable.\n- You pass it to a function that takes a reference.\n- When used with the tertiary operator ?\n\nIt results in a crash while linking ActiveMQ-CPP library with an application using the linking option --no-undefined (GNU linker ld returns \"undefined references\" for these two variables).\n\nThe variables should be defined as an enumeration (like the way it has been done in cms/Session.h for the acknowledgment modes)", "comments": [], "text": "Use of in-class static const variables in cms/DeliveryMode.h results in crash while linking with --no-undefined option\n\nDescription:\nThe constants variables defined in cms/DeliveryMode.h (i.e static const int PERSISTENT = 0 and static const int NON_PERSISTENT = 1;) are not defined out off the class. \n\nIn the following cases:\n\n- If you try to take the address of this constant variable.\n- You pass it to a function that takes a reference.\n- When used with the tertiary operator ?\n\nIt results in a crash while linking ActiveMQ-CPP library with an application using the linking option --no-undefined (GNU linker ld returns \"undefined references\" for these two variables).\n\nThe variables should be defined as an enumeration (like the way it has been done in cms/Session.h for the acknowledgment modes)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Use of in-class static const variables in cms/DeliveryMode.h results in crash while linking with --no-undefined option\n\nDescription:\nThe constants variables defined in cms/DeliveryMode.h (i.e static const int PERSISTENT = 0 and static const int NON_PERSISTENT = 1;) are not defined out off the class. \n\nIn the following cases:\n\n- If you try to take the address of this constant variable.\n- You pass it to a function that takes a reference.\n- When used with the tertiary operator ?\n\nIt results in a crash while linking ActiveMQ-CPP library with an application using the linking option --no-undefined (GNU linker ld returns \"undefined references\" for these two variables).\n\nThe variables should be defined as an enumeration (like the way it has been done in cms/Session.h for the acknowledgment modes)\n\nComments:\n", "classification": "Classify the issue 'Use of in-class static const variables in cms/DeliveryMode.h results in crash while linking with --no-undefined option' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-263?\nA: The constants variables defined in cms/DeliveryMode.h (i.e static const int PERSISTENT = 0 and static const int NON_PERSISTENT = 1;) are not defined out off the class. \n\nIn the following cases:\n\n- If you try to take the address of this constant variable.\n- You pass it to a function that takes a reference.\n- When used with the tertiary operator ?\n\nIt results in a crash while linking ActiveMQ-CPP li"}}
{"issue_key": "AMQCPP-262", "project": "AMQCPP", "title": "exception message in checkWriteOnlyBody is wrong", "status": "Resolved", "reporter": "Eric van Gyzen", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2009-09-25T18:54:36.000+0000", "updated": "2009-09-25T19:00:14.000+0000", "description": "In the checkWriteOnlyBody method of the ActiveMQBytesMessage and ActiveMQStreamMessage classes, the message in the exception claims the opposite of reality.\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (working copy)\n@@ -70,8 +70,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (working copy)\n@@ -90,8 +90,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }", "comments": [], "text": "exception message in checkWriteOnlyBody is wrong\n\nDescription:\nIn the checkWriteOnlyBody method of the ActiveMQBytesMessage and ActiveMQStreamMessage classes, the message in the exception claims the opposite of reality.\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (working copy)\n@@ -70,8 +70,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (working copy)\n@@ -90,8 +90,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: exception message in checkWriteOnlyBody is wrong\n\nDescription:\nIn the checkWriteOnlyBody method of the ActiveMQBytesMessage and ActiveMQStreamMessage classes, the message in the exception claims the opposite of reality.\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (working copy)\n@@ -70,8 +70,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (revision 817354)\n+++ activemq-cpp/src/main/activemq/commands/ActiveMQStreamMessage.cpp   (working copy)\n@@ -90,8 +90,8 @@\n     if( !this->isReadOnlyBody() ){\n         throw exceptions::ActiveMQException(\n             __FILE__, __LINE__,\n-            \"message is in read-only mode and \"\n-            \"cannot be written to\" ).convertToCMSException();\n+            \"message is in write-only mode and \"\n+            \"cannot be read from\" ).convertToCMSException();\n     }\n }\n\n\n\nComments:\n", "classification": "Classify the issue 'exception message in checkWriteOnlyBody is wrong' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-262?\nA: In the checkWriteOnlyBody method of the ActiveMQBytesMessage and ActiveMQStreamMessage classes, the message in the exception claims the opposite of reality.\n\nIndex: activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp\n===================================================================\n--- activemq-cpp/src/main/activemq/commands/ActiveMQBytesMessage.cpp    (revision 817354)\n+++ activemq"}}
{"issue_key": "AMQCPP-261", "project": "AMQCPP", "title": "Handle Multibyte Strings or Strings encoded in Charsets other than US-ASCII", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-09-02T21:14:26.000+0000", "updated": "2010-03-12T21:51:41.000+0000", "description": "The CMS API defines the interface for Strings in the TextMessage using the C++ std::string and const char* primitives and doesn't consider character encodings in its interface or the use of multibyte string representations.  \n\nIn order to allow the use of Strings between Java and C++ and .NET clients the strings in the TextMessage as well as those in MapMessage, StreamMessage, and BytesMessage (when wreiteUTF and readUTF are called) as well as message properties of the string type are encoded in the JAVA standard Modified UTF-8 format for serialized strings.  This design makes the assumption that strings passed are in US-ASCII format and that the strings from the broker are also encoded with no char values greater than 255 and throws an exception if one is encountered.  \n\nThe CMS interface needs to be extended to allow for more flexible string handling and offer a mechanism to deal with string encodings other than ASCII. \n\nAnother alternative is to change the assumption about strings in the CMS API to assume that all string are given as either ASCII strings with chars < 127 and no embedded nulls or are already encoded by the user as Modified UTF-8 by the user so that a Java or .NET client can read all strings sent in CMS Messages as well.", "comments": [], "text": "Handle Multibyte Strings or Strings encoded in Charsets other than US-ASCII\n\nDescription:\nThe CMS API defines the interface for Strings in the TextMessage using the C++ std::string and const char* primitives and doesn't consider character encodings in its interface or the use of multibyte string representations.  \n\nIn order to allow the use of Strings between Java and C++ and .NET clients the strings in the TextMessage as well as those in MapMessage, StreamMessage, and BytesMessage (when wreiteUTF and readUTF are called) as well as message properties of the string type are encoded in the JAVA standard Modified UTF-8 format for serialized strings.  This design makes the assumption that strings passed are in US-ASCII format and that the strings from the broker are also encoded with no char values greater than 255 and throws an exception if one is encountered.  \n\nThe CMS interface needs to be extended to allow for more flexible string handling and offer a mechanism to deal with string encodings other than ASCII. \n\nAnother alternative is to change the assumption about strings in the CMS API to assume that all string are given as either ASCII strings with chars < 127 and no embedded nulls or are already encoded by the user as Modified UTF-8 by the user so that a Java or .NET client can read all strings sent in CMS Messages as well.\n\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Handle Multibyte Strings or Strings encoded in Charsets other than US-ASCII\n\nDescription:\nThe CMS API defines the interface for Strings in the TextMessage using the C++ std::string and const char* primitives and doesn't consider character encodings in its interface or the use of multibyte string representations.  \n\nIn order to allow the use of Strings between Java and C++ and .NET clients the strings in the TextMessage as well as those in MapMessage, StreamMessage, and BytesMessage (when wreiteUTF and readUTF are called) as well as message properties of the string type are encoded in the JAVA standard Modified UTF-8 format for serialized strings.  This design makes the assumption that strings passed are in US-ASCII format and that the strings from the broker are also encoded with no char values greater than 255 and throws an exception if one is encountered.  \n\nThe CMS interface needs to be extended to allow for more flexible string handling and offer a mechanism to deal with string encodings other than ASCII. \n\nAnother alternative is to change the assumption about strings in the CMS API to assume that all string are given as either ASCII strings with chars < 127 and no embedded nulls or are already encoded by the user as Modified UTF-8 by the user so that a Java or .NET client can read all strings sent in CMS Messages as well.\n\n\n\n\n\nComments:\n", "classification": "Classify the issue 'Handle Multibyte Strings or Strings encoded in Charsets other than US-ASCII' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-261?\nA: The CMS API defines the interface for Strings in the TextMessage using the C++ std::string and const char* primitives and doesn't consider character encodings in its interface or the use of multibyte string representations.  \n\nIn order to allow the use of Strings between Java and C++ and .NET clients the strings in the TextMessage as well as those in MapMessage, StreamMessage, and BytesMessage (wh"}}
{"issue_key": "AMQCPP-260", "project": "AMQCPP", "title": "Wrong exception propogated from Transport close methods", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-08-31T15:29:47.000+0000", "updated": "2009-08-31T20:18:35.000+0000", "description": "some close methods in the Transports layer allow exceptions other than the declared type to be thrown which can cause segfaults on some systems.", "comments": [], "text": "Wrong exception propogated from Transport close methods\n\nDescription:\nsome close methods in the Transports layer allow exceptions other than the declared type to be thrown which can cause segfaults on some systems.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Wrong exception propogated from Transport close methods\n\nDescription:\nsome close methods in the Transports layer allow exceptions other than the declared type to be thrown which can cause segfaults on some systems.\n\n\n\nComments:\n", "classification": "Classify the issue 'Wrong exception propogated from Transport close methods' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-260?\nA: some close methods in the Transports layer allow exceptions other than the declared type to be thrown which can cause segfaults on some systems.\n\n"}}
{"issue_key": "AMQCPP-259", "project": "AMQCPP", "title": "Temporary queue don't go away after killing the process", "status": "Closed", "reporter": "Edison Melo", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-08-19T16:38:13.000+0000", "updated": "2009-11-09T20:11:15.000+0000", "description": "I'm trying to implement a reliable request - response. I have java and c++ producers that create a temporary queue. When I kill the java producer, the temporary queue goes away, and I get a InvalidDestinationException trying to send a message to that queue.  When I kill the c++ producer the temporary queue stays and I get no errors from any kind.", "comments": [], "text": "Temporary queue don't go away after killing the process\n\nDescription:\nI'm trying to implement a reliable request - response. I have java and c++ producers that create a temporary queue. When I kill the java producer, the temporary queue goes away, and I get a InvalidDestinationException trying to send a message to that queue.  When I kill the c++ producer the temporary queue stays and I get no errors from any kind.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Temporary queue don't go away after killing the process\n\nDescription:\nI'm trying to implement a reliable request - response. I have java and c++ producers that create a temporary queue. When I kill the java producer, the temporary queue goes away, and I get a InvalidDestinationException trying to send a message to that queue.  When I kill the c++ producer the temporary queue stays and I get no errors from any kind.\n\nComments:\n", "classification": "Classify the issue 'Temporary queue don't go away after killing the process' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-259?\nA: I'm trying to implement a reliable request - response. I have java and c++ producers that create a temporary queue. When I kill the java producer, the temporary queue goes away, and I get a InvalidDestinationException trying to send a message to that queue.  When I kill the c++ producer the temporary queue stays and I get no errors from any kind."}}
{"issue_key": "AMQCPP-258", "project": "AMQCPP", "title": "Allow clients to attach a TransportListener to an ActiveMQConnection", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2009-08-10T15:35:06.000+0000", "updated": "2009-08-10T18:23:44.000+0000", "description": "Add methods in ActiveMQConnection to allow a client to set a TransprotListener on the Connection to be informed of Transport events.", "comments": [], "text": "Allow clients to attach a TransportListener to an ActiveMQConnection\n\nDescription:\nAdd methods in ActiveMQConnection to allow a client to set a TransprotListener on the Connection to be informed of Transport events.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Allow clients to attach a TransportListener to an ActiveMQConnection\n\nDescription:\nAdd methods in ActiveMQConnection to allow a client to set a TransprotListener on the Connection to be informed of Transport events.\n\nComments:\n", "classification": "Classify the issue 'Allow clients to attach a TransportListener to an ActiveMQConnection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-258?\nA: Add methods in ActiveMQConnection to allow a client to set a TransprotListener on the Connection to be informed of Transport events."}}
{"issue_key": "AMQCPP-257", "project": "AMQCPP", "title": "Segfault on session or connection cleanup", "status": "Resolved", "reporter": "Ben Watrous", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-07-28T17:26:02.000+0000", "updated": "2009-08-03T13:55:35.000+0000", "description": "I recently moved up to ActiveMQ CPP 3.0 (and now 3.0.1) from 2.2 to take advantage of the failover transport, and discovered a segfault during testing.  It may be related to my test procedure, but I have found a quick patch to activemq/core/ActiveMQSession.cpp that seems to resolve the issue.\n\nIt appears that in some cases of connection loss, the connection->disposeOf() call may throw.  In which case the Session is left in an invalid state - the producers or consumer that caused the exception is still in the list, but it has already been destroyed.  This leads to an invalid pointer access later on.\n\nIn the current test, the exception is thrown because the connection to the broker has been dropped so disposeOf fails.\n\nTest Procedure:\nOpen the attached example (modified version of the basic sample) in the Visual Studio debugger.\nSet a breakpoint at the \"producer->send( message );\" line.\nRun to breakpoint.\nTo simulate a broken connection, connect to broker via JMX console and execute the JMX \"Stop\" operation on the Connector for the producer. \nContinue the debugger.\n\n( Note: I \"Purge\" the TEST.FOO queue between runs since messages may sometimes be left in queue during this type of testing. )\n\nSuggested Patch to ActiveMQSession.cpp:\n\n153a154\n>       try {\n155a157,159\n>       }\n>       /* Absorb */\n>       AMQ_CATCHALL_NOTHROW()\n1042a1047\n>             this->consumers.remove( id );\n1045c1050\n<                 this->consumers.remove( id );\n---\n>             //                this->consumers.remove( id );\n1065a1071\n>             this->producers.remove( id );\n1068c1074\n<                 this->producers.remove( id );\n---\n>             //                this->producers.remove( id );", "comments": [], "text": "Segfault on session or connection cleanup\n\nDescription:\nI recently moved up to ActiveMQ CPP 3.0 (and now 3.0.1) from 2.2 to take advantage of the failover transport, and discovered a segfault during testing.  It may be related to my test procedure, but I have found a quick patch to activemq/core/ActiveMQSession.cpp that seems to resolve the issue.\n\nIt appears that in some cases of connection loss, the connection->disposeOf() call may throw.  In which case the Session is left in an invalid state - the producers or consumer that caused the exception is still in the list, but it has already been destroyed.  This leads to an invalid pointer access later on.\n\nIn the current test, the exception is thrown because the connection to the broker has been dropped so disposeOf fails.\n\nTest Procedure:\nOpen the attached example (modified version of the basic sample) in the Visual Studio debugger.\nSet a breakpoint at the \"producer->send( message );\" line.\nRun to breakpoint.\nTo simulate a broken connection, connect to broker via JMX console and execute the JMX \"Stop\" operation on the Connector for the producer. \nContinue the debugger.\n\n( Note: I \"Purge\" the TEST.FOO queue between runs since messages may sometimes be left in queue during this type of testing. )\n\nSuggested Patch to ActiveMQSession.cpp:\n\n153a154\n>       try {\n155a157,159\n>       }\n>       /* Absorb */\n>       AMQ_CATCHALL_NOTHROW()\n1042a1047\n>             this->consumers.remove( id );\n1045c1050\n<                 this->consumers.remove( id );\n---\n>             //                this->consumers.remove( id );\n1065a1071\n>             this->producers.remove( id );\n1068c1074\n<                 this->producers.remove( id );\n---\n>             //                this->producers.remove( id );\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segfault on session or connection cleanup\n\nDescription:\nI recently moved up to ActiveMQ CPP 3.0 (and now 3.0.1) from 2.2 to take advantage of the failover transport, and discovered a segfault during testing.  It may be related to my test procedure, but I have found a quick patch to activemq/core/ActiveMQSession.cpp that seems to resolve the issue.\n\nIt appears that in some cases of connection loss, the connection->disposeOf() call may throw.  In which case the Session is left in an invalid state - the producers or consumer that caused the exception is still in the list, but it has already been destroyed.  This leads to an invalid pointer access later on.\n\nIn the current test, the exception is thrown because the connection to the broker has been dropped so disposeOf fails.\n\nTest Procedure:\nOpen the attached example (modified version of the basic sample) in the Visual Studio debugger.\nSet a breakpoint at the \"producer->send( message );\" line.\nRun to breakpoint.\nTo simulate a broken connection, connect to broker via JMX console and execute the JMX \"Stop\" operation on the Connector for the producer. \nContinue the debugger.\n\n( Note: I \"Purge\" the TEST.FOO queue between runs since messages may sometimes be left in queue during this type of testing. )\n\nSuggested Patch to ActiveMQSession.cpp:\n\n153a154\n>       try {\n155a157,159\n>       }\n>       /* Absorb */\n>       AMQ_CATCHALL_NOTHROW()\n1042a1047\n>             this->consumers.remove( id );\n1045c1050\n<                 this->consumers.remove( id );\n---\n>             //                this->consumers.remove( id );\n1065a1071\n>             this->producers.remove( id );\n1068c1074\n<                 this->producers.remove( id );\n---\n>             //                this->producers.remove( id );\n\n\n\nComments:\n", "classification": "Classify the issue 'Segfault on session or connection cleanup' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-257?\nA: I recently moved up to ActiveMQ CPP 3.0 (and now 3.0.1) from 2.2 to take advantage of the failover transport, and discovered a segfault during testing.  It may be related to my test procedure, but I have found a quick patch to activemq/core/ActiveMQSession.cpp that seems to resolve the issue.\n\nIt appears that in some cases of connection loss, the connection->disposeOf() call may throw.  In which c"}}
{"issue_key": "AMQCPP-256", "project": "AMQCPP", "title": "Transaction has not been started exceptions on the broker with parallel transacted sessions", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2009-07-21T16:56:53.000+0000", "updated": "2009-07-23T15:38:47.000+0000", "description": "When using parallel transacted sessions and consumers to same queue each sharing the same connection, the messages are delivered but the broker 5.2 gets exceptions\n\njavax.jms.JMSException: Transaction 'TX:de411476-d65d-fff7-1e84-be7c9abd80b5:6' has not been started.\n\nand some messages are left on the broker even though they were delivered.\n\nThe issue seems to be related to multi-threading, by protecting each receive/commit with a lock the error does not happen.  I am sorry I don't have a test program ready, but it should be easy to reproduce by creating multiple transacted session threads with prefetchSize=1 and consuming messages, commiting after each message.  I have seen this happen both with consumers and listeners.", "comments": [], "text": "Transaction has not been started exceptions on the broker with parallel transacted sessions\n\nDescription:\nWhen using parallel transacted sessions and consumers to same queue each sharing the same connection, the messages are delivered but the broker 5.2 gets exceptions\n\njavax.jms.JMSException: Transaction 'TX:de411476-d65d-fff7-1e84-be7c9abd80b5:6' has not been started.\n\nand some messages are left on the broker even though they were delivered.\n\nThe issue seems to be related to multi-threading, by protecting each receive/commit with a lock the error does not happen.  I am sorry I don't have a test program ready, but it should be easy to reproduce by creating multiple transacted session threads with prefetchSize=1 and consuming messages, commiting after each message.  I have seen this happen both with consumers and listeners.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Transaction has not been started exceptions on the broker with parallel transacted sessions\n\nDescription:\nWhen using parallel transacted sessions and consumers to same queue each sharing the same connection, the messages are delivered but the broker 5.2 gets exceptions\n\njavax.jms.JMSException: Transaction 'TX:de411476-d65d-fff7-1e84-be7c9abd80b5:6' has not been started.\n\nand some messages are left on the broker even though they were delivered.\n\nThe issue seems to be related to multi-threading, by protecting each receive/commit with a lock the error does not happen.  I am sorry I don't have a test program ready, but it should be easy to reproduce by creating multiple transacted session threads with prefetchSize=1 and consuming messages, commiting after each message.  I have seen this happen both with consumers and listeners.\n\nComments:\n", "classification": "Classify the issue 'Transaction has not been started exceptions on the broker with parallel transacted sessions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-256?\nA: When using parallel transacted sessions and consumers to same queue each sharing the same connection, the messages are delivered but the broker 5.2 gets exceptions\n\njavax.jms.JMSException: Transaction 'TX:de411476-d65d-fff7-1e84-be7c9abd80b5:6' has not been started.\n\nand some messages are left on the broker even though they were delivered.\n\nThe issue seems to be related to multi-threading, by prot"}}
{"issue_key": "AMQCPP-255", "project": "AMQCPP", "title": "decaf/internal/AprPool.cpp fails to compile with trunk APR", "status": "Closed", "reporter": "Ivan Pechorin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-07-01T11:18:47.000+0000", "updated": "2009-07-01T11:37:47.000+0000", "description": "Unmanaged pool APIs were removed from APR (apr_pools.h and apr_pools.c) on March 25, 2009: http://svn.apache.org/viewvc?view=rev&revision=758360\n\nTherefore, when I try to build trunk ActiveMQ C++ client against trunk version of APR, I get the following compilation error:\n\n------ Build started: Project: vs2005-activemq, Configuration: ReleaseDLL Win32 ------\nCompiling...\nUUID.cpp\nHexStringParser.cpp\nAprPool.cpp\n..\\src\\main\\decaf\\internal\\AprPool.cpp(41) : error C3861: 'apr_pool_create_unmanaged_ex': identifier not found", "comments": [], "text": "decaf/internal/AprPool.cpp fails to compile with trunk APR\n\nDescription:\nUnmanaged pool APIs were removed from APR (apr_pools.h and apr_pools.c) on March 25, 2009: http://svn.apache.org/viewvc?view=rev&revision=758360\n\nTherefore, when I try to build trunk ActiveMQ C++ client against trunk version of APR, I get the following compilation error:\n\n------ Build started: Project: vs2005-activemq, Configuration: ReleaseDLL Win32 ------\nCompiling...\nUUID.cpp\nHexStringParser.cpp\nAprPool.cpp\n..\\src\\main\\decaf\\internal\\AprPool.cpp(41) : error C3861: 'apr_pool_create_unmanaged_ex': identifier not found\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: decaf/internal/AprPool.cpp fails to compile with trunk APR\n\nDescription:\nUnmanaged pool APIs were removed from APR (apr_pools.h and apr_pools.c) on March 25, 2009: http://svn.apache.org/viewvc?view=rev&revision=758360\n\nTherefore, when I try to build trunk ActiveMQ C++ client against trunk version of APR, I get the following compilation error:\n\n------ Build started: Project: vs2005-activemq, Configuration: ReleaseDLL Win32 ------\nCompiling...\nUUID.cpp\nHexStringParser.cpp\nAprPool.cpp\n..\\src\\main\\decaf\\internal\\AprPool.cpp(41) : error C3861: 'apr_pool_create_unmanaged_ex': identifier not found\n\nComments:\n", "classification": "Classify the issue 'decaf/internal/AprPool.cpp fails to compile with trunk APR' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-255?\nA: Unmanaged pool APIs were removed from APR (apr_pools.h and apr_pools.c) on March 25, 2009: http://svn.apache.org/viewvc?view=rev&revision=758360\n\nTherefore, when I try to build trunk ActiveMQ C++ client against trunk version of APR, I get the following compilation error:\n\n------ Build started: Project: vs2005-activemq, Configuration: ReleaseDLL Win32 ------\nCompiling...\nUUID.cpp\nHexStringParser.cp"}}
{"issue_key": "AMQCPP-254", "project": "AMQCPP", "title": "Update client to add support for Openwire 4 and 5.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-06-26T14:31:03.000+0000", "updated": "2009-07-24T20:16:07.000+0000", "description": "Generate the command changes and new marshallers for Openwire v4 and v5", "comments": [], "text": "Update client to add support for Openwire 4 and 5.\n\nDescription:\nGenerate the command changes and new marshallers for Openwire v4 and v5\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update client to add support for Openwire 4 and 5.\n\nDescription:\nGenerate the command changes and new marshallers for Openwire v4 and v5\n\nComments:\n", "classification": "Classify the issue 'Update client to add support for Openwire 4 and 5.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-254?\nA: Generate the command changes and new marshallers for Openwire v4 and v5"}}
{"issue_key": "AMQCPP-253", "project": "AMQCPP", "title": "Problems with compiler aCC on HPUX", "status": "Resolved", "reporter": "Wolfgang.Klein", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-06-26T10:04:06.000+0000", "updated": "2009-12-12T21:23:09.000+0000", "description": "compile errors with native HP compiler", "comments": [], "text": "Problems with compiler aCC on HPUX\n\nDescription:\ncompile errors with native HP compiler\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Problems with compiler aCC on HPUX\n\nDescription:\ncompile errors with native HP compiler\n\nComments:\n", "classification": "Classify the issue 'Problems with compiler aCC on HPUX' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-253?\nA: compile errors with native HP compiler"}}
{"issue_key": "AMQCPP-252", "project": "AMQCPP", "title": "Can't set Producer Window Size from connection URI", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-25T13:24:25.000+0000", "updated": "2009-06-25T14:24:51.000+0000", "description": "The URI option for producerWindowSize isn't taking affect when set on the Connection URI", "comments": [], "text": "Can't set Producer Window Size from connection URI\n\nDescription:\nThe URI option for producerWindowSize isn't taking affect when set on the Connection URI\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Can't set Producer Window Size from connection URI\n\nDescription:\nThe URI option for producerWindowSize isn't taking affect when set on the Connection URI\n\nComments:\n", "classification": "Classify the issue 'Can't set Producer Window Size from connection URI' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-252?\nA: The URI option for producerWindowSize isn't taking affect when set on the Connection URI"}}
{"issue_key": "AMQCPP-251", "project": "AMQCPP", "title": "default to use failover:tcp://localhost:8080 by default so we use reconnection out of the box", "status": "Resolved", "reporter": "James Strachan", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-23T17:34:03.000+0000", "updated": "2009-06-24T14:29:08.000+0000", "description": "", "comments": [], "text": "default to use failover:tcp://localhost:8080 by default so we use reconnection out of the box\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: default to use failover:tcp://localhost:8080 by default so we use reconnection out of the box\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'default to use failover:tcp://localhost:8080 by default so we use reconnection out of the box' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-251?\nA: "}}
{"issue_key": "AMQCPP-250", "project": "AMQCPP", "title": "Implement an Inactivity Monotir Transport filter for use on Transport that are used by the Failover Transport", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-22T14:42:17.000+0000", "updated": "2009-11-23T20:48:16.000+0000", "description": "Now that the Failover Transport is in place we need an Inactivity Monitor to wrap around transports such as TCP to detect long periods of inactivity and failures due to TCP connections that are otherwise not detected as broken such as a plug pull or switch failure.", "comments": [], "text": "Implement an Inactivity Monotir Transport filter for use on Transport that are used by the Failover Transport\n\nDescription:\nNow that the Failover Transport is in place we need an Inactivity Monitor to wrap around transports such as TCP to detect long periods of inactivity and failures due to TCP connections that are otherwise not detected as broken such as a plug pull or switch failure.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement an Inactivity Monotir Transport filter for use on Transport that are used by the Failover Transport\n\nDescription:\nNow that the Failover Transport is in place we need an Inactivity Monitor to wrap around transports such as TCP to detect long periods of inactivity and failures due to TCP connections that are otherwise not detected as broken such as a plug pull or switch failure.  \n\nComments:\n", "classification": "Classify the issue 'Implement an Inactivity Monotir Transport filter for use on Transport that are used by the Failover Transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-250?\nA: Now that the Failover Transport is in place we need an Inactivity Monitor to wrap around transports such as TCP to detect long periods of inactivity and failures due to TCP connections that are otherwise not detected as broken such as a plug pull or switch failure.  "}}
{"issue_key": "AMQCPP-249", "project": "AMQCPP", "title": "activemq/core/ActiveMQSession.cpp fails to compile on Solaris 10 with Sun Studio Compiler", "status": "Resolved", "reporter": "Michael Vishchers", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-06-17T09:10:58.000+0000", "updated": "2009-06-17T22:14:52.000+0000", "description": "make aborts with the following error messages:\n\n\"activemq/core/ActiveMQSession.cpp\", line 437: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*)\" is expected to return a value.\n\"activemq/core/ActiveMQSession.cpp\", line 451: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*, const std::string &)\" is expected to return a value.\n2 Error(s) detected.\n\n\nFix:\nUntil the createBrowser method is supported, a \"\treturn (cms::QueueBrowser*) NULL;\" at the end of the try blocks in both functions fixes the problem.", "comments": [], "text": "activemq/core/ActiveMQSession.cpp fails to compile on Solaris 10 with Sun Studio Compiler\n\nDescription:\nmake aborts with the following error messages:\n\n\"activemq/core/ActiveMQSession.cpp\", line 437: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*)\" is expected to return a value.\n\"activemq/core/ActiveMQSession.cpp\", line 451: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*, const std::string &)\" is expected to return a value.\n2 Error(s) detected.\n\n\nFix:\nUntil the createBrowser method is supported, a \"\treturn (cms::QueueBrowser*) NULL;\" at the end of the try blocks in both functions fixes the problem.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq/core/ActiveMQSession.cpp fails to compile on Solaris 10 with Sun Studio Compiler\n\nDescription:\nmake aborts with the following error messages:\n\n\"activemq/core/ActiveMQSession.cpp\", line 437: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*)\" is expected to return a value.\n\"activemq/core/ActiveMQSession.cpp\", line 451: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*, const std::string &)\" is expected to return a value.\n2 Error(s) detected.\n\n\nFix:\nUntil the createBrowser method is supported, a \"\treturn (cms::QueueBrowser*) NULL;\" at the end of the try blocks in both functions fixes the problem.\n\n\nComments:\n", "classification": "Classify the issue 'activemq/core/ActiveMQSession.cpp fails to compile on Solaris 10 with Sun Studio Compiler' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-249?\nA: make aborts with the following error messages:\n\n\"activemq/core/ActiveMQSession.cpp\", line 437: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*)\" is expected to return a value.\n\"activemq/core/ActiveMQSession.cpp\", line 451: Error: \"activemq::core::ActiveMQSession::createBrowser(const cms::Queue*, const std::string &)\" is expected to return a value.\n2 Error(s) detected.\n\n\nFi"}}
{"issue_key": "AMQCPP-248", "project": "AMQCPP", "title": "Failover Transport can deadlock when the connection fails during restore of previous state.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-16T18:39:28.000+0000", "updated": "2009-06-17T14:54:09.000+0000", "description": "While reconnecting the Transport attempts to restore the past state, if the transport fails there's a chance of a deadlock when attempting to close the failed transport if its calling it onException method at the same time.", "comments": [], "text": "Failover Transport can deadlock when the connection fails during restore of previous state.\n\nDescription:\nWhile reconnecting the Transport attempts to restore the past state, if the transport fails there's a chance of a deadlock when attempting to close the failed transport if its calling it onException method at the same time.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover Transport can deadlock when the connection fails during restore of previous state.\n\nDescription:\nWhile reconnecting the Transport attempts to restore the past state, if the transport fails there's a chance of a deadlock when attempting to close the failed transport if its calling it onException method at the same time.\n\nComments:\n", "classification": "Classify the issue 'Failover Transport can deadlock when the connection fails during restore of previous state.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-248?\nA: While reconnecting the Transport attempts to restore the past state, if the transport fails there's a chance of a deadlock when attempting to close the failed transport if its calling it onException method at the same time."}}
{"issue_key": "AMQCPP-247", "project": "AMQCPP", "title": "Exception thrown while using failover and Transacted sessions.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-15T13:06:03.000+0000", "updated": "2009-06-15T15:46:33.000+0000", "description": "During a session that is transacted and the connection is using the Failover Transport the following exception is seen.\n\n{noformat}\nKey does not exist in map\n\tFILE: ../../../src/main/decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 587\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 92\n\tFILE: ../../../src/main/activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 61\n\tFILE: ../../../src/main/activemq/core/ActiveMQConnection.cpp, LINE: 549\n\tFILE: ../../../src/main/activemq/core/ActiveMQTransactionContext.cpp, LINE: 115\n\tFILE: ../../../src/main/activemq/core/ActiveMQConsumer.cpp, LINE: 849\n\tFILE: ../../../src/main/activemq/core/ActiveMQSessionExecutor.cpp, LINE: 133\n{noformat}", "comments": [], "text": "Exception thrown while using failover and Transacted sessions.\n\nDescription:\nDuring a session that is transacted and the connection is using the Failover Transport the following exception is seen.\n\n{noformat}\nKey does not exist in map\n\tFILE: ../../../src/main/decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 587\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 92\n\tFILE: ../../../src/main/activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 61\n\tFILE: ../../../src/main/activemq/core/ActiveMQConnection.cpp, LINE: 549\n\tFILE: ../../../src/main/activemq/core/ActiveMQTransactionContext.cpp, LINE: 115\n\tFILE: ../../../src/main/activemq/core/ActiveMQConsumer.cpp, LINE: 849\n\tFILE: ../../../src/main/activemq/core/ActiveMQSessionExecutor.cpp, LINE: 133\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception thrown while using failover and Transacted sessions.\n\nDescription:\nDuring a session that is transacted and the connection is using the Failover Transport the following exception is seen.\n\n{noformat}\nKey does not exist in map\n\tFILE: ../../../src/main/decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 587\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 92\n\tFILE: ../../../src/main/activemq/transport/correlator/ResponseCorrelator.cpp, LINE: 61\n\tFILE: ../../../src/main/activemq/core/ActiveMQConnection.cpp, LINE: 549\n\tFILE: ../../../src/main/activemq/core/ActiveMQTransactionContext.cpp, LINE: 115\n\tFILE: ../../../src/main/activemq/core/ActiveMQConsumer.cpp, LINE: 849\n\tFILE: ../../../src/main/activemq/core/ActiveMQSessionExecutor.cpp, LINE: 133\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'Exception thrown while using failover and Transacted sessions.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-247?\nA: During a session that is transacted and the connection is using the Failover Transport the following exception is seen.\n\n{noformat}\nKey does not exist in map\n\tFILE: ../../../src/main/decaf/util/concurrent/ConcurrentStlMap.h, LINE: 229\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 587\n\tFILE: ../../../src/main/activemq/state/ConnectionStateTracker.cpp, LINE: 92\n\tFILE: ../"}}
{"issue_key": "AMQCPP-246", "project": "AMQCPP", "title": "Failover transport doesn't detect network failures", "status": "Closed", "reporter": "Daniel Donoso", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-11T07:18:22.000+0000", "updated": "2009-06-22T02:50:29.000+0000", "description": "I tested the CMS SimpleAsyncConsumer example to check the failover transport funcionality and it doesn't detect the network failures, and after network restauration the consumer never receives any message.\n\nThese are the steps:\n1. The network has a failure. \n2. The Producer sends a message. \n3.  After a minute the network is up. (The consumer doesn't detect the failure)\n4. The consumer doesn't receive the message.\n5. The producer sends other message.\n6. The consumer never receives old and new messages", "comments": [], "text": "Failover transport doesn't detect network failures\n\nDescription:\nI tested the CMS SimpleAsyncConsumer example to check the failover transport funcionality and it doesn't detect the network failures, and after network restauration the consumer never receives any message.\n\nThese are the steps:\n1. The network has a failure. \n2. The Producer sends a message. \n3.  After a minute the network is up. (The consumer doesn't detect the failure)\n4. The consumer doesn't receive the message.\n5. The producer sends other message.\n6. The consumer never receives old and new messages\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failover transport doesn't detect network failures\n\nDescription:\nI tested the CMS SimpleAsyncConsumer example to check the failover transport funcionality and it doesn't detect the network failures, and after network restauration the consumer never receives any message.\n\nThese are the steps:\n1. The network has a failure. \n2. The Producer sends a message. \n3.  After a minute the network is up. (The consumer doesn't detect the failure)\n4. The consumer doesn't receive the message.\n5. The producer sends other message.\n6. The consumer never receives old and new messages\n\n\nComments:\n", "classification": "Classify the issue 'Failover transport doesn't detect network failures' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-246?\nA: I tested the CMS SimpleAsyncConsumer example to check the failover transport funcionality and it doesn't detect the network failures, and after network restauration the consumer never receives any message.\n\nThese are the steps:\n1. The network has a failure. \n2. The Producer sends a message. \n3.  After a minute the network is up. (The consumer doesn't detect the failure)\n4. The consumer doesn't rec"}}
{"issue_key": "AMQCPP-245", "project": "AMQCPP", "title": "Add docs to README file regarding the use of APR from MacPorts ", "status": "Resolved", "reporter": "Bruce Snyder", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-06-09T17:36:55.000+0000", "updated": "2009-06-09T17:58:01.000+0000", "description": "A patch to add a note about compilation of the sources when using APR and APR-Util from MacPorts.", "comments": [], "text": "Add docs to README file regarding the use of APR from MacPorts \n\nDescription:\nA patch to add a note about compilation of the sources when using APR and APR-Util from MacPorts. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add docs to README file regarding the use of APR from MacPorts \n\nDescription:\nA patch to add a note about compilation of the sources when using APR and APR-Util from MacPorts. \n\nComments:\n", "classification": "Classify the issue 'Add docs to README file regarding the use of APR from MacPorts ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-245?\nA: A patch to add a note about compilation of the sources when using APR and APR-Util from MacPorts. "}}
{"issue_key": "AMQCPP-244", "project": "AMQCPP", "title": "Provide the configure script in the distribution ", "status": "Resolved", "reporter": "Bruce Snyder", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-05-29T17:56:43.000+0000", "updated": "2009-06-03T19:52:34.000+0000", "description": "This is a reminder issue to provide the configure script in the source distribution. This will save users the step of running autogen.sh to generate the configure script and is a pretty standard practice with other open source C++ projects.", "comments": [], "text": "Provide the configure script in the distribution \n\nDescription:\nThis is a reminder issue to provide the configure script in the source distribution. This will save users the step of running autogen.sh to generate the configure script and is a pretty standard practice with other open source C++ projects. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Provide the configure script in the distribution \n\nDescription:\nThis is a reminder issue to provide the configure script in the source distribution. This will save users the step of running autogen.sh to generate the configure script and is a pretty standard practice with other open source C++ projects. \n\nComments:\n", "classification": "Classify the issue 'Provide the configure script in the distribution ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-244?\nA: This is a reminder issue to provide the configure script in the source distribution. This will save users the step of running autogen.sh to generate the configure script and is a pretty standard practice with other open source C++ projects. "}}
{"issue_key": "AMQCPP-243", "project": "AMQCPP", "title": "Error when acknowledging messages that are sent to Virtual Topic subscribers", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-05-27T18:04:02.000+0000", "updated": "2009-06-03T13:47:18.000+0000", "description": "When acknowledging messages sent to subscribers on a Queue that is receiving messages sent to a Virtual Topic the broker generates an error.\n\n{noformat}\n\nERROR Service                        - Async error occurred: java.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\njava.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\n\tat org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:364)\n\tat org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:462)\n\tat org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:194)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:85)\n\tat org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:456)\n\tat org.apache.activemq.command.MessageAck.visit(MessageAck.java:205)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:305)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:143)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:206)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:203)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:185)\n\tat java.lang.Thread.run(Thread.java:636)\n\n{noformat}", "comments": [], "text": "Error when acknowledging messages that are sent to Virtual Topic subscribers\n\nDescription:\nWhen acknowledging messages sent to subscribers on a Queue that is receiving messages sent to a Virtual Topic the broker generates an error.\n\n{noformat}\n\nERROR Service                        - Async error occurred: java.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\njava.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\n\tat org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:364)\n\tat org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:462)\n\tat org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:194)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:85)\n\tat org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:456)\n\tat org.apache.activemq.command.MessageAck.visit(MessageAck.java:205)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:305)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:143)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:206)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:203)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:185)\n\tat java.lang.Thread.run(Thread.java:636)\n\n{noformat}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Error when acknowledging messages that are sent to Virtual Topic subscribers\n\nDescription:\nWhen acknowledging messages sent to subscribers on a Queue that is receiving messages sent to a Virtual Topic the broker generates an error.\n\n{noformat}\n\nERROR Service                        - Async error occurred: java.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\njava.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\n\tat org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:364)\n\tat org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:462)\n\tat org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:194)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:74)\n\tat org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:85)\n\tat org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:456)\n\tat org.apache.activemq.command.MessageAck.visit(MessageAck.java:205)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:305)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:143)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:206)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:203)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:185)\n\tat java.lang.Thread.run(Thread.java:636)\n\n{noformat}\n\nComments:\n", "classification": "Classify the issue 'Error when acknowledging messages that are sent to Virtual Topic subscribers' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-243?\nA: When acknowledging messages sent to subscribers on a Queue that is receiving messages sent to a Virtual Topic the broker generates an error.\n\n{noformat}\n\nERROR Service                        - Async error occurred: java.lang.IllegalArgumentException: The subscription does not exist: f845dcb8-e92c-90af-46d8-e5dbc29aacae:0:0\njava.lang.IllegalArgumentException: The subscription does not exist: f845dc"}}
{"issue_key": "AMQCPP-242", "project": "AMQCPP", "title": "Segfault when destroying auto pointer managed objects", "status": "Resolved", "reporter": "Alexander Martens", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-05-07T10:53:21.000+0000", "updated": "2009-05-08T10:36:14.000+0000", "description": "Looks like integration tests may cause occasionally segmentation faults (3 chances in 165 tries), specially when releasing aut_ptr managed objects. The following three gdb sessions show similar crashes.\n\nTestRegistry.cpp was modified to run only OpenwireSimpleTest by commenting all other tests out in order to narrow the problem.\n\nHope this helps,\n  Alex\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  2 process 18477  0x007ad402 in __kernel_vsyscall ()\n* 1 process 18572  0x00000011 in ?? ()\n(gdb) bt full\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) thread apply all bt full\n\nThread 2 (process 18477):\n#0  0x007ad402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0039ca31 in select () from /lib/libc.so.6\nNo symbol table info available.\n#2  0x0050fb8c in apr_sleep (t=50000) at time/unix/time.c:246\n        tv = {tv_sec = 0, tv_usec = 49000}\n#3  0x00a4aa9a in decaf::lang::Thread::sleep (millisecs=50) at decaf/lang/Thread.cpp:104\nNo locals.\n#4  0x080566c6 in activemq::test::CMSTestFixture::tearDown (this=0x874c308) at ./activemq/test/CMSTestFixture.h:58\nNo locals.\n#5  0x08052b44 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::tearDown (this=0x874c390)\n    at /usr/local/include/cppunit/TestCaller.h:182\nNo locals.\n#6  0x00155bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbf978b74) at TestCase.cpp:32\nNo locals.\n#7  0x001475ee in CppUnit::DefaultProtector::protect (this=0x874bf40, functor=@0xbf978b74, context=@0xbf978b0c) at DefaultProtector.cpp:15\nNo locals.\n#8  0x001517a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x874c130) at ProtectorChain.cpp:20\nNo locals.\n#9  0x001514f5 in CppUnit::ProtectorChain::protect (this=0x874bce0, functor=@0xbf978b74, context=@0xbf978b0c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x874fc58, _M_map_size = 8, _M_start = {_M_cur = 0x874cb10, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}, _M_finish = {\n        _M_cur = 0x874cb14, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0xfffffdfe: Cannot access memory at address 0xfffffdfe\n\nThread 1 (process 18572):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) q\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n68                      delete this->counter;\n(gdb) info threads\n  3 process 24403  0x00bce402 in __kernel_vsyscall ()\n  2 process 24537  0x00bce402 in __kernel_vsyscall ()\n* 1 process 24769  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n(gdb) thread apply all bt\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n#7  0x00a01fd0 in activemq::core::ActiveMQConnection::syncRequest (this=0x80d3590, command=\n      {<decaf::lang::AtomicRefCounter> = {counter = 0x3a98}, _vptr.Pointer = 0xbfa9ef60, value = 0x1}, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:568\n#8  0x00a024c9 in activemq::core::ActiveMQConnection::disposeOf (this=0x80d3590, objectId=@0xbfa9efc4, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:612\n#9  0x00a0285a in activemq::core::ActiveMQConnection::disconnect (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:335\n#10 0x00a06328 in activemq::core::ActiveMQConnection::close (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:246\n#11 0x0808327b in activemq::util::CMSProvider::close (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:108\n#12 0x0808504a in ~CMSProvider (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:56\n#13 0x08066d78 in activemq::test::SimpleTest::testQuickCreateAndDestroy (this=0x80ce468) at activemq/test/SimpleTest.cpp:335\n#14 0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x80ce478) at /usr/local/include/cppunit/TestCaller.h:166\n#15 0x00ef3bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfa9f494) at TestCase.cpp:32\n#16 0x00ee55ee in CppUnit::DefaultProtector::protect (this=0x80cdf40, functor=@0xbfa9f494, context=@0xbfa9f43c) at DefaultProtector.cpp:15\n#17 0x00eef7a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x8110a70) at ProtectorChain.cpp:20\n#18 0x00eef4f5 in CppUnit::ProtectorChain::protect (this=0x80cdce0, functor=@0xbfa9f494, context=@0xbfa9f43c) at ProtectorChain.cpp:77\n#19 0x00efbe81 in CppUnit::TestResult::protect (this=0x80cda60, functor=@0xbfa9f494, test=0x80ce478, shortDescription=@0xbfa9f4b8) at TestResult.cpp:178\n#20 0x00ef38dd in CppUnit::TestCase::run (this=0x80ce478, result=0x80cda60) at TestCase.cpp:92\n#21 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80ce010, controller=0x80cda60) at TestComposite.cpp:64\n#22 0x00ef417a in CppUnit::TestComposite::run (this=0x80ce010, result=0x80cda60) at TestComposite.cpp:23\n#23 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80cdf80, controller=0x80cda60) at TestComposite.cpp:64\n#24 0x00ef417a in CppUnit::TestComposite::run (this=0x80cdf80, result=0x80cda60) at TestComposite.cpp:23\n#25 0x00efe440 in CppUnit::TestRunner::WrappingSuite::run (this=0x80cd570, result=0x80cda60) at TestRunner.cpp:47\n#26 0x00efbc1a in CppUnit::TestResult::runTest (this=0x80cda60, test=0x80cd570) at TestResult.cpp:145\n#27 0x00efe280 in CppUnit::TestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TestRunner.cpp:96\n#28 0x00f019db in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TextTestRunner.cpp:140\n#29 0x00f01a55 in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfa9f904 \"ï¿½ï¿½$\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#30 0x0804ffc5 in main (argc=1, argv=0xbfa9f9c4) at main.cpp:77\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x00627e1b in read () from /lib/libpthread.so.0\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\n#12 0x00578c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\n#4  0x00578c4e in clone () from /lib/libc.so.6\n(gdb) thread apply all bt full\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n        rv = 12196256\n        then = 1241684283140354\n        abstime = {tv_sec = 1241684283, tv_nsec = 140354000}\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n        lock_owner = 3086771968\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x8118020\n        subPool = (apr_pool_t *) 0x8117fe0\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x80d3d9c}\n        ex = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x98da55 \"\\213]ï¿½\\213uï¿½\\213}ï¿½\\211ï¿½]ï¿½ï¿½\\004$\\030\"}}, cause = 0x80d25d0, \n  stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n      _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xbfa9ef60, \n        _M_finish = 0x8, _M_end_of_storage = 0x2485d4}}, <No data fields>}}\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\nNo locals.\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n        lock_W = {_vptr.Lock = 0x8096df8, locked = false, syncObject = 0x80d34c4}\n        response = {<decaf::lang::AtomicRefCounter> = {counter = 0x80f2fc0}, _vptr.Pointer = 0xb8c718, value = 0x0}\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {Cannot access memory at address 0x5f3f\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00627e1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n        rv = -1208200952\n        arv = 1199426\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x124d42 \"\\211Eï¿½\\213Eï¿½\\203ï¿½\\024[]ï¿½U\\211ï¿½S\\203ï¿½\\024ï¿½ï¿½>ï¿½ï¿½\\201ï¿½\\226J\\001\"}}, cause = 0x80c0c7c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8110928, \n          _M_finish = 0xb7fc51c8, _M_end_of_storage = 0x807f0c1}}, <No data fields>}}, <No data fields>}\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0xb7fc51fc, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5208, \n          _M_finish = 0x0, _M_end_of_storage = 0xb7fc51f0}}, <No data fields>}}, <No data fields>}\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0x80d16d0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5248, \n          _M_finish = 0x5e6ff4, _M_end_of_storage = 0x5e8140}}, <No data fields>}}, <No data fields>}\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xb7fc5298 \"ï¿½Rï¿½ï¿½ï¿½\\031ï¿½\"}}, \n    cause = 0x217731, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x80fc820, \n          _M_finish = 0xba19a0, _M_end_of_storage = 0xb7fc52a8}}, <No data fields>}}, <No data fields>}\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d1ee8}, _vptr.Pointer = 0xb8bb40, value = 0x80fc820}\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c4f08\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d3db0}, _vptr.Pointer = 0xb8bb40, value = 0x80f3438}\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c5568\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\n(gdb) list\n63               *\n64               * @return true if the count is now zero.\n65               */\n66              bool release() {\n67                  if( this->counter->decrementAndGet() == 0 ) {\n68                      delete this->counter;\n69                      return true;\n70                  }\n71                  return false;\n72              }\n(gdb) up\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n125             thread->task->run();\n(gdb) list\n120         // Get the instance.\n121         Thread* thread = (Thread*)param;\n122\n123         // Invoke run on the task.\n124         try{\n125             thread->task->run();\n126         } catch( ... ){\n127             RuntimeException ex(\n128                 __FILE__, __LINE__,\n129                 \"unhandled exception bubbled up to Thread::run\");\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  3 process 5624  0x00be0402 in __kernel_vsyscall ()\n  2 process 5632  0x00be0402 in __kernel_vsyscall ()\n* 1 process 5500  0x00000011 in ?? ()\n(gdb) thread apply all bt full\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n        rv = -1208123128\n        arv = 6628709\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x92b460 \"U\\211ï¿½\\203ï¿½(\\211}ï¿½\\213}\\b\\211uï¿½\\213u\\f\\211]ï¿½ï¿½]ï¿½ï¿½ï¿½\\201ï¿½&5\\021\"}}, cause = 0x9efef48, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x146391, \n          _M_finish = 0x415140, _M_end_of_storage = 0x95495a}}, <No data fields>}}, <No data fields>}\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9ee9518 \"ï¿½nï¿½\"}}, \n    cause = 0xb7fd82f0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd81f8, \n          _M_finish = 0x1, _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9edf7d8 \"ï¿½ï¿½ï¿½\\t\"}}, \n    cause = 0x9ebe700, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd8248, \n          _M_finish = 0x147880, _M_end_of_storage = 0xb7fd8268}}, <No data fields>}}, <No data fields>}\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7fd82a8 \"\\030\\203ï¿½ï¿½\\200/o\"}}, cause = 0x652565, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x9edf7dc, \n          _M_finish = 0xa3e9a0, _M_end_of_storage = 0xb7fd82a8}}, <No data fields>}}, <No data fields>}\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edf7d8}, _vptr.Pointer = 0xa28b40, value = 0x9efef48}\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ec8\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n        rv = 166715416\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n        lock_owner = 3065867152\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x9edb7b0\n        subPool = (apr_pool_t *) 0x9edb770\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\nNo locals.\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x9efe008}\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\nNo locals.\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ee8\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#9  0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\nNo locals.\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\nNo locals.\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n        cpputMsg_ = {m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x9ee04bc \"activemq/test/SimpleTest.cpp\"}}, \n  m_details = {<std::_Deque_base<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {\n      _M_impl = {<std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<__gnu_cxx::new_allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<No data fields>}, <No data fields>}, _M_map = 0x9ee0548, _M_map_size = 8, _M_start = {\n          _M_cur = 0x9ee0570, _M_first = 0x9ee0570, _M_last = 0x9ee0770, _M_node = 0x9ee0554}, _M_finish = {_M_cur = 0x9ee0578, _M_first = 0x9ee0570, \n          _M_last = 0x9ee0770, _M_node = 0x9ee0554}}}, <No data fields>}}\n        session = <value optimized out>\n        consumer = (class cms::MessageConsumer *) 0x9efe6c8\n        producer = (class cms::MessageProducer *) 0x9efea40\n        bytesMessage2 = (class cms::BytesMessage *) 0x9edf7e8\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\nNo locals.\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\nNo locals.\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\nNo locals.\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\nNo locals.\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x9ebb2d0, _M_map_size = 8, _M_start = {_M_cur = 0x9ebbb10, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}, _M_finish = {\n        _M_cur = 0x9ebbb14, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0x9edffa0: {_vptr.Functor = 0x0}\n        succeed = <value optimized out>\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n        context = {m_test = 0x9ebb448, m_result = 0x9ebaa60, m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}}\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\nNo locals.\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 9\n        childCount = 14\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 1\n        childCount = 1\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\nNo locals.\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\nNo locals.\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n        path = {_vptr.TestPath = 0x1be1c8, m_tests = {<std::_Deque_base<CppUnit::Test*,std::allocator<CppUnit::Test*> >> = {\n      _M_impl = {<std::allocator<CppUnit::Test*>> = {<__gnu_cxx::new_allocator<CppUnit::Test*>> = {<No data fields>}, <No data fields>}, \n        _M_map = 0x9ebb2a8, _M_map_size = 8, _M_start = {_M_cur = 0x9ebb908, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}, _M_finish = {\n          _M_cur = 0x9ebb90c, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}}}, <No data fields>}}\n        testToRun = (class CppUnit::Test *) 0x9edffa0\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\nNo locals.\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n        progress = {<CppUnit::TestListener> = {_vptr.TestListener = 0x1be5e8}, <No data fields>}\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n        runner = {<CppUnit::TestRunner> = {_vptr.TestRunner = 0x1be708, m_suite = 0x9eba570}, m_result = 0x9eba588, m_eventManager = 0x9ebaa60, \n  m_outputter = 0x9ebaf50}\n        registry = (class CppUnit::TestFactoryRegistry &) @0x9eb60b8: {<CppUnit::TestFactory> = {_vptr.TestFactory = 0x1be0b0}, m_factories = {_M_t = {\n      _M_impl = {<std::allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, _M_header = {_M_color = std::_S_red, \n          _M_parent = 0x9eb6100, _M_left = 0x9eb6100, _M_right = 0x9eb6100}, _M_node_count = 1}}}, m_name = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9eb60a4 \"All Tests\"}}}\n        wasSuccessful = <value optimized out>\n        outputFile = <incomplete type>\n        useXMLOutputter = false\n(gdb) thread apply all bt\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\n#12 0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\n#9  0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n(gdb) up\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n68      }\n(gdb) list\n63          this->brokerOutTime = 0;\n64      }\n65\n66      ////////////////////////////////////////////////////////////////////////////////\n67      Message::~Message() {\n68      }\n69\n70      ////////////////////////////////////////////////////////////////////////////////\n71      Message* Message::cloneDataStructure() const {\n72          std::auto_ptr<Message> message( new Message() );\n(gdb) p this\n$1 = (class activemq::commands::Message * const) 0x9edf7ec\n(gdb) p *this\n$2 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {_vptr.MarshalAware = 0xa39108}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, \n    commandId = 5}, ackHandler = 0x0, \n  properties = {<decaf::util::StlMap<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::Map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa34be8}, <No data fields>}, valueMap = {_M_t = {\n          _M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, \n            _M_header = {_M_color = std::_S_red, _M_parent = 0x0, _M_left = 0x9edf804, _M_right = 0x9edf804}, _M_node_count = 0}}}, \n      mutex = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa25468}, aprPool = {_vptr.AprPool = 0xa25fa8, aprPool = 0x9f543f0}, \n        mutex = 0x9f54430, eventQ = {<std::_List_base<apr_thread_cond_t*,std::allocator<apr_thread_cond_t*> >> = {\n            _M_impl = {<std::allocator<std::_List_node<apr_thread_cond_t*> >> = {<__gnu_cxx::new_allocator<std::_List_node<apr_thread_cond_t*> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x9edf828, _M_prev = 0x9edf828}}}, <No data fields>}, lock_owner = 0, lock_count = 0}}, converter = {\n      _vptr.PrimitiveValueConverter = 0xa2d9b0}}, readOnlyProperties = true, readOnlyBody = true, static DEFAULT_MESSAGE_SIZE = 1024, \n  producerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee0250}, _vptr.Pointer = 0xa2aca0, value = 0x9ee01a8}, \n  destination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ebeee0}, _vptr.Pointer = 0xa2acf0, value = 0x9ee0260}, \n  transactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee02d0}, _vptr.Pointer = 0xa2a938, value = 0x0}, \n  originalDestination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc08}, _vptr.Pointer = 0xa2acf0, value = 0x0}, \n  messageId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc18}, _vptr.Pointer = 0xa2acc8, value = 0x9ee02e0}, \n  originalTransactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc28}, _vptr.Pointer = 0xa2a938, value = 0x0}, groupID = {\n    static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x2a9bbc \"\"}}, groupSequence = 0, correlationId = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  persistent = false, expiration = 0, priority = 4 '\\004', replyTo = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edff98}, _vptr.Pointer = 0xa2acf0, \n    value = 0x0}, timestamp = 1241684145316, type = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  content = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, \n        _M_start = 0x9ee0490 \"\", _M_finish = 0x9ee04aa \"il1\\005\", _M_end_of_storage = 0x9ee04aa \"il1\\005\"}}, <No data fields>}, \n  marshalledProperties = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, _M_start = 0x0, \n        _M_finish = 0x0, _M_end_of_storage = 0x0}}, <No data fields>}, dataStructure = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffa8}, \n    _vptr.Pointer = 0xa2a248, value = 0x0}, targetConsumerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffb8}, _vptr.Pointer = 0xa2aad8, \n    value = 0x0}, compressed = false, redeliveryCounter = 0, \n  brokerPath = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, arrival = 0, userID = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  recievedByDFBridge = false, droppable = false, \n  cluster = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, brokerInTime = 1241684145317, brokerOutTime = 1241684145317, static ID_MESSAGE = 0 '\\0'}\n{noformat}", "comments": [], "text": "Segfault when destroying auto pointer managed objects\n\nDescription:\nLooks like integration tests may cause occasionally segmentation faults (3 chances in 165 tries), specially when releasing aut_ptr managed objects. The following three gdb sessions show similar crashes.\n\nTestRegistry.cpp was modified to run only OpenwireSimpleTest by commenting all other tests out in order to narrow the problem.\n\nHope this helps,\n  Alex\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  2 process 18477  0x007ad402 in __kernel_vsyscall ()\n* 1 process 18572  0x00000011 in ?? ()\n(gdb) bt full\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) thread apply all bt full\n\nThread 2 (process 18477):\n#0  0x007ad402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0039ca31 in select () from /lib/libc.so.6\nNo symbol table info available.\n#2  0x0050fb8c in apr_sleep (t=50000) at time/unix/time.c:246\n        tv = {tv_sec = 0, tv_usec = 49000}\n#3  0x00a4aa9a in decaf::lang::Thread::sleep (millisecs=50) at decaf/lang/Thread.cpp:104\nNo locals.\n#4  0x080566c6 in activemq::test::CMSTestFixture::tearDown (this=0x874c308) at ./activemq/test/CMSTestFixture.h:58\nNo locals.\n#5  0x08052b44 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::tearDown (this=0x874c390)\n    at /usr/local/include/cppunit/TestCaller.h:182\nNo locals.\n#6  0x00155bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbf978b74) at TestCase.cpp:32\nNo locals.\n#7  0x001475ee in CppUnit::DefaultProtector::protect (this=0x874bf40, functor=@0xbf978b74, context=@0xbf978b0c) at DefaultProtector.cpp:15\nNo locals.\n#8  0x001517a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x874c130) at ProtectorChain.cpp:20\nNo locals.\n#9  0x001514f5 in CppUnit::ProtectorChain::protect (this=0x874bce0, functor=@0xbf978b74, context=@0xbf978b0c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x874fc58, _M_map_size = 8, _M_start = {_M_cur = 0x874cb10, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}, _M_finish = {\n        _M_cur = 0x874cb14, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0xfffffdfe: Cannot access memory at address 0xfffffdfe\n\nThread 1 (process 18572):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) q\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n68                      delete this->counter;\n(gdb) info threads\n  3 process 24403  0x00bce402 in __kernel_vsyscall ()\n  2 process 24537  0x00bce402 in __kernel_vsyscall ()\n* 1 process 24769  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n(gdb) thread apply all bt\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n#7  0x00a01fd0 in activemq::core::ActiveMQConnection::syncRequest (this=0x80d3590, command=\n      {<decaf::lang::AtomicRefCounter> = {counter = 0x3a98}, _vptr.Pointer = 0xbfa9ef60, value = 0x1}, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:568\n#8  0x00a024c9 in activemq::core::ActiveMQConnection::disposeOf (this=0x80d3590, objectId=@0xbfa9efc4, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:612\n#9  0x00a0285a in activemq::core::ActiveMQConnection::disconnect (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:335\n#10 0x00a06328 in activemq::core::ActiveMQConnection::close (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:246\n#11 0x0808327b in activemq::util::CMSProvider::close (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:108\n#12 0x0808504a in ~CMSProvider (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:56\n#13 0x08066d78 in activemq::test::SimpleTest::testQuickCreateAndDestroy (this=0x80ce468) at activemq/test/SimpleTest.cpp:335\n#14 0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x80ce478) at /usr/local/include/cppunit/TestCaller.h:166\n#15 0x00ef3bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfa9f494) at TestCase.cpp:32\n#16 0x00ee55ee in CppUnit::DefaultProtector::protect (this=0x80cdf40, functor=@0xbfa9f494, context=@0xbfa9f43c) at DefaultProtector.cpp:15\n#17 0x00eef7a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x8110a70) at ProtectorChain.cpp:20\n#18 0x00eef4f5 in CppUnit::ProtectorChain::protect (this=0x80cdce0, functor=@0xbfa9f494, context=@0xbfa9f43c) at ProtectorChain.cpp:77\n#19 0x00efbe81 in CppUnit::TestResult::protect (this=0x80cda60, functor=@0xbfa9f494, test=0x80ce478, shortDescription=@0xbfa9f4b8) at TestResult.cpp:178\n#20 0x00ef38dd in CppUnit::TestCase::run (this=0x80ce478, result=0x80cda60) at TestCase.cpp:92\n#21 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80ce010, controller=0x80cda60) at TestComposite.cpp:64\n#22 0x00ef417a in CppUnit::TestComposite::run (this=0x80ce010, result=0x80cda60) at TestComposite.cpp:23\n#23 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80cdf80, controller=0x80cda60) at TestComposite.cpp:64\n#24 0x00ef417a in CppUnit::TestComposite::run (this=0x80cdf80, result=0x80cda60) at TestComposite.cpp:23\n#25 0x00efe440 in CppUnit::TestRunner::WrappingSuite::run (this=0x80cd570, result=0x80cda60) at TestRunner.cpp:47\n#26 0x00efbc1a in CppUnit::TestResult::runTest (this=0x80cda60, test=0x80cd570) at TestResult.cpp:145\n#27 0x00efe280 in CppUnit::TestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TestRunner.cpp:96\n#28 0x00f019db in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TextTestRunner.cpp:140\n#29 0x00f01a55 in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfa9f904 \"ï¿½ï¿½$\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#30 0x0804ffc5 in main (argc=1, argv=0xbfa9f9c4) at main.cpp:77\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x00627e1b in read () from /lib/libpthread.so.0\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\n#12 0x00578c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\n#4  0x00578c4e in clone () from /lib/libc.so.6\n(gdb) thread apply all bt full\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n        rv = 12196256\n        then = 1241684283140354\n        abstime = {tv_sec = 1241684283, tv_nsec = 140354000}\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n        lock_owner = 3086771968\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x8118020\n        subPool = (apr_pool_t *) 0x8117fe0\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x80d3d9c}\n        ex = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x98da55 \"\\213]ï¿½\\213uï¿½\\213}ï¿½\\211ï¿½]ï¿½ï¿½\\004$\\030\"}}, cause = 0x80d25d0, \n  stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n      _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xbfa9ef60, \n        _M_finish = 0x8, _M_end_of_storage = 0x2485d4}}, <No data fields>}}\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\nNo locals.\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n        lock_W = {_vptr.Lock = 0x8096df8, locked = false, syncObject = 0x80d34c4}\n        response = {<decaf::lang::AtomicRefCounter> = {counter = 0x80f2fc0}, _vptr.Pointer = 0xb8c718, value = 0x0}\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {Cannot access memory at address 0x5f3f\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00627e1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n        rv = -1208200952\n        arv = 1199426\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x124d42 \"\\211Eï¿½\\213Eï¿½\\203ï¿½\\024[]ï¿½U\\211ï¿½S\\203ï¿½\\024ï¿½ï¿½>ï¿½ï¿½\\201ï¿½\\226J\\001\"}}, cause = 0x80c0c7c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8110928, \n          _M_finish = 0xb7fc51c8, _M_end_of_storage = 0x807f0c1}}, <No data fields>}}, <No data fields>}\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0xb7fc51fc, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5208, \n          _M_finish = 0x0, _M_end_of_storage = 0xb7fc51f0}}, <No data fields>}}, <No data fields>}\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0x80d16d0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5248, \n          _M_finish = 0x5e6ff4, _M_end_of_storage = 0x5e8140}}, <No data fields>}}, <No data fields>}\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xb7fc5298 \"ï¿½Rï¿½ï¿½ï¿½\\031ï¿½\"}}, \n    cause = 0x217731, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x80fc820, \n          _M_finish = 0xba19a0, _M_end_of_storage = 0xb7fc52a8}}, <No data fields>}}, <No data fields>}\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d1ee8}, _vptr.Pointer = 0xb8bb40, value = 0x80fc820}\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c4f08\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d3db0}, _vptr.Pointer = 0xb8bb40, value = 0x80f3438}\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c5568\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\n(gdb) list\n63               *\n64               * @return true if the count is now zero.\n65               */\n66              bool release() {\n67                  if( this->counter->decrementAndGet() == 0 ) {\n68                      delete this->counter;\n69                      return true;\n70                  }\n71                  return false;\n72              }\n(gdb) up\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n125             thread->task->run();\n(gdb) list\n120         // Get the instance.\n121         Thread* thread = (Thread*)param;\n122\n123         // Invoke run on the task.\n124         try{\n125             thread->task->run();\n126         } catch( ... ){\n127             RuntimeException ex(\n128                 __FILE__, __LINE__,\n129                 \"unhandled exception bubbled up to Thread::run\");\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  3 process 5624  0x00be0402 in __kernel_vsyscall ()\n  2 process 5632  0x00be0402 in __kernel_vsyscall ()\n* 1 process 5500  0x00000011 in ?? ()\n(gdb) thread apply all bt full\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n        rv = -1208123128\n        arv = 6628709\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x92b460 \"U\\211ï¿½\\203ï¿½(\\211}ï¿½\\213}\\b\\211uï¿½\\213u\\f\\211]ï¿½ï¿½]ï¿½ï¿½ï¿½\\201ï¿½&5\\021\"}}, cause = 0x9efef48, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x146391, \n          _M_finish = 0x415140, _M_end_of_storage = 0x95495a}}, <No data fields>}}, <No data fields>}\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9ee9518 \"ï¿½nï¿½\"}}, \n    cause = 0xb7fd82f0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd81f8, \n          _M_finish = 0x1, _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9edf7d8 \"ï¿½ï¿½ï¿½\\t\"}}, \n    cause = 0x9ebe700, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd8248, \n          _M_finish = 0x147880, _M_end_of_storage = 0xb7fd8268}}, <No data fields>}}, <No data fields>}\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7fd82a8 \"\\030\\203ï¿½ï¿½\\200/o\"}}, cause = 0x652565, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x9edf7dc, \n          _M_finish = 0xa3e9a0, _M_end_of_storage = 0xb7fd82a8}}, <No data fields>}}, <No data fields>}\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edf7d8}, _vptr.Pointer = 0xa28b40, value = 0x9efef48}\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ec8\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n        rv = 166715416\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n        lock_owner = 3065867152\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x9edb7b0\n        subPool = (apr_pool_t *) 0x9edb770\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\nNo locals.\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x9efe008}\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\nNo locals.\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ee8\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#9  0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\nNo locals.\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\nNo locals.\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n        cpputMsg_ = {m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x9ee04bc \"activemq/test/SimpleTest.cpp\"}}, \n  m_details = {<std::_Deque_base<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {\n      _M_impl = {<std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<__gnu_cxx::new_allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<No data fields>}, <No data fields>}, _M_map = 0x9ee0548, _M_map_size = 8, _M_start = {\n          _M_cur = 0x9ee0570, _M_first = 0x9ee0570, _M_last = 0x9ee0770, _M_node = 0x9ee0554}, _M_finish = {_M_cur = 0x9ee0578, _M_first = 0x9ee0570, \n          _M_last = 0x9ee0770, _M_node = 0x9ee0554}}}, <No data fields>}}\n        session = <value optimized out>\n        consumer = (class cms::MessageConsumer *) 0x9efe6c8\n        producer = (class cms::MessageProducer *) 0x9efea40\n        bytesMessage2 = (class cms::BytesMessage *) 0x9edf7e8\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\nNo locals.\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\nNo locals.\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\nNo locals.\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\nNo locals.\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x9ebb2d0, _M_map_size = 8, _M_start = {_M_cur = 0x9ebbb10, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}, _M_finish = {\n        _M_cur = 0x9ebbb14, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0x9edffa0: {_vptr.Functor = 0x0}\n        succeed = <value optimized out>\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n        context = {m_test = 0x9ebb448, m_result = 0x9ebaa60, m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}}\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\nNo locals.\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 9\n        childCount = 14\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 1\n        childCount = 1\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\nNo locals.\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\nNo locals.\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n        path = {_vptr.TestPath = 0x1be1c8, m_tests = {<std::_Deque_base<CppUnit::Test*,std::allocator<CppUnit::Test*> >> = {\n      _M_impl = {<std::allocator<CppUnit::Test*>> = {<__gnu_cxx::new_allocator<CppUnit::Test*>> = {<No data fields>}, <No data fields>}, \n        _M_map = 0x9ebb2a8, _M_map_size = 8, _M_start = {_M_cur = 0x9ebb908, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}, _M_finish = {\n          _M_cur = 0x9ebb90c, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}}}, <No data fields>}}\n        testToRun = (class CppUnit::Test *) 0x9edffa0\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\nNo locals.\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n        progress = {<CppUnit::TestListener> = {_vptr.TestListener = 0x1be5e8}, <No data fields>}\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n        runner = {<CppUnit::TestRunner> = {_vptr.TestRunner = 0x1be708, m_suite = 0x9eba570}, m_result = 0x9eba588, m_eventManager = 0x9ebaa60, \n  m_outputter = 0x9ebaf50}\n        registry = (class CppUnit::TestFactoryRegistry &) @0x9eb60b8: {<CppUnit::TestFactory> = {_vptr.TestFactory = 0x1be0b0}, m_factories = {_M_t = {\n      _M_impl = {<std::allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, _M_header = {_M_color = std::_S_red, \n          _M_parent = 0x9eb6100, _M_left = 0x9eb6100, _M_right = 0x9eb6100}, _M_node_count = 1}}}, m_name = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9eb60a4 \"All Tests\"}}}\n        wasSuccessful = <value optimized out>\n        outputFile = <incomplete type>\n        useXMLOutputter = false\n(gdb) thread apply all bt\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\n#12 0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\n#9  0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n(gdb) up\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n68      }\n(gdb) list\n63          this->brokerOutTime = 0;\n64      }\n65\n66      ////////////////////////////////////////////////////////////////////////////////\n67      Message::~Message() {\n68      }\n69\n70      ////////////////////////////////////////////////////////////////////////////////\n71      Message* Message::cloneDataStructure() const {\n72          std::auto_ptr<Message> message( new Message() );\n(gdb) p this\n$1 = (class activemq::commands::Message * const) 0x9edf7ec\n(gdb) p *this\n$2 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {_vptr.MarshalAware = 0xa39108}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, \n    commandId = 5}, ackHandler = 0x0, \n  properties = {<decaf::util::StlMap<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::Map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa34be8}, <No data fields>}, valueMap = {_M_t = {\n          _M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, \n            _M_header = {_M_color = std::_S_red, _M_parent = 0x0, _M_left = 0x9edf804, _M_right = 0x9edf804}, _M_node_count = 0}}}, \n      mutex = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa25468}, aprPool = {_vptr.AprPool = 0xa25fa8, aprPool = 0x9f543f0}, \n        mutex = 0x9f54430, eventQ = {<std::_List_base<apr_thread_cond_t*,std::allocator<apr_thread_cond_t*> >> = {\n            _M_impl = {<std::allocator<std::_List_node<apr_thread_cond_t*> >> = {<__gnu_cxx::new_allocator<std::_List_node<apr_thread_cond_t*> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x9edf828, _M_prev = 0x9edf828}}}, <No data fields>}, lock_owner = 0, lock_count = 0}}, converter = {\n      _vptr.PrimitiveValueConverter = 0xa2d9b0}}, readOnlyProperties = true, readOnlyBody = true, static DEFAULT_MESSAGE_SIZE = 1024, \n  producerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee0250}, _vptr.Pointer = 0xa2aca0, value = 0x9ee01a8}, \n  destination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ebeee0}, _vptr.Pointer = 0xa2acf0, value = 0x9ee0260}, \n  transactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee02d0}, _vptr.Pointer = 0xa2a938, value = 0x0}, \n  originalDestination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc08}, _vptr.Pointer = 0xa2acf0, value = 0x0}, \n  messageId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc18}, _vptr.Pointer = 0xa2acc8, value = 0x9ee02e0}, \n  originalTransactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc28}, _vptr.Pointer = 0xa2a938, value = 0x0}, groupID = {\n    static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x2a9bbc \"\"}}, groupSequence = 0, correlationId = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  persistent = false, expiration = 0, priority = 4 '\\004', replyTo = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edff98}, _vptr.Pointer = 0xa2acf0, \n    value = 0x0}, timestamp = 1241684145316, type = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  content = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, \n        _M_start = 0x9ee0490 \"\", _M_finish = 0x9ee04aa \"il1\\005\", _M_end_of_storage = 0x9ee04aa \"il1\\005\"}}, <No data fields>}, \n  marshalledProperties = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, _M_start = 0x0, \n        _M_finish = 0x0, _M_end_of_storage = 0x0}}, <No data fields>}, dataStructure = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffa8}, \n    _vptr.Pointer = 0xa2a248, value = 0x0}, targetConsumerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffb8}, _vptr.Pointer = 0xa2aad8, \n    value = 0x0}, compressed = false, redeliveryCounter = 0, \n  brokerPath = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, arrival = 0, userID = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  recievedByDFBridge = false, droppable = false, \n  cluster = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, brokerInTime = 1241684145317, brokerOutTime = 1241684145317, static ID_MESSAGE = 0 '\\0'}\n{noformat}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segfault when destroying auto pointer managed objects\n\nDescription:\nLooks like integration tests may cause occasionally segmentation faults (3 chances in 165 tries), specially when releasing aut_ptr managed objects. The following three gdb sessions show similar crashes.\n\nTestRegistry.cpp was modified to run only OpenwireSimpleTest by commenting all other tests out in order to narrow the problem.\n\nHope this helps,\n  Alex\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  2 process 18477  0x007ad402 in __kernel_vsyscall ()\n* 1 process 18572  0x00000011 in ?? ()\n(gdb) bt full\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) thread apply all bt full\n\nThread 2 (process 18477):\n#0  0x007ad402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0039ca31 in select () from /lib/libc.so.6\nNo symbol table info available.\n#2  0x0050fb8c in apr_sleep (t=50000) at time/unix/time.c:246\n        tv = {tv_sec = 0, tv_usec = 49000}\n#3  0x00a4aa9a in decaf::lang::Thread::sleep (millisecs=50) at decaf/lang/Thread.cpp:104\nNo locals.\n#4  0x080566c6 in activemq::test::CMSTestFixture::tearDown (this=0x874c308) at ./activemq/test/CMSTestFixture.h:58\nNo locals.\n#5  0x08052b44 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::tearDown (this=0x874c390)\n    at /usr/local/include/cppunit/TestCaller.h:182\nNo locals.\n#6  0x00155bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbf978b74) at TestCase.cpp:32\nNo locals.\n#7  0x001475ee in CppUnit::DefaultProtector::protect (this=0x874bf40, functor=@0xbf978b74, context=@0xbf978b0c) at DefaultProtector.cpp:15\nNo locals.\n#8  0x001517a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x874c130) at ProtectorChain.cpp:20\nNo locals.\n#9  0x001514f5 in CppUnit::ProtectorChain::protect (this=0x874bce0, functor=@0xbf978b74, context=@0xbf978b0c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x874fc58, _M_map_size = 8, _M_start = {_M_cur = 0x874cb10, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}, _M_finish = {\n        _M_cur = 0x874cb14, _M_first = 0x874cb10, _M_last = 0x874cd10, _M_node = 0x874fc64}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0xfffffdfe: Cannot access memory at address 0xfffffdfe\n\nThread 1 (process 18572):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x00a4ad98 in decaf::lang::Thread::runCallback (self=0x8742e08, param=0x878fb80) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x0050ea4c in dummy_worker (opaque=0x8742e08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x8742e08\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x003a3c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n(gdb) q\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n68                      delete this->counter;\n(gdb) info threads\n  3 process 24403  0x00bce402 in __kernel_vsyscall ()\n  2 process 24537  0x00bce402 in __kernel_vsyscall ()\n* 1 process 24769  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n(gdb) thread apply all bt\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n#7  0x00a01fd0 in activemq::core::ActiveMQConnection::syncRequest (this=0x80d3590, command=\n      {<decaf::lang::AtomicRefCounter> = {counter = 0x3a98}, _vptr.Pointer = 0xbfa9ef60, value = 0x1}, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:568\n#8  0x00a024c9 in activemq::core::ActiveMQConnection::disposeOf (this=0x80d3590, objectId=@0xbfa9efc4, timeout=15000)\n    at activemq/core/ActiveMQConnection.cpp:612\n#9  0x00a0285a in activemq::core::ActiveMQConnection::disconnect (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:335\n#10 0x00a06328 in activemq::core::ActiveMQConnection::close (this=0x80d3590) at activemq/core/ActiveMQConnection.cpp:246\n#11 0x0808327b in activemq::util::CMSProvider::close (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:108\n#12 0x0808504a in ~CMSProvider (this=0xbfa9f184) at activemq/util/CMSProvider.cpp:56\n#13 0x08066d78 in activemq::test::SimpleTest::testQuickCreateAndDestroy (this=0x80ce468) at activemq/test/SimpleTest.cpp:335\n#14 0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x80ce478) at /usr/local/include/cppunit/TestCaller.h:166\n#15 0x00ef3bd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfa9f494) at TestCase.cpp:32\n#16 0x00ee55ee in CppUnit::DefaultProtector::protect (this=0x80cdf40, functor=@0xbfa9f494, context=@0xbfa9f43c) at DefaultProtector.cpp:15\n#17 0x00eef7a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x8110a70) at ProtectorChain.cpp:20\n#18 0x00eef4f5 in CppUnit::ProtectorChain::protect (this=0x80cdce0, functor=@0xbfa9f494, context=@0xbfa9f43c) at ProtectorChain.cpp:77\n#19 0x00efbe81 in CppUnit::TestResult::protect (this=0x80cda60, functor=@0xbfa9f494, test=0x80ce478, shortDescription=@0xbfa9f4b8) at TestResult.cpp:178\n#20 0x00ef38dd in CppUnit::TestCase::run (this=0x80ce478, result=0x80cda60) at TestCase.cpp:92\n#21 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80ce010, controller=0x80cda60) at TestComposite.cpp:64\n#22 0x00ef417a in CppUnit::TestComposite::run (this=0x80ce010, result=0x80cda60) at TestComposite.cpp:23\n#23 0x00ef423f in CppUnit::TestComposite::doRunChildTests (this=0x80cdf80, controller=0x80cda60) at TestComposite.cpp:64\n#24 0x00ef417a in CppUnit::TestComposite::run (this=0x80cdf80, result=0x80cda60) at TestComposite.cpp:23\n#25 0x00efe440 in CppUnit::TestRunner::WrappingSuite::run (this=0x80cd570, result=0x80cda60) at TestRunner.cpp:47\n#26 0x00efbc1a in CppUnit::TestResult::runTest (this=0x80cda60, test=0x80cd570) at TestResult.cpp:145\n#27 0x00efe280 in CppUnit::TestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TestRunner.cpp:96\n#28 0x00f019db in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, controller=@0x80cda60, testPath=@0xbfa9f904) at TextTestRunner.cpp:140\n#29 0x00f01a55 in CppUnit::TextTestRunner::run (this=0xbfa9f8e4, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfa9f904 \"ï¿½ï¿½$\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#30 0x0804ffc5 in main (argc=1, argv=0xbfa9f9c4) at main.cpp:77\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\n#1  0x00627e1b in read () from /lib/libpthread.so.0\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\n#12 0x00578c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\n#4  0x00578c4e in clone () from /lib/libc.so.6\n(gdb) thread apply all bt full\n\nThread 3 (process 24403):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x006254dc in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00124f3e in apr_thread_cond_timedwait (cond=0x8118020, mutex=0x8116018, timeout=15000000) at locks/unix/thread_cond.c:89\n        rv = 12196256\n        then = 1241684283140354\n        abstime = {tv_sec = 1241684283, tv_nsec = 140354000}\n#3  0x007af72a in decaf::util::concurrent::Mutex::wait (this=0x80d3d9c, millisecs=15000) at decaf/util/concurrent/Mutex.cpp:116\n        lock_owner = 3086771968\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x8118020\n        subPool = (apr_pool_t *) 0x8117fe0\n#4  0x007b48df in decaf::util::concurrent::CountDownLatch::await (this=0x80d3d94, timeOut=15000) at decaf/util/concurrent/CountDownLatch.cpp:69\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x80d3d9c}\n        ex = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x98da55 \"\\213]ï¿½\\213uï¿½\\213}ï¿½\\211ï¿½]ï¿½ï¿½\\004$\\030\"}}, cause = 0x80d25d0, \n  stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n      _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xbfa9ef60, \n        _M_finish = 0x8, _M_end_of_storage = 0x2485d4}}, <No data fields>}}\n#5  0x0085538c in activemq::transport::correlator::FutureResponse::getResponse (this=0x80d3d90, timeout=15000)\n    at ./activemq/transport/correlator/FutureResponse.h:76\nNo locals.\n#6  0x00854264 in activemq::transport::correlator::ResponseCorrelator::request (this=0x80d3488, command=@0xbfa9ef60, timeout=15000)\n    at activemq/transport/correlator/ResponseCorrelator.cpp:142\n        lock_W = {_vptr.Lock = 0x8096df8, locked = false, syncObject = 0x80d34c4}\n        response = {<decaf::lang::AtomicRefCounter> = {counter = 0x80f2fc0}, _vptr.Pointer = 0xb8c718, value = 0x0}\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {Cannot access memory at address 0x5f3f\n\nThread 2 (process 24537):\n#0  0x00bce402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00627e1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0012bdd6 in apr_socket_recv (sock=0x80f5b98, buf=0x80fbaa0 \"\", len=0xb7fc5120) at network_io/unix/sendrecv.c:81\n        rv = -1208200952\n        arv = 1199426\n#3  0x00800f89 in decaf::net::SocketInputStream::read (this=0x80d1890, buffer=0x80fbaa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x00817e91 in decaf::io::BufferedInputStream::bufferData (this=0x80d1a10) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x124d42 \"\\211Eï¿½\\213Eï¿½\\203ï¿½\\024[]ï¿½U\\211ï¿½S\\203ï¿½\\024ï¿½ï¿½>ï¿½ï¿½\\201ï¿½\\226J\\001\"}}, cause = 0x80c0c7c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8110928, \n          _M_finish = 0xb7fc51c8, _M_end_of_storage = 0x807f0c1}}, <No data fields>}}, <No data fields>}\n#5  0x00818491 in decaf::io::BufferedInputStream::read (this=0x80d1a10, targetBuffer=0x80d180e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0xb7fc51fc, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5208, \n          _M_finish = 0x0, _M_end_of_storage = 0xb7fc51f0}}, <No data fields>}}, <No data fields>}\n#6  0x00825d07 in decaf::io::DataInputStream::readInt (this=0x80d17e0) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x80d1ee8 \"\\b\\206ï¿½\"}}, \n    cause = 0x80d16d0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fc5248, \n          _M_finish = 0x5e6ff4, _M_end_of_storage = 0x5e8140}}, <No data fields>}}, <No data fields>}\n#7  0x00861528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x80d0ee8, transport=0x80d16d0, dis=0x80d17e0)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xb7fc5298 \"ï¿½Rï¿½ï¿½ï¿½\\031ï¿½\"}}, \n    cause = 0x217731, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x80fc820, \n          _M_finish = 0xba19a0, _M_end_of_storage = 0xb7fc52a8}}, <No data fields>}}, <No data fields>}\n#8  0x00855f80 in activemq::transport::IOTransport::run (this=0x80d16d0) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d1ee8}, _vptr.Pointer = 0xb8bb40, value = 0x80fc820}\n#9  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c4f08, param=0x80d1790) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00134a4c in dummy_worker (opaque=0x80c4f08) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c4f08\n#11 0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 24769):\n#0  0x00855fb6 in activemq::transport::IOTransport::run (this=0x80d2588) at ./decaf/lang/Pointer.h:68\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x80d3db0}, _vptr.Pointer = 0xb8bb40, value = 0x80f3438}\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\nNo locals.\n#2  0x00134a4c in dummy_worker (opaque=0x80c5568) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x80c5568\n#3  0x0062145b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#4  0x00578c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\n(gdb) list\n63               *\n64               * @return true if the count is now zero.\n65               */\n66              bool release() {\n67                  if( this->counter->decrementAndGet() == 0 ) {\n68                      delete this->counter;\n69                      return true;\n70                  }\n71                  return false;\n72              }\n(gdb) up\n#1  0x007acd98 in decaf::lang::Thread::runCallback (self=0x80c5568, param=0x80d3560) at decaf/lang/Thread.cpp:125\n125             thread->task->run();\n(gdb) list\n120         // Get the instance.\n121         Thread* thread = (Thread*)param;\n122\n123         // Invoke run on the task.\n124         try{\n125             thread->task->run();\n126         } catch( ... ){\n127             RuntimeException ex(\n128                 __FILE__, __LINE__,\n129                 \"unhandled exception bubbled up to Thread::run\");\n{noformat}\n\n{noformat}\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00000011 in ?? ()\n(gdb) info threads\n  3 process 5624  0x00be0402 in __kernel_vsyscall ()\n  2 process 5632  0x00be0402 in __kernel_vsyscall ()\n* 1 process 5500  0x00000011 in ?? ()\n(gdb) thread apply all bt full\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n        rv = -1208123128\n        arv = 6628709\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n        size = 1\n        result = <value optimized out>\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n        available = 0\n        bytesRead = <value optimized out>\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = <invalid address>, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x92b460 \"U\\211ï¿½\\203ï¿½(\\211}ï¿½\\213}\\b\\211uï¿½\\213u\\f\\211]ï¿½ï¿½]ï¿½ï¿½ï¿½\\201ï¿½&5\\021\"}}, cause = 0x9efef48, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x146391, \n          _M_finish = 0x415140, _M_end_of_storage = 0x95495a}}, <No data fields>}}, <No data fields>}\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n        bytesToCopy = 0\n        totalRead = 0\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9ee9518 \"ï¿½nï¿½\"}}, \n    cause = 0xb7fd82f0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd81f8, \n          _M_finish = 0x1, _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9edf7d8 \"ï¿½ï¿½ï¿½\\t\"}}, \n    cause = 0x9ebe700, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7fd8248, \n          _M_finish = 0x147880, _M_end_of_storage = 0xb7fd8268}}, <No data fields>}}, <No data fields>}\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n        ex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7fd82a8 \"\\030\\203ï¿½ï¿½\\200/o\"}}, cause = 0x652565, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x9edf7dc, \n          _M_finish = 0xa3e9a0, _M_end_of_storage = 0xb7fd82a8}}, <No data fields>}}, <No data fields>}\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n        command = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edf7d8}, _vptr.Pointer = 0xa28b40, value = 0x9efef48}\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\nNo locals.\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ec8\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#12 0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n        rv = 166715416\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n        lock_owner = 3065867152\n        lock_count = 1\n        waitEvent = (apr_thread_cond_t *) 0x9edb7b0\n        subPool = (apr_pool_t *) 0x9edb770\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\nNo locals.\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n        lock_W = {_vptr.Lock = 0x8096df8, locked = true, syncObject = 0x9efe008}\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\nNo locals.\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n        thread = (apr_thread_t *) 0x9eb1ee8\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#9  0x003a5c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\nNo symbol table info available.\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\nNo locals.\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\nNo locals.\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n        cpputMsg_ = {m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x9ee04bc \"activemq/test/SimpleTest.cpp\"}}, \n  m_details = {<std::_Deque_base<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {\n      _M_impl = {<std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<__gnu_cxx::new_allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<No data fields>}, <No data fields>}, _M_map = 0x9ee0548, _M_map_size = 8, _M_start = {\n          _M_cur = 0x9ee0570, _M_first = 0x9ee0570, _M_last = 0x9ee0770, _M_node = 0x9ee0554}, _M_finish = {_M_cur = 0x9ee0578, _M_first = 0x9ee0570, \n          _M_last = 0x9ee0770, _M_node = 0x9ee0554}}}, <No data fields>}}\n        session = <value optimized out>\n        consumer = (class cms::MessageConsumer *) 0x9efe6c8\n        producer = (class cms::MessageProducer *) 0x9efea40\n        bytesMessage2 = (class cms::BytesMessage *) 0x9edf7e8\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\nNo locals.\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\nNo locals.\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\nNo locals.\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\nNo locals.\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n        __node_offset = <value optimized out>\n        functors = {<std::_Deque_base<CppUnit::Functor*,std::allocator<CppUnit::Functor*> >> = {\n    _M_impl = {<std::allocator<CppUnit::Functor*>> = {<__gnu_cxx::new_allocator<CppUnit::Functor*>> = {<No data fields>}, <No data fields>}, \n      _M_map = 0x9ebb2d0, _M_map_size = 8, _M_start = {_M_cur = 0x9ebbb10, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}, _M_finish = {\n        _M_cur = 0x9ebbb14, _M_first = 0x9ebbb10, _M_last = 0x9ebbd10, _M_node = 0x9ebb2dc}}}, <No data fields>}\n        outermostFunctor = (const class CppUnit::Functor &) @0x9edffa0: {_vptr.Functor = 0x0}\n        succeed = <value optimized out>\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n        context = {m_test = 0x9ebb448, m_result = 0x9ebaa60, m_shortDescription = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}}\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\nNo locals.\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 9\n        childCount = 14\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n        index = 1\n        childCount = 1\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\nNo locals.\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\nNo locals.\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\nNo locals.\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n        path = {_vptr.TestPath = 0x1be1c8, m_tests = {<std::_Deque_base<CppUnit::Test*,std::allocator<CppUnit::Test*> >> = {\n      _M_impl = {<std::allocator<CppUnit::Test*>> = {<__gnu_cxx::new_allocator<CppUnit::Test*>> = {<No data fields>}, <No data fields>}, \n        _M_map = 0x9ebb2a8, _M_map_size = 8, _M_start = {_M_cur = 0x9ebb908, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}, _M_finish = {\n          _M_cur = 0x9ebb90c, _M_first = 0x9ebb908, _M_last = 0x9ebbb08, _M_node = 0x9ebb2b4}}}, <No data fields>}}\n        testToRun = (class CppUnit::Test *) 0x9edffa0\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\nNo locals.\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n        progress = {<CppUnit::TestListener> = {_vptr.TestListener = 0x1be5e8}, <No data fields>}\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n        runner = {<CppUnit::TestRunner> = {_vptr.TestRunner = 0x1be708, m_suite = 0x9eba570}, m_result = 0x9eba588, m_eventManager = 0x9ebaa60, \n  m_outputter = 0x9ebaf50}\n        registry = (class CppUnit::TestFactoryRegistry &) @0x9eb60b8: {<CppUnit::TestFactory> = {_vptr.TestFactory = 0x1be0b0}, m_factories = {_M_t = {\n      _M_impl = {<std::allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<CppUnit::TestFactory*> >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, _M_header = {_M_color = std::_S_red, \n          _M_parent = 0x9eb6100, _M_left = 0x9eb6100, _M_right = 0x9eb6100}, _M_node_count = 1}}}, m_name = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x9eb60a4 \"All Tests\"}}}\n        wasSuccessful = <value optimized out>\n        outputFile = <incomplete type>\n        useXMLOutputter = false\n(gdb) thread apply all bt\n\nThread 3 (process 5624):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x0014ae1b in read () from /lib/libpthread.so.0\n#2  0x00f96dd6 in apr_socket_recv (sock=0x9ee2b98, buf=0x9ee8aa0 \"\", len=0xb7fd8120) at network_io/unix/sendrecv.c:81\n#3  0x0069df89 in decaf::net::SocketInputStream::read (this=0x9ebe8c0, buffer=0x9ee8aa0 \"\", offset=0, bufferSize=1) at decaf/net/SocketInputStream.cpp:179\n#4  0x006b4e91 in decaf::io::BufferedInputStream::bufferData (this=0x9ebea40) at decaf/io/BufferedInputStream.cpp:260\n#5  0x006b5491 in decaf::io::BufferedInputStream::read (this=0x9ebea40, targetBuffer=0x9ebe83e \"\", offset=0, targetBufferSize=4)\n    at decaf/io/BufferedInputStream.cpp:181\n#6  0x006c2d07 in decaf::io::DataInputStream::readInt (this=0x9ebe810) at ./decaf/io/DataInputStream.h:375\n#7  0x006fe528 in activemq::wireformat::openwire::OpenWireFormat::unmarshal (this=0x9ebdf38, transport=0x9ebe700, dis=0x9ebe810)\n    at activemq/wireformat/openwire/OpenWireFormat.cpp:250\n#8  0x006f2f80 in activemq::transport::IOTransport::run (this=0x9ebe700) at activemq/transport/IOTransport.cpp:223\n#9  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ec8, param=0x9ee9838) at decaf/lang/Thread.cpp:125\n#10 0x00f9fa4c in dummy_worker (opaque=0x9eb1ec8) at threadproc/unix/thread.c:142\n#11 0x0014445b in start_thread () from /lib/libpthread.so.0\n#12 0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 2 (process 5632):\n#0  0x00be0402 in __kernel_vsyscall ()\n#1  0x00148256 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x00f8fe83 in apr_thread_cond_wait (cond=0x9edb7b0, mutex=0x9ed5798) at locks/unix/thread_cond.c:68\n#3  0x0064c775 in decaf::util::concurrent::Mutex::wait (this=0x9efe008, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:118\n#4  0x0064c635 in decaf::util::concurrent::Mutex::wait (this=0x9efe008) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x00892f85 in activemq::threads::DedicatedTaskRunner::run (this=0x9efe000) at activemq/threads/DedicatedTaskRunner.cpp:118\n#6  0x00649d98 in decaf::lang::Thread::runCallback (self=0x9eb1ee8, param=0x9ebb770) at decaf/lang/Thread.cpp:125\n#7  0x00f9fa4c in dummy_worker (opaque=0x9eb1ee8) at threadproc/unix/thread.c:142\n#8  0x0014445b in start_thread () from /lib/libpthread.so.0\n#9  0x003a5c4e in clone () from /lib/libc.so.6\n\nThread 1 (process 5500):\n#0  0x00000011 in ?? ()\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n#2  0x00924793 in ~ActiveMQBytesMessage (this=0x9edf7e8) at ./activemq/commands/ActiveMQMessageTemplate.h:45\n#3  0x0806bc96 in activemq::test::SimpleTest::testBytesMessageSendRecv (this=0x9ebb438)\n    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259\n#4  0x08052ac7 in CppUnit::TestCaller<activemq::test::openwire::OpenwireSimpleTest>::runTest (this=0x9ebb448) at /usr/local/include/cppunit/TestCaller.h:166\n#5  0x0019bbd7 in CppUnit::TestCaseMethodFunctor::operator() (this=0xbfac14b4) at TestCase.cpp:32\n#6  0x0018d5ee in CppUnit::DefaultProtector::protect (this=0x9ebaf40, functor=@0xbfac14b4, context=@0xbfac145c) at DefaultProtector.cpp:15\n#7  0x001977a3 in CppUnit::ProtectorChain::ProtectFunctor::operator() (this=0x9efde60) at ProtectorChain.cpp:20\n#8  0x001974f5 in CppUnit::ProtectorChain::protect (this=0x9ebace0, functor=@0xbfac14b4, context=@0xbfac145c) at ProtectorChain.cpp:77\n#9  0x001a3e81 in CppUnit::TestResult::protect (this=0x9ebaa60, functor=@0xbfac14b4, test=0x9ebb448, shortDescription=@0xbfac14d8) at TestResult.cpp:178\n#10 0x0019b8dd in CppUnit::TestCase::run (this=0x9ebb448, result=0x9ebaa60) at TestCase.cpp:92\n#11 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebb010, controller=0x9ebaa60) at TestComposite.cpp:64\n#12 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebb010, result=0x9ebaa60) at TestComposite.cpp:23\n#13 0x0019c23f in CppUnit::TestComposite::doRunChildTests (this=0x9ebaf80, controller=0x9ebaa60) at TestComposite.cpp:64\n#14 0x0019c17a in CppUnit::TestComposite::run (this=0x9ebaf80, result=0x9ebaa60) at TestComposite.cpp:23\n#15 0x001a6440 in CppUnit::TestRunner::WrappingSuite::run (this=0x9eba570, result=0x9ebaa60) at TestRunner.cpp:47\n#16 0x001a3c1a in CppUnit::TestResult::runTest (this=0x9ebaa60, test=0x9eba570) at TestResult.cpp:145\n#17 0x001a6280 in CppUnit::TestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TestRunner.cpp:96\n#18 0x001a99db in CppUnit::TextTestRunner::run (this=0xbfac1904, controller=@0x9ebaa60, testPath=@0xbfac1924) at TextTestRunner.cpp:140\n#19 0x001a9a55 in CppUnit::TextTestRunner::run (this=0xbfac1904, testName=\n        {static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0xbfac1924 \"ï¿½\\233*\"}}, doWait=false, doPrintResult=true, doPrintProgress=true) at TextTestRunner.cpp:64\n#20 0x0804ffc5 in main (argc=1, argv=0xbfac19e4) at main.cpp:77\n(gdb) up\n#1  0x008ea35d in ~Message (this=0x9edf7ec) at activemq/commands/Message.cpp:68\n68      }\n(gdb) list\n63          this->brokerOutTime = 0;\n64      }\n65\n66      ////////////////////////////////////////////////////////////////////////////////\n67      Message::~Message() {\n68      }\n69\n70      ////////////////////////////////////////////////////////////////////////////////\n71      Message* Message::cloneDataStructure() const {\n72          std::auto_ptr<Message> message( new Message() );\n(gdb) p this\n$1 = (class activemq::commands::Message * const) 0x9edf7ec\n(gdb) p *this\n$2 = {<activemq::commands::BaseCommand> = {<activemq::commands::Command> = {<activemq::commands::BaseDataStructure> = {<activemq::commands::DataStructure> = {<activemq::wireformat::MarshalAware> = {_vptr.MarshalAware = 0xa39108}, <No data fields>}, <No data fields>}, <No data fields>}, responseRequired = false, \n    commandId = 5}, ackHandler = 0x0, \n  properties = {<decaf::util::StlMap<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::Map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,activemq::util::PrimitiveValueNode,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa34be8}, <No data fields>}, valueMap = {_M_t = {\n          _M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, activemq::util::PrimitiveValueNode> > >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<> = {<No data fields>}, <No data fields>}, \n            _M_header = {_M_color = std::_S_red, _M_parent = 0x0, _M_left = 0x9edf804, _M_right = 0x9edf804}, _M_node_count = 0}}}, \n      mutex = {<decaf::util::concurrent::Synchronizable> = {_vptr.Synchronizable = 0xa25468}, aprPool = {_vptr.AprPool = 0xa25fa8, aprPool = 0x9f543f0}, \n        mutex = 0x9f54430, eventQ = {<std::_List_base<apr_thread_cond_t*,std::allocator<apr_thread_cond_t*> >> = {\n            _M_impl = {<std::allocator<std::_List_node<apr_thread_cond_t*> >> = {<__gnu_cxx::new_allocator<std::_List_node<apr_thread_cond_t*> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x9edf828, _M_prev = 0x9edf828}}}, <No data fields>}, lock_owner = 0, lock_count = 0}}, converter = {\n      _vptr.PrimitiveValueConverter = 0xa2d9b0}}, readOnlyProperties = true, readOnlyBody = true, static DEFAULT_MESSAGE_SIZE = 1024, \n  producerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee0250}, _vptr.Pointer = 0xa2aca0, value = 0x9ee01a8}, \n  destination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ebeee0}, _vptr.Pointer = 0xa2acf0, value = 0x9ee0260}, \n  transactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9ee02d0}, _vptr.Pointer = 0xa2a938, value = 0x0}, \n  originalDestination = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc08}, _vptr.Pointer = 0xa2acf0, value = 0x0}, \n  messageId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc18}, _vptr.Pointer = 0xa2acc8, value = 0x9ee02e0}, \n  originalTransactionId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edfc28}, _vptr.Pointer = 0xa2a938, value = 0x0}, groupID = {\n    static npos = 4294967295, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n      _M_p = 0x2a9bbc \"\"}}, groupSequence = 0, correlationId = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  persistent = false, expiration = 0, priority = 4 '\\004', replyTo = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edff98}, _vptr.Pointer = 0xa2acf0, \n    value = 0x0}, timestamp = 1241684145316, type = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  content = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, \n        _M_start = 0x9ee0490 \"\", _M_finish = 0x9ee04aa \"il1\\005\", _M_end_of_storage = 0x9ee04aa \"il1\\005\"}}, <No data fields>}, \n  marshalledProperties = {<std::_Vector_base<unsigned char,std::allocator<unsigned char> >> = {\n      _M_impl = {<std::allocator<unsigned char>> = {<__gnu_cxx::new_allocator<unsigned char>> = {<No data fields>}, <No data fields>}, _M_start = 0x0, \n        _M_finish = 0x0, _M_end_of_storage = 0x0}}, <No data fields>}, dataStructure = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffa8}, \n    _vptr.Pointer = 0xa2a248, value = 0x0}, targetConsumerId = {<decaf::lang::AtomicRefCounter> = {counter = 0x9edffb8}, _vptr.Pointer = 0xa2aad8, \n    value = 0x0}, compressed = false, redeliveryCounter = 0, \n  brokerPath = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, arrival = 0, userID = {static npos = 4294967295, \n    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x2a9bbc \"\"}}, \n  recievedByDFBridge = false, droppable = false, \n  cluster = {<std::_Vector_base<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter>,std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> > >> = {\n      _M_impl = {<std::allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<__gnu_cxx::new_allocator<decaf::lang::Pointer<activemq::commands::BrokerId, decaf::lang::AtomicRefCounter> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n        _M_end_of_storage = 0x0}}, <No data fields>}, brokerInTime = 1241684145317, brokerOutTime = 1241684145317, static ID_MESSAGE = 0 '\\0'}\n{noformat}\n\n\nComments:\n", "classification": "Classify the issue 'Segfault when destroying auto pointer managed objects' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-242?\nA: Looks like integration tests may cause occasionally segmentation faults (3 chances in 165 tries), specially when releasing aut_ptr managed objects. The following three gdb sessions show similar crashes.\n\nTestRegistry.cpp was modified to run only OpenwireSimpleTest by commenting all other tests out in order to narrow the problem.\n\nHope this helps,\n  Alex\n\n{noformat}\nProgram terminated with signal 1"}}
{"issue_key": "AMQCPP-241", "project": "AMQCPP", "title": "Support the standard JMS property type conversion rules.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-04-30T18:56:16.000+0000", "updated": "2009-05-04T15:15:08.000+0000", "description": "Currently the CMS Message interface restricts the user from calling a get method on a property that is not of the type that matches the call, for instance call getIntProperty when the value contained internally is a long would throw an exception.  To make this interface more flexible and to allow for stomp support to work properly in the new architecture it is necessary to support conversion of all the elements in the properties to a string type.  Since this happens automatically as a result of implementing the standard JMS conversion table it makes sense to do this in a way that's allows the CMS interface implementation to benefit from it as well.\n\nThe implementation follows the same rules as defined in the JMS API docs for the Message Interface.\n\n{quote}\nMessage properties support the following conversion table. The marked cases must be supported. The unmarked cases must throw a JMSException. The String-to-primitive conversions may throw a runtime exception if the primitive's valueOf method does not accept the String as a valid representation of the primitive.\n\nA value written as the row type can be read as the column type.\n\n{noformat}\n |        | boolean byte short int long float double String \n |----------------------------------------------------------\n |boolean |    X                                       X\n |byte    |          X     X    X   X                  X \n |short   |                X    X   X                  X \n |int     |                     X   X                  X \n |long    |                         X                  X \n |float   |                               X     X      X \n |double  |                                     X      X \n |String  |    X     X     X    X   X     X     X      X \n |----------------------------------------------------------\n \n{noformat}\n\n{quote}", "comments": [], "text": "Support the standard JMS property type conversion rules.\n\nDescription:\nCurrently the CMS Message interface restricts the user from calling a get method on a property that is not of the type that matches the call, for instance call getIntProperty when the value contained internally is a long would throw an exception.  To make this interface more flexible and to allow for stomp support to work properly in the new architecture it is necessary to support conversion of all the elements in the properties to a string type.  Since this happens automatically as a result of implementing the standard JMS conversion table it makes sense to do this in a way that's allows the CMS interface implementation to benefit from it as well.\n\nThe implementation follows the same rules as defined in the JMS API docs for the Message Interface.\n\n{quote}\nMessage properties support the following conversion table. The marked cases must be supported. The unmarked cases must throw a JMSException. The String-to-primitive conversions may throw a runtime exception if the primitive's valueOf method does not accept the String as a valid representation of the primitive.\n\nA value written as the row type can be read as the column type.\n\n{noformat}\n |        | boolean byte short int long float double String \n |----------------------------------------------------------\n |boolean |    X                                       X\n |byte    |          X     X    X   X                  X \n |short   |                X    X   X                  X \n |int     |                     X   X                  X \n |long    |                         X                  X \n |float   |                               X     X      X \n |double  |                                     X      X \n |String  |    X     X     X    X   X     X     X      X \n |----------------------------------------------------------\n \n{noformat}\n\n{quote}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Support the standard JMS property type conversion rules.\n\nDescription:\nCurrently the CMS Message interface restricts the user from calling a get method on a property that is not of the type that matches the call, for instance call getIntProperty when the value contained internally is a long would throw an exception.  To make this interface more flexible and to allow for stomp support to work properly in the new architecture it is necessary to support conversion of all the elements in the properties to a string type.  Since this happens automatically as a result of implementing the standard JMS conversion table it makes sense to do this in a way that's allows the CMS interface implementation to benefit from it as well.\n\nThe implementation follows the same rules as defined in the JMS API docs for the Message Interface.\n\n{quote}\nMessage properties support the following conversion table. The marked cases must be supported. The unmarked cases must throw a JMSException. The String-to-primitive conversions may throw a runtime exception if the primitive's valueOf method does not accept the String as a valid representation of the primitive.\n\nA value written as the row type can be read as the column type.\n\n{noformat}\n |        | boolean byte short int long float double String \n |----------------------------------------------------------\n |boolean |    X                                       X\n |byte    |          X     X    X   X                  X \n |short   |                X    X   X                  X \n |int     |                     X   X                  X \n |long    |                         X                  X \n |float   |                               X     X      X \n |double  |                                     X      X \n |String  |    X     X     X    X   X     X     X      X \n |----------------------------------------------------------\n \n{noformat}\n\n{quote}\n\nComments:\n", "classification": "Classify the issue 'Support the standard JMS property type conversion rules.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-241?\nA: Currently the CMS Message interface restricts the user from calling a get method on a property that is not of the type that matches the call, for instance call getIntProperty when the value contained internally is a long would throw an exception.  To make this interface more flexible and to allow for stomp support to work properly in the new architecture it is necessary to support conversion of al"}}
{"issue_key": "AMQCPP-240", "project": "AMQCPP", "title": "Add the Individual Ack type to the CMS API and support of it in the ActiveMQConsumer code.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-04-30T13:35:05.000+0000", "updated": "2009-11-12T22:31:42.000+0000", "description": "ActiveMQ supports an individual Ack type that only acks a single message instead of all messages that came before the one being ack'd.  We should add this to the set of supported Ack types in CMS and implement this processing in the consumer code, and also would have to add it to the StompWireFormat message ack marshalling.", "comments": [], "text": "Add the Individual Ack type to the CMS API and support of it in the ActiveMQConsumer code.\n\nDescription:\nActiveMQ supports an individual Ack type that only acks a single message instead of all messages that came before the one being ack'd.  We should add this to the set of supported Ack types in CMS and implement this processing in the consumer code, and also would have to add it to the StompWireFormat message ack marshalling.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add the Individual Ack type to the CMS API and support of it in the ActiveMQConsumer code.\n\nDescription:\nActiveMQ supports an individual Ack type that only acks a single message instead of all messages that came before the one being ack'd.  We should add this to the set of supported Ack types in CMS and implement this processing in the consumer code, and also would have to add it to the StompWireFormat message ack marshalling.\n\nComments:\n", "classification": "Classify the issue 'Add the Individual Ack type to the CMS API and support of it in the ActiveMQConsumer code.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-240?\nA: ActiveMQ supports an individual Ack type that only acks a single message instead of all messages that came before the one being ack'd.  We should add this to the set of supported Ack types in CMS and implement this processing in the consumer code, and also would have to add it to the StompWireFormat message ack marshalling."}}
{"issue_key": "AMQCPP-239", "project": "AMQCPP", "title": "How to Build binary using ActiveMQ CPP and Purify", "status": "Closed", "reporter": "Chintan Desai", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-04-24T07:29:24.000+0000", "updated": "2009-04-24T12:25:44.000+0000", "description": "I am trying to build binary for my project. Using Purify and ActiveMQCpp 2.2.5, I am getting following error :\nPurify engine: While processing file /home/cndesai/ActiveMQCPP2.2.5/lib/libactivemq-cpp.so.7.0.0:\nError: PIC offset 0x59be5e (section 10) not in text or GOT section\nPlease visit www.ibm.com/software/support and search the\nsupport database using keywords from the error message.\nIf you are unable to resolve this issue, please submit\na problem report using the same web page.\nPlease include the product name and version \n(Purify 2003a.06.15 FixPack 0194 051103 Solaris 2 (32-bit)),\nplus your compiler name and version, operating system version,\nthis and any preceding error messages, and ideally a uuencoded\ncopy of any object or data files involved.\nThank you.", "comments": [], "text": "How to Build binary using ActiveMQ CPP and Purify\n\nDescription:\nI am trying to build binary for my project. Using Purify and ActiveMQCpp 2.2.5, I am getting following error :\nPurify engine: While processing file /home/cndesai/ActiveMQCPP2.2.5/lib/libactivemq-cpp.so.7.0.0:\nError: PIC offset 0x59be5e (section 10) not in text or GOT section\nPlease visit www.ibm.com/software/support and search the\nsupport database using keywords from the error message.\nIf you are unable to resolve this issue, please submit\na problem report using the same web page.\nPlease include the product name and version \n(Purify 2003a.06.15 FixPack 0194 051103 Solaris 2 (32-bit)),\nplus your compiler name and version, operating system version,\nthis and any preceding error messages, and ideally a uuencoded\ncopy of any object or data files involved.\nThank you.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: How to Build binary using ActiveMQ CPP and Purify\n\nDescription:\nI am trying to build binary for my project. Using Purify and ActiveMQCpp 2.2.5, I am getting following error :\nPurify engine: While processing file /home/cndesai/ActiveMQCPP2.2.5/lib/libactivemq-cpp.so.7.0.0:\nError: PIC offset 0x59be5e (section 10) not in text or GOT section\nPlease visit www.ibm.com/software/support and search the\nsupport database using keywords from the error message.\nIf you are unable to resolve this issue, please submit\na problem report using the same web page.\nPlease include the product name and version \n(Purify 2003a.06.15 FixPack 0194 051103 Solaris 2 (32-bit)),\nplus your compiler name and version, operating system version,\nthis and any preceding error messages, and ideally a uuencoded\ncopy of any object or data files involved.\nThank you.\n\n\nComments:\n", "classification": "Classify the issue 'How to Build binary using ActiveMQ CPP and Purify' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-239?\nA: I am trying to build binary for my project. Using Purify and ActiveMQCpp 2.2.5, I am getting following error :\nPurify engine: While processing file /home/cndesai/ActiveMQCPP2.2.5/lib/libactivemq-cpp.so.7.0.0:\nError: PIC offset 0x59be5e (section 10) not in text or GOT section\nPlease visit www.ibm.com/software/support and search the\nsupport database using keywords from the error message.\nIf you are "}}
{"issue_key": "AMQCPP-238", "project": "AMQCPP", "title": "Add support for output of CPPUnit test results in different formats", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-04-22T15:11:20.000+0000", "updated": "2009-04-22T22:49:20.000+0000", "description": "Add the ability to specify on the command line for the unit and integration tests the format of the test result output.  This will allow for different output format for use in running the tests under a continuous integration suite.\n\nPlanned set\n\n-xml <filename>\n-default\n-teamcity", "comments": [], "text": "Add support for output of CPPUnit test results in different formats\n\nDescription:\nAdd the ability to specify on the command line for the unit and integration tests the format of the test result output.  This will allow for different output format for use in running the tests under a continuous integration suite.\n\nPlanned set\n\n-xml <filename>\n-default\n-teamcity\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for output of CPPUnit test results in different formats\n\nDescription:\nAdd the ability to specify on the command line for the unit and integration tests the format of the test result output.  This will allow for different output format for use in running the tests under a continuous integration suite.\n\nPlanned set\n\n-xml <filename>\n-default\n-teamcity\n\n\n\nComments:\n", "classification": "Classify the issue 'Add support for output of CPPUnit test results in different formats' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-238?\nA: Add the ability to specify on the command line for the unit and integration tests the format of the test result output.  This will allow for different output format for use in running the tests under a continuous integration suite.\n\nPlanned set\n\n-xml <filename>\n-default\n-teamcity\n\n"}}
{"issue_key": "AMQCPP-237", "project": "AMQCPP", "title": "Create 64bit configurations in the VC2005 build projects", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-04-14T14:44:18.000+0000", "updated": "2009-04-18T13:22:38.000+0000", "description": "Create a configuration for building the AMQPP library as a 64bit library on Windows.", "comments": [], "text": "Create 64bit configurations in the VC2005 build projects\n\nDescription:\nCreate a configuration for building the AMQPP library as a 64bit library on Windows.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create 64bit configurations in the VC2005 build projects\n\nDescription:\nCreate a configuration for building the AMQPP library as a 64bit library on Windows.\n\nComments:\n", "classification": "Classify the issue 'Create 64bit configurations in the VC2005 build projects' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-237?\nA: Create a configuration for building the AMQPP library as a 64bit library on Windows."}}
{"issue_key": "AMQCPP-236", "project": "AMQCPP", "title": "maxInactivityDuration of Wire-Format is not supported by ActiveMQ-CPP2.2.5", "status": "Resolved", "reporter": "liu jun", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-04-10T02:14:55.000+0000", "updated": "2009-04-14T20:07:30.000+0000", "description": "maxInactivityDuration argument  in brokerurl is not processed by the wireformat factory", "comments": [], "text": "maxInactivityDuration of Wire-Format is not supported by ActiveMQ-CPP2.2.5\n\nDescription:\nmaxInactivityDuration argument  in brokerurl is not processed by the wireformat factory \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: maxInactivityDuration of Wire-Format is not supported by ActiveMQ-CPP2.2.5\n\nDescription:\nmaxInactivityDuration argument  in brokerurl is not processed by the wireformat factory \n\nComments:\n", "classification": "Classify the issue 'maxInactivityDuration of Wire-Format is not supported by ActiveMQ-CPP2.2.5' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-236?\nA: maxInactivityDuration argument  in brokerurl is not processed by the wireformat factory "}}
{"issue_key": "AMQCPP-235", "project": "AMQCPP", "title": "UTF8 length marshalling bug in openwire readString and writeString.", "status": "Resolved", "reporter": "Martin Schlapfer", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-04-08T16:46:06.000+0000", "updated": "2009-04-20T23:30:07.000+0000", "description": "In investigating a bug for the check \"if( str->size() > 65536 )\" which should be \"if( str->size() > 65535 )\" in writeString() , I found a couple of other problems:\n(1) The OpenwireStringSupport::readString method should read the utf8 length as an unsigned short rather than short.  The problem is that utf8 encoded strings (using writeString) longer than 32768 will become truncated when read back using readString().\n(2) The writeString() method should also check the value of utflen after determining the UTF8 length of the encoded string, since with the support of characters greater than value 127, encodings of 2 UTF8 bytes per byte can exist.", "comments": [], "text": "UTF8 length marshalling bug in openwire readString and writeString.\n\nDescription:\nIn investigating a bug for the check \"if( str->size() > 65536 )\" which should be \"if( str->size() > 65535 )\" in writeString() , I found a couple of other problems:\n(1) The OpenwireStringSupport::readString method should read the utf8 length as an unsigned short rather than short.  The problem is that utf8 encoded strings (using writeString) longer than 32768 will become truncated when read back using readString().\n(2) The writeString() method should also check the value of utflen after determining the UTF8 length of the encoded string, since with the support of characters greater than value 127, encodings of 2 UTF8 bytes per byte can exist.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: UTF8 length marshalling bug in openwire readString and writeString.\n\nDescription:\nIn investigating a bug for the check \"if( str->size() > 65536 )\" which should be \"if( str->size() > 65535 )\" in writeString() , I found a couple of other problems:\n(1) The OpenwireStringSupport::readString method should read the utf8 length as an unsigned short rather than short.  The problem is that utf8 encoded strings (using writeString) longer than 32768 will become truncated when read back using readString().\n(2) The writeString() method should also check the value of utflen after determining the UTF8 length of the encoded string, since with the support of characters greater than value 127, encodings of 2 UTF8 bytes per byte can exist.\n\n\nComments:\n", "classification": "Classify the issue 'UTF8 length marshalling bug in openwire readString and writeString.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-235?\nA: In investigating a bug for the check \"if( str->size() > 65536 )\" which should be \"if( str->size() > 65535 )\" in writeString() , I found a couple of other problems:\n(1) The OpenwireStringSupport::readString method should read the utf8 length as an unsigned short rather than short.  The problem is that utf8 encoded strings (using writeString) longer than 32768 will become truncated when read back us"}}
{"issue_key": "AMQCPP-234", "project": "AMQCPP", "title": "URI class helpers are missing the DLLExport Macro", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-04-08T14:12:59.000+0000", "updated": "2009-04-08T14:37:35.000+0000", "description": "Two internal classes used in the URI class are missing the DECAF_API macro to properly export their public symbols in a DLL build.", "comments": [], "text": "URI class helpers are missing the DLLExport Macro\n\nDescription:\nTwo internal classes used in the URI class are missing the DECAF_API macro to properly export their public symbols in a DLL build.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: URI class helpers are missing the DLLExport Macro\n\nDescription:\nTwo internal classes used in the URI class are missing the DECAF_API macro to properly export their public symbols in a DLL build.\n\nComments:\n", "classification": "Classify the issue 'URI class helpers are missing the DLLExport Macro' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-234?\nA: Two internal classes used in the URI class are missing the DECAF_API macro to properly export their public symbols in a DLL build."}}
{"issue_key": "AMQCPP-233", "project": "AMQCPP", "title": "Update Windows Builds Files to use ENV vars to find dependancies", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2009-04-08T12:59:33.000+0000", "updated": "2009-04-10T12:22:25.000+0000", "description": "Update the DevStudio project files to use ENV vars to locate the includes and libraries it needs\n\nProposed ENV vars\n\nAPR_DIST - Points to the location APR and APR-Util are installed in (e.g. C:\\Program Files\\APR)\nCPPUNIT_DIST - Points to the CPPUnit install location\nPLATFORM_SDK - Points to the versions of the platform SDK to use.", "comments": [], "text": "Update Windows Builds Files to use ENV vars to find dependancies\n\nDescription:\nUpdate the DevStudio project files to use ENV vars to locate the includes and libraries it needs\n\nProposed ENV vars\n\nAPR_DIST - Points to the location APR and APR-Util are installed in (e.g. C:\\Program Files\\APR)\nCPPUNIT_DIST - Points to the CPPUnit install location\nPLATFORM_SDK - Points to the versions of the platform SDK to use.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update Windows Builds Files to use ENV vars to find dependancies\n\nDescription:\nUpdate the DevStudio project files to use ENV vars to locate the includes and libraries it needs\n\nProposed ENV vars\n\nAPR_DIST - Points to the location APR and APR-Util are installed in (e.g. C:\\Program Files\\APR)\nCPPUNIT_DIST - Points to the CPPUnit install location\nPLATFORM_SDK - Points to the versions of the platform SDK to use.\n\n\n\nComments:\n", "classification": "Classify the issue 'Update Windows Builds Files to use ENV vars to find dependancies' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-233?\nA: Update the DevStudio project files to use ENV vars to locate the includes and libraries it needs\n\nProposed ENV vars\n\nAPR_DIST - Points to the location APR and APR-Util are installed in (e.g. C:\\Program Files\\APR)\nCPPUNIT_DIST - Points to the CPPUnit install location\nPLATFORM_SDK - Points to the versions of the platform SDK to use.\n\n"}}
{"issue_key": "AMQCPP-232", "project": "AMQCPP", "title": "OpenWire encode and decode UTF8 incorrect", "status": "Resolved", "reporter": "Peter Pfort", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-03-26T15:26:54.000+0000", "updated": "2009-04-04T14:49:42.000+0000", "description": "Hallo,\n\nwe are using topic messages to sent messages from one user to another. Our program subscribe a durable consumer with selector \"UserName='<user>'\" and send a message with the property \"UserName\" and value \"<user>\".\n\nAll works fine, when <user> contains only ASCII characters. When <user> contains non ASCII characters like Ã¤Ã¶Ã¼ÃÃ©, the message is not send to the\n consumer.\n\nThe problem ist that readString and writeString in OpenwireStringSupport.cpp have bugs\n\n\nRegards,\nPeter", "comments": [], "text": "OpenWire encode and decode UTF8 incorrect\n\nDescription:\nHallo,\n\nwe are using topic messages to sent messages from one user to another. Our program subscribe a durable consumer with selector \"UserName='<user>'\" and send a message with the property \"UserName\" and value \"<user>\".\n\nAll works fine, when <user> contains only ASCII characters. When <user> contains non ASCII characters like Ã¤Ã¶Ã¼ÃÃ©, the message is not send to the\n consumer.\n\nThe problem ist that readString and writeString in OpenwireStringSupport.cpp have bugs\n\n\nRegards,\nPeter\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: OpenWire encode and decode UTF8 incorrect\n\nDescription:\nHallo,\n\nwe are using topic messages to sent messages from one user to another. Our program subscribe a durable consumer with selector \"UserName='<user>'\" and send a message with the property \"UserName\" and value \"<user>\".\n\nAll works fine, when <user> contains only ASCII characters. When <user> contains non ASCII characters like Ã¤Ã¶Ã¼ÃÃ©, the message is not send to the\n consumer.\n\nThe problem ist that readString and writeString in OpenwireStringSupport.cpp have bugs\n\n\nRegards,\nPeter\n\nComments:\n", "classification": "Classify the issue 'OpenWire encode and decode UTF8 incorrect' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-232?\nA: Hallo,\n\nwe are using topic messages to sent messages from one user to another. Our program subscribe a durable consumer with selector \"UserName='<user>'\" and send a message with the property \"UserName\" and value \"<user>\".\n\nAll works fine, when <user> contains only ASCII characters. When <user> contains non ASCII characters like Ã¤Ã¶Ã¼ÃÃ©, the message is not send to the\n consumer.\n\nThe problem ist that"}}
{"issue_key": "AMQCPP-231", "project": "AMQCPP", "title": "Segmentation fault in APR", "status": "Closed", "reporter": "Sebastien SOILEN", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-03-23T14:10:36.000+0000", "updated": "2009-08-31T20:20:28.000+0000", "description": "We get this segmentation fault occasionally with a monitoring script which establishes and closes a connection to the broker.\n\nHere is the used script:\n\n\n{quote}\n    import sys\n    from pyactivemq import *\n\n    broker = \"tcp://127.0.0.1:61616?connection.closeTimeout=1000&connection.sendTimeout=5000&connection.socketBufferSize=128*1024\"\n\n    def check_broker():\n\n    try:\n    f = pyactivemq.ActiveMQConnectionFactory(broker)\n    c = f.createConnection()\n    c.start()\n    c.stop()\n    c.close()\n    sys.exit(0)\n\n    except Exception, e:\n    sys.stderr.write(\"Erreur activeMQ: \"+str(e))\n    sys.exit(1)\n\n    check_broker()\n{quote}\n\n\nHere are the full traces:\n\n{quote}\nCore was generated by `python /etc/init.d/appli_ccss.py status'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n78\t    apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\n(gdb) thread apply all bt full\n\nThread 4 (process 13751):\n#0  0x00d97940 in __gnu_cxx::stdio_sync_filebuf<wchar_t, std::char_traits<wchar_t> >::file () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#1  0x00d99502 in std::ostream::flush () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#2  0x00d61bb1 in std::ios_base::Init::~Init () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#3  0x00d77150 in std::basic_ios<char, std::char_traits<char> >::copyfmt () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#4  0x005029c9 in exit () from /lib/libc.so.6\nNo symbol table info available.\n#5  0x00707a42 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#6  0x00707b12 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#7  0x00707d29 in PyErr_PrintEx () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#8  0x00707f5e in PyErr_Print () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#9  0x00708141 in PyRun_SimpleFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#10 0x007088ca in PyRun_AnyFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#11 0x0070f2d5 in Py_Main () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#12 0x080485b2 in main ()\nNo symbol table info available.\n\nThread 3 (process 13772):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x894ccb8, buf=0x8954bc8 \"\", len=0xb7ad30c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8947018, buffer=0x8954bc8 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x893f240) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xdc9731 \"\\203Ã\\004[]Ã\\220\\220\\220\\220\\220\\220\\220\\220\\220U\\211Ã¥S\\203Ã¬\\004\\213E\\bÃ¨Ã¨ÃÃ¸Ã¿\\201Ã\\205\\016\\003\"}}, \n    cause = 0x884dee8, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0xb7ad3148, \n          _M_end_of_storage = 0x11e2093}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x893f240, targetBuffer=0xb7ad31f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xffffffff <Address 0xffffffff out of bounds>}}, cause = 0x0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x13a1860, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x8972228) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x6 <Address 0x6 out of bounds>}}, cause = 0xb7ad325c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7ad3228, _M_finish = 0x12e7780, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x896d8d8, dis=0x8972228)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7ad3278 \"Ã2Â­- Ã¯Â®\\021\\001Â°Ã \\226\\bÃ¨Ã\\204\\b`\\030:\\001\"}}, cause = 0x10e7a2d, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8949d10, _M_finish = 0x884dee8, \n          _M_end_of_storage = 0x13a3638}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x8949d8c)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x8925f30) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x884dee8\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e8398, param=0x8976388) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e8398) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 13781):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x8992958, buf=0x8980260 \"\", len=0xb66d10c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8980050, buffer=0x8980260 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x89801a0) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x5fd558 \"double free or corruption (fasttop)\"}}, cause = 0x89c4d50, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13a3638, _M_finish = 0x89c4d54, \n          _M_end_of_storage = 0x12dc420}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x89801a0, targetBuffer=0xb66d11f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2764 \"\"}}, cause = 0x13b544c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d11b8, _M_finish = 0xdfa5d4, \n          _M_end_of_storage = 0x62db51}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x89b8100) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2760 \" '\\235\\b\"}}, cause = 0xb66d1b90, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d1b90, _M_finish = 0x2038e0, \n          _M_end_of_storage = 0x899ce1c}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x89b3730, dis=0x89b8100)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb66d1278 \"Ã\\022mÂ¶ÃÂ®\\021\\001(Ã\\231\\bPM\\234\\bÃ\\022mÂ¶\"}}, cause = 0x117f6cf, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x899ce18, _M_finish = 0x89c4700, \n          _M_end_of_storage = 0x884deb4}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x899ee44)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x897fd70) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x89c4d50\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83d8, param=0x89bc260) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e83d8) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 13776):\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n\told_value = 0\n\tmutex = <value optimized out>\n#1  0x00210c65 in apr_atomic_inc32 (mem=0x87c010c) at atomic/unix/mutex.c:132\nNo locals.\n#2  0x01186460 in decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement (this=0x87c0108)\n    at decaf/util/concurrent/atomic/AtomicInteger.cpp:54\nNo locals.\n#3  0x01119713 in activemq::transport::filters::ResponseCorrelator::oneway (this=0x87c00e8, command=0xb70d2074)\n    at activemq/transport/filters/ResponseCorrelator.cpp:51\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x1 <Address 0x1 out of bounds>}}, cause = 0x20, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x617150, _M_finish = 0x0, \n            _M_end_of_storage = 0x1}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#4  0x010e7ff3 in activemq::connector::openwire::OpenWireFormatNegotiator::oneway (this=0x896e0b0, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:75\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x884ff4c \"lY\\234\\b\"}}, cause = 0x89c5944, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x10, \n            _M_end_of_storage = 0x884ff48}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#5  0x010e8d72 in activemq::connector::openwire::OpenWireConnector::oneway (this=0x8949d10, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1495\n\tex = {<activemq::connector::ConnectorException> = {<activemq::exceptions::ActiveMQException> = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n          _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n            _M_p = 0x0}}, cause = 0x6, \n        stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n            _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0x11e3ce0, \n              _M_end_of_storage = 0x897f9b0}}, <No data fields>}}, <No data fields>}, <No data fields>}, <No data fields>}\n#6  0x010ea560 in activemq::connector::openwire::OpenWireConnector::acknowledge (this=0x8949d10, session=0x897ea78, \n    consumer=0x897f870, message=0x89c5550, ackType=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:916\n\tack = {<activemq::connector::openwire::commands::BaseCommand<activemq::transport::Command>> = {<activemq::transport::Command> = {\n      _vptr.Command = 0x13ab268}, <activemq::connector::openwire::commands::BaseDataStructure> = {<activemq::connector::openwire::commands::DataStructure> = {<activemq::connector::openwire::marshal::MarshalAware> = {\n          _vptr.MarshalAware = 0x13ab2ec}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, \n  destination = 0x884dea8, transactionId = 0x0, consumerId = 0x884dee0, ackType = 2 '\\002', firstMessageId = 0x89c52a0, \n  lastMessageId = 0x884ff28, messageCount = 1, static ID_MESSAGEACK = <optimized out>}\n\tex = <value optimized out>\n\tex = <value optimized out>\n#7  0x01077ded in activemq::core::ActiveMQConsumer::acknowledge (this=0x897f8a8, message=0x89c5608, ackType=2)\n    at activemq/core/ActiveMQConsumer.cpp:458\n\tex = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x1d3550 \"U\\211Ã¥WVS\\203Ã¬\\f\\213E\\bÃ¨6(Ã¿Ã¿\\201ÃÃÅ¡\\001\"}}, cause = 0x8d6f78, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7b00c6c, _M_finish = 0x89c5ae8, \n          _M_end_of_storage = 0xb70d2178}}, <No data fields>}}, <No data fields>}\n#8  0x0107825c in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x897f8a8, message=0x89c5608, \n    messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:408\nNo locals.\n#9  0x0107901f in activemq::core::ActiveMQConsumer::dispatch (this=0x897f8a8, data=@0x89c5a80)\n    at activemq/core/ActiveMQConsumer.cpp:492\n\tmessage = (class activemq::core::ActiveMQMessage *) 0x89c5608\n#10 0x010921d5 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x897ed48, data=@0x89c5a80)\n    at activemq/core/ActiveMQSessionExecutor.cpp:185\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ec20}\n#11 0x01093801 in activemq::core::ActiveMQSessionExecutor::dispatchAll (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:266\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ed60}\n\tdataList = {<std::_List_base<activemq::core::DispatchData,std::allocator<activemq::core::DispatchData> >> = {\n    _M_impl = {<std::allocator<std::_List_node<activemq::core::DispatchData> >> = {<__gnu_cxx::new_allocator<std::_List_node<activemq::core::DispatchData> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x89c5a78, \n        _M_prev = 0x89c5a78}}}, <No data fields>}\n\tlock_W = {_vptr.Lock = 0x139f470, locked = true, syncObject = 0x897ed80}\n#12 0x01093e2f in activemq::core::ActiveMQSessionExecutor::run (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:208\nNo locals.\n#13 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83b8, param=0x897f778) at decaf/lang/Thread.cpp:125\nNo locals.\n#14 0x0020e736 in dummy_worker (opaque=0x88e83b8) at threadproc/unix/thread.c:142\nNo locals.\n#15 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#16 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n{quote}", "comments": [], "text": "Segmentation fault in APR\n\nDescription:\n\nWe get this segmentation fault occasionally with a monitoring script which establishes and closes a connection to the broker.\n\nHere is the used script:\n\n\n{quote}\n    import sys\n    from pyactivemq import *\n\n    broker = \"tcp://127.0.0.1:61616?connection.closeTimeout=1000&connection.sendTimeout=5000&connection.socketBufferSize=128*1024\"\n\n    def check_broker():\n\n    try:\n    f = pyactivemq.ActiveMQConnectionFactory(broker)\n    c = f.createConnection()\n    c.start()\n    c.stop()\n    c.close()\n    sys.exit(0)\n\n    except Exception, e:\n    sys.stderr.write(\"Erreur activeMQ: \"+str(e))\n    sys.exit(1)\n\n    check_broker()\n{quote}\n\n\nHere are the full traces:\n\n{quote}\nCore was generated by `python /etc/init.d/appli_ccss.py status'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n78\t    apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\n(gdb) thread apply all bt full\n\nThread 4 (process 13751):\n#0  0x00d97940 in __gnu_cxx::stdio_sync_filebuf<wchar_t, std::char_traits<wchar_t> >::file () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#1  0x00d99502 in std::ostream::flush () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#2  0x00d61bb1 in std::ios_base::Init::~Init () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#3  0x00d77150 in std::basic_ios<char, std::char_traits<char> >::copyfmt () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#4  0x005029c9 in exit () from /lib/libc.so.6\nNo symbol table info available.\n#5  0x00707a42 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#6  0x00707b12 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#7  0x00707d29 in PyErr_PrintEx () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#8  0x00707f5e in PyErr_Print () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#9  0x00708141 in PyRun_SimpleFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#10 0x007088ca in PyRun_AnyFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#11 0x0070f2d5 in Py_Main () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#12 0x080485b2 in main ()\nNo symbol table info available.\n\nThread 3 (process 13772):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x894ccb8, buf=0x8954bc8 \"\", len=0xb7ad30c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8947018, buffer=0x8954bc8 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x893f240) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xdc9731 \"\\203Ã\\004[]Ã\\220\\220\\220\\220\\220\\220\\220\\220\\220U\\211Ã¥S\\203Ã¬\\004\\213E\\bÃ¨Ã¨ÃÃ¸Ã¿\\201Ã\\205\\016\\003\"}}, \n    cause = 0x884dee8, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0xb7ad3148, \n          _M_end_of_storage = 0x11e2093}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x893f240, targetBuffer=0xb7ad31f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xffffffff <Address 0xffffffff out of bounds>}}, cause = 0x0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x13a1860, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x8972228) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x6 <Address 0x6 out of bounds>}}, cause = 0xb7ad325c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7ad3228, _M_finish = 0x12e7780, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x896d8d8, dis=0x8972228)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7ad3278 \"Ã2Â­- Ã¯Â®\\021\\001Â°Ã \\226\\bÃ¨Ã\\204\\b`\\030:\\001\"}}, cause = 0x10e7a2d, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8949d10, _M_finish = 0x884dee8, \n          _M_end_of_storage = 0x13a3638}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x8949d8c)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x8925f30) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x884dee8\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e8398, param=0x8976388) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e8398) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 13781):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x8992958, buf=0x8980260 \"\", len=0xb66d10c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8980050, buffer=0x8980260 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x89801a0) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x5fd558 \"double free or corruption (fasttop)\"}}, cause = 0x89c4d50, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13a3638, _M_finish = 0x89c4d54, \n          _M_end_of_storage = 0x12dc420}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x89801a0, targetBuffer=0xb66d11f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2764 \"\"}}, cause = 0x13b544c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d11b8, _M_finish = 0xdfa5d4, \n          _M_end_of_storage = 0x62db51}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x89b8100) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2760 \" '\\235\\b\"}}, cause = 0xb66d1b90, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d1b90, _M_finish = 0x2038e0, \n          _M_end_of_storage = 0x899ce1c}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x89b3730, dis=0x89b8100)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb66d1278 \"Ã\\022mÂ¶ÃÂ®\\021\\001(Ã\\231\\bPM\\234\\bÃ\\022mÂ¶\"}}, cause = 0x117f6cf, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x899ce18, _M_finish = 0x89c4700, \n          _M_end_of_storage = 0x884deb4}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x899ee44)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x897fd70) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x89c4d50\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83d8, param=0x89bc260) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e83d8) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 13776):\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n\told_value = 0\n\tmutex = <value optimized out>\n#1  0x00210c65 in apr_atomic_inc32 (mem=0x87c010c) at atomic/unix/mutex.c:132\nNo locals.\n#2  0x01186460 in decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement (this=0x87c0108)\n    at decaf/util/concurrent/atomic/AtomicInteger.cpp:54\nNo locals.\n#3  0x01119713 in activemq::transport::filters::ResponseCorrelator::oneway (this=0x87c00e8, command=0xb70d2074)\n    at activemq/transport/filters/ResponseCorrelator.cpp:51\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x1 <Address 0x1 out of bounds>}}, cause = 0x20, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x617150, _M_finish = 0x0, \n            _M_end_of_storage = 0x1}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#4  0x010e7ff3 in activemq::connector::openwire::OpenWireFormatNegotiator::oneway (this=0x896e0b0, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:75\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x884ff4c \"lY\\234\\b\"}}, cause = 0x89c5944, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x10, \n            _M_end_of_storage = 0x884ff48}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#5  0x010e8d72 in activemq::connector::openwire::OpenWireConnector::oneway (this=0x8949d10, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1495\n\tex = {<activemq::connector::ConnectorException> = {<activemq::exceptions::ActiveMQException> = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n          _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n            _M_p = 0x0}}, cause = 0x6, \n        stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n            _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0x11e3ce0, \n              _M_end_of_storage = 0x897f9b0}}, <No data fields>}}, <No data fields>}, <No data fields>}, <No data fields>}\n#6  0x010ea560 in activemq::connector::openwire::OpenWireConnector::acknowledge (this=0x8949d10, session=0x897ea78, \n    consumer=0x897f870, message=0x89c5550, ackType=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:916\n\tack = {<activemq::connector::openwire::commands::BaseCommand<activemq::transport::Command>> = {<activemq::transport::Command> = {\n      _vptr.Command = 0x13ab268}, <activemq::connector::openwire::commands::BaseDataStructure> = {<activemq::connector::openwire::commands::DataStructure> = {<activemq::connector::openwire::marshal::MarshalAware> = {\n          _vptr.MarshalAware = 0x13ab2ec}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, \n  destination = 0x884dea8, transactionId = 0x0, consumerId = 0x884dee0, ackType = 2 '\\002', firstMessageId = 0x89c52a0, \n  lastMessageId = 0x884ff28, messageCount = 1, static ID_MESSAGEACK = <optimized out>}\n\tex = <value optimized out>\n\tex = <value optimized out>\n#7  0x01077ded in activemq::core::ActiveMQConsumer::acknowledge (this=0x897f8a8, message=0x89c5608, ackType=2)\n    at activemq/core/ActiveMQConsumer.cpp:458\n\tex = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x1d3550 \"U\\211Ã¥WVS\\203Ã¬\\f\\213E\\bÃ¨6(Ã¿Ã¿\\201ÃÃÅ¡\\001\"}}, cause = 0x8d6f78, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7b00c6c, _M_finish = 0x89c5ae8, \n          _M_end_of_storage = 0xb70d2178}}, <No data fields>}}, <No data fields>}\n#8  0x0107825c in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x897f8a8, message=0x89c5608, \n    messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:408\nNo locals.\n#9  0x0107901f in activemq::core::ActiveMQConsumer::dispatch (this=0x897f8a8, data=@0x89c5a80)\n    at activemq/core/ActiveMQConsumer.cpp:492\n\tmessage = (class activemq::core::ActiveMQMessage *) 0x89c5608\n#10 0x010921d5 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x897ed48, data=@0x89c5a80)\n    at activemq/core/ActiveMQSessionExecutor.cpp:185\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ec20}\n#11 0x01093801 in activemq::core::ActiveMQSessionExecutor::dispatchAll (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:266\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ed60}\n\tdataList = {<std::_List_base<activemq::core::DispatchData,std::allocator<activemq::core::DispatchData> >> = {\n    _M_impl = {<std::allocator<std::_List_node<activemq::core::DispatchData> >> = {<__gnu_cxx::new_allocator<std::_List_node<activemq::core::DispatchData> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x89c5a78, \n        _M_prev = 0x89c5a78}}}, <No data fields>}\n\tlock_W = {_vptr.Lock = 0x139f470, locked = true, syncObject = 0x897ed80}\n#12 0x01093e2f in activemq::core::ActiveMQSessionExecutor::run (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:208\nNo locals.\n#13 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83b8, param=0x897f778) at decaf/lang/Thread.cpp:125\nNo locals.\n#14 0x0020e736 in dummy_worker (opaque=0x88e83b8) at threadproc/unix/thread.c:142\nNo locals.\n#15 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#16 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n{quote}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation fault in APR\n\nDescription:\n\nWe get this segmentation fault occasionally with a monitoring script which establishes and closes a connection to the broker.\n\nHere is the used script:\n\n\n{quote}\n    import sys\n    from pyactivemq import *\n\n    broker = \"tcp://127.0.0.1:61616?connection.closeTimeout=1000&connection.sendTimeout=5000&connection.socketBufferSize=128*1024\"\n\n    def check_broker():\n\n    try:\n    f = pyactivemq.ActiveMQConnectionFactory(broker)\n    c = f.createConnection()\n    c.start()\n    c.stop()\n    c.close()\n    sys.exit(0)\n\n    except Exception, e:\n    sys.stderr.write(\"Erreur activeMQ: \"+str(e))\n    sys.exit(1)\n\n    check_broker()\n{quote}\n\n\nHere are the full traces:\n\n{quote}\nCore was generated by `python /etc/init.d/appli_ccss.py status'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n78\t    apr_thread_mutex_t *mutex = hash_mutex[ATOMIC_HASH(mem)];\n(gdb) thread apply all bt full\n\nThread 4 (process 13751):\n#0  0x00d97940 in __gnu_cxx::stdio_sync_filebuf<wchar_t, std::char_traits<wchar_t> >::file () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#1  0x00d99502 in std::ostream::flush () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#2  0x00d61bb1 in std::ios_base::Init::~Init () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#3  0x00d77150 in std::basic_ios<char, std::char_traits<char> >::copyfmt () from /usr/lib/libstdc++.so.6\nNo symbol table info available.\n#4  0x005029c9 in exit () from /lib/libc.so.6\nNo symbol table info available.\n#5  0x00707a42 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#6  0x00707b12 in Py_Exit () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#7  0x00707d29 in PyErr_PrintEx () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#8  0x00707f5e in PyErr_Print () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#9  0x00708141 in PyRun_SimpleFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#10 0x007088ca in PyRun_AnyFileExFlags () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#11 0x0070f2d5 in Py_Main () from /usr/lib/libpython2.4.so.1.0\nNo symbol table info available.\n#12 0x080485b2 in main ()\nNo symbol table info available.\n\nThread 3 (process 13772):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x894ccb8, buf=0x8954bc8 \"\", len=0xb7ad30c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8947018, buffer=0x8954bc8 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x893f240) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xdc9731 \"\\203Ã\\004[]Ã\\220\\220\\220\\220\\220\\220\\220\\220\\220U\\211Ã¥S\\203Ã¬\\004\\213E\\bÃ¨Ã¨ÃÃ¸Ã¿\\201Ã\\205\\016\\003\"}}, \n    cause = 0x884dee8, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0xb7ad3148, \n          _M_end_of_storage = 0x11e2093}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x893f240, targetBuffer=0xb7ad31f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xffffffff <Address 0xffffffff out of bounds>}}, cause = 0x0, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x13a1860, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x8972228) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x6 <Address 0x6 out of bounds>}}, cause = 0xb7ad325c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7ad3228, _M_finish = 0x12e7780, \n          _M_end_of_storage = 0x884dee8}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x896d8d8, dis=0x8972228)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb7ad3278 \"Ã2Â­- Ã¯Â®\\021\\001Â°Ã \\226\\bÃ¨Ã\\204\\b`\\030:\\001\"}}, cause = 0x10e7a2d, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x8949d10, _M_finish = 0x884dee8, \n          _M_end_of_storage = 0x13a3638}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x8949d8c)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x8925f30) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x884dee8\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e8398, param=0x8976388) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e8398) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 2 (process 13781):\n#0  0x00434402 in __kernel_vsyscall ()\nNo symbol table info available.\n#1  0x0062de1b in read () from /lib/libpthread.so.0\nNo symbol table info available.\n#2  0x0020894a in apr_socket_recv (sock=0x8992958, buf=0x8980260 \"\", len=0xb66d10c0) at /usr/include/bits/unistd.h:35\n\trv = <value optimized out>\n\tarv = <value optimized out>\n#3  0x011548d9 in decaf::net::SocketInputStream::read (this=0x8980050, buffer=0x8980260 \"\", offset=0, bufferSize=1)\n    at decaf/net/SocketInputStream.cpp:180\n\tsize = 1\n\tresult = <value optimized out>\n#4  0x01174a01 in decaf::io::BufferedInputStream::bufferData (this=0x89801a0) at decaf/io/BufferedInputStream.cpp:260\n\tavailable = 0\n\tbytesRead = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x5fd558 \"double free or corruption (fasttop)\"}}, cause = 0x89c4d50, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13a3638, _M_finish = 0x89c4d54, \n          _M_end_of_storage = 0x12dc420}}, <No data fields>}}, <No data fields>}\n#5  0x01174f81 in decaf::io::BufferedInputStream::read (this=0x89801a0, targetBuffer=0xb66d11f4 \"\", offset=0, \n    targetBufferSize=4) at decaf/io/BufferedInputStream.cpp:181\n\tbytesToCopy = 0\n\ttotalRead = 0\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2764 \"\"}}, cause = 0x13b544c, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d11b8, _M_finish = 0xdfa5d4, \n          _M_end_of_storage = 0x62db51}}, <No data fields>}}, <No data fields>}\n#6  0x01178998 in decaf::io::DataInputStream::readInt (this=0x89b8100) at decaf/io/DataInputStream.h:360\n\tbuffer = \"\\000\\000\\000\"\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x89d2760 \" '\\235\\b\"}}, cause = 0xb66d1b90, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb66d1b90, _M_finish = 0x2038e0, \n          _M_end_of_storage = 0x899ce1c}}, <No data fields>}}, <No data fields>}\n#7  0x010e021e in activemq::connector::openwire::OpenWireFormat::unmarshal (this=0x89b3730, dis=0x89b8100)\n    at activemq/connector/openwire/OpenWireFormat.cpp:227\n\tdata = <value optimized out>\n\tex = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {\n      static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0xb66d1278 \"Ã\\022mÂ¶ÃÂ®\\021\\001(Ã\\231\\bPM\\234\\bÃ\\022mÂ¶\"}}, cause = 0x117f6cf, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x899ce18, _M_finish = 0x89c4700, \n          _M_end_of_storage = 0x884deb4}}, <No data fields>}}, <No data fields>}\n#8  0x010e5461 in activemq::connector::openwire::OpenWireCommandReader::readCommand (this=0x899ee44)\n    at activemq/connector/openwire/OpenWireCommandReader.cpp:71\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x0}}, cause = 0x0, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x0, _M_finish = 0x0, \n            _M_end_of_storage = 0x0}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#9  0x01114a9a in activemq::transport::IOTransport::run (this=0x897fd70) at activemq/transport/IOTransport.cpp:188\n\tcommand = (class activemq::transport::Command *) 0x89c4d50\n#10 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83d8, param=0x89bc260) at decaf/lang/Thread.cpp:125\nNo locals.\n#11 0x0020e736 in dummy_worker (opaque=0x88e83d8) at threadproc/unix/thread.c:142\nNo locals.\n#12 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#13 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n\nThread 1 (process 13776):\n#0  0x00210bf7 in apr_atomic_add32 (mem=0x87c010c, val=1) at atomic/unix/mutex.c:78\n\told_value = 0\n\tmutex = <value optimized out>\n#1  0x00210c65 in apr_atomic_inc32 (mem=0x87c010c) at atomic/unix/mutex.c:132\nNo locals.\n#2  0x01186460 in decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement (this=0x87c0108)\n    at decaf/util/concurrent/atomic/AtomicInteger.cpp:54\nNo locals.\n#3  0x01119713 in activemq::transport::filters::ResponseCorrelator::oneway (this=0x87c00e8, command=0xb70d2074)\n    at activemq/transport/filters/ResponseCorrelator.cpp:51\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x1 <Address 0x1 out of bounds>}}, cause = 0x20, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x617150, _M_finish = 0x0, \n            _M_end_of_storage = 0x1}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#4  0x010e7ff3 in activemq::connector::openwire::OpenWireFormatNegotiator::oneway (this=0x896e0b0, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:75\n\tex = {<decaf::io::IOException> = {<decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n        _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n          _M_p = 0x884ff4c \"lY\\234\\b\"}}, cause = 0x89c5944, \n      stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n          _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x6, _M_finish = 0x10, \n            _M_end_of_storage = 0x884ff48}}, <No data fields>}}, <No data fields>}, <No data fields>}\n#5  0x010e8d72 in activemq::connector::openwire::OpenWireConnector::oneway (this=0x8949d10, command=0xb70d2074)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1495\n\tex = {<activemq::connector::ConnectorException> = {<activemq::exceptions::ActiveMQException> = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n          _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n            _M_p = 0x0}}, cause = 0x6, \n        stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n            _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0x13b544c, _M_finish = 0x11e3ce0, \n              _M_end_of_storage = 0x897f9b0}}, <No data fields>}}, <No data fields>}, <No data fields>}, <No data fields>}\n#6  0x010ea560 in activemq::connector::openwire::OpenWireConnector::acknowledge (this=0x8949d10, session=0x897ea78, \n    consumer=0x897f870, message=0x89c5550, ackType=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:916\n\tack = {<activemq::connector::openwire::commands::BaseCommand<activemq::transport::Command>> = {<activemq::transport::Command> = {\n      _vptr.Command = 0x13ab268}, <activemq::connector::openwire::commands::BaseDataStructure> = {<activemq::connector::openwire::commands::DataStructure> = {<activemq::connector::openwire::marshal::MarshalAware> = {\n          _vptr.MarshalAware = 0x13ab2ec}, <No data fields>}, <No data fields>}, responseRequired = false, commandId = 0}, \n  destination = 0x884dea8, transactionId = 0x0, consumerId = 0x884dee0, ackType = 2 '\\002', firstMessageId = 0x89c52a0, \n  lastMessageId = 0x884ff28, messageCount = 1, static ID_MESSAGEACK = <optimized out>}\n\tex = <value optimized out>\n\tex = <value optimized out>\n#7  0x01077ded in activemq::core::ActiveMQConsumer::acknowledge (this=0x897f8a8, message=0x89c5608, ackType=2)\n    at activemq/core/ActiveMQConsumer.cpp:458\n\tex = {<cms::CMSException> = {<> = {<No data fields>}, <No data fields>}, <decaf::lang::Exception> = {<decaf::lang::Throwable> = {<> = {<No data fields>}, <No data fields>}, message = {static npos = 4294967295, \n      _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, \n        _M_p = 0x1d3550 \"U\\211Ã¥WVS\\203Ã¬\\f\\213E\\bÃ¨6(Ã¿Ã¿\\201ÃÃÅ¡\\001\"}}, cause = 0x8d6f78, \n    stackTrace = {<std::_Vector_base<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >> = {\n        _M_impl = {<std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<__gnu_cxx::new_allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> >> = {<No data fields>}, <No data fields>}, _M_start = 0xb7b00c6c, _M_finish = 0x89c5ae8, \n          _M_end_of_storage = 0xb70d2178}}, <No data fields>}}, <No data fields>}\n#8  0x0107825c in activemq::core::ActiveMQConsumer::afterMessageIsConsumed (this=0x897f8a8, message=0x89c5608, \n    messageExpired=false) at activemq/core/ActiveMQConsumer.cpp:408\nNo locals.\n#9  0x0107901f in activemq::core::ActiveMQConsumer::dispatch (this=0x897f8a8, data=@0x89c5a80)\n    at activemq/core/ActiveMQConsumer.cpp:492\n\tmessage = (class activemq::core::ActiveMQMessage *) 0x89c5608\n#10 0x010921d5 in activemq::core::ActiveMQSessionExecutor::dispatch (this=0x897ed48, data=@0x89c5a80)\n    at activemq/core/ActiveMQSessionExecutor.cpp:185\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ec20}\n#11 0x01093801 in activemq::core::ActiveMQSessionExecutor::dispatchAll (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:266\n\tlock_W = {_vptr.Lock = 0x139f470, locked = false, syncObject = 0x897ed60}\n\tdataList = {<std::_List_base<activemq::core::DispatchData,std::allocator<activemq::core::DispatchData> >> = {\n    _M_impl = {<std::allocator<std::_List_node<activemq::core::DispatchData> >> = {<__gnu_cxx::new_allocator<std::_List_node<activemq::core::DispatchData> >> = {<No data fields>}, <No data fields>}, _M_node = {_M_next = 0x89c5a78, \n        _M_prev = 0x89c5a78}}}, <No data fields>}\n\tlock_W = {_vptr.Lock = 0x139f470, locked = true, syncObject = 0x897ed80}\n#12 0x01093e2f in activemq::core::ActiveMQSessionExecutor::run (this=0x897ed48)\n    at activemq/core/ActiveMQSessionExecutor.cpp:208\nNo locals.\n#13 0x011691b8 in decaf::lang::Thread::runCallback (self=0x88e83b8, param=0x897f778) at decaf/lang/Thread.cpp:125\nNo locals.\n#14 0x0020e736 in dummy_worker (opaque=0x88e83b8) at threadproc/unix/thread.c:142\nNo locals.\n#15 0x0062745b in start_thread () from /lib/libpthread.so.0\nNo symbol table info available.\n#16 0x005a7c4e in clone () from /lib/libc.so.6\nNo symbol table info available.\n{quote}\n\nComments:\n", "classification": "Classify the issue 'Segmentation fault in APR' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-231?\nA: \nWe get this segmentation fault occasionally with a monitoring script which establishes and closes a connection to the broker.\n\nHere is the used script:\n\n\n{quote}\n    import sys\n    from pyactivemq import *\n\n    broker = \"tcp://127.0.0.1:61616?connection.closeTimeout=1000&connection.sendTimeout=5000&connection.socketBufferSize=128*1024\"\n\n    def check_broker():\n\n    try:\n    f = pyactivemq.ActiveM"}}
{"issue_key": "AMQCPP-230", "project": "AMQCPP", "title": "BlockByteArrayInputStream read method is not thread safe", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-03-20T19:05:34.000+0000", "updated": "2009-03-20T19:09:08.000+0000", "description": "The read method can access an invalid pointer depending on its state when the close method is called from another thread.", "comments": [], "text": "BlockByteArrayInputStream read method is not thread safe\n\nDescription:\nThe read method can access an invalid pointer depending on its state when the close method is called from another thread.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: BlockByteArrayInputStream read method is not thread safe\n\nDescription:\nThe read method can access an invalid pointer depending on its state when the close method is called from another thread.\n\nComments:\n", "classification": "Classify the issue 'BlockByteArrayInputStream read method is not thread safe' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-230?\nA: The read method can access an invalid pointer depending on its state when the close method is called from another thread."}}
{"issue_key": "AMQCPP-229", "project": "AMQCPP", "title": "Session createTopic and createQueue don't provide clear error when an empty Destination is given", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-03-18T14:33:17.000+0000", "updated": "2009-03-18T14:36:25.000+0000", "description": "When creating Destinations with an Empty string value the error given from the client doesn't make it clear what happened.  The code should catch the problem earlier and throw a meaningful error.", "comments": [], "text": "Session createTopic and createQueue don't provide clear error when an empty Destination is given\n\nDescription:\nWhen creating Destinations with an Empty string value the error given from the client doesn't make it clear what happened.  The code should catch the problem earlier and throw a meaningful error.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Session createTopic and createQueue don't provide clear error when an empty Destination is given\n\nDescription:\nWhen creating Destinations with an Empty string value the error given from the client doesn't make it clear what happened.  The code should catch the problem earlier and throw a meaningful error.\n\nComments:\n", "classification": "Classify the issue 'Session createTopic and createQueue don't provide clear error when an empty Destination is given' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-229?\nA: When creating Destinations with an Empty string value the error given from the client doesn't make it clear what happened.  The code should catch the problem earlier and throw a meaningful error."}}
{"issue_key": "AMQCPP-228", "project": "AMQCPP", "title": "Segmentation Fault(coredump) on Solaris running example in version 2.2.2", "status": "Closed", "reporter": "David Sanchez", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2009-03-05T20:35:25.000+0000", "updated": "2009-03-10T18:23:08.000+0000", "description": "I am trying to run the example program in version 2.2.2  I get  stopped with a Segmentation Fault(coredump) before any messages are sent.", "comments": [], "text": "Segmentation Fault(coredump) on Solaris running example in version 2.2.2\n\nDescription:\nI am trying to run the example program in version 2.2.2  I get  stopped with a Segmentation Fault(coredump) before any messages are sent.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation Fault(coredump) on Solaris running example in version 2.2.2\n\nDescription:\nI am trying to run the example program in version 2.2.2  I get  stopped with a Segmentation Fault(coredump) before any messages are sent.\n\nComments:\n", "classification": "Classify the issue 'Segmentation Fault(coredump) on Solaris running example in version 2.2.2' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-228?\nA: I am trying to run the example program in version 2.2.2  I get  stopped with a Segmentation Fault(coredump) before any messages are sent."}}
{"issue_key": "AMQCPP-227", "project": "AMQCPP", "title": "Mutex class allows for double free in APR pools under certain circumstances", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2009-03-03T18:46:14.000+0000", "updated": "2009-03-23T12:24:01.000+0000", "description": "The Mutex class in the Decaf library can allow for two copies to be created which both share pointers to APR resources and when the second instance is destroyed a segfault occurs.  The code needs to be correct to properly copy itself or prevent copying altogether so that this does not happen.", "comments": [], "text": "Mutex class allows for double free in APR pools under certain circumstances\n\nDescription:\nThe Mutex class in the Decaf library can allow for two copies to be created which both share pointers to APR resources and when the second instance is destroyed a segfault occurs.  The code needs to be correct to properly copy itself or prevent copying altogether so that this does not happen.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Mutex class allows for double free in APR pools under certain circumstances\n\nDescription:\nThe Mutex class in the Decaf library can allow for two copies to be created which both share pointers to APR resources and when the second instance is destroyed a segfault occurs.  The code needs to be correct to properly copy itself or prevent copying altogether so that this does not happen.\n\n\n\nComments:\n", "classification": "Classify the issue 'Mutex class allows for double free in APR pools under certain circumstances' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-227?\nA: The Mutex class in the Decaf library can allow for two copies to be created which both share pointers to APR resources and when the second instance is destroyed a segfault occurs.  The code needs to be correct to properly copy itself or prevent copying altogether so that this does not happen.\n\n"}}
{"issue_key": "AMQCPP-226", "project": "AMQCPP", "title": "During linking, the expat library is not found if apr-utils was installed in non standard path", "status": "Closed", "reporter": "Michael Vishchers", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-02-27T17:25:41.000+0000", "updated": "2009-04-14T23:41:42.000+0000", "description": "When installing apr-utils in a non-standard directory (and maybe even then, have not checked it), the linking steps fail with a \"ld: fatal: library -lexpat: not found\" error.\n\nEven adding the directory where the expat lib could be found to apu-1-config did not help. The only way to get around this problem was create links to the expat library in /usr/lib (not my preferred solution ;-)\n\nThe output from the interesting moment:\n\nMaking all in src/examples\n/bin/bash ../../libtool --tag=CXX    --mode=link CC -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1  -PIC   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g    -o example example-main.o ../main/libactivemq-cpp.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.la -luuid -lsendfile -lrt -lsocket -lnsl  -lpthread    /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.la \nCC -mt -w -O5 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -PIC -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat -library=stlport4 -lm /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.so /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.so -luuid -lsendfile -lrt -lsocket -lnsl -lpthread /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.so  -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/activemq-cpp-2.2.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib\nld: fatal: library -lexpat: not found\nld: fatal: File processing errors. No output written to .libs/example", "comments": [], "text": "During linking, the expat library is not found if apr-utils was installed in non standard path\n\nDescription:\nWhen installing apr-utils in a non-standard directory (and maybe even then, have not checked it), the linking steps fail with a \"ld: fatal: library -lexpat: not found\" error.\n\nEven adding the directory where the expat lib could be found to apu-1-config did not help. The only way to get around this problem was create links to the expat library in /usr/lib (not my preferred solution ;-)\n\nThe output from the interesting moment:\n\nMaking all in src/examples\n/bin/bash ../../libtool --tag=CXX    --mode=link CC -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1  -PIC   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g    -o example example-main.o ../main/libactivemq-cpp.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.la -luuid -lsendfile -lrt -lsocket -lnsl  -lpthread    /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.la \nCC -mt -w -O5 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -PIC -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat -library=stlport4 -lm /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.so /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.so -luuid -lsendfile -lrt -lsocket -lnsl -lpthread /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.so  -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/activemq-cpp-2.2.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib\nld: fatal: library -lexpat: not found\nld: fatal: File processing errors. No output written to .libs/example\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: During linking, the expat library is not found if apr-utils was installed in non standard path\n\nDescription:\nWhen installing apr-utils in a non-standard directory (and maybe even then, have not checked it), the linking steps fail with a \"ld: fatal: library -lexpat: not found\" error.\n\nEven adding the directory where the expat lib could be found to apu-1-config did not help. The only way to get around this problem was create links to the expat library in /usr/lib (not my preferred solution ;-)\n\nThe output from the interesting moment:\n\nMaking all in src/examples\n/bin/bash ../../libtool --tag=CXX    --mode=link CC -mt -w -O5 -library=stlport4   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1  -PIC   -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE  -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1   -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g    -o example example-main.o ../main/libactivemq-cpp.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.la -luuid -lsendfile -lrt -lsocket -lnsl  -lpthread    /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.la  /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.la \nCC -mt -w -O5 -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -PIC -DSOLARIS2=10 -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_LARGEFILE64_SOURCE -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/include/apr-1 -I/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/include/apr-1 -I./../main -g -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat -library=stlport4 -lm /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libaprutil-1.so /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib/libapr-1.so -luuid -lsendfile -lrt -lsocket -lnsl -lpthread /localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib/libexpat.so  -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/activemq-cpp-2.2.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-util-1.3.4/lib -R/localhome/export/home/gnu/try2/install/sun4u/SunOS/5.10/packages/apr-1.3.3/lib\nld: fatal: library -lexpat: not found\nld: fatal: File processing errors. No output written to .libs/example\n\n\nComments:\n", "classification": "Classify the issue 'During linking, the expat library is not found if apr-utils was installed in non standard path' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-226?\nA: When installing apr-utils in a non-standard directory (and maybe even then, have not checked it), the linking steps fail with a \"ld: fatal: library -lexpat: not found\" error.\n\nEven adding the directory where the expat lib could be found to apu-1-config did not help. The only way to get around this problem was create links to the expat library in /usr/lib (not my preferred solution ;-)\n\nThe output "}}
{"issue_key": "AMQCPP-225", "project": "AMQCPP", "title": "configure.ac does not work correctly on Solaris with SunStudio Compiler", "status": "Resolved", "reporter": "Michael Vishchers", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-02-27T17:11:10.000+0000", "updated": "2009-03-09T13:51:10.000+0000", "description": "The configure.ac tries to set a flag to use the stlport4 when using the SunStudio compiler. Unfortunately, neither is the \"+=\" construct supported by the shell, nor is the correct variable used.\n\nThe following diff shows the faulty and the correct version:\n\n$ diff configure.ac~ configure.ac\n148,149c148\n<        PLAT_CXXFLAGS=\"-mt -w -O5\"\n<        PLAT_LIBS+=\"-library=stlport4\"\n---\n>        PLAT_CXXFLAGS=\"-mt -w -O5 -library=stlport4\"", "comments": [], "text": "configure.ac does not work correctly on Solaris with SunStudio Compiler\n\nDescription:\nThe configure.ac tries to set a flag to use the stlport4 when using the SunStudio compiler. Unfortunately, neither is the \"+=\" construct supported by the shell, nor is the correct variable used.\n\nThe following diff shows the faulty and the correct version:\n\n$ diff configure.ac~ configure.ac\n148,149c148\n<        PLAT_CXXFLAGS=\"-mt -w -O5\"\n<        PLAT_LIBS+=\"-library=stlport4\"\n---\n>        PLAT_CXXFLAGS=\"-mt -w -O5 -library=stlport4\"\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: configure.ac does not work correctly on Solaris with SunStudio Compiler\n\nDescription:\nThe configure.ac tries to set a flag to use the stlport4 when using the SunStudio compiler. Unfortunately, neither is the \"+=\" construct supported by the shell, nor is the correct variable used.\n\nThe following diff shows the faulty and the correct version:\n\n$ diff configure.ac~ configure.ac\n148,149c148\n<        PLAT_CXXFLAGS=\"-mt -w -O5\"\n<        PLAT_LIBS+=\"-library=stlport4\"\n---\n>        PLAT_CXXFLAGS=\"-mt -w -O5 -library=stlport4\"\n\n\nComments:\n", "classification": "Classify the issue 'configure.ac does not work correctly on Solaris with SunStudio Compiler' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-225?\nA: The configure.ac tries to set a flag to use the stlport4 when using the SunStudio compiler. Unfortunately, neither is the \"+=\" construct supported by the shell, nor is the correct variable used.\n\nThe following diff shows the faulty and the correct version:\n\n$ diff configure.ac~ configure.ac\n148,149c148\n<        PLAT_CXXFLAGS=\"-mt -w -O5\"\n<        PLAT_LIBS+=\"-library=stlport4\"\n---\n>        PLAT_CX"}}
{"issue_key": "AMQCPP-224", "project": "AMQCPP", "title": "Configure accept wrong versions of apr-util", "status": "Resolved", "reporter": "Utopia", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-02-27T14:42:38.000+0000", "updated": "2009-02-27T19:59:51.000+0000", "description": "The configure script accepts the following\nchecking for APR-util... yes\nchecking APR version... 1.3.3\nchecking APU version... 1.2.7\n\nWhich eventually results in a compile error.\n---\n/usr/local//include/apr-1/apr_file_info.h:192: error: 'apr_ino_t' does not name a type\n/usr/local//include/apr-1/apr_want.h:92: error: redefinition of 'struct iovec'\n/usr/include/sys/socket.h:128: error: previous definition of 'struct iovec'\nmake[2]: *** [activemq/core/libactivemq_cpp_la-ActiveMQConnectionFactory.lo] Error 1\nmake[1]: *** [all-recursive] Error 1\nmake: *** [all] Error 2\n--\n\nWhen fixing the version of apr-util version it will compile without any problems.", "comments": [], "text": "Configure accept wrong versions of apr-util\n\nDescription:\nThe configure script accepts the following\nchecking for APR-util... yes\nchecking APR version... 1.3.3\nchecking APU version... 1.2.7\n\nWhich eventually results in a compile error.\n---\n/usr/local//include/apr-1/apr_file_info.h:192: error: 'apr_ino_t' does not name a type\n/usr/local//include/apr-1/apr_want.h:92: error: redefinition of 'struct iovec'\n/usr/include/sys/socket.h:128: error: previous definition of 'struct iovec'\nmake[2]: *** [activemq/core/libactivemq_cpp_la-ActiveMQConnectionFactory.lo] Error 1\nmake[1]: *** [all-recursive] Error 1\nmake: *** [all] Error 2\n--\n\nWhen fixing the version of apr-util version it will compile without any problems.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Configure accept wrong versions of apr-util\n\nDescription:\nThe configure script accepts the following\nchecking for APR-util... yes\nchecking APR version... 1.3.3\nchecking APU version... 1.2.7\n\nWhich eventually results in a compile error.\n---\n/usr/local//include/apr-1/apr_file_info.h:192: error: 'apr_ino_t' does not name a type\n/usr/local//include/apr-1/apr_want.h:92: error: redefinition of 'struct iovec'\n/usr/include/sys/socket.h:128: error: previous definition of 'struct iovec'\nmake[2]: *** [activemq/core/libactivemq_cpp_la-ActiveMQConnectionFactory.lo] Error 1\nmake[1]: *** [all-recursive] Error 1\nmake: *** [all] Error 2\n--\n\nWhen fixing the version of apr-util version it will compile without any problems.\n\nComments:\n", "classification": "Classify the issue 'Configure accept wrong versions of apr-util' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-224?\nA: The configure script accepts the following\nchecking for APR-util... yes\nchecking APR version... 1.3.3\nchecking APU version... 1.2.7\n\nWhich eventually results in a compile error.\n---\n/usr/local//include/apr-1/apr_file_info.h:192: error: 'apr_ino_t' does not name a type\n/usr/local//include/apr-1/apr_want.h:92: error: redefinition of 'struct iovec'\n/usr/include/sys/socket.h:128: error: previous defin"}}
{"issue_key": "AMQCPP-223", "project": "AMQCPP", "title": "Message delivered async do not have their read only properties set properly.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2009-02-21T23:46:13.000+0000", "updated": "2009-02-24T00:04:28.000+0000", "description": "The Messages are not properly tagged as readonly in a consistant manner in the Asnyc dispatch from ActiveMQConnection.  Some changes are needed in the Message classes to consolidate the readonly mode change so that it can be done correctly.", "comments": [], "text": "Message delivered async do not have their read only properties set properly.\n\nDescription:\nThe Messages are not properly tagged as readonly in a consistant manner in the Asnyc dispatch from ActiveMQConnection.  Some changes are needed in the Message classes to consolidate the readonly mode change so that it can be done correctly.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Message delivered async do not have their read only properties set properly.\n\nDescription:\nThe Messages are not properly tagged as readonly in a consistant manner in the Asnyc dispatch from ActiveMQConnection.  Some changes are needed in the Message classes to consolidate the readonly mode change so that it can be done correctly.\n\nComments:\n", "classification": "Classify the issue 'Message delivered async do not have their read only properties set properly.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-223?\nA: The Messages are not properly tagged as readonly in a consistant manner in the Asnyc dispatch from ActiveMQConnection.  Some changes are needed in the Message classes to consolidate the readonly mode change so that it can be done correctly."}}
{"issue_key": "AMQCPP-222", "project": "AMQCPP", "title": "Potential memory leak in OpenWire Commands", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-02-10T21:51:33.000+0000", "updated": "2009-02-10T21:52:44.000+0000", "description": "When cloning an Openwire command object its possible for a memory leak to occur if an exception is thrown.", "comments": [], "text": "Potential memory leak in OpenWire Commands\n\nDescription:\nWhen cloning an Openwire command object its possible for a memory leak to occur if an exception is thrown.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Potential memory leak in OpenWire Commands\n\nDescription:\nWhen cloning an Openwire command object its possible for a memory leak to occur if an exception is thrown.\n\nComments:\n", "classification": "Classify the issue 'Potential memory leak in OpenWire Commands' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-222?\nA: When cloning an Openwire command object its possible for a memory leak to occur if an exception is thrown."}}
{"issue_key": "AMQCPP-221", "project": "AMQCPP", "title": "\"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67", "status": "Closed", "reporter": "Wolfgang.Klein", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-02-10T09:47:48.000+0000", "updated": "2009-02-10T11:38:35.000+0000", "description": "All activemq c++ clients core after missing a response from the broker. It seems that the broker is in a bad state.\n\nHere i have used the code from /opt/apache-activemq-5.1.0/activemq-cpp-2.1.3-src/src/examples/main.cpp of the download software.\n\n#0  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n#1  0x0000003dcc44602b in vfprintf () from /lib64/libc.so.6\n#2  0x0000003dcc4671fa in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaac00c2f in activemq::exceptions::ActiveMQException::buildMessage (this=Variable \"this\" is not available.\n) at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaac13708 in CommandIOException (this=0x17c39e60, file=0x2aaaaad31160 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146,\n    msg=0x2aaaaad31198 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaac623c2 in activemq::transport::filters::ResponseCorrelator::request (this=Variable \"this\" is not available.\n) at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaac38c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x17c37660, command=0x17c38d28)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaac3fe2f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=Variable \"this\" is not available.\n) at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaac41511 in activemq::connector::openwire::OpenWireConnector::send (this=0x17c35cc0, message=Variable \"message\" is not available.\n)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaabd994c in activemq::core::ActiveMQSession::send (this=Variable \"this\" is not available.\n) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaabe52c0 in activemq::core::ActiveMQProducer::send (this=0x17c38c70, destination=Variable \"destination\" is not available.\n) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaabe4dea in activemq::core::ActiveMQProducer::send (this=0x4, destination=0x2aaaaad311c0, message=0x43203b98)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaabe50fb in activemq::core::ActiveMQProducer::send (this=0x17c38c70, message=0x17c38d20) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000000004034e0 in HelloWorldProducer::run (this=0x7ffffc892390) at main.cpp:111\n#14 0x00002aaaaabff0e0 in activemq::concurrent::Thread::runCallback (param=Variable \"param\" is not available.\n) at activemq/concurrent/Thread.cpp:152\n#15 0x0000003dcd0062e7 in start_thread () from /lib64/libpthread.so.0\n#16 0x0000003dcc4ce3bd in clone () from /lib64/libc.so.6\n\n\n(gdb) info thread\n  9 process 21565  0x0000003dcd0075a5 in pthread_join () from /lib64/libpthread.so.0\n  8 process 21566  0x0000003dcd00a687 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  7 process 21569  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  6 process 21571  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  5 process 21579  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  4 process 21585  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  3 process 21586  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  2 process 21594  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n* 1 process 21584  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n\nI assume that the command object is created by another thread which dies.", "comments": [], "text": "\"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n\nDescription:\nAll activemq c++ clients core after missing a response from the broker. It seems that the broker is in a bad state.\n\nHere i have used the code from /opt/apache-activemq-5.1.0/activemq-cpp-2.1.3-src/src/examples/main.cpp of the download software.\n\n#0  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n#1  0x0000003dcc44602b in vfprintf () from /lib64/libc.so.6\n#2  0x0000003dcc4671fa in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaac00c2f in activemq::exceptions::ActiveMQException::buildMessage (this=Variable \"this\" is not available.\n) at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaac13708 in CommandIOException (this=0x17c39e60, file=0x2aaaaad31160 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146,\n    msg=0x2aaaaad31198 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaac623c2 in activemq::transport::filters::ResponseCorrelator::request (this=Variable \"this\" is not available.\n) at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaac38c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x17c37660, command=0x17c38d28)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaac3fe2f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=Variable \"this\" is not available.\n) at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaac41511 in activemq::connector::openwire::OpenWireConnector::send (this=0x17c35cc0, message=Variable \"message\" is not available.\n)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaabd994c in activemq::core::ActiveMQSession::send (this=Variable \"this\" is not available.\n) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaabe52c0 in activemq::core::ActiveMQProducer::send (this=0x17c38c70, destination=Variable \"destination\" is not available.\n) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaabe4dea in activemq::core::ActiveMQProducer::send (this=0x4, destination=0x2aaaaad311c0, message=0x43203b98)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaabe50fb in activemq::core::ActiveMQProducer::send (this=0x17c38c70, message=0x17c38d20) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000000004034e0 in HelloWorldProducer::run (this=0x7ffffc892390) at main.cpp:111\n#14 0x00002aaaaabff0e0 in activemq::concurrent::Thread::runCallback (param=Variable \"param\" is not available.\n) at activemq/concurrent/Thread.cpp:152\n#15 0x0000003dcd0062e7 in start_thread () from /lib64/libpthread.so.0\n#16 0x0000003dcc4ce3bd in clone () from /lib64/libc.so.6\n\n\n(gdb) info thread\n  9 process 21565  0x0000003dcd0075a5 in pthread_join () from /lib64/libpthread.so.0\n  8 process 21566  0x0000003dcd00a687 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  7 process 21569  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  6 process 21571  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  5 process 21579  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  4 process 21585  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  3 process 21586  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  2 process 21594  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n* 1 process 21584  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n\nI assume that the command object is created by another thread which dies.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n\nDescription:\nAll activemq c++ clients core after missing a response from the broker. It seems that the broker is in a bad state.\n\nHere i have used the code from /opt/apache-activemq-5.1.0/activemq-cpp-2.1.3-src/src/examples/main.cpp of the download software.\n\n#0  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n#1  0x0000003dcc44602b in vfprintf () from /lib64/libc.so.6\n#2  0x0000003dcc4671fa in vsnprintf () from /lib64/libc.so.6\n#3  0x00002aaaaac00c2f in activemq::exceptions::ActiveMQException::buildMessage (this=Variable \"this\" is not available.\n) at activemq/exceptions/ActiveMQException.cpp:76\n#4  0x00002aaaaac13708 in CommandIOException (this=0x17c39e60, file=0x2aaaaad31160 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=146,\n    msg=0x2aaaaad31198 \"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67\n#5  0x00002aaaaac623c2 in activemq::transport::filters::ResponseCorrelator::request (this=Variable \"this\" is not available.\n) at activemq/transport/filters/ResponseCorrelator.cpp:148\n#6  0x00002aaaaac38c1a in activemq::connector::openwire::OpenWireFormatNegotiator::request (this=0x17c37660, command=0x17c38d28)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00002aaaaac3fe2f in activemq::connector::openwire::OpenWireConnector::syncRequest (this=Variable \"this\" is not available.\n) at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00002aaaaac41511 in activemq::connector::openwire::OpenWireConnector::send (this=0x17c35cc0, message=Variable \"message\" is not available.\n)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00002aaaaabd994c in activemq::core::ActiveMQSession::send (this=Variable \"this\" is not available.\n) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00002aaaaabe52c0 in activemq::core::ActiveMQProducer::send (this=0x17c38c70, destination=Variable \"destination\" is not available.\n) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00002aaaaabe4dea in activemq::core::ActiveMQProducer::send (this=0x4, destination=0x2aaaaad311c0, message=0x43203b98)\n    at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00002aaaaabe50fb in activemq::core::ActiveMQProducer::send (this=0x17c38c70, message=0x17c38d20) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x00000000004034e0 in HelloWorldProducer::run (this=0x7ffffc892390) at main.cpp:111\n#14 0x00002aaaaabff0e0 in activemq::concurrent::Thread::runCallback (param=Variable \"param\" is not available.\n) at activemq/concurrent/Thread.cpp:152\n#15 0x0000003dcd0062e7 in start_thread () from /lib64/libpthread.so.0\n#16 0x0000003dcc4ce3bd in clone () from /lib64/libc.so.6\n\n\n(gdb) info thread\n  9 process 21565  0x0000003dcd0075a5 in pthread_join () from /lib64/libpthread.so.0\n  8 process 21566  0x0000003dcd00a687 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  7 process 21569  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  6 process 21571  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  5 process 21579  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  4 process 21585  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n  3 process 21586  0x0000003dcc4cee41 in recv () from /lib64/libc.so.6\n  2 process 21594  0x0000003dcd00a496 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n* 1 process 21584  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n\nI assume that the command object is created by another thread which dies.\n\n\n\nComments:\n", "classification": "Classify the issue '\"No valid response received for command: %s, check broker.\") at ./activemq/transport/CommandIOException.h:67' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-221?\nA: All activemq c++ clients core after missing a response from the broker. It seems that the broker is in a bad state.\n\nHere i have used the code from /opt/apache-activemq-5.1.0/activemq-cpp-2.1.3-src/src/examples/main.cpp of the download software.\n\n#0  0x0000003dcc476090 in strlen () from /lib64/libc.so.6\n#1  0x0000003dcc44602b in vfprintf () from /lib64/libc.so.6\n#2  0x0000003dcc4671fa in vsnprintf"}}
{"issue_key": "AMQCPP-220", "project": "AMQCPP", "title": "Memory leak in activemq-cpp", "status": "Resolved", "reporter": "Brian Roach", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2009-01-28T04:27:03.000+0000", "updated": "2009-01-30T22:19:52.000+0000", "description": "The API leaks ~ 2MB of memory for every 1 million messages consumed.\n\nThe example consumer in activemq-cpp-2.2.3-src/src/examples/consumers can be used as a test bed, it exhibits the behavior.  \n\nIt's even worse if you are not using the consumer->setMessageListener( ) method and are instead directly using the consumer->receive() method in your own loop.  I dont' have hard numbers but it is somewhere around ten-fold. \n\nWe have an application which is processing ~ 40 million messages per day, and will keep growing until the box runs out of memory.", "comments": [], "text": "Memory leak in activemq-cpp\n\nDescription:\n\nThe API leaks ~ 2MB of memory for every 1 million messages consumed.\n\nThe example consumer in activemq-cpp-2.2.3-src/src/examples/consumers can be used as a test bed, it exhibits the behavior.  \n\nIt's even worse if you are not using the consumer->setMessageListener( ) method and are instead directly using the consumer->receive() method in your own loop.  I dont' have hard numbers but it is somewhere around ten-fold. \n\nWe have an application which is processing ~ 40 million messages per day, and will keep growing until the box runs out of memory. \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak in activemq-cpp\n\nDescription:\n\nThe API leaks ~ 2MB of memory for every 1 million messages consumed.\n\nThe example consumer in activemq-cpp-2.2.3-src/src/examples/consumers can be used as a test bed, it exhibits the behavior.  \n\nIt's even worse if you are not using the consumer->setMessageListener( ) method and are instead directly using the consumer->receive() method in your own loop.  I dont' have hard numbers but it is somewhere around ten-fold. \n\nWe have an application which is processing ~ 40 million messages per day, and will keep growing until the box runs out of memory. \n\n\nComments:\n", "classification": "Classify the issue 'Memory leak in activemq-cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-220?\nA: \nThe API leaks ~ 2MB of memory for every 1 million messages consumed.\n\nThe example consumer in activemq-cpp-2.2.3-src/src/examples/consumers can be used as a test bed, it exhibits the behavior.  \n\nIt's even worse if you are not using the consumer->setMessageListener( ) method and are instead directly using the consumer->receive() method in your own loop.  I dont' have hard numbers but it is somewh"}}
{"issue_key": "AMQCPP-219", "project": "AMQCPP", "title": "Compilation errors in main/decaf/net on Solaris 10 with SunStudio 12", "status": "Resolved", "reporter": "Michael Vishchers", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2009-01-23T12:03:36.000+0000", "updated": "2009-01-23T14:50:42.000+0000", "description": "compilation of TcpSocket.cpp fails with:\n\"decaf/net/TcpSocket.cpp\", line 32: Error: Cannot use const int to initialize apr_socket_t*.\n\"decaf/net/TcpSocket.cpp\", line 39: Error: Cannot use const int to initialize apr_socket_t*.\n2 Error(s) detected.\n\ncompilation of SocketInputStream.cpp fails with:\n\"decaf/net/SocketInputStream.cpp\", line 102: Error: ioctl is not a member of file level.\n1 Error(s) detected.", "comments": [], "text": "Compilation errors in main/decaf/net on Solaris 10 with SunStudio 12\n\nDescription:\ncompilation of TcpSocket.cpp fails with:\n\"decaf/net/TcpSocket.cpp\", line 32: Error: Cannot use const int to initialize apr_socket_t*.\n\"decaf/net/TcpSocket.cpp\", line 39: Error: Cannot use const int to initialize apr_socket_t*.\n2 Error(s) detected.\n\ncompilation of SocketInputStream.cpp fails with:\n\"decaf/net/SocketInputStream.cpp\", line 102: Error: ioctl is not a member of file level.\n1 Error(s) detected.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation errors in main/decaf/net on Solaris 10 with SunStudio 12\n\nDescription:\ncompilation of TcpSocket.cpp fails with:\n\"decaf/net/TcpSocket.cpp\", line 32: Error: Cannot use const int to initialize apr_socket_t*.\n\"decaf/net/TcpSocket.cpp\", line 39: Error: Cannot use const int to initialize apr_socket_t*.\n2 Error(s) detected.\n\ncompilation of SocketInputStream.cpp fails with:\n\"decaf/net/SocketInputStream.cpp\", line 102: Error: ioctl is not a member of file level.\n1 Error(s) detected.\n\n\nComments:\n", "classification": "Classify the issue 'Compilation errors in main/decaf/net on Solaris 10 with SunStudio 12' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-219?\nA: compilation of TcpSocket.cpp fails with:\n\"decaf/net/TcpSocket.cpp\", line 32: Error: Cannot use const int to initialize apr_socket_t*.\n\"decaf/net/TcpSocket.cpp\", line 39: Error: Cannot use const int to initialize apr_socket_t*.\n2 Error(s) detected.\n\ncompilation of SocketInputStream.cpp fails with:\n\"decaf/net/SocketInputStream.cpp\", line 102: Error: ioctl is not a member of file level.\n1 Error(s) de"}}
{"issue_key": "AMQCPP-218", "project": "AMQCPP", "title": "CMSException is not getting caught by base class std::exception.", "status": "Resolved", "reporter": "Ashok Panchal", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-12-30T06:36:17.000+0000", "updated": "2009-02-05T15:26:04.000+0000", "description": "I am upgrading CPP libary 2.1.1 to AMQCPP 2.2.2, and using fuse-message-broker-5.2.0.1. \n\nMy application is in C++ so it uses std::exception handler as generic. But with AMQCPP 2.2.2 and 2.2.1, these handlers are not getting called though cms:CMSException handlers get called. \n\nI tested it using test application in AMQCPP library <vs2005-activemq-example>. Here is consumer's run method from example. Put your broker down, so you will get exception at CreateConnection(). \n\nEx: \n virtual void run() { \n\n        try { \n\n            // Create a ConnectionFactory \n            auto_ptr<ConnectionFactory> connectionFactory( \n                ConnectionFactory::createCMSConnectionFactory( brokerURI ) ); \n\n            // Create a Connection \n            connection = connectionFactory->createConnection(); \n            connection->start(); \n            connection->setExceptionListener(this); \n\n            // Create a Session \n            if( this->sessionTransacted == true ) { \n                session = connection->createSession( Session::SESSION_TRANSACTED ); \n            } else { \n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE ); \n            } \n\n            // Create the destination (Topic or Queue) \n            if( useTopic ) { \n                destination = session->createTopic( \"TEST.FOO\" ); \n            } else { \n                destination = session->createQueue( \"TEST.FOO\" ); \n            } \n\n            // Create a MessageConsumer from the Session to the Topic or Queue \n            consumer = session->createConsumer( destination ); \n\n            consumer->setMessageListener( this ); \n\n            std::cout.flush(); \n            std::cerr.flush(); \n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n\n            // Wait while asynchronous messages come in. \n            doneLatch.await( waitMillis ); \n\n                } catch (std::exception& e) {\n                      //e.printStackTrace(); \n                        printf(e.what()); \n                        printf( \"Std Exception at Consumer:\"); \n                }catch(cms::CMSException& e) {\n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n          printf(\"cms Exception occurred. Consumer.\\n\"); \n\n            e.printStackTrace(); \n                } \n    } \n\nI am getting warning for this as expected in build: \nwarning C4286: 'cms::CMSException &' : is caught by base class ('std::exception &') on line 127 \n\nBut the std::exception handler is not getting called though CMSException handler excuted. As a base class  I believe that std:exception should get called. This is working fine using 2.1.1 library, but not 2.2.1/2.2.2.", "comments": [], "text": "CMSException is not getting caught by base class std::exception.\n\nDescription:\nI am upgrading CPP libary 2.1.1 to AMQCPP 2.2.2, and using fuse-message-broker-5.2.0.1. \n\nMy application is in C++ so it uses std::exception handler as generic. But with AMQCPP 2.2.2 and 2.2.1, these handlers are not getting called though cms:CMSException handlers get called. \n\nI tested it using test application in AMQCPP library <vs2005-activemq-example>. Here is consumer's run method from example. Put your broker down, so you will get exception at CreateConnection(). \n\nEx: \n virtual void run() { \n\n        try { \n\n            // Create a ConnectionFactory \n            auto_ptr<ConnectionFactory> connectionFactory( \n                ConnectionFactory::createCMSConnectionFactory( brokerURI ) ); \n\n            // Create a Connection \n            connection = connectionFactory->createConnection(); \n            connection->start(); \n            connection->setExceptionListener(this); \n\n            // Create a Session \n            if( this->sessionTransacted == true ) { \n                session = connection->createSession( Session::SESSION_TRANSACTED ); \n            } else { \n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE ); \n            } \n\n            // Create the destination (Topic or Queue) \n            if( useTopic ) { \n                destination = session->createTopic( \"TEST.FOO\" ); \n            } else { \n                destination = session->createQueue( \"TEST.FOO\" ); \n            } \n\n            // Create a MessageConsumer from the Session to the Topic or Queue \n            consumer = session->createConsumer( destination ); \n\n            consumer->setMessageListener( this ); \n\n            std::cout.flush(); \n            std::cerr.flush(); \n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n\n            // Wait while asynchronous messages come in. \n            doneLatch.await( waitMillis ); \n\n                } catch (std::exception& e) {\n                      //e.printStackTrace(); \n                        printf(e.what()); \n                        printf( \"Std Exception at Consumer:\"); \n                }catch(cms::CMSException& e) {\n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n          printf(\"cms Exception occurred. Consumer.\\n\"); \n\n            e.printStackTrace(); \n                } \n    } \n\nI am getting warning for this as expected in build: \nwarning C4286: 'cms::CMSException &' : is caught by base class ('std::exception &') on line 127 \n\nBut the std::exception handler is not getting called though CMSException handler excuted. As a base class  I believe that std:exception should get called. This is working fine using 2.1.1 library, but not 2.2.1/2.2.2. \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMSException is not getting caught by base class std::exception.\n\nDescription:\nI am upgrading CPP libary 2.1.1 to AMQCPP 2.2.2, and using fuse-message-broker-5.2.0.1. \n\nMy application is in C++ so it uses std::exception handler as generic. But with AMQCPP 2.2.2 and 2.2.1, these handlers are not getting called though cms:CMSException handlers get called. \n\nI tested it using test application in AMQCPP library <vs2005-activemq-example>. Here is consumer's run method from example. Put your broker down, so you will get exception at CreateConnection(). \n\nEx: \n virtual void run() { \n\n        try { \n\n            // Create a ConnectionFactory \n            auto_ptr<ConnectionFactory> connectionFactory( \n                ConnectionFactory::createCMSConnectionFactory( brokerURI ) ); \n\n            // Create a Connection \n            connection = connectionFactory->createConnection(); \n            connection->start(); \n            connection->setExceptionListener(this); \n\n            // Create a Session \n            if( this->sessionTransacted == true ) { \n                session = connection->createSession( Session::SESSION_TRANSACTED ); \n            } else { \n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE ); \n            } \n\n            // Create the destination (Topic or Queue) \n            if( useTopic ) { \n                destination = session->createTopic( \"TEST.FOO\" ); \n            } else { \n                destination = session->createQueue( \"TEST.FOO\" ); \n            } \n\n            // Create a MessageConsumer from the Session to the Topic or Queue \n            consumer = session->createConsumer( destination ); \n\n            consumer->setMessageListener( this ); \n\n            std::cout.flush(); \n            std::cerr.flush(); \n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n\n            // Wait while asynchronous messages come in. \n            doneLatch.await( waitMillis ); \n\n                } catch (std::exception& e) {\n                      //e.printStackTrace(); \n                        printf(e.what()); \n                        printf( \"Std Exception at Consumer:\"); \n                }catch(cms::CMSException& e) {\n\n            // Indicate we are ready for messages. \n            latch.countDown(); \n          printf(\"cms Exception occurred. Consumer.\\n\"); \n\n            e.printStackTrace(); \n                } \n    } \n\nI am getting warning for this as expected in build: \nwarning C4286: 'cms::CMSException &' : is caught by base class ('std::exception &') on line 127 \n\nBut the std::exception handler is not getting called though CMSException handler excuted. As a base class  I believe that std:exception should get called. This is working fine using 2.1.1 library, but not 2.2.1/2.2.2. \n\n\nComments:\n", "classification": "Classify the issue 'CMSException is not getting caught by base class std::exception.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-218?\nA: I am upgrading CPP libary 2.1.1 to AMQCPP 2.2.2, and using fuse-message-broker-5.2.0.1. \n\nMy application is in C++ so it uses std::exception handler as generic. But with AMQCPP 2.2.2 and 2.2.1, these handlers are not getting called though cms:CMSException handlers get called. \n\nI tested it using test application in AMQCPP library <vs2005-activemq-example>. Here is consumer's run method from exampl"}}
{"issue_key": "AMQCPP-217", "project": "AMQCPP", "title": "Implement StreamMessage", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-12-12T23:26:56.000+0000", "updated": "2009-05-15T14:50:10.000+0000", "description": "Implement the StreamMessage interface in CMS.  \n\n1. Add the StreamMessage interface to CMS API\n2. Implement ActiveMQStreamMessage\n3. Generate the Marshaller code.", "comments": [], "text": "Implement StreamMessage\n\nDescription:\nImplement the StreamMessage interface in CMS.  \n\n1. Add the StreamMessage interface to CMS API\n2. Implement ActiveMQStreamMessage\n3. Generate the Marshaller code.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement StreamMessage\n\nDescription:\nImplement the StreamMessage interface in CMS.  \n\n1. Add the StreamMessage interface to CMS API\n2. Implement ActiveMQStreamMessage\n3. Generate the Marshaller code.\n\n\nComments:\n", "classification": "Classify the issue 'Implement StreamMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-217?\nA: Implement the StreamMessage interface in CMS.  \n\n1. Add the StreamMessage interface to CMS API\n2. Implement ActiveMQStreamMessage\n3. Generate the Marshaller code.\n"}}
{"issue_key": "AMQCPP-216", "project": "AMQCPP", "title": "Implement BlobMessage", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-12-12T23:23:48.000+0000", "updated": "2013-04-26T22:31:40.000+0000", "description": "Implement BlobMessage in CMS and in the OpenWire code, this requires implementation of ActiveMQBlobMessage and its associated Marshaller.  Add code to the OpenWireConnector to deal with it, and add code to the StompConnector to throw an unsupported operation exception.", "comments": [], "text": "Implement BlobMessage\n\nDescription:\nImplement BlobMessage in CMS and in the OpenWire code, this requires implementation of ActiveMQBlobMessage and its associated Marshaller.  Add code to the OpenWireConnector to deal with it, and add code to the StompConnector to throw an unsupported operation exception.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement BlobMessage\n\nDescription:\nImplement BlobMessage in CMS and in the OpenWire code, this requires implementation of ActiveMQBlobMessage and its associated Marshaller.  Add code to the OpenWireConnector to deal with it, and add code to the StompConnector to throw an unsupported operation exception.\n\nComments:\n", "classification": "Classify the issue 'Implement BlobMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-216?\nA: Implement BlobMessage in CMS and in the OpenWire code, this requires implementation of ActiveMQBlobMessage and its associated Marshaller.  Add code to the OpenWireConnector to deal with it, and add code to the StompConnector to throw an unsupported operation exception."}}
{"issue_key": "AMQCPP-215", "project": "AMQCPP", "title": "[Fri Dec 12 16:32:14 2008] [notice] child pid 14242 exit signal Bus error (10) ", "status": "Closed", "reporter": "yuhong", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-12-12T09:08:11.000+0000", "updated": "2008-12-18T13:26:32.000+0000", "description": "create a content generator (module) for apache 2.2.9, this module send TextMessage to a ActiveMQ Queue.\nuse loadrunner to simulate 200 users access this apache server to send message,  \"signal Bus error (10)\" is printed in apache's error log.\n\nnot always, just sometime.", "comments": [], "text": "[Fri Dec 12 16:32:14 2008] [notice] child pid 14242 exit signal Bus error (10) \n\nDescription:\ncreate a content generator (module) for apache 2.2.9, this module send TextMessage to a ActiveMQ Queue.\nuse loadrunner to simulate 200 users access this apache server to send message,  \"signal Bus error (10)\" is printed in apache's error log.\n\nnot always, just sometime.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: [Fri Dec 12 16:32:14 2008] [notice] child pid 14242 exit signal Bus error (10) \n\nDescription:\ncreate a content generator (module) for apache 2.2.9, this module send TextMessage to a ActiveMQ Queue.\nuse loadrunner to simulate 200 users access this apache server to send message,  \"signal Bus error (10)\" is printed in apache's error log.\n\nnot always, just sometime.\n\n\nComments:\n", "classification": "Classify the issue '[Fri Dec 12 16:32:14 2008] [notice] child pid 14242 exit signal Bus error (10) ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-215?\nA: create a content generator (module) for apache 2.2.9, this module send TextMessage to a ActiveMQ Queue.\nuse loadrunner to simulate 200 users access this apache server to send message,  \"signal Bus error (10)\" is printed in apache's error log.\n\nnot always, just sometime.\n"}}
{"issue_key": "AMQCPP-214", "project": "AMQCPP", "title": "Support the ActiveMQBlobMessage and ActiveMQStreamMessage", "status": "Closed", "reporter": "Sahayaraj", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2008-12-11T05:18:51.000+0000", "updated": "2013-04-26T22:32:26.000+0000", "description": "In order to integrate the legacy C and C++ application with modern messaging architecture of ActiveMQ, the C++ client MUST support the Blob and Stream messages as supported in JMS. This support  would add the value of interop between the java and legacy C++ systems in enterprise environment.\n\nDue to this unavailablity, we are unable to use ActiveMQ and forced us to go for other soultions.", "comments": [], "text": "Support the ActiveMQBlobMessage and ActiveMQStreamMessage\n\nDescription:\nIn order to integrate the legacy C and C++ application with modern messaging architecture of ActiveMQ, the C++ client MUST support the Blob and Stream messages as supported in JMS. This support  would add the value of interop between the java and legacy C++ systems in enterprise environment.\n\nDue to this unavailablity, we are unable to use ActiveMQ and forced us to go for other soultions.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Support the ActiveMQBlobMessage and ActiveMQStreamMessage\n\nDescription:\nIn order to integrate the legacy C and C++ application with modern messaging architecture of ActiveMQ, the C++ client MUST support the Blob and Stream messages as supported in JMS. This support  would add the value of interop between the java and legacy C++ systems in enterprise environment.\n\nDue to this unavailablity, we are unable to use ActiveMQ and forced us to go for other soultions.\n\nComments:\n", "classification": "Classify the issue 'Support the ActiveMQBlobMessage and ActiveMQStreamMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-214?\nA: In order to integrate the legacy C and C++ application with modern messaging architecture of ActiveMQ, the C++ client MUST support the Blob and Stream messages as supported in JMS. This support  would add the value of interop between the java and legacy C++ systems in enterprise environment.\n\nDue to this unavailablity, we are unable to use ActiveMQ and forced us to go for other soultions."}}
{"issue_key": "AMQCPP-213", "project": "AMQCPP", "title": "JMSXGroupID works with Stomp, not OpenWire. ", "status": "Resolved", "reporter": "Adam Chase", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-12-09T23:16:27.000+0000", "updated": "2008-12-10T22:39:11.000+0000", "description": "No error codes, but messages get queued without groups and are not partitioned.  When I switch the wireformat to Stomp the code works.", "comments": [], "text": "JMSXGroupID works with Stomp, not OpenWire. \n\nDescription:\n No error codes, but messages get queued without groups and are not partitioned.  When I switch the wireformat to Stomp the code works.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: JMSXGroupID works with Stomp, not OpenWire. \n\nDescription:\n No error codes, but messages get queued without groups and are not partitioned.  When I switch the wireformat to Stomp the code works.\n\nComments:\n", "classification": "Classify the issue 'JMSXGroupID works with Stomp, not OpenWire. ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-213?\nA:  No error codes, but messages get queued without groups and are not partitioned.  When I switch the wireformat to Stomp the code works."}}
{"issue_key": "AMQCPP-212", "project": "AMQCPP", "title": "Add more examples to the CPP Client", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2008-12-08T21:05:23.000+0000", "updated": "2008-12-31T20:53:20.000+0000", "description": "Add additional samples to the examples suite", "comments": [], "text": "Add more examples to the CPP Client\n\nDescription:\nAdd additional samples to the examples suite\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add more examples to the CPP Client\n\nDescription:\nAdd additional samples to the examples suite\n\nComments:\n", "classification": "Classify the issue 'Add more examples to the CPP Client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-212?\nA: Add additional samples to the examples suite"}}
{"issue_key": "AMQCPP-211", "project": "AMQCPP", "title": "Add support for responding to the KeepAliveInfo message from the Broker to Openwire", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-12-08T14:54:47.000+0000", "updated": "2008-12-08T15:21:07.000+0000", "description": "The Openwire Connector should properly respond to KeepAliveInfo commands.", "comments": [], "text": "Add support for responding to the KeepAliveInfo message from the Broker to Openwire\n\nDescription:\nThe Openwire Connector should properly respond to KeepAliveInfo commands.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for responding to the KeepAliveInfo message from the Broker to Openwire\n\nDescription:\nThe Openwire Connector should properly respond to KeepAliveInfo commands.\n\nComments:\n", "classification": "Classify the issue 'Add support for responding to the KeepAliveInfo message from the Broker to Openwire' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-211?\nA: The Openwire Connector should properly respond to KeepAliveInfo commands."}}
{"issue_key": "AMQCPP-210", "project": "AMQCPP", "title": "ActiveMQ-CPP on Mac OS X and iPhone OS link error", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-12-03T11:31:44.000+0000", "updated": "2009-04-27T14:52:05.000+0000", "description": "Created this from an email\n\n---Email From - Chris Campbell---\n\nThanks for the excellent work on ActiveMQ-CPP! We're using it with  \ngreat success in several of our projects.\n\nI downloaded version 2.2.2 today and needed to patch src/main/decaf/ \nlang/System.cpp to get it to work on Mac OS X and iPhone OS. Not sure  \nwhich variant of 2.2 I was using before, but I didn't recall patching  \nit.\n\nFor use in our software, I compile ActiveMQ-CPP as a static library  \n(libactivemq-cpp.a) and link it into a Mac OS X framework for use with  \nour Mac OS X applications, or link it directly into an iPhone  \napplication (you're not allowed to build frameworks on the iPhone).\n\nActiveMQ-CPP 2.2.2 will successfully compile and link on Mac OS X, but  \nif you attempt to use the static library in a non-executable (like a  \nshared library or a framework) you get an error at link time that the  \n\"_environ\" symbol could not be found. The reason for this error is  \nexplained at:\n\n     http://lists.apple.com/archives/xcode-users/2004/Jan/msg00230.html\n\nI changed System.cpp by adding the following OS X-specific  \nimplementation of System::getEnvArray() in src/main/decaf/lang/ \nSystem.cpp, created by slightly modifying the non-WIN32 version:\n\n--- BEGIN patch ---\n\n--- activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp.orig   \n2008-12-02 23:51:46.000000000 -0500\n+++ activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp       2008-12-02  \n19:16:00.000000000 -0500\n@@ -208,6 +208,30 @@\n      return buffer;\n  }\n\n+#elif defined(__APPLE__)\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+char*** _NSGetEnviron(void);\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+std::vector<std::string> System::getEnvArray() {\n+\n+    std::vector<std::string> buffer;\n+    int count = 0;\n+\n+    char **environ = *_NSGetEnviron();\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        count++;\n+    }\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        buffer.push_back( environ[i] );\n+    }\n+\n+    return buffer;\n+}\n+\n  #else\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n--- END patch --\n\nBTW, what's the first for loop doing? It calculates \"count\" but  \ndoesn't use it for anything later in the function?\n\nAnyway, thanks again for the great software. Wanted to send you the  \npatch, and thought you might be interested to know that ActiveMQ-CPP  \nis working well on the iPhone!", "comments": [], "text": "ActiveMQ-CPP on Mac OS X and iPhone OS link error\n\nDescription:\nCreated this from an email\n\n---Email From - Chris Campbell---\n\nThanks for the excellent work on ActiveMQ-CPP! We're using it with  \ngreat success in several of our projects.\n\nI downloaded version 2.2.2 today and needed to patch src/main/decaf/ \nlang/System.cpp to get it to work on Mac OS X and iPhone OS. Not sure  \nwhich variant of 2.2 I was using before, but I didn't recall patching  \nit.\n\nFor use in our software, I compile ActiveMQ-CPP as a static library  \n(libactivemq-cpp.a) and link it into a Mac OS X framework for use with  \nour Mac OS X applications, or link it directly into an iPhone  \napplication (you're not allowed to build frameworks on the iPhone).\n\nActiveMQ-CPP 2.2.2 will successfully compile and link on Mac OS X, but  \nif you attempt to use the static library in a non-executable (like a  \nshared library or a framework) you get an error at link time that the  \n\"_environ\" symbol could not be found. The reason for this error is  \nexplained at:\n\n     http://lists.apple.com/archives/xcode-users/2004/Jan/msg00230.html\n\nI changed System.cpp by adding the following OS X-specific  \nimplementation of System::getEnvArray() in src/main/decaf/lang/ \nSystem.cpp, created by slightly modifying the non-WIN32 version:\n\n--- BEGIN patch ---\n\n--- activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp.orig   \n2008-12-02 23:51:46.000000000 -0500\n+++ activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp       2008-12-02  \n19:16:00.000000000 -0500\n@@ -208,6 +208,30 @@\n      return buffer;\n  }\n\n+#elif defined(__APPLE__)\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+char*** _NSGetEnviron(void);\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+std::vector<std::string> System::getEnvArray() {\n+\n+    std::vector<std::string> buffer;\n+    int count = 0;\n+\n+    char **environ = *_NSGetEnviron();\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        count++;\n+    }\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        buffer.push_back( environ[i] );\n+    }\n+\n+    return buffer;\n+}\n+\n  #else\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n--- END patch --\n\nBTW, what's the first for loop doing? It calculates \"count\" but  \ndoesn't use it for anything later in the function?\n\nAnyway, thanks again for the great software. Wanted to send you the  \npatch, and thought you might be interested to know that ActiveMQ-CPP  \nis working well on the iPhone!\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ-CPP on Mac OS X and iPhone OS link error\n\nDescription:\nCreated this from an email\n\n---Email From - Chris Campbell---\n\nThanks for the excellent work on ActiveMQ-CPP! We're using it with  \ngreat success in several of our projects.\n\nI downloaded version 2.2.2 today and needed to patch src/main/decaf/ \nlang/System.cpp to get it to work on Mac OS X and iPhone OS. Not sure  \nwhich variant of 2.2 I was using before, but I didn't recall patching  \nit.\n\nFor use in our software, I compile ActiveMQ-CPP as a static library  \n(libactivemq-cpp.a) and link it into a Mac OS X framework for use with  \nour Mac OS X applications, or link it directly into an iPhone  \napplication (you're not allowed to build frameworks on the iPhone).\n\nActiveMQ-CPP 2.2.2 will successfully compile and link on Mac OS X, but  \nif you attempt to use the static library in a non-executable (like a  \nshared library or a framework) you get an error at link time that the  \n\"_environ\" symbol could not be found. The reason for this error is  \nexplained at:\n\n     http://lists.apple.com/archives/xcode-users/2004/Jan/msg00230.html\n\nI changed System.cpp by adding the following OS X-specific  \nimplementation of System::getEnvArray() in src/main/decaf/lang/ \nSystem.cpp, created by slightly modifying the non-WIN32 version:\n\n--- BEGIN patch ---\n\n--- activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp.orig   \n2008-12-02 23:51:46.000000000 -0500\n+++ activemq-cpp-2.2.2-src/src/main/decaf/lang/System.cpp       2008-12-02  \n19:16:00.000000000 -0500\n@@ -208,6 +208,30 @@\n      return buffer;\n  }\n\n+#elif defined(__APPLE__)\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+char*** _NSGetEnviron(void);\n+\n+ \n////////////////////////////////////////////////////////////////////////////////\n+std::vector<std::string> System::getEnvArray() {\n+\n+    std::vector<std::string> buffer;\n+    int count = 0;\n+\n+    char **environ = *_NSGetEnviron();\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        count++;\n+    }\n+\n+    for( int i = 0; *(environ + i); i++ ){\n+        buffer.push_back( environ[i] );\n+    }\n+\n+    return buffer;\n+}\n+\n  #else\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n--- END patch --\n\nBTW, what's the first for loop doing? It calculates \"count\" but  \ndoesn't use it for anything later in the function?\n\nAnyway, thanks again for the great software. Wanted to send you the  \npatch, and thought you might be interested to know that ActiveMQ-CPP  \nis working well on the iPhone!\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ-CPP on Mac OS X and iPhone OS link error' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-210?\nA: Created this from an email\n\n---Email From - Chris Campbell---\n\nThanks for the excellent work on ActiveMQ-CPP! We're using it with  \ngreat success in several of our projects.\n\nI downloaded version 2.2.2 today and needed to patch src/main/decaf/ \nlang/System.cpp to get it to work on Mac OS X and iPhone OS. Not sure  \nwhich variant of 2.2 I was using before, but I didn't recall patching  \nit.\n\nFor us"}}
{"issue_key": "AMQCPP-209", "project": "AMQCPP", "title": "Transaction Integration Tests for both Stomp and Openwire fail randomly", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-11-26T14:29:42.000+0000", "updated": "2009-04-20T17:30:23.000+0000", "description": "The Transaction tests in the Integration test suite are incorrect and lead to occasional failures against recent brokers.  The tests need to be rewritten to correctly test the Transactional Logic.", "comments": [], "text": "Transaction Integration Tests for both Stomp and Openwire fail randomly\n\nDescription:\nThe Transaction tests in the Integration test suite are incorrect and lead to occasional failures against recent brokers.  The tests need to be rewritten to correctly test the Transactional Logic.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Transaction Integration Tests for both Stomp and Openwire fail randomly\n\nDescription:\nThe Transaction tests in the Integration test suite are incorrect and lead to occasional failures against recent brokers.  The tests need to be rewritten to correctly test the Transactional Logic.\n\nComments:\n", "classification": "Classify the issue 'Transaction Integration Tests for both Stomp and Openwire fail randomly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-209?\nA: The Transaction tests in the Integration test suite are incorrect and lead to occasional failures against recent brokers.  The tests need to be rewritten to correctly test the Transactional Logic."}}
{"issue_key": "AMQCPP-208", "project": "AMQCPP", "title": "Update Openwire Command and Marshaler generator", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-11-24T13:55:15.000+0000", "updated": "2008-11-25T14:12:07.000+0000", "description": "Update the Java code for the Openwire Command Generator to properly add the AMQCPP_API macro to the generated commands an marshaller classes so that the unit test and integration test projects can be linked against the DLL built on Windows.\n\nAlso add the getSize method to the Generated Message class.", "comments": [], "text": "Update Openwire Command and Marshaler generator\n\nDescription:\nUpdate the Java code for the Openwire Command Generator to properly add the AMQCPP_API macro to the generated commands an marshaller classes so that the unit test and integration test projects can be linked against the DLL built on Windows.\n\nAlso add the getSize method to the Generated Message class.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update Openwire Command and Marshaler generator\n\nDescription:\nUpdate the Java code for the Openwire Command Generator to properly add the AMQCPP_API macro to the generated commands an marshaller classes so that the unit test and integration test projects can be linked against the DLL built on Windows.\n\nAlso add the getSize method to the Generated Message class.\n\nComments:\n", "classification": "Classify the issue 'Update Openwire Command and Marshaler generator' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-208?\nA: Update the Java code for the Openwire Command Generator to properly add the AMQCPP_API macro to the generated commands an marshaller classes so that the unit test and integration test projects can be linked against the DLL built on Windows.\n\nAlso add the getSize method to the Generated Message class."}}
{"issue_key": "AMQCPP-207", "project": "AMQCPP", "title": "Memory leak/segv's with frequent reconnections (identified)", "status": "Closed", "reporter": "Michael J. Kitchin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-11-14T19:29:16.000+0000", "updated": "2008-11-14T23:21:53.000+0000", "description": "If a CMS consumer client reconnects frequently a segv will arise with reliability (it's guaranteed for us within a hundred reconnections or so). Additionally, in researching this we seem to have stumbled across a related memory leak.\n\nWhen we shut down our consumer in the following order, as suggested by the sample code:\n\n- delete destination\n- delete consumer\n- close session\n- close connection (*)\n- delete session\n- delete connection\n\n...a segv will occur at the step marked with a (*), due to effects observable in these thread stack traces:\n\nThread #1:\n\n>\tactivemq-cppd.dll!activemq::transport::IOTransport::close()  Line 158\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::close()  Line 222 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::TcpTransport::close()  Line 147 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::ResponseCorrelator::close()  Line 290 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormatNegotiator::close()  Line 257 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireConnector::close()  Line 178 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::close()  Line 89 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::~ActiveMQConnectionData()  Line 77\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::`vector deleting destructor'()  + 0x54 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnection::close()  Line 160 + 0x37 bytes\tC++\n\nThread #2:\n\n \tactivemq-cppd.dll!decaf::net::SocketInputStream::read(unsigned char * buffer=0x08b4dcb8, unsigned int offset=0, unsigned int bufferSize=1)  Line 170 + 0x18 bytes\tC++\n>\tactivemq-cppd.dll!decaf::io::BufferedInputStream::bufferData()  Line 260 + 0x30 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::BufferedInputStream::read(unsigned char * targetBuffer=0x0a80f7d8, unsigned int offset=0, unsigned int targetBufferSize=4)  Line 181 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readAllData(unsigned char * buffer=0x0a80f7d8, unsigned int length=4)  Line 360 + 0x25 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readInt()  Line 167\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormat::unmarshal(decaf::io::DataInputStream * dis=0x08bd66d8)  Line 227 + 0xf bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1c bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 188 + 0x15 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::runCallback(apr_thread_t * self=0x08bb3ea0, void * param=0x08bd6828)  Line 113 + 0x15 bytes\tC++\n \tlibapr-1.dll!dummy_worker(void * opaque=0x08bb3ea0)  Line 80\tC\n\n...where, in thread #2, the SocketInputStream interior to the BufferedInputStream (the inputStream member) has been NULL'ed between two method calls shown below, ending at bufferedinputstream.cpp:260:\n\n        // Get the number of bytes currently available on the input stream\n        // that could be read without blocking.\n        std::size_t available = inputStream->available();\n\n        // Calculate the number of bytes that we can read.  Always >= 1 byte!\n        std::size_t bytesToRead = max( (std::size_t)1, min( available, getUnusedBytes() ) );\n\n        // Read the bytes from the input stream.\n        int bytesRead = inputStream->read( getTail(), 0, bytesToRead );\n\n....as a result of the stream close() call in thread #1. The close() call is in place to break any waiting IO so the executor thread may terminate in an orderly fashion, but the stream and/or iotransport calls don't anticipate a case where in-stream processing is underway at the time its internal state is reset.\n\nThis suggests either:\n\n(1) more careful synchronization of the compound stream's state\n(2) realigning the compound stream's member data\n\n...I would vote the former, and could suggest some options. \n\nAdditionally, when reviewing the code in in thread #1 we found the following, beginning at iotransport.cpp:150:\n\n        // We have to close the input stream before\n        // we stop the thread.  this will force us to\n        // wake up the thread if it's stuck in a read\n        // (which is likely).  Otherwise, the join that\n        // follows will block forever.\n        if( inputStream != NULL ){\n\n            inputStream->close();\n            inputStream = NULL;\n        }\n\n        // Wait for the thread to die.\n        if( thread != NULL ){\n            thread->join();\n            delete thread;\n            thread = NULL;\n        }\n\n        // Close the output stream.\n        if( outputStream != NULL ){\n\n            outputStream->close();\n            outputStream = NULL;\n        }\n\n...our familiarity with decaf is limited, but it appears inputStream and outputStream are conventional pointers, so should therefore be deleted prior to being set to NULL to avoid leaking memory. To minimize the other potential segv edge cases, we would suggest doing the close() calls before completing the thread join(), then deleting/NULL'ing the pointers afterwards.", "comments": [], "text": "Memory leak/segv's with frequent reconnections (identified)\n\nDescription:\nIf a CMS consumer client reconnects frequently a segv will arise with reliability (it's guaranteed for us within a hundred reconnections or so). Additionally, in researching this we seem to have stumbled across a related memory leak.\n\nWhen we shut down our consumer in the following order, as suggested by the sample code:\n\n- delete destination\n- delete consumer\n- close session\n- close connection (*)\n- delete session\n- delete connection\n\n...a segv will occur at the step marked with a (*), due to effects observable in these thread stack traces:\n\nThread #1:\n\n>\tactivemq-cppd.dll!activemq::transport::IOTransport::close()  Line 158\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::close()  Line 222 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::TcpTransport::close()  Line 147 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::ResponseCorrelator::close()  Line 290 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormatNegotiator::close()  Line 257 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireConnector::close()  Line 178 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::close()  Line 89 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::~ActiveMQConnectionData()  Line 77\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::`vector deleting destructor'()  + 0x54 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnection::close()  Line 160 + 0x37 bytes\tC++\n\nThread #2:\n\n \tactivemq-cppd.dll!decaf::net::SocketInputStream::read(unsigned char * buffer=0x08b4dcb8, unsigned int offset=0, unsigned int bufferSize=1)  Line 170 + 0x18 bytes\tC++\n>\tactivemq-cppd.dll!decaf::io::BufferedInputStream::bufferData()  Line 260 + 0x30 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::BufferedInputStream::read(unsigned char * targetBuffer=0x0a80f7d8, unsigned int offset=0, unsigned int targetBufferSize=4)  Line 181 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readAllData(unsigned char * buffer=0x0a80f7d8, unsigned int length=4)  Line 360 + 0x25 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readInt()  Line 167\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormat::unmarshal(decaf::io::DataInputStream * dis=0x08bd66d8)  Line 227 + 0xf bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1c bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 188 + 0x15 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::runCallback(apr_thread_t * self=0x08bb3ea0, void * param=0x08bd6828)  Line 113 + 0x15 bytes\tC++\n \tlibapr-1.dll!dummy_worker(void * opaque=0x08bb3ea0)  Line 80\tC\n\n...where, in thread #2, the SocketInputStream interior to the BufferedInputStream (the inputStream member) has been NULL'ed between two method calls shown below, ending at bufferedinputstream.cpp:260:\n\n        // Get the number of bytes currently available on the input stream\n        // that could be read without blocking.\n        std::size_t available = inputStream->available();\n\n        // Calculate the number of bytes that we can read.  Always >= 1 byte!\n        std::size_t bytesToRead = max( (std::size_t)1, min( available, getUnusedBytes() ) );\n\n        // Read the bytes from the input stream.\n        int bytesRead = inputStream->read( getTail(), 0, bytesToRead );\n\n....as a result of the stream close() call in thread #1. The close() call is in place to break any waiting IO so the executor thread may terminate in an orderly fashion, but the stream and/or iotransport calls don't anticipate a case where in-stream processing is underway at the time its internal state is reset.\n\nThis suggests either:\n\n(1) more careful synchronization of the compound stream's state\n(2) realigning the compound stream's member data\n\n...I would vote the former, and could suggest some options. \n\nAdditionally, when reviewing the code in in thread #1 we found the following, beginning at iotransport.cpp:150:\n\n        // We have to close the input stream before\n        // we stop the thread.  this will force us to\n        // wake up the thread if it's stuck in a read\n        // (which is likely).  Otherwise, the join that\n        // follows will block forever.\n        if( inputStream != NULL ){\n\n            inputStream->close();\n            inputStream = NULL;\n        }\n\n        // Wait for the thread to die.\n        if( thread != NULL ){\n            thread->join();\n            delete thread;\n            thread = NULL;\n        }\n\n        // Close the output stream.\n        if( outputStream != NULL ){\n\n            outputStream->close();\n            outputStream = NULL;\n        }\n\n...our familiarity with decaf is limited, but it appears inputStream and outputStream are conventional pointers, so should therefore be deleted prior to being set to NULL to avoid leaking memory. To minimize the other potential segv edge cases, we would suggest doing the close() calls before completing the thread join(), then deleting/NULL'ing the pointers afterwards.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leak/segv's with frequent reconnections (identified)\n\nDescription:\nIf a CMS consumer client reconnects frequently a segv will arise with reliability (it's guaranteed for us within a hundred reconnections or so). Additionally, in researching this we seem to have stumbled across a related memory leak.\n\nWhen we shut down our consumer in the following order, as suggested by the sample code:\n\n- delete destination\n- delete consumer\n- close session\n- close connection (*)\n- delete session\n- delete connection\n\n...a segv will occur at the step marked with a (*), due to effects observable in these thread stack traces:\n\nThread #1:\n\n>\tactivemq-cppd.dll!activemq::transport::IOTransport::close()  Line 158\tC++\n \tactivemq-cppd.dll!activemq::transport::TransportFilter::close()  Line 222 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::TcpTransport::close()  Line 147 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::filters::ResponseCorrelator::close()  Line 290 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormatNegotiator::close()  Line 257 + 0x1b bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireConnector::close()  Line 178 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::close()  Line 89 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::~ActiveMQConnectionData()  Line 77\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnectionData::`vector deleting destructor'()  + 0x54 bytes\tC++\n \tactivemq-cppd.dll!activemq::core::ActiveMQConnection::close()  Line 160 + 0x37 bytes\tC++\n\nThread #2:\n\n \tactivemq-cppd.dll!decaf::net::SocketInputStream::read(unsigned char * buffer=0x08b4dcb8, unsigned int offset=0, unsigned int bufferSize=1)  Line 170 + 0x18 bytes\tC++\n>\tactivemq-cppd.dll!decaf::io::BufferedInputStream::bufferData()  Line 260 + 0x30 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::BufferedInputStream::read(unsigned char * targetBuffer=0x0a80f7d8, unsigned int offset=0, unsigned int targetBufferSize=4)  Line 181 + 0x8 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readAllData(unsigned char * buffer=0x0a80f7d8, unsigned int length=4)  Line 360 + 0x25 bytes\tC++\n \tactivemq-cppd.dll!decaf::io::DataInputStream::readInt()  Line 167\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireFormat::unmarshal(decaf::io::DataInputStream * dis=0x08bd66d8)  Line 227 + 0xf bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1c bytes\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 188 + 0x15 bytes\tC++\n \tactivemq-cppd.dll!decaf::lang::Thread::runCallback(apr_thread_t * self=0x08bb3ea0, void * param=0x08bd6828)  Line 113 + 0x15 bytes\tC++\n \tlibapr-1.dll!dummy_worker(void * opaque=0x08bb3ea0)  Line 80\tC\n\n...where, in thread #2, the SocketInputStream interior to the BufferedInputStream (the inputStream member) has been NULL'ed between two method calls shown below, ending at bufferedinputstream.cpp:260:\n\n        // Get the number of bytes currently available on the input stream\n        // that could be read without blocking.\n        std::size_t available = inputStream->available();\n\n        // Calculate the number of bytes that we can read.  Always >= 1 byte!\n        std::size_t bytesToRead = max( (std::size_t)1, min( available, getUnusedBytes() ) );\n\n        // Read the bytes from the input stream.\n        int bytesRead = inputStream->read( getTail(), 0, bytesToRead );\n\n....as a result of the stream close() call in thread #1. The close() call is in place to break any waiting IO so the executor thread may terminate in an orderly fashion, but the stream and/or iotransport calls don't anticipate a case where in-stream processing is underway at the time its internal state is reset.\n\nThis suggests either:\n\n(1) more careful synchronization of the compound stream's state\n(2) realigning the compound stream's member data\n\n...I would vote the former, and could suggest some options. \n\nAdditionally, when reviewing the code in in thread #1 we found the following, beginning at iotransport.cpp:150:\n\n        // We have to close the input stream before\n        // we stop the thread.  this will force us to\n        // wake up the thread if it's stuck in a read\n        // (which is likely).  Otherwise, the join that\n        // follows will block forever.\n        if( inputStream != NULL ){\n\n            inputStream->close();\n            inputStream = NULL;\n        }\n\n        // Wait for the thread to die.\n        if( thread != NULL ){\n            thread->join();\n            delete thread;\n            thread = NULL;\n        }\n\n        // Close the output stream.\n        if( outputStream != NULL ){\n\n            outputStream->close();\n            outputStream = NULL;\n        }\n\n...our familiarity with decaf is limited, but it appears inputStream and outputStream are conventional pointers, so should therefore be deleted prior to being set to NULL to avoid leaking memory. To minimize the other potential segv edge cases, we would suggest doing the close() calls before completing the thread join(), then deleting/NULL'ing the pointers afterwards.\n\n\n\nComments:\n", "classification": "Classify the issue 'Memory leak/segv's with frequent reconnections (identified)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-207?\nA: If a CMS consumer client reconnects frequently a segv will arise with reliability (it's guaranteed for us within a hundred reconnections or so). Additionally, in researching this we seem to have stumbled across a related memory leak.\n\nWhen we shut down our consumer in the following order, as suggested by the sample code:\n\n- delete destination\n- delete consumer\n- close session\n- close connection (*"}}
{"issue_key": "AMQCPP-206", "project": "AMQCPP", "title": "Fix warnings generated when compiling the library on Windows.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-11-12T15:49:19.000+0000", "updated": "2008-11-17T11:34:57.000+0000", "description": "Fix warnings that are generated by the MS compiler and update the Studio projects for the next release.", "comments": [], "text": "Fix warnings generated when compiling the library on Windows.\n\nDescription:\nFix warnings that are generated by the MS compiler and update the Studio projects for the next release.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Fix warnings generated when compiling the library on Windows.\n\nDescription:\nFix warnings that are generated by the MS compiler and update the Studio projects for the next release.\n\nComments:\n", "classification": "Classify the issue 'Fix warnings generated when compiling the library on Windows.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-206?\nA: Fix warnings that are generated by the MS compiler and update the Studio projects for the next release."}}
{"issue_key": "AMQCPP-205", "project": "AMQCPP", "title": "CmsTemplate testBasics test can hang", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-11-12T15:42:50.000+0000", "updated": "2009-05-06T11:53:57.000+0000", "description": "Running the CmsTemplate integration tests in a loop can result in a hang.  The code appears to be deadlocked when two threads that share the same instance of an ActiveMQSessionExecutor are run.  \n\nThis snippet from a backtrace shows the case:\n\n{noformat}\nThread 3 (Thread 1094732688 (LWP 15620)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813a0, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\nThread 2 (Thread 1098935184 (LWP 15621)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813d8, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\n{noformat}", "comments": [], "text": "CmsTemplate testBasics test can hang\n\nDescription:\nRunning the CmsTemplate integration tests in a loop can result in a hang.  The code appears to be deadlocked when two threads that share the same instance of an ActiveMQSessionExecutor are run.  \n\nThis snippet from a backtrace shows the case:\n\n{noformat}\nThread 3 (Thread 1094732688 (LWP 15620)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813a0, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\nThread 2 (Thread 1098935184 (LWP 15621)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813d8, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\n{noformat}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CmsTemplate testBasics test can hang\n\nDescription:\nRunning the CmsTemplate integration tests in a loop can result in a hang.  The code appears to be deadlocked when two threads that share the same instance of an ActiveMQSessionExecutor are run.  \n\nThis snippet from a backtrace shows the case:\n\n{noformat}\nThread 3 (Thread 1094732688 (LWP 15620)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813a0, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\nThread 2 (Thread 1098935184 (LWP 15621)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0\n#2  0x4056c327 in apr_thread_cond_wait (cond=0x86813d8, mutex=0x40912ae8) at locks/unix/thread_cond.c:68\n#3  0x4031e458 in decaf::util::concurrent::Mutex::wait (this=0x409030c0, millisecs=4294967295) at decaf/util/concurrent/Mutex.cpp:116\n#4  0x4031e13e in decaf::util::concurrent::Mutex::wait (this=0x409030c0) at decaf/util/concurrent/Mutex.cpp:82\n#5  0x40238268 in activemq::core::ActiveMQSessionExecutor::run (this=0x409030a8) at activemq/core/ActiveMQSessionExecutor.cpp:222\n#6  0x4030589f in decaf::lang::Thread::runCallback (self=0x858f488, param=0x40902f08) at decaf/lang/Thread.cpp:121\n#7  0x4057aa1c in dummy_worker (opaque=0x858f488) at threadproc/unix/thread.c:142\n#8  0x005a846b in start_thread () from /lib/libpthread.so.0\n#9  0x004ffdbe in clone () from /lib/libc.so.6\n\n{noformat}\n\nComments:\n", "classification": "Classify the issue 'CmsTemplate testBasics test can hang' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-205?\nA: Running the CmsTemplate integration tests in a loop can result in a hang.  The code appears to be deadlocked when two threads that share the same instance of an ActiveMQSessionExecutor are run.  \n\nThis snippet from a backtrace shows the case:\n\n{noformat}\nThread 3 (Thread 1094732688 (LWP 15620)):\n#0  0x40000402 in __kernel_vsyscall ()\n#1  0x005ac266 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/li"}}
{"issue_key": "AMQCPP-204", "project": "AMQCPP", "title": "Add the ability to package the ActiveMQ-CPP Project for distribution.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-11-05T00:12:18.000+0000", "updated": "2012-11-28T22:01:35.000+0000", "description": "Add the tooling needed to package the library for release to various OS packaging sites.\n\nRPM, DEB, PKG, etc.", "comments": [], "text": "Add the ability to package the ActiveMQ-CPP Project for distribution.\n\nDescription:\nAdd the tooling needed to package the library for release to various OS packaging sites.\n\nRPM, DEB, PKG, etc.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add the ability to package the ActiveMQ-CPP Project for distribution.\n\nDescription:\nAdd the tooling needed to package the library for release to various OS packaging sites.\n\nRPM, DEB, PKG, etc.\n\nComments:\n", "classification": "Classify the issue 'Add the ability to package the ActiveMQ-CPP Project for distribution.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-204?\nA: Add the tooling needed to package the library for release to various OS packaging sites.\n\nRPM, DEB, PKG, etc."}}
{"issue_key": "AMQCPP-203", "project": "AMQCPP", "title": "Segmentation Fault in Integration tests occurs occasionally.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-11-03T14:09:10.000+0000", "updated": "2008-11-12T15:44:51.000+0000", "description": "While running the integration tests in a long loop an occasional Segmentation fault has been seen.", "comments": [], "text": "Segmentation Fault in Integration tests occurs occasionally.\n\nDescription:\nWhile running the integration tests in a long loop an occasional Segmentation fault has been seen. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation Fault in Integration tests occurs occasionally.\n\nDescription:\nWhile running the integration tests in a long loop an occasional Segmentation fault has been seen. \n\nComments:\n", "classification": "Classify the issue 'Segmentation Fault in Integration tests occurs occasionally.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-203?\nA: While running the integration tests in a long loop an occasional Segmentation fault has been seen. "}}
{"issue_key": "AMQCPP-202", "project": "AMQCPP", "title": "Occasional Deadlocks when Integration tests are run in a long loop on CentOS and REHL.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-11-03T14:07:30.000+0000", "updated": "2008-11-12T15:44:21.000+0000", "description": "When run in a continuous loop the integration tests have been seen to deadlock.", "comments": [], "text": "Occasional Deadlocks when Integration tests are run in a long loop on CentOS and REHL.\n\nDescription:\nWhen run in a continuous loop the integration tests have been seen to deadlock.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Occasional Deadlocks when Integration tests are run in a long loop on CentOS and REHL.\n\nDescription:\nWhen run in a continuous loop the integration tests have been seen to deadlock.\n\nComments:\n", "classification": "Classify the issue 'Occasional Deadlocks when Integration tests are run in a long loop on CentOS and REHL.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-202?\nA: When run in a continuous loop the integration tests have been seen to deadlock."}}
{"issue_key": "AMQCPP-201", "project": "AMQCPP", "title": "My C++ ActiveMQ client can produce messages, but not consume them", "status": "Closed", "reporter": "Joe Crotchett", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-10-29T20:19:33.000+0000", "updated": "2008-10-30T19:52:52.000+0000", "description": "I have the ActiveMQ-CPP 2.2.1 Visual Studio 2005 project compiling and running the example and unit tests. In the console window, it shows the messages are being sent, though they're not being received.\n\nI can both produce and consume messages with my ActiveMQ-CPP 2.0.1 program, but not 2.2.1. I'm new to ActiveMQ and don't even know where to begin troubleshooting. Any thoughts/suggestions/good place to start would be a great help.\n\nJoe", "comments": [], "text": "My C++ ActiveMQ client can produce messages, but not consume them\n\nDescription:\nI have the ActiveMQ-CPP 2.2.1 Visual Studio 2005 project compiling and running the example and unit tests. In the console window, it shows the messages are being sent, though they're not being received.\n\nI can both produce and consume messages with my ActiveMQ-CPP 2.0.1 program, but not 2.2.1. I'm new to ActiveMQ and don't even know where to begin troubleshooting. Any thoughts/suggestions/good place to start would be a great help.\n\nJoe\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: My C++ ActiveMQ client can produce messages, but not consume them\n\nDescription:\nI have the ActiveMQ-CPP 2.2.1 Visual Studio 2005 project compiling and running the example and unit tests. In the console window, it shows the messages are being sent, though they're not being received.\n\nI can both produce and consume messages with my ActiveMQ-CPP 2.0.1 program, but not 2.2.1. I'm new to ActiveMQ and don't even know where to begin troubleshooting. Any thoughts/suggestions/good place to start would be a great help.\n\nJoe\n\nComments:\n", "classification": "Classify the issue 'My C++ ActiveMQ client can produce messages, but not consume them' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-201?\nA: I have the ActiveMQ-CPP 2.2.1 Visual Studio 2005 project compiling and running the example and unit tests. In the console window, it shows the messages are being sent, though they're not being received.\n\nI can both produce and consume messages with my ActiveMQ-CPP 2.0.1 program, but not 2.2.1. I'm new to ActiveMQ and don't even know where to begin troubleshooting. Any thoughts/suggestions/good pla"}}
{"issue_key": "AMQCPP-200", "project": "AMQCPP", "title": "activemq-cpp-2.2.1 test fails for decaf::io::ByteArrayInputStreamTest::testConstructor (segmentation fault)", "status": "Resolved", "reporter": "Alexander Martens", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-10-05T10:24:18.000+0000", "updated": "2008-11-12T15:45:14.000+0000", "description": "This unit test seems to fail.\nI send you attached a gdb postmortem log (bt, bt full, info threads). \nThanks!", "comments": [], "text": "activemq-cpp-2.2.1 test fails for decaf::io::ByteArrayInputStreamTest::testConstructor (segmentation fault)\n\nDescription:\nThis unit test seems to fail.\nI send you attached a gdb postmortem log (bt, bt full, info threads). \nThanks!\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq-cpp-2.2.1 test fails for decaf::io::ByteArrayInputStreamTest::testConstructor (segmentation fault)\n\nDescription:\nThis unit test seems to fail.\nI send you attached a gdb postmortem log (bt, bt full, info threads). \nThanks!\n\n\nComments:\n", "classification": "Classify the issue 'activemq-cpp-2.2.1 test fails for decaf::io::ByteArrayInputStreamTest::testConstructor (segmentation fault)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-200?\nA: This unit test seems to fail.\nI send you attached a gdb postmortem log (bt, bt full, info threads). \nThanks!\n"}}
{"issue_key": "AMQCPP-199", "project": "AMQCPP", "title": "Segmentation fault at decaf/net/SocketInputStream.cpp (line 108)", "status": "Resolved", "reporter": "Alexander Martens", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-10-05T08:49:16.000+0000", "updated": "2008-11-18T14:28:47.000+0000", "description": "We're getting occasional segmentation faults in our Python based application.\nThe easiest way to reproduce it is by running pyactivemq's stress tests (src/tests/stresstest.py).\nThe offending line seems to be always the same.\nI send you attached a full gdb postmortem back-trace.\nAny help will be appreciated!", "comments": [], "text": "Segmentation fault at decaf/net/SocketInputStream.cpp (line 108)\n\nDescription:\nWe're getting occasional segmentation faults in our Python based application.\nThe easiest way to reproduce it is by running pyactivemq's stress tests (src/tests/stresstest.py).\nThe offending line seems to be always the same.\nI send you attached a full gdb postmortem back-trace.\nAny help will be appreciated!\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation fault at decaf/net/SocketInputStream.cpp (line 108)\n\nDescription:\nWe're getting occasional segmentation faults in our Python based application.\nThe easiest way to reproduce it is by running pyactivemq's stress tests (src/tests/stresstest.py).\nThe offending line seems to be always the same.\nI send you attached a full gdb postmortem back-trace.\nAny help will be appreciated!\n\n\nComments:\n", "classification": "Classify the issue 'Segmentation fault at decaf/net/SocketInputStream.cpp (line 108)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-199?\nA: We're getting occasional segmentation faults in our Python based application.\nThe easiest way to reproduce it is by running pyactivemq's stress tests (src/tests/stresstest.py).\nThe offending line seems to be always the same.\nI send you attached a full gdb postmortem back-trace.\nAny help will be appreciated!\n"}}
{"issue_key": "AMQCPP-198", "project": "AMQCPP", "title": "File activemq/exceptions/ActiveMQException.h isn't installed during make install", "status": "Resolved", "reporter": "Alexey Parshin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-10-03T01:15:52.000+0000", "updated": "2008-10-03T10:44:55.000+0000", "description": "Compiling a project right after upgrade from ActiveMQCPP-2.2 gives the following error:\n\n/usr/local/include/activemq-cpp-2.2.1/activemq/exceptions/ActiveMQException.h:23:50: error: activemq/exceptions/ExceptionDefines.h: No such file or directory\n\nThe file is missing in the location above. Copiing the file from the source directory to that location fixes the problem.", "comments": [], "text": "File activemq/exceptions/ActiveMQException.h isn't installed during make install\n\nDescription:\nCompiling a project right after upgrade from ActiveMQCPP-2.2 gives the following error:\n\n/usr/local/include/activemq-cpp-2.2.1/activemq/exceptions/ActiveMQException.h:23:50: error: activemq/exceptions/ExceptionDefines.h: No such file or directory\n\nThe file is missing in the location above. Copiing the file from the source directory to that location fixes the problem.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: File activemq/exceptions/ActiveMQException.h isn't installed during make install\n\nDescription:\nCompiling a project right after upgrade from ActiveMQCPP-2.2 gives the following error:\n\n/usr/local/include/activemq-cpp-2.2.1/activemq/exceptions/ActiveMQException.h:23:50: error: activemq/exceptions/ExceptionDefines.h: No such file or directory\n\nThe file is missing in the location above. Copiing the file from the source directory to that location fixes the problem.\n\nComments:\n", "classification": "Classify the issue 'File activemq/exceptions/ActiveMQException.h isn't installed during make install' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-198?\nA: Compiling a project right after upgrade from ActiveMQCPP-2.2 gives the following error:\n\n/usr/local/include/activemq-cpp-2.2.1/activemq/exceptions/ActiveMQException.h:23:50: error: activemq/exceptions/ExceptionDefines.h: No such file or directory\n\nThe file is missing in the location above. Copiing the file from the source directory to that location fixes the problem."}}
{"issue_key": "AMQCPP-197", "project": "AMQCPP", "title": "include file activemq/exceptions/ExceptionDefines.h missing", "status": "Resolved", "reporter": "Marc SchrÃ¶der", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2008-09-15T08:38:55.000+0000", "updated": "2008-09-15T12:06:56.000+0000", "description": "The include files for ActiveMQ-CPP list activemq/exceptions/ActiveMQException.h, which includes activemq/exceptions/ExceptionDefines.h; however, activemq/exceptions/ExceptionDefines.h is not included.\n\nThe trivial workaround is to copy src/main/activemq/exceptions/ExceptionDefines.h into includes/activemq-cpp-2.2.1/.\n\nProbably a fix is to add activemq/exceptions/ExceptionDefines.h to src/main/Makefile.am", "comments": [], "text": "include file activemq/exceptions/ExceptionDefines.h missing\n\nDescription:\nThe include files for ActiveMQ-CPP list activemq/exceptions/ActiveMQException.h, which includes activemq/exceptions/ExceptionDefines.h; however, activemq/exceptions/ExceptionDefines.h is not included.\n\nThe trivial workaround is to copy src/main/activemq/exceptions/ExceptionDefines.h into includes/activemq-cpp-2.2.1/.\n\nProbably a fix is to add activemq/exceptions/ExceptionDefines.h to src/main/Makefile.am\n\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: include file activemq/exceptions/ExceptionDefines.h missing\n\nDescription:\nThe include files for ActiveMQ-CPP list activemq/exceptions/ActiveMQException.h, which includes activemq/exceptions/ExceptionDefines.h; however, activemq/exceptions/ExceptionDefines.h is not included.\n\nThe trivial workaround is to copy src/main/activemq/exceptions/ExceptionDefines.h into includes/activemq-cpp-2.2.1/.\n\nProbably a fix is to add activemq/exceptions/ExceptionDefines.h to src/main/Makefile.am\n\n\n\n\nComments:\n", "classification": "Classify the issue 'include file activemq/exceptions/ExceptionDefines.h missing' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-197?\nA: The include files for ActiveMQ-CPP list activemq/exceptions/ActiveMQException.h, which includes activemq/exceptions/ExceptionDefines.h; however, activemq/exceptions/ExceptionDefines.h is not included.\n\nThe trivial workaround is to copy src/main/activemq/exceptions/ExceptionDefines.h into includes/activemq-cpp-2.2.1/.\n\nProbably a fix is to add activemq/exceptions/ExceptionDefines.h to src/main/Make"}}
{"issue_key": "AMQCPP-196", "project": "AMQCPP", "title": "Make the openwire connecter handle sending messages sync or async based on rules and settings", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-08-30T18:42:25.000+0000", "updated": "2008-11-17T21:52:10.000+0000", "description": "The only messages that really require a synchronous send are persistant messages not in a transaction, so we should send the rest asynchronously.  We should support flags for forcing always sync sends and also forcing async sends of persistant messages not in a transaction as well. \n\nWe will need to also start monitoring the producer window size since messages will be going out async.  This means we needs to somehow get close to the message sizes that the broker will be returning in the ProducerAck message.  This will allow use to use better producer flow control for async sends.  \n\nCurrently all our sends are sync so we just depend on the broker for flow control, stalling on a send if a timeout is not set.\n\nThis should result in a net performance increase for message that don't need to be sent synchronously.", "comments": [], "text": "Make the openwire connecter handle sending messages sync or async based on rules and settings\n\nDescription:\nThe only messages that really require a synchronous send are persistant messages not in a transaction, so we should send the rest asynchronously.  We should support flags for forcing always sync sends and also forcing async sends of persistant messages not in a transaction as well. \n\nWe will need to also start monitoring the producer window size since messages will be going out async.  This means we needs to somehow get close to the message sizes that the broker will be returning in the ProducerAck message.  This will allow use to use better producer flow control for async sends.  \n\nCurrently all our sends are sync so we just depend on the broker for flow control, stalling on a send if a timeout is not set.\n\nThis should result in a net performance increase for message that don't need to be sent synchronously.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Make the openwire connecter handle sending messages sync or async based on rules and settings\n\nDescription:\nThe only messages that really require a synchronous send are persistant messages not in a transaction, so we should send the rest asynchronously.  We should support flags for forcing always sync sends and also forcing async sends of persistant messages not in a transaction as well. \n\nWe will need to also start monitoring the producer window size since messages will be going out async.  This means we needs to somehow get close to the message sizes that the broker will be returning in the ProducerAck message.  This will allow use to use better producer flow control for async sends.  \n\nCurrently all our sends are sync so we just depend on the broker for flow control, stalling on a send if a timeout is not set.\n\nThis should result in a net performance increase for message that don't need to be sent synchronously.\n\nComments:\n", "classification": "Classify the issue 'Make the openwire connecter handle sending messages sync or async based on rules and settings' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-196?\nA: The only messages that really require a synchronous send are persistant messages not in a transaction, so we should send the rest asynchronously.  We should support flags for forcing always sync sends and also forcing async sends of persistant messages not in a transaction as well. \n\nWe will need to also start monitoring the producer window size since messages will be going out async.  This means "}}
{"issue_key": "AMQCPP-195", "project": "AMQCPP", "title": "Message stuck in queue when using transactional sessions", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-08-22T15:26:54.000+0000", "updated": "2008-08-24T19:58:16.000+0000", "description": "Here is what I have now done.\n\nI used Examples/Producers/SimpleProducer.cpp to put 2000 messages onto the\nqueue TEST.FOO.\n\nI then ran up Examples/Consumers/SimpleAsyncConsumer.cpp in it's default\nautoack mode and it consumed all 2000 messages off the queue.\n\nI then modified it and made the following changes:\n\nIn RunConsumer\n\n            // Create a Session\n/*\n            if( clientAck ) {\n                session = connection->createSession(\nSession::CLIENT_ACKNOWLEDGE );\n            } else {\n                session = connection->createSession(\nSession::AUTO_ACKNOWLEDGE );\n            }\n*/\n            session = connection->createSession( Session::SESSION_TRANSACTED\n);\n\nThis will force the session to be transactional\n\nThen in onMessage\n\n/*\n            if( clientAck ) {\n                message->acknowledge();\n            }\n*/\n            this->session->commit();\n\nWhen I then run the example - if looks like the messages are processed\nnormally but message #1 is left on the queue.  \n\nIf I run the exe a second time it outputs message #1 to standard out but\nlooking at the queue in jconsole the message is still there.\n\nI can keep running the exe over and over and it outputs message#1 to stdout\nbut never removes it off the queue.  This is the situation I'm seeing in my\nown project.\n\nFor completeness I went back to autoack and the message was consumed and\nremoved from the queue.", "comments": [], "text": "Message stuck in queue when using transactional sessions\n\nDescription:\nHere is what I have now done.\n\nI used Examples/Producers/SimpleProducer.cpp to put 2000 messages onto the\nqueue TEST.FOO.\n\nI then ran up Examples/Consumers/SimpleAsyncConsumer.cpp in it's default\nautoack mode and it consumed all 2000 messages off the queue.\n\nI then modified it and made the following changes:\n\nIn RunConsumer\n\n            // Create a Session\n/*\n            if( clientAck ) {\n                session = connection->createSession(\nSession::CLIENT_ACKNOWLEDGE );\n            } else {\n                session = connection->createSession(\nSession::AUTO_ACKNOWLEDGE );\n            }\n*/\n            session = connection->createSession( Session::SESSION_TRANSACTED\n);\n\nThis will force the session to be transactional\n\nThen in onMessage\n\n/*\n            if( clientAck ) {\n                message->acknowledge();\n            }\n*/\n            this->session->commit();\n\nWhen I then run the example - if looks like the messages are processed\nnormally but message #1 is left on the queue.  \n\nIf I run the exe a second time it outputs message #1 to standard out but\nlooking at the queue in jconsole the message is still there.\n\nI can keep running the exe over and over and it outputs message#1 to stdout\nbut never removes it off the queue.  This is the situation I'm seeing in my\nown project.\n\nFor completeness I went back to autoack and the message was consumed and\nremoved from the queue.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Message stuck in queue when using transactional sessions\n\nDescription:\nHere is what I have now done.\n\nI used Examples/Producers/SimpleProducer.cpp to put 2000 messages onto the\nqueue TEST.FOO.\n\nI then ran up Examples/Consumers/SimpleAsyncConsumer.cpp in it's default\nautoack mode and it consumed all 2000 messages off the queue.\n\nI then modified it and made the following changes:\n\nIn RunConsumer\n\n            // Create a Session\n/*\n            if( clientAck ) {\n                session = connection->createSession(\nSession::CLIENT_ACKNOWLEDGE );\n            } else {\n                session = connection->createSession(\nSession::AUTO_ACKNOWLEDGE );\n            }\n*/\n            session = connection->createSession( Session::SESSION_TRANSACTED\n);\n\nThis will force the session to be transactional\n\nThen in onMessage\n\n/*\n            if( clientAck ) {\n                message->acknowledge();\n            }\n*/\n            this->session->commit();\n\nWhen I then run the example - if looks like the messages are processed\nnormally but message #1 is left on the queue.  \n\nIf I run the exe a second time it outputs message #1 to standard out but\nlooking at the queue in jconsole the message is still there.\n\nI can keep running the exe over and over and it outputs message#1 to stdout\nbut never removes it off the queue.  This is the situation I'm seeing in my\nown project.\n\nFor completeness I went back to autoack and the message was consumed and\nremoved from the queue.\n\nComments:\n", "classification": "Classify the issue 'Message stuck in queue when using transactional sessions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-195?\nA: Here is what I have now done.\n\nI used Examples/Producers/SimpleProducer.cpp to put 2000 messages onto the\nqueue TEST.FOO.\n\nI then ran up Examples/Consumers/SimpleAsyncConsumer.cpp in it's default\nautoack mode and it consumed all 2000 messages off the queue.\n\nI then modified it and made the following changes:\n\nIn RunConsumer\n\n            // Create a Session\n/*\n            if( clientAck ) {\n        "}}
{"issue_key": "AMQCPP-194", "project": "AMQCPP", "title": "Potential Deadlock in OpenwireConnector on exception from transport", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-08-19T11:01:32.000+0000", "updated": "2008-08-19T11:02:53.000+0000", "description": "Mutex in onTransportException can lead to deadlock.", "comments": [], "text": "Potential Deadlock in OpenwireConnector on exception from transport\n\nDescription:\nMutex in onTransportException can lead to deadlock.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Potential Deadlock in OpenwireConnector on exception from transport\n\nDescription:\nMutex in onTransportException can lead to deadlock.  \n\nComments:\n", "classification": "Classify the issue 'Potential Deadlock in OpenwireConnector on exception from transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-194?\nA: Mutex in onTransportException can lead to deadlock.  "}}
{"issue_key": "AMQCPP-193", "project": "AMQCPP", "title": "If activeMQ blocks due to reaching memory limit during a transaction, the last message sent is posted to the queue after the rollback occurs and persists", "status": "Closed", "reporter": "Brian Roach", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-08-18T07:22:58.000+0000", "updated": "2009-01-07T16:31:54.000+0000", "description": "If you send a large number of messages inside a transaction, and ActiveMQ runs out of memory, cms::MessageProducer::send() throws an exception (as it should).\n\nThe exception text is: No valid response received for command\n\nThe problem is ... the last message sent (the one that caused the exception to be thrown) gets added to the queue while the others are rolled back. This is a large problem, as the whole point of transactions is to avoid this sort of thing.\n\nTo summarize:\n- Start sending messages with the session set to SESSION_TRANSACTED\n- Fill ActiveMQ memory\n- Receive exception\n- The last message sent will be in the queue. All other messages will be rolled back.\n\nHere's what the debug log looks like:\nDEBUG Usage                          - Memory usage change.  from: 2, to: 1\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:109, at: offset = 4527877, file = 6, size = 47444, type = 1\nDEBUG Usage                          - Memory usage change.  from: 1, to: 0\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:110, at: offset = 4575321, file = 6, size = 47439, type = 1\nDEBUG TransportConnection            - Connection Stopped: /127.0.0.1:44382\nDEBUG AMQMessageStore                - Journalled message add for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:111, at: offset = 4622760, file = 6, size = 47442, type = 1\n\nAs you can see, it adds a message to the queue after the rollback and after stopping the connection.\n\nAttached is C++ that will demonstrate the problem.", "comments": [], "text": "If activeMQ blocks due to reaching memory limit during a transaction, the last message sent is posted to the queue after the rollback occurs and persists\n\nDescription:\nIf you send a large number of messages inside a transaction, and ActiveMQ runs out of memory, cms::MessageProducer::send() throws an exception (as it should).\n\nThe exception text is: No valid response received for command\n\nThe problem is ... the last message sent (the one that caused the exception to be thrown) gets added to the queue while the others are rolled back. This is a large problem, as the whole point of transactions is to avoid this sort of thing.\n\nTo summarize:\n- Start sending messages with the session set to SESSION_TRANSACTED\n- Fill ActiveMQ memory\n- Receive exception\n- The last message sent will be in the queue. All other messages will be rolled back.\n\nHere's what the debug log looks like:\nDEBUG Usage                          - Memory usage change.  from: 2, to: 1\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:109, at: offset = 4527877, file = 6, size = 47444, type = 1\nDEBUG Usage                          - Memory usage change.  from: 1, to: 0\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:110, at: offset = 4575321, file = 6, size = 47439, type = 1\nDEBUG TransportConnection            - Connection Stopped: /127.0.0.1:44382\nDEBUG AMQMessageStore                - Journalled message add for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:111, at: offset = 4622760, file = 6, size = 47442, type = 1\n\nAs you can see, it adds a message to the queue after the rollback and after stopping the connection.\n\nAttached is C++ that will demonstrate the problem.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: If activeMQ blocks due to reaching memory limit during a transaction, the last message sent is posted to the queue after the rollback occurs and persists\n\nDescription:\nIf you send a large number of messages inside a transaction, and ActiveMQ runs out of memory, cms::MessageProducer::send() throws an exception (as it should).\n\nThe exception text is: No valid response received for command\n\nThe problem is ... the last message sent (the one that caused the exception to be thrown) gets added to the queue while the others are rolled back. This is a large problem, as the whole point of transactions is to avoid this sort of thing.\n\nTo summarize:\n- Start sending messages with the session set to SESSION_TRANSACTED\n- Fill ActiveMQ memory\n- Receive exception\n- The last message sent will be in the queue. All other messages will be rolled back.\n\nHere's what the debug log looks like:\nDEBUG Usage                          - Memory usage change.  from: 2, to: 1\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:109, at: offset = 4527877, file = 6, size = 47444, type = 1\nDEBUG Usage                          - Memory usage change.  from: 1, to: 0\nDEBUG AMQMessageStore                - Transacted message add rollback for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:110, at: offset = 4575321, file = 6, size = 47439, type = 1\nDEBUG TransportConnection            - Connection Stopped: /127.0.0.1:44382\nDEBUG AMQMessageStore                - Journalled message add for: 68445488-66bc-c258-0d30-4a1faede93a5:0:1:111, at: offset = 4622760, file = 6, size = 47442, type = 1\n\nAs you can see, it adds a message to the queue after the rollback and after stopping the connection.\n\nAttached is C++ that will demonstrate the problem.\n\nComments:\n", "classification": "Classify the issue 'If activeMQ blocks due to reaching memory limit during a transaction, the last message sent is posted to the queue after the rollback occurs and persists' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-193?\nA: If you send a large number of messages inside a transaction, and ActiveMQ runs out of memory, cms::MessageProducer::send() throws an exception (as it should).\n\nThe exception text is: No valid response received for command\n\nThe problem is ... the last message sent (the one that caused the exception to be thrown) gets added to the queue while the others are rolled back. This is a large problem, as t"}}
{"issue_key": "AMQCPP-192", "project": "AMQCPP", "title": "Add getCause to the CMS and Decaf exception interfaces", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-08-16T19:24:48.000+0000", "updated": "2008-08-23T14:08:59.000+0000", "description": "Since the ActiveMQ-CPP code node only throws exceptions of type ActiveMQException out of the client code the user can no longer cast the exceptions to a type on the Decaf hierarchy.  Adding a getCause method to the exception interfaces would allow us to carry only the decaf exceptions, we would return them as std::exception's since CMS and Decaf's exception classes both inherit from std::exception.", "comments": [], "text": "Add getCause to the CMS and Decaf exception interfaces\n\nDescription:\nSince the ActiveMQ-CPP code node only throws exceptions of type ActiveMQException out of the client code the user can no longer cast the exceptions to a type on the Decaf hierarchy.  Adding a getCause method to the exception interfaces would allow us to carry only the decaf exceptions, we would return them as std::exception's since CMS and Decaf's exception classes both inherit from std::exception.  \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add getCause to the CMS and Decaf exception interfaces\n\nDescription:\nSince the ActiveMQ-CPP code node only throws exceptions of type ActiveMQException out of the client code the user can no longer cast the exceptions to a type on the Decaf hierarchy.  Adding a getCause method to the exception interfaces would allow us to carry only the decaf exceptions, we would return them as std::exception's since CMS and Decaf's exception classes both inherit from std::exception.  \n\n\n\nComments:\n", "classification": "Classify the issue 'Add getCause to the CMS and Decaf exception interfaces' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-192?\nA: Since the ActiveMQ-CPP code node only throws exceptions of type ActiveMQException out of the client code the user can no longer cast the exceptions to a type on the Decaf hierarchy.  Adding a getCause method to the exception interfaces would allow us to carry only the decaf exceptions, we would return them as std::exception's since CMS and Decaf's exception classes both inherit from std::exception"}}
{"issue_key": "AMQCPP-191", "project": "AMQCPP", "title": "autogen.sh fails to create configure : doxygen-related", "status": "Resolved", "reporter": "Alexey Parshin", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-08-15T03:02:16.000+0000", "updated": "2009-01-29T16:47:37.000+0000", "description": "@squirrel ~/activemq-cpp-2.2 $ ./autogen.sh\nconfigure.ac:202: error: AC_SUBST: `DX_FLAG_[]DX_CURRENT_FEATURE' is not a valid shell variable name\nm4/ac_doxygen.m4:89: DX_REQUIRE_PROG is expanded from...\nm4/ac_doxygen.m4:129: DX_ARG_ABLE is expanded from...\nm4/ac_doxygen.m4:190: DX_INIT_DOXYGEN is expanded from...\nconfigure.ac:202: the top level\nautom4te-2.62: /usr/bin/m4 failed with exit status: 1\naclocal-1.10: autom4te failed with exit status: 1\nautoreconf-2.62: aclocal failed with exit status: 1", "comments": [], "text": "autogen.sh fails to create configure : doxygen-related\n\nDescription:\n@squirrel ~/activemq-cpp-2.2 $ ./autogen.sh\nconfigure.ac:202: error: AC_SUBST: `DX_FLAG_[]DX_CURRENT_FEATURE' is not a valid shell variable name\nm4/ac_doxygen.m4:89: DX_REQUIRE_PROG is expanded from...\nm4/ac_doxygen.m4:129: DX_ARG_ABLE is expanded from...\nm4/ac_doxygen.m4:190: DX_INIT_DOXYGEN is expanded from...\nconfigure.ac:202: the top level\nautom4te-2.62: /usr/bin/m4 failed with exit status: 1\naclocal-1.10: autom4te failed with exit status: 1\nautoreconf-2.62: aclocal failed with exit status: 1\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: autogen.sh fails to create configure : doxygen-related\n\nDescription:\n@squirrel ~/activemq-cpp-2.2 $ ./autogen.sh\nconfigure.ac:202: error: AC_SUBST: `DX_FLAG_[]DX_CURRENT_FEATURE' is not a valid shell variable name\nm4/ac_doxygen.m4:89: DX_REQUIRE_PROG is expanded from...\nm4/ac_doxygen.m4:129: DX_ARG_ABLE is expanded from...\nm4/ac_doxygen.m4:190: DX_INIT_DOXYGEN is expanded from...\nconfigure.ac:202: the top level\nautom4te-2.62: /usr/bin/m4 failed with exit status: 1\naclocal-1.10: autom4te failed with exit status: 1\nautoreconf-2.62: aclocal failed with exit status: 1\n\n\nComments:\n", "classification": "Classify the issue 'autogen.sh fails to create configure : doxygen-related' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-191?\nA: @squirrel ~/activemq-cpp-2.2 $ ./autogen.sh\nconfigure.ac:202: error: AC_SUBST: `DX_FLAG_[]DX_CURRENT_FEATURE' is not a valid shell variable name\nm4/ac_doxygen.m4:89: DX_REQUIRE_PROG is expanded from...\nm4/ac_doxygen.m4:129: DX_ARG_ABLE is expanded from...\nm4/ac_doxygen.m4:190: DX_INIT_DOXYGEN is expanded from...\nconfigure.ac:202: the top level\nautom4te-2.62: /usr/bin/m4 failed with exit status: 1\n"}}
{"issue_key": "AMQCPP-190", "project": "AMQCPP", "title": "setStringProperty() max length", "status": "Resolved", "reporter": "Eddie Fast", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-07-30T22:38:04.000+0000", "updated": "2008-08-23T14:42:38.000+0000", "description": "Initially reported here  http://www.nabble.com/CMS---setStringProperty%28%29-max-length-td18577838.html\n\nUsing main.cpp in \\activemq-cpp-2.1\\src\\examples\\  to reproduce the issue:\n\nIf I set the text in the TextMessage to something very large (I was successful at even 2meg), the message sends / receives fine.\n\nHowever, if I set a StringProperty on that message to something large (I hit a limit at 32800, probably 32767?), then it crashes.\n\nShould be simple to re-create.  I've attached the modified main.cpp  (see HelloWorldProducer::run() )\n\n\nShould the max TextMessage size apply to StringProperties as well?  Or do they have different behavior?\n\n\nHere's the output from my exception:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQTopic\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQTopic\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 0\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217456902624\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 154\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 1371\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 848\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108", "comments": [], "text": "setStringProperty() max length\n\nDescription:\nInitially reported here  http://www.nabble.com/CMS---setStringProperty%28%29-max-length-td18577838.html\n\nUsing main.cpp in \\activemq-cpp-2.1\\src\\examples\\  to reproduce the issue:\n\nIf I set the text in the TextMessage to something very large (I was successful at even 2meg), the message sends / receives fine.\n\nHowever, if I set a StringProperty on that message to something large (I hit a limit at 32800, probably 32767?), then it crashes.\n\nShould be simple to re-create.  I've attached the modified main.cpp  (see HelloWorldProducer::run() )\n\n\nShould the max TextMessage size apply to StringProperties as well?  Or do they have different behavior?\n\n\nHere's the output from my exception:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQTopic\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQTopic\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 0\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217456902624\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 154\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 1371\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 848\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: setStringProperty() max length\n\nDescription:\nInitially reported here  http://www.nabble.com/CMS---setStringProperty%28%29-max-length-td18577838.html\n\nUsing main.cpp in \\activemq-cpp-2.1\\src\\examples\\  to reproduce the issue:\n\nIf I set the text in the TextMessage to something very large (I was successful at even 2meg), the message sends / receives fine.\n\nHowever, if I set a StringProperty on that message to something large (I hit a limit at 32800, probably 32767?), then it crashes.\n\nShould be simple to re-create.  I've attached the modified main.cpp  (see HelloWorldProducer::run() )\n\n\nShould the max TextMessage size apply to StringProperties as well?  Or do they have different behavior?\n\n\nHere's the output from my exception:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQTopic\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQTopic\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 8b866eb2-5954-42e7-9820-6d87383b1433\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 0\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217456902624\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 154\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 1371\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenwireConnector.cpp, LINE: 848\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n\n\nComments:\n", "classification": "Classify the issue 'setStringProperty() max length' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-190?\nA: Initially reported here  http://www.nabble.com/CMS---setStringProperty%28%29-max-length-td18577838.html\n\nUsing main.cpp in \\activemq-cpp-2.1\\src\\examples\\  to reproduce the issue:\n\nIf I set the text in the TextMessage to something very large (I was successful at even 2meg), the message sends / receives fine.\n\nHowever, if I set a StringProperty on that message to something large (I hit a limit at 3"}}
{"issue_key": "AMQCPP-189", "project": "AMQCPP", "title": "the message producer core dump during sending lots of  messages", "status": "Resolved", "reporter": "dj", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2008-07-30T02:47:57.000+0000", "updated": "2008-08-24T20:00:27.000+0000", "description": "i set up the 5.1 broker on 192.168.10.64:61616, then i edit the example file (SimpleProducer.cpp)\nchanged the numMessages from 2000 to 10000,  after that i made the executable target and i run it.\nbut the program always core dump when it sent 4846 messages, it seems to send 4846 messages at most!\ni didn't run message consumer during the period\n\n\n std::string brokerURI =\n        \"tcp://192.168.10.64:61616\"\n        \"?wireFormat=openwire\"\n        \"&transport.useAsyncSend=true\"\n//        \"&transport.commandTracingEnabled=true\"\n//        \"&transport.tcpTracingEnabled=true\";\n        \"&wireFormat.tightEncodingEnabled=true\";\n\n    //============================================================\n    // Total number of messages for this producer to send.\n    //============================================================\n    unsigned int numMessages = 10000;\n\n    //============================================================\n    // This is the Destination Name and URI options.  Use this to\n    // customize where the Producer produces, to have the producer\n    // use a topic or queue set the 'useTopics' flag.\n    //============================================================\n    std::string destURI = \"mm.mq\";\n\n-----------------------------------------------------------------------------------------------------------------------------------------\n\n\ncore dump description below:\n...\nSent message #4847 from thread -1208858928\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 4846\nEnd Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = mm.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 4846\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217384921228\n Value of Type = \n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 151\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 159\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 106\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 866\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 670\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 190\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 145\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 105\n-----------------------------------------------------\nFinished with the example.", "comments": [], "text": "the message producer core dump during sending lots of  messages\n\nDescription:\ni set up the 5.1 broker on 192.168.10.64:61616, then i edit the example file (SimpleProducer.cpp)\nchanged the numMessages from 2000 to 10000,  after that i made the executable target and i run it.\nbut the program always core dump when it sent 4846 messages, it seems to send 4846 messages at most!\ni didn't run message consumer during the period\n\n\n std::string brokerURI =\n        \"tcp://192.168.10.64:61616\"\n        \"?wireFormat=openwire\"\n        \"&transport.useAsyncSend=true\"\n//        \"&transport.commandTracingEnabled=true\"\n//        \"&transport.tcpTracingEnabled=true\";\n        \"&wireFormat.tightEncodingEnabled=true\";\n\n    //============================================================\n    // Total number of messages for this producer to send.\n    //============================================================\n    unsigned int numMessages = 10000;\n\n    //============================================================\n    // This is the Destination Name and URI options.  Use this to\n    // customize where the Producer produces, to have the producer\n    // use a topic or queue set the 'useTopics' flag.\n    //============================================================\n    std::string destURI = \"mm.mq\";\n\n-----------------------------------------------------------------------------------------------------------------------------------------\n\n\ncore dump description below:\n...\nSent message #4847 from thread -1208858928\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 4846\nEnd Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = mm.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 4846\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217384921228\n Value of Type = \n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 151\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 159\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 106\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 866\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 670\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 190\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 145\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 105\n-----------------------------------------------------\nFinished with the example.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: the message producer core dump during sending lots of  messages\n\nDescription:\ni set up the 5.1 broker on 192.168.10.64:61616, then i edit the example file (SimpleProducer.cpp)\nchanged the numMessages from 2000 to 10000,  after that i made the executable target and i run it.\nbut the program always core dump when it sent 4846 messages, it seems to send 4846 messages at most!\ni didn't run message consumer during the period\n\n\n std::string brokerURI =\n        \"tcp://192.168.10.64:61616\"\n        \"?wireFormat=openwire\"\n        \"&transport.useAsyncSend=true\"\n//        \"&transport.commandTracingEnabled=true\"\n//        \"&transport.tcpTracingEnabled=true\";\n        \"&wireFormat.tightEncodingEnabled=true\";\n\n    //============================================================\n    // Total number of messages for this producer to send.\n    //============================================================\n    unsigned int numMessages = 10000;\n\n    //============================================================\n    // This is the Destination Name and URI options.  Use this to\n    // customize where the Producer produces, to have the producer\n    // use a topic or queue set the 'useTopics' flag.\n    //============================================================\n    std::string destURI = \"mm.mq\";\n\n-----------------------------------------------------------------------------------------------------------------------------------------\n\n\ncore dump description below:\n...\nSent message #4847 from thread -1208858928\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 4846\nEnd Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = mm.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 484e5a07-8fda-f925-266f-f7fe809c44b9\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 4846\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1217384921228\n Value of Type = \n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 151\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 159\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 106\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 866\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 670\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 190\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 145\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 105\n-----------------------------------------------------\nFinished with the example.\n\nComments:\n", "classification": "Classify the issue 'the message producer core dump during sending lots of  messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-189?\nA: i set up the 5.1 broker on 192.168.10.64:61616, then i edit the example file (SimpleProducer.cpp)\nchanged the numMessages from 2000 to 10000,  after that i made the executable target and i run it.\nbut the program always core dump when it sent 4846 messages, it seems to send 4846 messages at most!\ni didn't run message consumer during the period\n\n\n std::string brokerURI =\n        \"tcp://192.168.10.6"}}
{"issue_key": "AMQCPP-188", "project": "AMQCPP", "title": "ActiveMQ message consumer waiting for receive to complete is not closing...", "status": "Resolved", "reporter": "Rakesh", "assignee": "Nicky Sandhu", "priority": "Major", "labels": [], "created": "2008-07-10T06:31:58.000+0000", "updated": "2008-07-25T14:24:59.000+0000", "description": "I have a created an application which creates a connection and consumers using ActiveMQ C++ Client, after running the application consumer is waiting for the recive to complete. when we shutdown the application we close the connection, but close call of connection does not notify all the consumers (who is waiting for the message to be recived). \nI have seen in the close method of ActiveMQConsumer after purging all the messages there is no call to notifyAll on object unconsumedMessages because of which consumers waiting for the receive does not does not come out of the wait call, which is causing our application not to shutdown.\nwe modified the close call the notify all the consumers after purging all the unconsumed mesages and our application is working fine.\n\nFollowing is the changes that i have made in ActiveMQConsumer.cpp class\nvoid ActiveMQConsumer::close(){\n....\n....\n            // Purge all the pending messages\n            try{\n                purgeMessages();\n            } catch ( ActiveMQException& ex ){\n                if( !haveException ){\n                    ex.setMark( __FILE__, __LINE__ );\n                    error = ex;\n                    haveException = true;\n                }\n            }\n\n\n\n         //Start of additional code\n         synchronized( &unconsumedMessages )\n         {\n                unconsumedMessages.notifyAll();\n         }\n         //End of additional code\n\n....\n....\n}\n\ncan anyone let me know why this has not been done? I think this should be done. please explain if I am missing something", "comments": [], "text": "ActiveMQ message consumer waiting for receive to complete is not closing...\n\nDescription:\nI have a created an application which creates a connection and consumers using ActiveMQ C++ Client, after running the application consumer is waiting for the recive to complete. when we shutdown the application we close the connection, but close call of connection does not notify all the consumers (who is waiting for the message to be recived). \nI have seen in the close method of ActiveMQConsumer after purging all the messages there is no call to notifyAll on object unconsumedMessages because of which consumers waiting for the receive does not does not come out of the wait call, which is causing our application not to shutdown.\nwe modified the close call the notify all the consumers after purging all the unconsumed mesages and our application is working fine.\n\nFollowing is the changes that i have made in ActiveMQConsumer.cpp class\nvoid ActiveMQConsumer::close(){\n....\n....\n            // Purge all the pending messages\n            try{\n                purgeMessages();\n            } catch ( ActiveMQException& ex ){\n                if( !haveException ){\n                    ex.setMark( __FILE__, __LINE__ );\n                    error = ex;\n                    haveException = true;\n                }\n            }\n\n\n\n         //Start of additional code\n         synchronized( &unconsumedMessages )\n         {\n                unconsumedMessages.notifyAll();\n         }\n         //End of additional code\n\n....\n....\n}\n\ncan anyone let me know why this has not been done? I think this should be done. please explain if I am missing something\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ message consumer waiting for receive to complete is not closing...\n\nDescription:\nI have a created an application which creates a connection and consumers using ActiveMQ C++ Client, after running the application consumer is waiting for the recive to complete. when we shutdown the application we close the connection, but close call of connection does not notify all the consumers (who is waiting for the message to be recived). \nI have seen in the close method of ActiveMQConsumer after purging all the messages there is no call to notifyAll on object unconsumedMessages because of which consumers waiting for the receive does not does not come out of the wait call, which is causing our application not to shutdown.\nwe modified the close call the notify all the consumers after purging all the unconsumed mesages and our application is working fine.\n\nFollowing is the changes that i have made in ActiveMQConsumer.cpp class\nvoid ActiveMQConsumer::close(){\n....\n....\n            // Purge all the pending messages\n            try{\n                purgeMessages();\n            } catch ( ActiveMQException& ex ){\n                if( !haveException ){\n                    ex.setMark( __FILE__, __LINE__ );\n                    error = ex;\n                    haveException = true;\n                }\n            }\n\n\n\n         //Start of additional code\n         synchronized( &unconsumedMessages )\n         {\n                unconsumedMessages.notifyAll();\n         }\n         //End of additional code\n\n....\n....\n}\n\ncan anyone let me know why this has not been done? I think this should be done. please explain if I am missing something\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ message consumer waiting for receive to complete is not closing...' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-188?\nA: I have a created an application which creates a connection and consumers using ActiveMQ C++ Client, after running the application consumer is waiting for the recive to complete. when we shutdown the application we close the connection, but close call of connection does not notify all the consumers (who is waiting for the message to be recived). \nI have seen in the close method of ActiveMQConsumer "}}
{"issue_key": "AMQCPP-187", "project": "AMQCPP", "title": "Link error for Example", "status": "Closed", "reporter": "Amit Parikh", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-07-03T23:02:17.000+0000", "updated": "2008-07-04T14:45:27.000+0000", "description": "On running Makefile I am getting following error\n/bin/sh ../../libtool --tag=CXX --mode=link g++  -g -O2   -o example  example-main.o ../main/libactivemq-cpp.la  /usr/local/apr/lib/libapr-1.la -luuid -lrt -lcrypt  -lpthread -ldl    /usr/local/apr/lib/libaprutil-1.la   \ng++ -g -O2 -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat /usr/local/apr/lib/libaprutil-1.so /usr/local/apr/lib/libexpat.so /usr/local/apr/lib/libapr-1.so -luuid -lrt -lcrypt -lpthread -ldl  -Wl,--rpath -Wl,/usr/local/lib -Wl,--rpath -Wl,/usr/local/apr/lib\n/usr/bin/ld: cannot find -lexpat\ncollect2: ld returned 1 exit status\nmake: *** [example] Error 1\n\nEverything under src/main is correctly compiled and linked. Issue is only with linking of Example files", "comments": [], "text": "Link error for Example\n\nDescription:\nOn running Makefile I am getting following error\n/bin/sh ../../libtool --tag=CXX --mode=link g++  -g -O2   -o example  example-main.o ../main/libactivemq-cpp.la  /usr/local/apr/lib/libapr-1.la -luuid -lrt -lcrypt  -lpthread -ldl    /usr/local/apr/lib/libaprutil-1.la   \ng++ -g -O2 -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat /usr/local/apr/lib/libaprutil-1.so /usr/local/apr/lib/libexpat.so /usr/local/apr/lib/libapr-1.so -luuid -lrt -lcrypt -lpthread -ldl  -Wl,--rpath -Wl,/usr/local/lib -Wl,--rpath -Wl,/usr/local/apr/lib\n/usr/bin/ld: cannot find -lexpat\ncollect2: ld returned 1 exit status\nmake: *** [example] Error 1\n\nEverything under src/main is correctly compiled and linked. Issue is only with linking of Example files\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Link error for Example\n\nDescription:\nOn running Makefile I am getting following error\n/bin/sh ../../libtool --tag=CXX --mode=link g++  -g -O2   -o example  example-main.o ../main/libactivemq-cpp.la  /usr/local/apr/lib/libapr-1.la -luuid -lrt -lcrypt  -lpthread -ldl    /usr/local/apr/lib/libaprutil-1.la   \ng++ -g -O2 -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat /usr/local/apr/lib/libaprutil-1.so /usr/local/apr/lib/libexpat.so /usr/local/apr/lib/libapr-1.so -luuid -lrt -lcrypt -lpthread -ldl  -Wl,--rpath -Wl,/usr/local/lib -Wl,--rpath -Wl,/usr/local/apr/lib\n/usr/bin/ld: cannot find -lexpat\ncollect2: ld returned 1 exit status\nmake: *** [example] Error 1\n\nEverything under src/main is correctly compiled and linked. Issue is only with linking of Example files\n\nComments:\n", "classification": "Classify the issue 'Link error for Example' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-187?\nA: On running Makefile I am getting following error\n/bin/sh ../../libtool --tag=CXX --mode=link g++  -g -O2   -o example  example-main.o ../main/libactivemq-cpp.la  /usr/local/apr/lib/libapr-1.la -luuid -lrt -lcrypt  -lpthread -ldl    /usr/local/apr/lib/libaprutil-1.la   \ng++ -g -O2 -o .libs/example example-main.o  ../main/.libs/libactivemq-cpp.so -lexpat /usr/local/apr/lib/libaprutil-1.so /usr/local"}}
{"issue_key": "AMQCPP-186", "project": "AMQCPP", "title": "CMSExpiration computed incorrectly (?)", "status": "Closed", "reporter": "Eddie Epstein", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-06-30T21:26:28.000+0000", "updated": "2008-07-05T00:00:01.000+0000", "description": "The C++ consumer is treating messages as expired in situations where the Java consumer is not.\n\nIt could be that the problem is due to the code in connector/openwire/commands/ActiveMQMessageBase.h which compares the CMSExpiration time specified by producer.setTimeToLive()  with the local clock on the consumer machine.\n\n        /**\n         * Returns if this message has expired, meaning that its\n         * Expiration time has elapsed.\n         * @returns true if message is expired.\n         */\n        virtual bool isExpired() const {\n            long long expireTime = this->getCMSExpiration();\n            long long currentTime = decaf::util::Date::getCurrentTimeMilliseconds();\n            if( expireTime > 0 && currentTime > expireTime ) {\n                return true;\n            }\n            return false;\n        }", "comments": [], "text": "CMSExpiration computed incorrectly (?)\n\nDescription:\nThe C++ consumer is treating messages as expired in situations where the Java consumer is not.\n\nIt could be that the problem is due to the code in connector/openwire/commands/ActiveMQMessageBase.h which compares the CMSExpiration time specified by producer.setTimeToLive()  with the local clock on the consumer machine.\n\n        /**\n         * Returns if this message has expired, meaning that its\n         * Expiration time has elapsed.\n         * @returns true if message is expired.\n         */\n        virtual bool isExpired() const {\n            long long expireTime = this->getCMSExpiration();\n            long long currentTime = decaf::util::Date::getCurrentTimeMilliseconds();\n            if( expireTime > 0 && currentTime > expireTime ) {\n                return true;\n            }\n            return false;\n        }\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMSExpiration computed incorrectly (?)\n\nDescription:\nThe C++ consumer is treating messages as expired in situations where the Java consumer is not.\n\nIt could be that the problem is due to the code in connector/openwire/commands/ActiveMQMessageBase.h which compares the CMSExpiration time specified by producer.setTimeToLive()  with the local clock on the consumer machine.\n\n        /**\n         * Returns if this message has expired, meaning that its\n         * Expiration time has elapsed.\n         * @returns true if message is expired.\n         */\n        virtual bool isExpired() const {\n            long long expireTime = this->getCMSExpiration();\n            long long currentTime = decaf::util::Date::getCurrentTimeMilliseconds();\n            if( expireTime > 0 && currentTime > expireTime ) {\n                return true;\n            }\n            return false;\n        }\n\n\n\nComments:\n", "classification": "Classify the issue 'CMSExpiration computed incorrectly (?)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-186?\nA: The C++ consumer is treating messages as expired in situations where the Java consumer is not.\n\nIt could be that the problem is due to the code in connector/openwire/commands/ActiveMQMessageBase.h which compares the CMSExpiration time specified by producer.setTimeToLive()  with the local clock on the consumer machine.\n\n        /**\n         * Returns if this message has expired, meaning that its\n  "}}
{"issue_key": "AMQCPP-185", "project": "AMQCPP", "title": "Some CmsTemplate headers missing from headers section in Makefile.am", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-06-29T22:58:54.000+0000", "updated": "2008-06-29T23:00:41.000+0000", "description": "Some of the CmsTemplate headers are missing from the makefile which causes them not to be installed when running 'make install'", "comments": [], "text": "Some CmsTemplate headers missing from headers section in Makefile.am\n\nDescription:\nSome of the CmsTemplate headers are missing from the makefile which causes them not to be installed when running 'make install'\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Some CmsTemplate headers missing from headers section in Makefile.am\n\nDescription:\nSome of the CmsTemplate headers are missing from the makefile which causes them not to be installed when running 'make install'\n\nComments:\n", "classification": "Classify the issue 'Some CmsTemplate headers missing from headers section in Makefile.am' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-185?\nA: Some of the CmsTemplate headers are missing from the makefile which causes them not to be installed when running 'make install'"}}
{"issue_key": "AMQCPP-184", "project": "AMQCPP", "title": "TransportFilter::fire() crashes after accessing a dangling pointer during exception in ActiveMQConnectionFactory::createConnection()", "status": "Closed", "reporter": "python", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-06-18T18:20:43.000+0000", "updated": "2008-11-26T01:45:01.000+0000", "description": "This problems was seen on:\n\nVersions:\nActiveMQ-cpp-2.1.3 (WindowsServer2003/XP)\nActiveMQ Broker 5.1 (WindowsServer2003)\n\nThis looks similar to issue [AMQCPP-122|https://issues.apache.org/activemq/browse/AMQCPP-122], which was fixed in 2.1, but I don't see how IOTransport::run() and error handling have been properly synchronized. \n\nSteps to reproduce:\n# Continuously try to reconnect to an activemq broker that has run out of memory.\n# This may eventually produce the crash (could take several hours to produce depending on frequency of reconnect attempts).\n# Running activemq-cpp through purify can help reproduce this problem more easily. \n# A \"R6025 pure virtual function call\" error message may be printed out to the console when this error happens.\n\nBacktraces:\n\nThread 1:\n{noformat}\nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::IOTransport::fire()  + 0x48 bytes                \nactivemq::transport::IOTransport::run()  + 0x7f bytes                \nactivemq::concurrent::Thread::runCallback()  + 0x45 bytes      \nmsvcr80.dll!781329bb()\n{noformat}\n\nThe crash happens on this line:\n\texceptionListener->onTransportException( this, ex );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nDuring ActiveMQConnectionFactory::createConnection() an exception is thrown and the transport object is deleted. Unfortunately,\nwhile being deleted this object is still being used by Thread#1 (IOTransport::run). \n\nI greatly reduced the likelihood of this problem by calling setTransportExceptionListener(NULL) in TransportFilter's destructor. \n\n\nAfter doing that, another crash will start to appear (under the same test conditions) with the following backtrace:\n\nThread 1:\n{noformat}\nactivemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1e bytes    C++\nactivemq::transport::IOTransport::run()  Line 166 + 0x19 bytes       C++\nactivemq::concurrent::Thread::runCallback(void * param=0x02a750b0)  Line 152 + 0x13 bytes            C++\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes    C\nmsvcr80d.dll!_threadstartex(void * ptd=0x02a6b8c0)  Line 331    C\nkernel32.dll!7c80b683() \nntdll.dll!7c91b686()     \n{noformat}\n\nThe crash happens on this line:\n\treturn openWireFormat->unmarshal( dataInputStream );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nThis second problem is similar to the first and seems to be caused when the OpenWireConnector is deleted before IOTransport::close() is called. Since IOTransport::run() tries to use the OpenWireConnector (via OpenWireCommandReader::readCommand()), a crash can occur.", "comments": [], "text": "TransportFilter::fire() crashes after accessing a dangling pointer during exception in ActiveMQConnectionFactory::createConnection()\n\nDescription:\nThis problems was seen on:\n\nVersions:\nActiveMQ-cpp-2.1.3 (WindowsServer2003/XP)\nActiveMQ Broker 5.1 (WindowsServer2003)\n\nThis looks similar to issue [AMQCPP-122|https://issues.apache.org/activemq/browse/AMQCPP-122], which was fixed in 2.1, but I don't see how IOTransport::run() and error handling have been properly synchronized. \n\nSteps to reproduce:\n# Continuously try to reconnect to an activemq broker that has run out of memory.\n# This may eventually produce the crash (could take several hours to produce depending on frequency of reconnect attempts).\n# Running activemq-cpp through purify can help reproduce this problem more easily. \n# A \"R6025 pure virtual function call\" error message may be printed out to the console when this error happens.\n\nBacktraces:\n\nThread 1:\n{noformat}\nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::IOTransport::fire()  + 0x48 bytes                \nactivemq::transport::IOTransport::run()  + 0x7f bytes                \nactivemq::concurrent::Thread::runCallback()  + 0x45 bytes      \nmsvcr80.dll!781329bb()\n{noformat}\n\nThe crash happens on this line:\n\texceptionListener->onTransportException( this, ex );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nDuring ActiveMQConnectionFactory::createConnection() an exception is thrown and the transport object is deleted. Unfortunately,\nwhile being deleted this object is still being used by Thread#1 (IOTransport::run). \n\nI greatly reduced the likelihood of this problem by calling setTransportExceptionListener(NULL) in TransportFilter's destructor. \n\n\nAfter doing that, another crash will start to appear (under the same test conditions) with the following backtrace:\n\nThread 1:\n{noformat}\nactivemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1e bytes    C++\nactivemq::transport::IOTransport::run()  Line 166 + 0x19 bytes       C++\nactivemq::concurrent::Thread::runCallback(void * param=0x02a750b0)  Line 152 + 0x13 bytes            C++\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes    C\nmsvcr80d.dll!_threadstartex(void * ptd=0x02a6b8c0)  Line 331    C\nkernel32.dll!7c80b683() \nntdll.dll!7c91b686()     \n{noformat}\n\nThe crash happens on this line:\n\treturn openWireFormat->unmarshal( dataInputStream );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nThis second problem is similar to the first and seems to be caused when the OpenWireConnector is deleted before IOTransport::close() is called. Since IOTransport::run() tries to use the OpenWireConnector (via OpenWireCommandReader::readCommand()), a crash can occur.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: TransportFilter::fire() crashes after accessing a dangling pointer during exception in ActiveMQConnectionFactory::createConnection()\n\nDescription:\nThis problems was seen on:\n\nVersions:\nActiveMQ-cpp-2.1.3 (WindowsServer2003/XP)\nActiveMQ Broker 5.1 (WindowsServer2003)\n\nThis looks similar to issue [AMQCPP-122|https://issues.apache.org/activemq/browse/AMQCPP-122], which was fixed in 2.1, but I don't see how IOTransport::run() and error handling have been properly synchronized. \n\nSteps to reproduce:\n# Continuously try to reconnect to an activemq broker that has run out of memory.\n# This may eventually produce the crash (could take several hours to produce depending on frequency of reconnect attempts).\n# Running activemq-cpp through purify can help reproduce this problem more easily. \n# A \"R6025 pure virtual function call\" error message may be printed out to the console when this error happens.\n\nBacktraces:\n\nThread 1:\n{noformat}\nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::TransportFilter::fire()  + 0x48 bytes          \nactivemq::transport::IOTransport::fire()  + 0x48 bytes                \nactivemq::transport::IOTransport::run()  + 0x7f bytes                \nactivemq::concurrent::Thread::runCallback()  + 0x45 bytes      \nmsvcr80.dll!781329bb()\n{noformat}\n\nThe crash happens on this line:\n\texceptionListener->onTransportException( this, ex );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nDuring ActiveMQConnectionFactory::createConnection() an exception is thrown and the transport object is deleted. Unfortunately,\nwhile being deleted this object is still being used by Thread#1 (IOTransport::run). \n\nI greatly reduced the likelihood of this problem by calling setTransportExceptionListener(NULL) in TransportFilter's destructor. \n\n\nAfter doing that, another crash will start to appear (under the same test conditions) with the following backtrace:\n\nThread 1:\n{noformat}\nactivemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1e bytes    C++\nactivemq::transport::IOTransport::run()  Line 166 + 0x19 bytes       C++\nactivemq::concurrent::Thread::runCallback(void * param=0x02a750b0)  Line 152 + 0x13 bytes            C++\nmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes    C\nmsvcr80d.dll!_threadstartex(void * ptd=0x02a6b8c0)  Line 331    C\nkernel32.dll!7c80b683() \nntdll.dll!7c91b686()     \n{noformat}\n\nThe crash happens on this line:\n\treturn openWireFormat->unmarshal( dataInputStream );\n\nThread 2:\n{noformat}\nactivemq::concurrent::Thread::join()  Line 108       C++\nactivemq::transport::IOTransport::close()  Line 143           C++\nactivemq::transport::TransportFilter::close()  Line 213       C++\nactivemq::transport::filters::TcpTransport::close()  Line 143 + 0xb bytes    C++\nactivemq::transport::filters::ResponseCorrelator::close()  Line 241 C++\nactivemq::transport::filters::ResponseCorrelator::~ResponseCorrelator()  Line 64   C++\nactivemq::transport::filters::ResponseCorrelator::`scalar deleting destructor'()  + 0xf bytes C++\nactivemq::core::ActiveMQConnectionFactory::createConnection(const std::basic_string<char,std::char_traits<char>,std::allocator<char>\nactivemq::core::ActiveMQConnectionFactory::createConnection()  Line 66 + 0x3a bytes     C++\n{noformat}\n\nThis second problem is similar to the first and seems to be caused when the OpenWireConnector is deleted before IOTransport::close() is called. Since IOTransport::run() tries to use the OpenWireConnector (via OpenWireCommandReader::readCommand()), a crash can occur.\n\n\n\nComments:\n", "classification": "Classify the issue 'TransportFilter::fire() crashes after accessing a dangling pointer during exception in ActiveMQConnectionFactory::createConnection()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-184?\nA: This problems was seen on:\n\nVersions:\nActiveMQ-cpp-2.1.3 (WindowsServer2003/XP)\nActiveMQ Broker 5.1 (WindowsServer2003)\n\nThis looks similar to issue [AMQCPP-122|https://issues.apache.org/activemq/browse/AMQCPP-122], which was fixed in 2.1, but I don't see how IOTransport::run() and error handling have been properly synchronized. \n\nSteps to reproduce:\n# Continuously try to reconnect to an activemq "}}
{"issue_key": "AMQCPP-183", "project": "AMQCPP", "title": "Add a note about using LIBTOOLIZE environment variable when building on MacOS X", "status": "Resolved", "reporter": "Bruce Snyder", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-06-16T21:55:24.000+0000", "updated": "2008-06-17T11:30:01.000+0000", "description": "When building the ActiveMQ CPP client on MacOS X 10.5, I continually received the following error even though I had all the right tools and versions installed: \n\n{panel}\n$ ./autogen.sh \nCan't exec \"libtoolize\": No such file or directory at /opt/local/share/autoconf/Autom4te/FileUtils.pm line 290, <GEN2> line 5.\nautoreconf: failed to run libtoolize: No such file or directory\n{panel} \n\nI was able to work around this by using the LIBTOOLIZE environment variable to point to  /usr/bin/glibtoolize. After doing this the build completed successfully.", "comments": [], "text": "Add a note about using LIBTOOLIZE environment variable when building on MacOS X\n\nDescription:\nWhen building the ActiveMQ CPP client on MacOS X 10.5, I continually received the following error even though I had all the right tools and versions installed: \n\n{panel}\n$ ./autogen.sh \nCan't exec \"libtoolize\": No such file or directory at /opt/local/share/autoconf/Autom4te/FileUtils.pm line 290, <GEN2> line 5.\nautoreconf: failed to run libtoolize: No such file or directory\n{panel} \n\nI was able to work around this by using the LIBTOOLIZE environment variable to point to  /usr/bin/glibtoolize. After doing this the build completed successfully. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add a note about using LIBTOOLIZE environment variable when building on MacOS X\n\nDescription:\nWhen building the ActiveMQ CPP client on MacOS X 10.5, I continually received the following error even though I had all the right tools and versions installed: \n\n{panel}\n$ ./autogen.sh \nCan't exec \"libtoolize\": No such file or directory at /opt/local/share/autoconf/Autom4te/FileUtils.pm line 290, <GEN2> line 5.\nautoreconf: failed to run libtoolize: No such file or directory\n{panel} \n\nI was able to work around this by using the LIBTOOLIZE environment variable to point to  /usr/bin/glibtoolize. After doing this the build completed successfully. \n\nComments:\n", "classification": "Classify the issue 'Add a note about using LIBTOOLIZE environment variable when building on MacOS X' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-183?\nA: When building the ActiveMQ CPP client on MacOS X 10.5, I continually received the following error even though I had all the right tools and versions installed: \n\n{panel}\n$ ./autogen.sh \nCan't exec \"libtoolize\": No such file or directory at /opt/local/share/autoconf/Autom4te/FileUtils.pm line 290, <GEN2> line 5.\nautoreconf: failed to run libtoolize: No such file or directory\n{panel} \n\nI was able to"}}
{"issue_key": "AMQCPP-182", "project": "AMQCPP", "title": "Compile with GCC 4.3.0 fails", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-06-10T17:20:40.000+0000", "updated": "2008-06-10T18:30:49.000+0000", "description": "Errors during compilation on Fedora 9 related to not having string.h included in the right places.", "comments": [], "text": "Compile with GCC 4.3.0 fails\n\nDescription:\nErrors during compilation on Fedora 9 related to not having string.h included in the right places.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compile with GCC 4.3.0 fails\n\nDescription:\nErrors during compilation on Fedora 9 related to not having string.h included in the right places.\n\nComments:\n", "classification": "Classify the issue 'Compile with GCC 4.3.0 fails' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-182?\nA: Errors during compilation on Fedora 9 related to not having string.h included in the right places."}}
{"issue_key": "AMQCPP-181", "project": "AMQCPP", "title": "Failed unit tests in 2.2 RC1", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-06-06T12:53:35.000+0000", "updated": "2008-06-12T14:50:20.000+0000", "description": "I checked out the tag on OS X and built and ran the unit tests.  Everything builds cleanly, but I did notice a couple of failed unit tests (both in MathTest):\n\n1) test: decaf::lang::MathTest::test_hypot_DD (F) line: 262 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.79769313486232e+308\n- Actual  : inf\n- Should return 1.7976931348623157E308\n\n\n2) test: decaf::lang::MathTest::test_tanD (F) line: 567 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.5574077246549\n- Actual  : 1.5574077246549\n- Incorrect answer\n\nGenerally, these are just bothersome errors that probably don't need a lot of attention.  The second one seems to just be an error in some far off decimal place.  We can take care of that by just multiplying the values and casting to long before comparing.  The first is a little trickier - I'm not sure what the fix is.  Perhaps an temporary solution is to just #ifdef it out for OS X?", "comments": [], "text": "Failed unit tests in 2.2 RC1\n\nDescription:\nI checked out the tag on OS X and built and ran the unit tests.  Everything builds cleanly, but I did notice a couple of failed unit tests (both in MathTest):\n\n1) test: decaf::lang::MathTest::test_hypot_DD (F) line: 262 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.79769313486232e+308\n- Actual  : inf\n- Should return 1.7976931348623157E308\n\n\n2) test: decaf::lang::MathTest::test_tanD (F) line: 567 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.5574077246549\n- Actual  : 1.5574077246549\n- Incorrect answer\n\nGenerally, these are just bothersome errors that probably don't need a lot of attention.  The second one seems to just be an error in some far off decimal place.  We can take care of that by just multiplying the values and casting to long before comparing.  The first is a little trickier - I'm not sure what the fix is.  Perhaps an temporary solution is to just #ifdef it out for OS X?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Failed unit tests in 2.2 RC1\n\nDescription:\nI checked out the tag on OS X and built and ran the unit tests.  Everything builds cleanly, but I did notice a couple of failed unit tests (both in MathTest):\n\n1) test: decaf::lang::MathTest::test_hypot_DD (F) line: 262 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.79769313486232e+308\n- Actual  : inf\n- Should return 1.7976931348623157E308\n\n\n2) test: decaf::lang::MathTest::test_tanD (F) line: 567 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.5574077246549\n- Actual  : 1.5574077246549\n- Incorrect answer\n\nGenerally, these are just bothersome errors that probably don't need a lot of attention.  The second one seems to just be an error in some far off decimal place.  We can take care of that by just multiplying the values and casting to long before comparing.  The first is a little trickier - I'm not sure what the fix is.  Perhaps an temporary solution is to just #ifdef it out for OS X?\n\nComments:\n", "classification": "Classify the issue 'Failed unit tests in 2.2 RC1' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-181?\nA: I checked out the tag on OS X and built and ran the unit tests.  Everything builds cleanly, but I did notice a couple of failed unit tests (both in MathTest):\n\n1) test: decaf::lang::MathTest::test_hypot_DD (F) line: 262 decaf/lang/MathTest.cpp\nequality assertion failed\n- Expected: 1.79769313486232e+308\n- Actual  : inf\n- Should return 1.7976931348623157E308\n\n\n2) test: decaf::lang::MathTest::test_ta"}}
{"issue_key": "AMQCPP-180", "project": "AMQCPP", "title": "Segmentation fault after removing derivation from runnable", "status": "Closed", "reporter": "Wolfgang.Klein", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-06-04T09:43:29.000+0000", "updated": "2008-07-07T14:58:56.000+0000", "description": "I have unstalled ActiveMQ 5.1.0 and activemq-cpp-2.1.3.\nI have used simple_producer and simple_async_consumer successful.\nThen i have started several times simple_producer without starting a consumer. Which (clearly) results in an exception:\n\n[wok@orion] ~/src 679$ /opt/apache-activemq-5.1.0/bin/simple_producer\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread -1420801584\nNo valid response received for command: (null), check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1371\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 848\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n\nThat's all ok. \n\nBut then i haved change the SimpleProducer in line 43 and 110 to be closer to our integration:\n   < class SimpleProducer /*: public Runnable*/ {\n   string threadIdStr;   // = Integer::toString( Thread::getId() );\n\nI repeated the test and got a Segmentation fault (wihout a core file).\n\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread\nSegmentation fault\n\nWHY ???????????????", "comments": [], "text": "Segmentation fault after removing derivation from runnable\n\nDescription:\nI have unstalled ActiveMQ 5.1.0 and activemq-cpp-2.1.3.\nI have used simple_producer and simple_async_consumer successful.\nThen i have started several times simple_producer without starting a consumer. Which (clearly) results in an exception:\n\n[wok@orion] ~/src 679$ /opt/apache-activemq-5.1.0/bin/simple_producer\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread -1420801584\nNo valid response received for command: (null), check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1371\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 848\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n\nThat's all ok. \n\nBut then i haved change the SimpleProducer in line 43 and 110 to be closer to our integration:\n   < class SimpleProducer /*: public Runnable*/ {\n   string threadIdStr;   // = Integer::toString( Thread::getId() );\n\nI repeated the test and got a Segmentation fault (wihout a core file).\n\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread\nSegmentation fault\n\nWHY ???????????????\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation fault after removing derivation from runnable\n\nDescription:\nI have unstalled ActiveMQ 5.1.0 and activemq-cpp-2.1.3.\nI have used simple_producer and simple_async_consumer successful.\nThen i have started several times simple_producer without starting a consumer. Which (clearly) results in an exception:\n\n[wok@orion] ~/src 679$ /opt/apache-activemq-5.1.0/bin/simple_producer\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread -1420801584\nNo valid response received for command: (null), check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1371\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 848\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example.\n=====================================================\n\nThat's all ok. \n\nBut then i haved change the SimpleProducer in line 43 and 110 to be closer to our integration:\n   < class SimpleProducer /*: public Runnable*/ {\n   string threadIdStr;   // = Integer::toString( Thread::getId() );\n\nI repeated the test and got a Segmentation fault (wihout a core file).\n\n=====================================================\nStarting the example:\n-----------------------------------------------------\nSent message #1 from thread\nSegmentation fault\n\nWHY ???????????????\n\n\nComments:\n", "classification": "Classify the issue 'Segmentation fault after removing derivation from runnable' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-180?\nA: I have unstalled ActiveMQ 5.1.0 and activemq-cpp-2.1.3.\nI have used simple_producer and simple_async_consumer successful.\nThen i have started several times simple_producer without starting a consumer. Which (clearly) results in an exception:\n\n[wok@orion] ~/src 679$ /opt/apache-activemq-5.1.0/bin/simple_producer\n=====================================================\nStarting the example:\n-----------"}}
{"issue_key": "AMQCPP-179", "project": "AMQCPP", "title": "Add support for the openwire 3.0 commands", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-06-02T14:52:25.000+0000", "updated": "2008-08-15T14:54:43.000+0000", "description": "We should add support for openwire V3 as there are some new features in the commands such as flow control etc that we could use.  This requires regenerating the commands and making some mods to the Openwire Connector classes.", "comments": [], "text": "Add support for the openwire 3.0 commands\n\nDescription:\nWe should add support for openwire V3 as there are some new features in the commands such as flow control etc that we could use.  This requires regenerating the commands and making some mods to the Openwire Connector classes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for the openwire 3.0 commands\n\nDescription:\nWe should add support for openwire V3 as there are some new features in the commands such as flow control etc that we could use.  This requires regenerating the commands and making some mods to the Openwire Connector classes.\n\nComments:\n", "classification": "Classify the issue 'Add support for the openwire 3.0 commands' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-179?\nA: We should add support for openwire V3 as there are some new features in the commands such as flow control etc that we could use.  This requires regenerating the commands and making some mods to the Openwire Connector classes."}}
{"issue_key": "AMQCPP-178", "project": "AMQCPP", "title": "Core dump in ActiveMQException::buildMessage", "status": "Resolved", "reporter": "Aaron Riekenberg", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-05-26T13:26:44.000+0000", "updated": "2008-05-29T15:08:25.000+0000", "description": "Running the \"example\" example program, I find I get a segmentation fault in \"example\" if I terminate the message broker while its running.  This seems like quite a serious problem, I can't have all c++ clients core dump if the broker goes down.  Full stack trace from gdb is at the bottom.\n\nDid some digging with gdb and found the \"size\" variable in ActiveMQException::buildMessage is 256, meaning our string was longer than 128 so we're going through the loop for the second time:\n\n(gdb) down\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n75              int written = vsnprintf(buffer, size, format, vargs);\n(gdb) p size\n$1 = 256\n\nActiveMQException::buildMessage does a vsnprintf to try to write vargs into buffer, and if buffer isn't big enough it doubles the size and tries another vsnprintf.  Trouble is it's only legal to do ONE vsnprintf between calls to va_start and va_end, so on the second try vargs is garbage.  See \"man vsnprintf\":\n\n       The  functions  vprintf(),  vfprintf(),  vsprintf(), vsnprintf() are equivalent to the\n       functions printf(), fprintf(), sprintf(), snprintf(), respectively, except  that  they\n       are  called with a va_list instead of a variable number of arguments.  These functions\n       do not call the va_end macro.  Because they invoke the va_arg macro, the value  of  ap\n       is undefined after the call.  See stdarg(3).\n\nOne possible solution is to use va_copy or __va_copy to make a copy of vargs so we have a fresh copy to traverse on each iteration in buildMessage.  I've verified the following works on my system (I have __va_copy instead of va_copy on Ubunutu 8.0.4):\n\nvoid ActiveMQException::buildMessage(const char* format, va_list& vargs)\n{\n    // Allocate buffer with a guess of it's size\n    int size = 128;\n\n    // Format string\n    while( true ){\n        // Allocate a buffer of the specified size.\n        char* buffer = new char[size];\n        va_list vargsCopy;\n        __va_copy(vargsCopy, vargs);\n\n        int written = vsnprintf(buffer, size, format, vargsCopy);\n        if (written > -1 && written < size-1) {\n\n            // Guessed size was enough. Assign the string.\n            message.assign (buffer, written);\n\n            // assign isn't passing ownership, just copying, delete\n            // the allocated buffer.\n            delete [] buffer;\n            va_end(vargsCopy);\n\n            break;\n        }\n\n        // Our buffer wasn't big enough - destroy the old buffer,\n        // double the size and try again.\n        delete [] buffer;\n        va_end(vargsCopy);\n        size *= 2;\n    }\n\n    //activemq::logger::SimpleLogger logger(\"com.yadda1\");\n    //logger.log( message );   \n}\n\n\n\nFull stack trace of the failure from gdb:\n\nCore was generated by `/home/aaron/activemq/activemq-cpp-2.1.3-src/src/examples/.libs/lt-example\n'.\nProgram terminated with signal 11, Segmentation fault.\n[New process 22513]\n[New process 22517]\n[New process 22497]\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n(gdb) where\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n#1  0x00007fd6a4b48e1a in vfprintf () from /lib/libc.so.6\n#2  0x00007fd6a4b6c9ea in vsnprintf () from /lib/libc.so.6\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n#4  0x00007fd6a57709e8 in CommandIOException (this=0x610600, \n    file=0x7fd6a58981e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=145, \n    msg=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\")\n    at ./activemq/transport/CommandIOException.h:67\n#5  0x00007fd6a57c20d8 in activemq::transport::filters::ResponseCorrelator::request (\n    this=<value optimized out>, command=<value optimized out>)\n    at activemq/transport/filters/ResponseCorrelator.cpp:147\n#6  0x00007fd6a5796735 in activemq::connector::openwire::OpenWireFormatNegotiator::request (\n    this=0x60ef60, command=0x610688)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00007fd6a57991fa in activemq::connector::openwire::OpenWireConnector::syncRequest (\n    this=<value optimized out>, command=0x7fd6a5898240)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00007fd6a5799dd1 in activemq::connector::openwire::OpenWireConnector::send (\n    this=0x60d5c0, message=<value optimized out>, producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00007fd6a5735aec in activemq::core::ActiveMQSession::send (this=<value optimized out>, \n    message=0x610680, producer=0x6103d0) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00007fd6a5741b00 in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    destination=<value optimized out>, message=0x610680, deliveryMode=626508689, priority=4, \n    timeToLive=0) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00007fd6a574161a in activemq::core::ActiveMQProducer::send (this=0x6554514d65766974, \n    destination=0x7fd6a5898240, message=0x409a2958) at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00007fd6a574193b in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    message=0x610680) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x0000000000402bbe in HelloWorldProducer::run (this=0x7fffadd50ff0) at main.cpp:114\n#14 0x00007fd6a575bda0 in activemq::concurrent::Thread::runCallback (\n    param=<value optimized out>) at activemq/concurrent/Thread.cpp:152\n#15 0x00007fd6a48eb3f7 in start_thread () from /lib/libpthread.so.0\n#16 0x00007fd6a4bd8b2d in clone () from /lib/libc.so.6\n#17 0x0000000000000000 in ?? ()", "comments": [], "text": "Core dump in ActiveMQException::buildMessage\n\nDescription:\nRunning the \"example\" example program, I find I get a segmentation fault in \"example\" if I terminate the message broker while its running.  This seems like quite a serious problem, I can't have all c++ clients core dump if the broker goes down.  Full stack trace from gdb is at the bottom.\n\nDid some digging with gdb and found the \"size\" variable in ActiveMQException::buildMessage is 256, meaning our string was longer than 128 so we're going through the loop for the second time:\n\n(gdb) down\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n75              int written = vsnprintf(buffer, size, format, vargs);\n(gdb) p size\n$1 = 256\n\nActiveMQException::buildMessage does a vsnprintf to try to write vargs into buffer, and if buffer isn't big enough it doubles the size and tries another vsnprintf.  Trouble is it's only legal to do ONE vsnprintf between calls to va_start and va_end, so on the second try vargs is garbage.  See \"man vsnprintf\":\n\n       The  functions  vprintf(),  vfprintf(),  vsprintf(), vsnprintf() are equivalent to the\n       functions printf(), fprintf(), sprintf(), snprintf(), respectively, except  that  they\n       are  called with a va_list instead of a variable number of arguments.  These functions\n       do not call the va_end macro.  Because they invoke the va_arg macro, the value  of  ap\n       is undefined after the call.  See stdarg(3).\n\nOne possible solution is to use va_copy or __va_copy to make a copy of vargs so we have a fresh copy to traverse on each iteration in buildMessage.  I've verified the following works on my system (I have __va_copy instead of va_copy on Ubunutu 8.0.4):\n\nvoid ActiveMQException::buildMessage(const char* format, va_list& vargs)\n{\n    // Allocate buffer with a guess of it's size\n    int size = 128;\n\n    // Format string\n    while( true ){\n        // Allocate a buffer of the specified size.\n        char* buffer = new char[size];\n        va_list vargsCopy;\n        __va_copy(vargsCopy, vargs);\n\n        int written = vsnprintf(buffer, size, format, vargsCopy);\n        if (written > -1 && written < size-1) {\n\n            // Guessed size was enough. Assign the string.\n            message.assign (buffer, written);\n\n            // assign isn't passing ownership, just copying, delete\n            // the allocated buffer.\n            delete [] buffer;\n            va_end(vargsCopy);\n\n            break;\n        }\n\n        // Our buffer wasn't big enough - destroy the old buffer,\n        // double the size and try again.\n        delete [] buffer;\n        va_end(vargsCopy);\n        size *= 2;\n    }\n\n    //activemq::logger::SimpleLogger logger(\"com.yadda1\");\n    //logger.log( message );   \n}\n\n\n\nFull stack trace of the failure from gdb:\n\nCore was generated by `/home/aaron/activemq/activemq-cpp-2.1.3-src/src/examples/.libs/lt-example\n'.\nProgram terminated with signal 11, Segmentation fault.\n[New process 22513]\n[New process 22517]\n[New process 22497]\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n(gdb) where\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n#1  0x00007fd6a4b48e1a in vfprintf () from /lib/libc.so.6\n#2  0x00007fd6a4b6c9ea in vsnprintf () from /lib/libc.so.6\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n#4  0x00007fd6a57709e8 in CommandIOException (this=0x610600, \n    file=0x7fd6a58981e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=145, \n    msg=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\")\n    at ./activemq/transport/CommandIOException.h:67\n#5  0x00007fd6a57c20d8 in activemq::transport::filters::ResponseCorrelator::request (\n    this=<value optimized out>, command=<value optimized out>)\n    at activemq/transport/filters/ResponseCorrelator.cpp:147\n#6  0x00007fd6a5796735 in activemq::connector::openwire::OpenWireFormatNegotiator::request (\n    this=0x60ef60, command=0x610688)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00007fd6a57991fa in activemq::connector::openwire::OpenWireConnector::syncRequest (\n    this=<value optimized out>, command=0x7fd6a5898240)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00007fd6a5799dd1 in activemq::connector::openwire::OpenWireConnector::send (\n    this=0x60d5c0, message=<value optimized out>, producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00007fd6a5735aec in activemq::core::ActiveMQSession::send (this=<value optimized out>, \n    message=0x610680, producer=0x6103d0) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00007fd6a5741b00 in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    destination=<value optimized out>, message=0x610680, deliveryMode=626508689, priority=4, \n    timeToLive=0) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00007fd6a574161a in activemq::core::ActiveMQProducer::send (this=0x6554514d65766974, \n    destination=0x7fd6a5898240, message=0x409a2958) at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00007fd6a574193b in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    message=0x610680) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x0000000000402bbe in HelloWorldProducer::run (this=0x7fffadd50ff0) at main.cpp:114\n#14 0x00007fd6a575bda0 in activemq::concurrent::Thread::runCallback (\n    param=<value optimized out>) at activemq/concurrent/Thread.cpp:152\n#15 0x00007fd6a48eb3f7 in start_thread () from /lib/libpthread.so.0\n#16 0x00007fd6a4bd8b2d in clone () from /lib/libc.so.6\n#17 0x0000000000000000 in ?? ()\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Core dump in ActiveMQException::buildMessage\n\nDescription:\nRunning the \"example\" example program, I find I get a segmentation fault in \"example\" if I terminate the message broker while its running.  This seems like quite a serious problem, I can't have all c++ clients core dump if the broker goes down.  Full stack trace from gdb is at the bottom.\n\nDid some digging with gdb and found the \"size\" variable in ActiveMQException::buildMessage is 256, meaning our string was longer than 128 so we're going through the loop for the second time:\n\n(gdb) down\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n75              int written = vsnprintf(buffer, size, format, vargs);\n(gdb) p size\n$1 = 256\n\nActiveMQException::buildMessage does a vsnprintf to try to write vargs into buffer, and if buffer isn't big enough it doubles the size and tries another vsnprintf.  Trouble is it's only legal to do ONE vsnprintf between calls to va_start and va_end, so on the second try vargs is garbage.  See \"man vsnprintf\":\n\n       The  functions  vprintf(),  vfprintf(),  vsprintf(), vsnprintf() are equivalent to the\n       functions printf(), fprintf(), sprintf(), snprintf(), respectively, except  that  they\n       are  called with a va_list instead of a variable number of arguments.  These functions\n       do not call the va_end macro.  Because they invoke the va_arg macro, the value  of  ap\n       is undefined after the call.  See stdarg(3).\n\nOne possible solution is to use va_copy or __va_copy to make a copy of vargs so we have a fresh copy to traverse on each iteration in buildMessage.  I've verified the following works on my system (I have __va_copy instead of va_copy on Ubunutu 8.0.4):\n\nvoid ActiveMQException::buildMessage(const char* format, va_list& vargs)\n{\n    // Allocate buffer with a guess of it's size\n    int size = 128;\n\n    // Format string\n    while( true ){\n        // Allocate a buffer of the specified size.\n        char* buffer = new char[size];\n        va_list vargsCopy;\n        __va_copy(vargsCopy, vargs);\n\n        int written = vsnprintf(buffer, size, format, vargsCopy);\n        if (written > -1 && written < size-1) {\n\n            // Guessed size was enough. Assign the string.\n            message.assign (buffer, written);\n\n            // assign isn't passing ownership, just copying, delete\n            // the allocated buffer.\n            delete [] buffer;\n            va_end(vargsCopy);\n\n            break;\n        }\n\n        // Our buffer wasn't big enough - destroy the old buffer,\n        // double the size and try again.\n        delete [] buffer;\n        va_end(vargsCopy);\n        size *= 2;\n    }\n\n    //activemq::logger::SimpleLogger logger(\"com.yadda1\");\n    //logger.log( message );   \n}\n\n\n\nFull stack trace of the failure from gdb:\n\nCore was generated by `/home/aaron/activemq/activemq-cpp-2.1.3-src/src/examples/.libs/lt-example\n'.\nProgram terminated with signal 11, Segmentation fault.\n[New process 22513]\n[New process 22517]\n[New process 22497]\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n(gdb) where\n#0  0x00007fd6a4b7c060 in strlen () from /lib/libc.so.6\n#1  0x00007fd6a4b48e1a in vfprintf () from /lib/libc.so.6\n#2  0x00007fd6a4b6c9ea in vsnprintf () from /lib/libc.so.6\n#3  0x00007fd6a575d90f in activemq::exceptions::ActiveMQException::buildMessage (\n    this=0x610600, \n    format=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\", \n    vargs=<value optimized out>) at activemq/exceptions/ActiveMQException.cpp:75\n#4  0x00007fd6a57709e8 in CommandIOException (this=0x610600, \n    file=0x7fd6a58981e0 \"activemq/transport/filters/ResponseCorrelator.cpp\", lineNumber=145, \n    msg=0x7fd6a5898218 \"No valid response received for command: %s, check broker.\")\n    at ./activemq/transport/CommandIOException.h:67\n#5  0x00007fd6a57c20d8 in activemq::transport::filters::ResponseCorrelator::request (\n    this=<value optimized out>, command=<value optimized out>)\n    at activemq/transport/filters/ResponseCorrelator.cpp:147\n#6  0x00007fd6a5796735 in activemq::connector::openwire::OpenWireFormatNegotiator::request (\n    this=0x60ef60, command=0x610688)\n    at activemq/connector/openwire/OpenWireFormatNegotiator.cpp:102\n#7  0x00007fd6a57991fa in activemq::connector::openwire::OpenWireConnector::syncRequest (\n    this=<value optimized out>, command=0x7fd6a5898240)\n    at activemq/connector/openwire/OpenWireConnector.cpp:1349\n#8  0x00007fd6a5799dd1 in activemq::connector::openwire::OpenWireConnector::send (\n    this=0x60d5c0, message=<value optimized out>, producerInfo=<value optimized out>)\n    at activemq/connector/openwire/OpenWireConnector.cpp:838\n#9  0x00007fd6a5735aec in activemq::core::ActiveMQSession::send (this=<value optimized out>, \n    message=0x610680, producer=0x6103d0) at activemq/core/ActiveMQSession.cpp:673\n#10 0x00007fd6a5741b00 in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    destination=<value optimized out>, message=0x610680, deliveryMode=626508689, priority=4, \n    timeToLive=0) at activemq/core/ActiveMQProducer.cpp:192\n#11 0x00007fd6a574161a in activemq::core::ActiveMQProducer::send (this=0x6554514d65766974, \n    destination=0x7fd6a5898240, message=0x409a2958) at activemq/core/ActiveMQProducer.cpp:147\n#12 0x00007fd6a574193b in activemq::core::ActiveMQProducer::send (this=0x6103d0, \n    message=0x610680) at activemq/core/ActiveMQProducer.cpp:106\n#13 0x0000000000402bbe in HelloWorldProducer::run (this=0x7fffadd50ff0) at main.cpp:114\n#14 0x00007fd6a575bda0 in activemq::concurrent::Thread::runCallback (\n    param=<value optimized out>) at activemq/concurrent/Thread.cpp:152\n#15 0x00007fd6a48eb3f7 in start_thread () from /lib/libpthread.so.0\n#16 0x00007fd6a4bd8b2d in clone () from /lib/libc.so.6\n#17 0x0000000000000000 in ?? ()\n\n\nComments:\n", "classification": "Classify the issue 'Core dump in ActiveMQException::buildMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-178?\nA: Running the \"example\" example program, I find I get a segmentation fault in \"example\" if I terminate the message broker while its running.  This seems like quite a serious problem, I can't have all c++ clients core dump if the broker goes down.  Full stack trace from gdb is at the bottom.\n\nDid some digging with gdb and found the \"size\" variable in ActiveMQException::buildMessage is 256, meaning ou"}}
{"issue_key": "AMQCPP-177", "project": "AMQCPP", "title": "Defines for static linking with APR on Windows", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-05-26T00:16:49.000+0000", "updated": "2008-05-28T14:56:26.000+0000", "description": "It seems one has to define\n\nAPR_DECLARE_STATIC\nAPU_DECLARE_STATIC\nAPI_DECLARE_STATIC\n\nin the Windows Debug and Release builds so that the static library version of AMQCPP can be properly linked along with the static version of apr, apr-util and apr-iconv.\n\nI had to do this to get pyactivemq building with VS2005 using the latest AMQCPP from trunk (thanks for fixing the Windows build!).", "comments": [], "text": "Defines for static linking with APR on Windows\n\nDescription:\nIt seems one has to define\n\nAPR_DECLARE_STATIC\nAPU_DECLARE_STATIC\nAPI_DECLARE_STATIC\n\nin the Windows Debug and Release builds so that the static library version of AMQCPP can be properly linked along with the static version of apr, apr-util and apr-iconv.\n\nI had to do this to get pyactivemq building with VS2005 using the latest AMQCPP from trunk (thanks for fixing the Windows build!).\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Defines for static linking with APR on Windows\n\nDescription:\nIt seems one has to define\n\nAPR_DECLARE_STATIC\nAPU_DECLARE_STATIC\nAPI_DECLARE_STATIC\n\nin the Windows Debug and Release builds so that the static library version of AMQCPP can be properly linked along with the static version of apr, apr-util and apr-iconv.\n\nI had to do this to get pyactivemq building with VS2005 using the latest AMQCPP from trunk (thanks for fixing the Windows build!).\n\n\nComments:\n", "classification": "Classify the issue 'Defines for static linking with APR on Windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-177?\nA: It seems one has to define\n\nAPR_DECLARE_STATIC\nAPU_DECLARE_STATIC\nAPI_DECLARE_STATIC\n\nin the Windows Debug and Release builds so that the static library version of AMQCPP can be properly linked along with the static version of apr, apr-util and apr-iconv.\n\nI had to do this to get pyactivemq building with VS2005 using the latest AMQCPP from trunk (thanks for fixing the Windows build!).\n"}}
{"issue_key": "AMQCPP-176", "project": "AMQCPP", "title": "Work around Visual Studio .NET 2003 covariant return issues", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-05-25T22:58:50.000+0000", "updated": "2008-10-23T15:26:47.000+0000", "description": "It would be very useful if something could be done in the AMQCPP code to work around the issues Visual Studio .NET 2003 has with having base classes with virtual functions as covariant return types.\n\nThese problems are alluded to here:\n\nhttp://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=23760&SiteID=1\n\nSome ideas have been discussed here:\n\nhttp://www.nabble.com/Unable-to-comile-C%2B%2B-client-on-VC%2B%2B-2003-td14680479s2354.html\n\nbut I'm hoping there might be a way to slightly restructure the AMQCPP code instead of resorting to preprocessor directives.\n\nAny ideas I could try would be much appreciated.", "comments": [], "text": "Work around Visual Studio .NET 2003 covariant return issues\n\nDescription:\nIt would be very useful if something could be done in the AMQCPP code to work around the issues Visual Studio .NET 2003 has with having base classes with virtual functions as covariant return types.\n\nThese problems are alluded to here:\n\nhttp://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=23760&SiteID=1\n\nSome ideas have been discussed here:\n\nhttp://www.nabble.com/Unable-to-comile-C%2B%2B-client-on-VC%2B%2B-2003-td14680479s2354.html\n\nbut I'm hoping there might be a way to slightly restructure the AMQCPP code instead of resorting to preprocessor directives.\n\nAny ideas I could try would be much appreciated.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Work around Visual Studio .NET 2003 covariant return issues\n\nDescription:\nIt would be very useful if something could be done in the AMQCPP code to work around the issues Visual Studio .NET 2003 has with having base classes with virtual functions as covariant return types.\n\nThese problems are alluded to here:\n\nhttp://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=23760&SiteID=1\n\nSome ideas have been discussed here:\n\nhttp://www.nabble.com/Unable-to-comile-C%2B%2B-client-on-VC%2B%2B-2003-td14680479s2354.html\n\nbut I'm hoping there might be a way to slightly restructure the AMQCPP code instead of resorting to preprocessor directives.\n\nAny ideas I could try would be much appreciated.\n\nComments:\n", "classification": "Classify the issue 'Work around Visual Studio .NET 2003 covariant return issues' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-176?\nA: It would be very useful if something could be done in the AMQCPP code to work around the issues Visual Studio .NET 2003 has with having base classes with virtual functions as covariant return types.\n\nThese problems are alluded to here:\n\nhttp://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=23760&SiteID=1\n\nSome ideas have been discussed here:\n\nhttp://www.nabble.com/Unable-to-comile-C%2B%2B-client-o"}}
{"issue_key": "AMQCPP-175", "project": "AMQCPP", "title": "No valid response received for command:", "status": "Closed", "reporter": "dj", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-05-21T10:03:16.000+0000", "updated": "2008-10-23T15:25:47.000+0000", "description": "terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  No valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[guid] = ydid=v41512280\nmap[referrer] = http://www.dgkaiyue.net/products.htm?dataid=5?winkee_pt_id=1e\nmap[src_href] = http://www.dgkaiyue.net/xmb/xslt/Pagination.xsl\nmap[src_ip] = 58.61.58.2\nmap[start_time] = 2008-05-09 11:59:30\nmap[type] = 1\nmap[user_agent] = Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = log.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 3927\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 1\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1211363710174\n Value of Type = MAP\n Value of DataStructure is Below:\n   Object is NULL\n Value of TargetConsumerId is Below:\n   Object is NULL\n Value of Compressed = 0\n Value of RedeliveryCounter = 0\n Value of Arrival = 0\n Value of UserID = \n Value of RecievedByDFBridge = 0\n Value of Droppable = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 3932\nEnd Class = BaseCommand\nEnd Class = Message\nEnd Class = ActiveMQMessageBase\nBegin Class = ActiveMQTextMessage\n, check broker.\nAborted", "comments": [], "text": "No valid response received for command:\n\nDescription:\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  No valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[guid] = ydid=v41512280\nmap[referrer] = http://www.dgkaiyue.net/products.htm?dataid=5?winkee_pt_id=1e\nmap[src_href] = http://www.dgkaiyue.net/xmb/xslt/Pagination.xsl\nmap[src_ip] = 58.61.58.2\nmap[start_time] = 2008-05-09 11:59:30\nmap[type] = 1\nmap[user_agent] = Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = log.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 3927\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 1\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1211363710174\n Value of Type = MAP\n Value of DataStructure is Below:\n   Object is NULL\n Value of TargetConsumerId is Below:\n   Object is NULL\n Value of Compressed = 0\n Value of RedeliveryCounter = 0\n Value of Arrival = 0\n Value of UserID = \n Value of RecievedByDFBridge = 0\n Value of Droppable = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 3932\nEnd Class = BaseCommand\nEnd Class = Message\nEnd Class = ActiveMQMessageBase\nBegin Class = ActiveMQTextMessage\n, check broker.\nAborted\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: No valid response received for command:\n\nDescription:\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  No valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[guid] = ydid=v41512280\nmap[referrer] = http://www.dgkaiyue.net/products.htm?dataid=5?winkee_pt_id=1e\nmap[src_href] = http://www.dgkaiyue.net/xmb/xslt/Pagination.xsl\nmap[src_ip] = 58.61.58.2\nmap[start_time] = 2008-05-09 11:59:30\nmap[type] = 1\nmap[user_agent] = Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = log.mq\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = 3a3275de-9c8c-406e-b387-7d7ed259c641\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 3927\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID = \n Value of GroupSequence = 0\n Value of CorrelationId = \n Value of Persistent = 1\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1211363710174\n Value of Type = MAP\n Value of DataStructure is Below:\n   Object is NULL\n Value of TargetConsumerId is Below:\n   Object is NULL\n Value of Compressed = 0\n Value of RedeliveryCounter = 0\n Value of Arrival = 0\n Value of UserID = \n Value of RecievedByDFBridge = 0\n Value of Droppable = 0\nBegin Class = BaseCommand\nNo Data for Class BaseDataStructure\n  Response Required = 1\n  Command Id = 3932\nEnd Class = BaseCommand\nEnd Class = Message\nEnd Class = ActiveMQMessageBase\nBegin Class = ActiveMQTextMessage\n, check broker.\nAborted\n\nComments:\n", "classification": "Classify the issue 'No valid response received for command:' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-175?\nA: terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  No valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[guid] = ydid=v41512280\nmap[referrer] = http://www.dgkaiyue.net/products.htm?dataid=5"}}
{"issue_key": "AMQCPP-174", "project": "AMQCPP", "title": "Deadlock on transacted session", "status": "Resolved", "reporter": "Nick Cooper", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-04-15T01:38:03.000+0000", "updated": "2008-05-19T15:15:10.000+0000", "description": "I am implementing a request/response client and require the ability to do transactions. I initially created one connection with one session with a producer and a consumer. This worked fine when creating the session with Session::AUTO_ACKNOWLEDGE. When I changed this to use Session::SESSION_TRANSACTED\nwith session->commit() the application stopped working. To help work out the issue I created separate connections and sessions for the producer and consumer which did not help.\n\nLooking at the application in the debugger it looks like when session->commit() is called, a dead lock occurs.\n\nIn ActiveMQSessionExecutor::stop()  the following line is executed:\n\n        // Wakeup the thread so that it can acknowledge the stop request.\n        mutex.notifyAll();\n\nbut eventQ.size() is 0, that is no thread is notified. The next line is then executed:\n\n        // Wait for the thread to notify us that it has acknowledged\n        // the stop request.\n        mutex.wait();\n\nbut there is no other thread to ever come and wake it up, thus it hangs and the session is never committed.\n\nAm I using the API incorrectly or is this a real issue?\nNote this looks very similar to issue 155 https://issues.apache.org/activemq/browse/AMQCPP-155\n\nThread Summary\n--------------\n \t2000\tmain\t             tool::DefaultCounter::`scalar deleting destructor'\tNormal\t0\n \t1896\t_threadstartex\tactivemq::concurrent::Mutex::wait\t                       Normal\t0\n \t3984\t_threadstartex\tactivemq::network::SocketInputStream::read\t           Normal\t0\n>\t1544\t_threadstartex\tactivemq::concurrent::Mutex::notifyAll\t                       Normal\t0\n\nThread 1544 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::notifyAll()  Line 233\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 150 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::stop()  Line 847 + 0x1b\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQTransaction::commit()  Line 205\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::commit()  Line 150 + 0x13\tC++\n \tppl_worker_d.exe!dist::TransactedConnector::onMessage(const cms::Message * message=0x014df8c0)  Line 176 + 0x30\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQConsumer::dispatch(activemq::core::DispatchData & data={...})  Line 429 + 0x3a\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatch(activemq::core::DispatchData & data={...})  Line 188 + 0x15\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatchAll()  Line 273 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::run()  Line 213\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dc3e8)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014df798)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 3984 Stacktrace....\n>\tppl_worker_d.exe!activemq::network::SocketInputStream::read(unsigned char * buffer=0x014d8f70, unsigned int bufferSize=1)  Line 152 + 0x19\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::bufferData()  Line 190 + 0x2c\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::read(unsigned char * targetBuffer=0x017ff6f4, unsigned int targetBufferSize=4)  Line 125\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readAllData(unsigned char * buffer=0x017ff6f4, unsigned int length=4)  Line 369 + 0x21\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readInt()  Line 168\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream * dis=0x014dcbe8)  Line 218 + 0xd\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1a\tC++\n \tppl_worker_d.exe!activemq::transport::IOTransport::run()  Line 166 + 0x13\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dce40)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014ddd10)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 1896 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::wait(unsigned long millisecs=4294967295)  Line 178 + 0x10\tC++\n \tppl_worker_d.exe!activemq::concurrent::Mutex::wait()  Line 102 + 0xf\tC++\n \tppl_worker_d.exe!activemq::util::Queue<activemq::transport::Command *>::wait()  Line 206 + 0x11\tC++\n \tppl_worker_d.exe!activemq::transport::filters::AsyncSendTransport::run()  Line 118 + 0x11\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dcad0)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014dcd78)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683()", "comments": [], "text": "Deadlock on transacted session\n\nDescription:\nI am implementing a request/response client and require the ability to do transactions. I initially created one connection with one session with a producer and a consumer. This worked fine when creating the session with Session::AUTO_ACKNOWLEDGE. When I changed this to use Session::SESSION_TRANSACTED\nwith session->commit() the application stopped working. To help work out the issue I created separate connections and sessions for the producer and consumer which did not help.\n\nLooking at the application in the debugger it looks like when session->commit() is called, a dead lock occurs.\n\nIn ActiveMQSessionExecutor::stop()  the following line is executed:\n\n        // Wakeup the thread so that it can acknowledge the stop request.\n        mutex.notifyAll();\n\nbut eventQ.size() is 0, that is no thread is notified. The next line is then executed:\n\n        // Wait for the thread to notify us that it has acknowledged\n        // the stop request.\n        mutex.wait();\n\nbut there is no other thread to ever come and wake it up, thus it hangs and the session is never committed.\n\nAm I using the API incorrectly or is this a real issue?\nNote this looks very similar to issue 155 https://issues.apache.org/activemq/browse/AMQCPP-155\n\nThread Summary\n--------------\n \t2000\tmain\t             tool::DefaultCounter::`scalar deleting destructor'\tNormal\t0\n \t1896\t_threadstartex\tactivemq::concurrent::Mutex::wait\t                       Normal\t0\n \t3984\t_threadstartex\tactivemq::network::SocketInputStream::read\t           Normal\t0\n>\t1544\t_threadstartex\tactivemq::concurrent::Mutex::notifyAll\t                       Normal\t0\n\nThread 1544 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::notifyAll()  Line 233\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 150 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::stop()  Line 847 + 0x1b\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQTransaction::commit()  Line 205\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::commit()  Line 150 + 0x13\tC++\n \tppl_worker_d.exe!dist::TransactedConnector::onMessage(const cms::Message * message=0x014df8c0)  Line 176 + 0x30\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQConsumer::dispatch(activemq::core::DispatchData & data={...})  Line 429 + 0x3a\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatch(activemq::core::DispatchData & data={...})  Line 188 + 0x15\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatchAll()  Line 273 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::run()  Line 213\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dc3e8)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014df798)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 3984 Stacktrace....\n>\tppl_worker_d.exe!activemq::network::SocketInputStream::read(unsigned char * buffer=0x014d8f70, unsigned int bufferSize=1)  Line 152 + 0x19\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::bufferData()  Line 190 + 0x2c\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::read(unsigned char * targetBuffer=0x017ff6f4, unsigned int targetBufferSize=4)  Line 125\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readAllData(unsigned char * buffer=0x017ff6f4, unsigned int length=4)  Line 369 + 0x21\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readInt()  Line 168\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream * dis=0x014dcbe8)  Line 218 + 0xd\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1a\tC++\n \tppl_worker_d.exe!activemq::transport::IOTransport::run()  Line 166 + 0x13\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dce40)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014ddd10)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 1896 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::wait(unsigned long millisecs=4294967295)  Line 178 + 0x10\tC++\n \tppl_worker_d.exe!activemq::concurrent::Mutex::wait()  Line 102 + 0xf\tC++\n \tppl_worker_d.exe!activemq::util::Queue<activemq::transport::Command *>::wait()  Line 206 + 0x11\tC++\n \tppl_worker_d.exe!activemq::transport::filters::AsyncSendTransport::run()  Line 118 + 0x11\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dcad0)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014dcd78)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock on transacted session\n\nDescription:\nI am implementing a request/response client and require the ability to do transactions. I initially created one connection with one session with a producer and a consumer. This worked fine when creating the session with Session::AUTO_ACKNOWLEDGE. When I changed this to use Session::SESSION_TRANSACTED\nwith session->commit() the application stopped working. To help work out the issue I created separate connections and sessions for the producer and consumer which did not help.\n\nLooking at the application in the debugger it looks like when session->commit() is called, a dead lock occurs.\n\nIn ActiveMQSessionExecutor::stop()  the following line is executed:\n\n        // Wakeup the thread so that it can acknowledge the stop request.\n        mutex.notifyAll();\n\nbut eventQ.size() is 0, that is no thread is notified. The next line is then executed:\n\n        // Wait for the thread to notify us that it has acknowledged\n        // the stop request.\n        mutex.wait();\n\nbut there is no other thread to ever come and wake it up, thus it hangs and the session is never committed.\n\nAm I using the API incorrectly or is this a real issue?\nNote this looks very similar to issue 155 https://issues.apache.org/activemq/browse/AMQCPP-155\n\nThread Summary\n--------------\n \t2000\tmain\t             tool::DefaultCounter::`scalar deleting destructor'\tNormal\t0\n \t1896\t_threadstartex\tactivemq::concurrent::Mutex::wait\t                       Normal\t0\n \t3984\t_threadstartex\tactivemq::network::SocketInputStream::read\t           Normal\t0\n>\t1544\t_threadstartex\tactivemq::concurrent::Mutex::notifyAll\t                       Normal\t0\n\nThread 1544 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::notifyAll()  Line 233\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::stop()  Line 150 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::stop()  Line 847 + 0x1b\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQTransaction::commit()  Line 205\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSession::commit()  Line 150 + 0x13\tC++\n \tppl_worker_d.exe!dist::TransactedConnector::onMessage(const cms::Message * message=0x014df8c0)  Line 176 + 0x30\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQConsumer::dispatch(activemq::core::DispatchData & data={...})  Line 429 + 0x3a\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatch(activemq::core::DispatchData & data={...})  Line 188 + 0x15\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::dispatchAll()  Line 273 + 0x11\tC++\n \tppl_worker_d.exe!activemq::core::ActiveMQSessionExecutor::run()  Line 213\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dc3e8)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014df798)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 3984 Stacktrace....\n>\tppl_worker_d.exe!activemq::network::SocketInputStream::read(unsigned char * buffer=0x014d8f70, unsigned int bufferSize=1)  Line 152 + 0x19\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::bufferData()  Line 190 + 0x2c\tC++\n \tppl_worker_d.exe!activemq::io::BufferedInputStream::read(unsigned char * targetBuffer=0x017ff6f4, unsigned int targetBufferSize=4)  Line 125\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readAllData(unsigned char * buffer=0x017ff6f4, unsigned int length=4)  Line 369 + 0x21\tC++\n \tppl_worker_d.exe!activemq::io::DataInputStream::readInt()  Line 168\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream * dis=0x014dcbe8)  Line 218 + 0xd\tC++\n \tppl_worker_d.exe!activemq::connector::openwire::OpenWireCommandReader::readCommand()  Line 71 + 0x1a\tC++\n \tppl_worker_d.exe!activemq::transport::IOTransport::run()  Line 166 + 0x13\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dce40)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014ddd10)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \t\n\nThread 1896 Stacktrace....\n>\tppl_worker_d.exe!activemq::concurrent::Mutex::wait(unsigned long millisecs=4294967295)  Line 178 + 0x10\tC++\n \tppl_worker_d.exe!activemq::concurrent::Mutex::wait()  Line 102 + 0xf\tC++\n \tppl_worker_d.exe!activemq::util::Queue<activemq::transport::Command *>::wait()  Line 206 + 0x11\tC++\n \tppl_worker_d.exe!activemq::transport::filters::AsyncSendTransport::run()  Line 118 + 0x11\tC++\n \tppl_worker_d.exe!activemq::concurrent::Thread::runCallback(void * param=0x014dcad0)  Line 152 + 0x13\tC++\n \tmsvcr71d.dll!_threadstartex(void * ptd=0x014dcd78)  Line 241 + 0xd\tC\n \tkernel32.dll!7c80b683() \n\nComments:\n", "classification": "Classify the issue 'Deadlock on transacted session' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-174?\nA: I am implementing a request/response client and require the ability to do transactions. I initially created one connection with one session with a producer and a consumer. This worked fine when creating the session with Session::AUTO_ACKNOWLEDGE. When I changed this to use Session::SESSION_TRANSACTED\nwith session->commit() the application stopped working. To help work out the issue I created separ"}}
{"issue_key": "AMQCPP-173", "project": "AMQCPP", "title": "C++ Client has memory leaks", "status": "Closed", "reporter": "John Urberg", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-04-07T16:46:23.000+0000", "updated": "2008-04-12T13:14:13.000+0000", "description": "I added memory debugging calls to the vs2005-activemq-example project.  When I ran it it produced a memory leak dump.  To recreate, do the following:\n\n1) Add the following to the top of main.cpp:\n#define CRTDBG_MAP_ALLOC\n#include <stdlib.h>\n#include <crtdbg.h>\n\n2) Add the following to the bottom of the main function:\n_CrtDumpMemoryLeaks();\n\n3) Run the application thru the debbugger\n\nThe output will display a memory leak dump similar to the one attached.", "comments": [], "text": "C++ Client has memory leaks\n\nDescription:\nI added memory debugging calls to the vs2005-activemq-example project.  When I ran it it produced a memory leak dump.  To recreate, do the following:\n\n1) Add the following to the top of main.cpp:\n#define CRTDBG_MAP_ALLOC\n#include <stdlib.h>\n#include <crtdbg.h>\n\n2) Add the following to the bottom of the main function:\n_CrtDumpMemoryLeaks();\n\n3) Run the application thru the debbugger\n\nThe output will display a memory leak dump similar to the one attached.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: C++ Client has memory leaks\n\nDescription:\nI added memory debugging calls to the vs2005-activemq-example project.  When I ran it it produced a memory leak dump.  To recreate, do the following:\n\n1) Add the following to the top of main.cpp:\n#define CRTDBG_MAP_ALLOC\n#include <stdlib.h>\n#include <crtdbg.h>\n\n2) Add the following to the bottom of the main function:\n_CrtDumpMemoryLeaks();\n\n3) Run the application thru the debbugger\n\nThe output will display a memory leak dump similar to the one attached.\n\n\nComments:\n", "classification": "Classify the issue 'C++ Client has memory leaks' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-173?\nA: I added memory debugging calls to the vs2005-activemq-example project.  When I ran it it produced a memory leak dump.  To recreate, do the following:\n\n1) Add the following to the top of main.cpp:\n#define CRTDBG_MAP_ALLOC\n#include <stdlib.h>\n#include <crtdbg.h>\n\n2) Add the following to the bottom of the main function:\n_CrtDumpMemoryLeaks();\n\n3) Run the application thru the debbugger\n\nThe output wil"}}
{"issue_key": "AMQCPP-172", "project": "AMQCPP", "title": "Add support for MAP_TYPE and LIST_TYPE to the PrimitiveMap implementation", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-03-07T12:30:35.000+0000", "updated": "2008-06-01T15:14:28.000+0000", "description": "Add support for the Map and List types to be stored and transmitted in a PrimitiveMap.", "comments": [], "text": "Add support for MAP_TYPE and LIST_TYPE to the PrimitiveMap implementation\n\nDescription:\nAdd support for the Map and List types to be stored and transmitted in a PrimitiveMap.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for MAP_TYPE and LIST_TYPE to the PrimitiveMap implementation\n\nDescription:\nAdd support for the Map and List types to be stored and transmitted in a PrimitiveMap.  \n\nComments:\n", "classification": "Classify the issue 'Add support for MAP_TYPE and LIST_TYPE to the PrimitiveMap implementation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-172?\nA: Add support for the Map and List types to be stored and transmitted in a PrimitiveMap.  "}}
{"issue_key": "AMQCPP-171", "project": "AMQCPP", "title": "futureResponse error when on a slow connection", "status": "Closed", "reporter": "John Coe", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-03-06T19:10:29.000+0000", "updated": "2008-03-07T00:49:34.000+0000", "description": "I am supporting an application that uses ActiveMQ, it is working fine, but we have now deployed it to a site that is using satellite communication. we now get a futureResponse error when we try to connect, I have seen other post that show this error when the systems are very busy. any suggestions ???\n2008-03-06 04:03:04 INFO:[ActiveMQProcessor]tcp://db1.prod1.nakika.tv:61616 ActiveMQProcessor send exception: response from futureResponse was invalid\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 153\n\tFILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 924\n\tFILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n2008-03-06 04:03:04 INFO:[TransmissionLayerManager]TransmissionLayerManager changes", "comments": [], "text": "futureResponse error when on a slow connection\n\nDescription:\nI am supporting an application that uses ActiveMQ, it is working fine, but we have now deployed it to a site that is using satellite communication. we now get a futureResponse error when we try to connect, I have seen other post that show this error when the systems are very busy. any suggestions ???\n2008-03-06 04:03:04 INFO:[ActiveMQProcessor]tcp://db1.prod1.nakika.tv:61616 ActiveMQProcessor send exception: response from futureResponse was invalid\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 153\n\tFILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 924\n\tFILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n2008-03-06 04:03:04 INFO:[TransmissionLayerManager]TransmissionLayerManager changes\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: futureResponse error when on a slow connection\n\nDescription:\nI am supporting an application that uses ActiveMQ, it is working fine, but we have now deployed it to a site that is using satellite communication. we now get a futureResponse error when we try to connect, I have seen other post that show this error when the systems are very busy. any suggestions ???\n2008-03-06 04:03:04 INFO:[ActiveMQProcessor]tcp://db1.prod1.nakika.tv:61616 ActiveMQProcessor send exception: response from futureResponse was invalid\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n\tFILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 153\n\tFILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1454\n\tFILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 924\n\tFILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n\tFILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n2008-03-06 04:03:04 INFO:[TransmissionLayerManager]TransmissionLayerManager changes\n\nComments:\n", "classification": "Classify the issue 'futureResponse error when on a slow connection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-171?\nA: I am supporting an application that uses ActiveMQ, it is working fine, but we have now deployed it to a site that is using satellite communication. we now get a futureResponse error when we try to connect, I have seen other post that show this error when the systems are very busy. any suggestions ???\n2008-03-06 04:03:04 INFO:[ActiveMQProcessor]tcp://db1.prod1.nakika.tv:61616 ActiveMQProcessor send"}}
{"issue_key": "AMQCPP-170", "project": "AMQCPP", "title": "SEGV in activemq::connector::openwire::OpenWireConnector::createProducer", "status": "Resolved", "reporter": "Ismail Mehdi", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-02-25T22:41:48.000+0000", "updated": "2008-02-26T00:37:31.000+0000", "description": "Client setup is a JMS client sending messages to a C++ process with a timeout. Under heavy load the C++ process does not reply fast enough and the  java client gives-up.\nIf the connection is dropped while the C++ is inside of OpenWireConnector::createProducer, an exception is thrown and the cleanup code causes a segv in:\nactivemq/connector/openwire/OpenWireConnector.cpp:752\n(this is for CMS 2.1)\n\nreproduced for 2.1.3 as well. line 679 for 2.1.3\n\nFix is pretty straightforward, do not delete the producerInfo twice. The first time it is done in producer should be sufficient. \nAlternatively, I imagine setting producerInfo to 0 once it is deleted would avoid the crash as well.", "comments": [], "text": "SEGV in activemq::connector::openwire::OpenWireConnector::createProducer\n\nDescription:\nClient setup is a JMS client sending messages to a C++ process with a timeout. Under heavy load the C++ process does not reply fast enough and the  java client gives-up.\nIf the connection is dropped while the C++ is inside of OpenWireConnector::createProducer, an exception is thrown and the cleanup code causes a segv in:\nactivemq/connector/openwire/OpenWireConnector.cpp:752\n(this is for CMS 2.1)\n\nreproduced for 2.1.3 as well. line 679 for 2.1.3\n\nFix is pretty straightforward, do not delete the producerInfo twice. The first time it is done in producer should be sufficient. \nAlternatively, I imagine setting producerInfo to 0 once it is deleted would avoid the crash as well.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SEGV in activemq::connector::openwire::OpenWireConnector::createProducer\n\nDescription:\nClient setup is a JMS client sending messages to a C++ process with a timeout. Under heavy load the C++ process does not reply fast enough and the  java client gives-up.\nIf the connection is dropped while the C++ is inside of OpenWireConnector::createProducer, an exception is thrown and the cleanup code causes a segv in:\nactivemq/connector/openwire/OpenWireConnector.cpp:752\n(this is for CMS 2.1)\n\nreproduced for 2.1.3 as well. line 679 for 2.1.3\n\nFix is pretty straightforward, do not delete the producerInfo twice. The first time it is done in producer should be sufficient. \nAlternatively, I imagine setting producerInfo to 0 once it is deleted would avoid the crash as well.\n\nComments:\n", "classification": "Classify the issue 'SEGV in activemq::connector::openwire::OpenWireConnector::createProducer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-170?\nA: Client setup is a JMS client sending messages to a C++ process with a timeout. Under heavy load the C++ process does not reply fast enough and the  java client gives-up.\nIf the connection is dropped while the C++ is inside of OpenWireConnector::createProducer, an exception is thrown and the cleanup code causes a segv in:\nactivemq/connector/openwire/OpenWireConnector.cpp:752\n(this is for CMS 2.1)\n\n"}}
{"issue_key": "AMQCPP-169", "project": "AMQCPP", "title": "Add a new Broker managment interface in ActiveMQ Core.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2008-02-21T16:36:39.000+0000", "updated": "2008-12-05T20:42:12.000+0000", "description": "It would be nice to add a new interface to the ActiveMQ core package that allowed as much Broker management as possible using CPP.  Some things can be accomplished over the openwire protocol like removing a destination from the Broker.  Its possible that we could add other command to the next openwire protocol such that the CPP client can have access to functionality similar to the java clients.", "comments": [], "text": "Add a new Broker managment interface in ActiveMQ Core.\n\nDescription:\nIt would be nice to add a new interface to the ActiveMQ core package that allowed as much Broker management as possible using CPP.  Some things can be accomplished over the openwire protocol like removing a destination from the Broker.  Its possible that we could add other command to the next openwire protocol such that the CPP client can have access to functionality similar to the java clients.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add a new Broker managment interface in ActiveMQ Core.\n\nDescription:\nIt would be nice to add a new interface to the ActiveMQ core package that allowed as much Broker management as possible using CPP.  Some things can be accomplished over the openwire protocol like removing a destination from the Broker.  Its possible that we could add other command to the next openwire protocol such that the CPP client can have access to functionality similar to the java clients.\n\nComments:\n", "classification": "Classify the issue 'Add a new Broker managment interface in ActiveMQ Core.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-169?\nA: It would be nice to add a new interface to the ActiveMQ core package that allowed as much Broker management as possible using CPP.  Some things can be accomplished over the openwire protocol like removing a destination from the Broker.  Its possible that we could add other command to the next openwire protocol such that the CPP client can have access to functionality similar to the java clients."}}
{"issue_key": "AMQCPP-168", "project": "AMQCPP", "title": "Create a connection can block for up to 4 mins under Linux when TCP socket connect() times out", "status": "Resolved", "reporter": "Olivier Langlois", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-02-14T20:21:21.000+0000", "updated": "2008-04-12T16:30:58.000+0000", "description": "With the following code:\n\n\t{\n\t\t// Create a ConnectionFactory\n\t\tstd::auto_ptr<cms::ConnectionFactory> pConnectionFactory(\n\t\t\tcms::ConnectionFactory::createCMSConnectionFactory( uri ) );\n\t\tm_pConnection.reset(pConnectionFactory->createConnection());\n\t\tm_pConnection->start();\n\t}\n\nThe call to createConnection() will block for up to 4 mins if the URI is a TCP address pointing to an unreachable host.\n\nIn my application, the time out interval is way too long. I would like to have it set to around 5 sec to 10 seconds.\n\nI could take care of the fix if you want as all that would be needed is make the socket non blocking only for the connect() call and manage the time out with a select(). The only indication I would need is how you ActiveMQ cms architects/designers would like the timeout specified to the API.\n\nUsing a new property (ie: \"connect-timeout\")\nhardcoding a small timeout value in TcpSocket\netc...", "comments": [], "text": "Create a connection can block for up to 4 mins under Linux when TCP socket connect() times out\n\nDescription:\nWith the following code:\n\n\t{\n\t\t// Create a ConnectionFactory\n\t\tstd::auto_ptr<cms::ConnectionFactory> pConnectionFactory(\n\t\t\tcms::ConnectionFactory::createCMSConnectionFactory( uri ) );\n\t\tm_pConnection.reset(pConnectionFactory->createConnection());\n\t\tm_pConnection->start();\n\t}\n\nThe call to createConnection() will block for up to 4 mins if the URI is a TCP address pointing to an unreachable host.\n\nIn my application, the time out interval is way too long. I would like to have it set to around 5 sec to 10 seconds.\n\nI could take care of the fix if you want as all that would be needed is make the socket non blocking only for the connect() call and manage the time out with a select(). The only indication I would need is how you ActiveMQ cms architects/designers would like the timeout specified to the API.\n\nUsing a new property (ie: \"connect-timeout\")\nhardcoding a small timeout value in TcpSocket\netc...\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create a connection can block for up to 4 mins under Linux when TCP socket connect() times out\n\nDescription:\nWith the following code:\n\n\t{\n\t\t// Create a ConnectionFactory\n\t\tstd::auto_ptr<cms::ConnectionFactory> pConnectionFactory(\n\t\t\tcms::ConnectionFactory::createCMSConnectionFactory( uri ) );\n\t\tm_pConnection.reset(pConnectionFactory->createConnection());\n\t\tm_pConnection->start();\n\t}\n\nThe call to createConnection() will block for up to 4 mins if the URI is a TCP address pointing to an unreachable host.\n\nIn my application, the time out interval is way too long. I would like to have it set to around 5 sec to 10 seconds.\n\nI could take care of the fix if you want as all that would be needed is make the socket non blocking only for the connect() call and manage the time out with a select(). The only indication I would need is how you ActiveMQ cms architects/designers would like the timeout specified to the API.\n\nUsing a new property (ie: \"connect-timeout\")\nhardcoding a small timeout value in TcpSocket\netc...\n\n\n\nComments:\n", "classification": "Classify the issue 'Create a connection can block for up to 4 mins under Linux when TCP socket connect() times out' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-168?\nA: With the following code:\n\n\t{\n\t\t// Create a ConnectionFactory\n\t\tstd::auto_ptr<cms::ConnectionFactory> pConnectionFactory(\n\t\t\tcms::ConnectionFactory::createCMSConnectionFactory( uri ) );\n\t\tm_pConnection.reset(pConnectionFactory->createConnection());\n\t\tm_pConnection->start();\n\t}\n\nThe call to createConnection() will block for up to 4 mins if the URI is a TCP address pointing to an unreachable host.\n\nI"}}
{"issue_key": "AMQCPP-167", "project": "AMQCPP", "title": "Client has memory leaks when used in an MFC application", "status": "Closed", "reporter": "John Urberg", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2008-02-11T14:17:34.000+0000", "updated": "2008-04-12T13:12:02.000+0000", "description": "I'm building an MFC application that uses the ActiveMQ CMS to communicate with an ActiveMQ server.  When I first introduced MFC into my project, I started getting \"Detected memory leaks!\" showing up in my output when debugging.  To verify this was due to ActiveMQ, I created a separate MFC console application and copied the code from the vs2005-activemq-example project into it and the memory leaks continued.  Running the example (non MFC) program that comes with the ActiveMQ distribution does not produce the memory leaks.\n\nTo reproduce:\n1) Create an MFC console application project\n2) Copy the code from the vs2005-activemq-example main.cpp into the new application file (see attached example)\n3) Modify stdafx.h to include debugging includes (example attached)\n\nYou will see a memory dump similar to the one in the attached file when you run the program.", "comments": [], "text": "Client has memory leaks when used in an MFC application\n\nDescription:\nI'm building an MFC application that uses the ActiveMQ CMS to communicate with an ActiveMQ server.  When I first introduced MFC into my project, I started getting \"Detected memory leaks!\" showing up in my output when debugging.  To verify this was due to ActiveMQ, I created a separate MFC console application and copied the code from the vs2005-activemq-example project into it and the memory leaks continued.  Running the example (non MFC) program that comes with the ActiveMQ distribution does not produce the memory leaks.\n\nTo reproduce:\n1) Create an MFC console application project\n2) Copy the code from the vs2005-activemq-example main.cpp into the new application file (see attached example)\n3) Modify stdafx.h to include debugging includes (example attached)\n\nYou will see a memory dump similar to the one in the attached file when you run the program.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Client has memory leaks when used in an MFC application\n\nDescription:\nI'm building an MFC application that uses the ActiveMQ CMS to communicate with an ActiveMQ server.  When I first introduced MFC into my project, I started getting \"Detected memory leaks!\" showing up in my output when debugging.  To verify this was due to ActiveMQ, I created a separate MFC console application and copied the code from the vs2005-activemq-example project into it and the memory leaks continued.  Running the example (non MFC) program that comes with the ActiveMQ distribution does not produce the memory leaks.\n\nTo reproduce:\n1) Create an MFC console application project\n2) Copy the code from the vs2005-activemq-example main.cpp into the new application file (see attached example)\n3) Modify stdafx.h to include debugging includes (example attached)\n\nYou will see a memory dump similar to the one in the attached file when you run the program.\n\nComments:\n", "classification": "Classify the issue 'Client has memory leaks when used in an MFC application' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-167?\nA: I'm building an MFC application that uses the ActiveMQ CMS to communicate with an ActiveMQ server.  When I first introduced MFC into my project, I started getting \"Detected memory leaks!\" showing up in my output when debugging.  To verify this was due to ActiveMQ, I created a separate MFC console application and copied the code from the vs2005-activemq-example project into it and the memory leaks "}}
{"issue_key": "AMQCPP-166", "project": "AMQCPP", "title": "MapMessage does not send mapped fields", "status": "Resolved", "reporter": "Thomas Johnson", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-02-06T13:32:56.000+0000", "updated": "2008-04-14T09:03:38.000+0000", "description": "Modified the vs2005-activemq-example's HelloWorldProducer to use a map message:\n\n\t\t\t\tMapMessage *message=session->createMapMessage();\n\t\t\t\tmessage->setInt(\"MsgNum\",ix);\n\t\t\t\tmessage->setString(\"Thread\",threadIdStr.c_str());\n                producer->send( message );\n\nand the HelloWorldConsumer to receive it:\n\n\t\t\tconst MapMessage * mapMessage=\n\t\t\t\tdynamic_cast<const MapMessage *>(message);\n\t\t\tif (mapMessage!=NULL) {\n\t\t\t\tint num=mapMessage->getInt(\"MsgNum\");\n\t\t\t\tprintf(\"Msg #%d from thread %s\\n\",num,mapMessage->getString(\"Thread\").c_str());\n\t\t\t} else {\n\t\t\t\tprintf(\"Not a map message\\n\");\n\t\t\t}\n\nThe getInt with Msgnum throw a field not in map exception.   After closer inspection, the map was empty.   Also, while not an expert in the code, but I tried tracing it through the producer->send and as far as I could tell, the map was never marshalled.", "comments": [], "text": "MapMessage does not send mapped fields\n\nDescription:\nModified the vs2005-activemq-example's HelloWorldProducer to use a map message:\n\n\t\t\t\tMapMessage *message=session->createMapMessage();\n\t\t\t\tmessage->setInt(\"MsgNum\",ix);\n\t\t\t\tmessage->setString(\"Thread\",threadIdStr.c_str());\n                producer->send( message );\n\nand the HelloWorldConsumer to receive it:\n\n\t\t\tconst MapMessage * mapMessage=\n\t\t\t\tdynamic_cast<const MapMessage *>(message);\n\t\t\tif (mapMessage!=NULL) {\n\t\t\t\tint num=mapMessage->getInt(\"MsgNum\");\n\t\t\t\tprintf(\"Msg #%d from thread %s\\n\",num,mapMessage->getString(\"Thread\").c_str());\n\t\t\t} else {\n\t\t\t\tprintf(\"Not a map message\\n\");\n\t\t\t}\n\nThe getInt with Msgnum throw a field not in map exception.   After closer inspection, the map was empty.   Also, while not an expert in the code, but I tried tracing it through the producer->send and as far as I could tell, the map was never marshalled.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: MapMessage does not send mapped fields\n\nDescription:\nModified the vs2005-activemq-example's HelloWorldProducer to use a map message:\n\n\t\t\t\tMapMessage *message=session->createMapMessage();\n\t\t\t\tmessage->setInt(\"MsgNum\",ix);\n\t\t\t\tmessage->setString(\"Thread\",threadIdStr.c_str());\n                producer->send( message );\n\nand the HelloWorldConsumer to receive it:\n\n\t\t\tconst MapMessage * mapMessage=\n\t\t\t\tdynamic_cast<const MapMessage *>(message);\n\t\t\tif (mapMessage!=NULL) {\n\t\t\t\tint num=mapMessage->getInt(\"MsgNum\");\n\t\t\t\tprintf(\"Msg #%d from thread %s\\n\",num,mapMessage->getString(\"Thread\").c_str());\n\t\t\t} else {\n\t\t\t\tprintf(\"Not a map message\\n\");\n\t\t\t}\n\nThe getInt with Msgnum throw a field not in map exception.   After closer inspection, the map was empty.   Also, while not an expert in the code, but I tried tracing it through the producer->send and as far as I could tell, the map was never marshalled.\n\n\nComments:\n", "classification": "Classify the issue 'MapMessage does not send mapped fields' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-166?\nA: Modified the vs2005-activemq-example's HelloWorldProducer to use a map message:\n\n\t\t\t\tMapMessage *message=session->createMapMessage();\n\t\t\t\tmessage->setInt(\"MsgNum\",ix);\n\t\t\t\tmessage->setString(\"Thread\",threadIdStr.c_str());\n                producer->send( message );\n\nand the HelloWorldConsumer to receive it:\n\n\t\t\tconst MapMessage * mapMessage=\n\t\t\t\tdynamic_cast<const MapMessage *>(message);\n\t\t\tif (map"}}
{"issue_key": "AMQCPP-165", "project": "AMQCPP", "title": "Core Dump on reconnect/open queue", "status": "Resolved", "reporter": "pfid", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-02-04T07:37:35.000+0000", "updated": "2008-08-31T23:58:26.000+0000", "description": "our activemq application core dumped several times during the last days when the connection to the broker was lost. each time it was either caused by the broker beeing restartet or write attempts failing (see exception below).\nin both cases the application catches a CMS exception, closes all queues and tries to re-open them after 60s. all activemq objects are destroyed after closing (see cleanup() from web example).\nthe core dumps seemed to happen when the application trys to re-open the connection, but fails because the broker is still unreachable. here is the backtrace:\n\n<quote>\n#0  activemq::connector::openwire::OpenWireConnector::closeResource (this=0x8b4a268, resource=0x8b4dde0) at activemq/connector/openwire/OpenWireConnector.cpp:1200\n#1  0x080da6fc in activemq::connector::BaseConnectorResource::close (this=0x8b4dde0) at activemq/connector/BaseConnectorResource.cpp:59\n#2  0x0812ff50 in ~OpenWireSessionInfo (this=0x8b4dde0) at OpenWireSessionInfo.h:56\n#3  0x0812d0c4 in activemq::connector::openwire::OpenWireConnector::createSession (this=0x8b4dde0, ackMode=cms::Session::AUTO_ACKNOWLEDGE)\n    at activemq/connector/openwire/OpenWireConnector.cpp:281\n#4  0x080e86c1 in activemq::core::ActiveMQConnection::createSession (this=0x8b4ded0, ackMode=137247624) at activemq/core/ActiveMQConnection.cpp:98\n#5  0x08059c19 in ActiveMqQueue::open (this=0x8b1d6b0, aQueueName=0x8ab925c \"outqueue\", aMode=ActiveMqQueue::modeWrite, aListenMode=0) at activemqqueue.cc:335\n</quote>\n\nDebuggin shows that at activemq/connector/openwire/OpenWireConnector.cpp:1200\n\n1200:  dataStructure = session->getSessionInfo()->getSessionId();\n\nthe session object is null, the previously dyn-casted resource object however is not null:\n\n<quote>\n(gdb) p session\n$1 = (activemq::connector::openwire::OpenWireSessionInfo *) 0x0\n(gdb) p resource\n$2 = (class activemq::connector::ConnectorResource *) 0x8b4dde0</quote>\n(corrupt memory?)\n\nException when write attempts fail:\n<quote>No valid response received for command: Begin Class = ActiveMQTextMessage Begin Class = ActiveMQMessageBase  Value of ackHandler = 0  Value of redeliveryCount = 0  Value of properties = Begin Class PrimitiveMap: Begin Class PrimitiveMap:  Begin Class = Message  Value of Message::ID_MESSAGE = 0  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of Destination is Below: Begin Class = ActiveMQQueue Begin Class = ActiveMQDestination  Value of exclusive = false  Value of ordered = false  Value of advisory = false  Value of orderedTarget = coordinator  Value of physicalName = ffs_out  Value of options = Begin Class activemq::util::Properties: End Class activemq::util::Properties:  No Data for Class BaseDataStructure End Class = ActiveMQDestination End Class = ActiveMQQueue   Value of TransactionId is Below:    Object is NULL  Value of OriginalDestination is Below:    Object is NULL  Value of MessageId is Below: Begin Class = MessageId  Value of MessageId::ID_MESSAGEID = 110  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of ProducerSequenceId = 4  Value of BrokerSequenceId = 0 No Data for Class BaseDataStructure End Class = MessageId   Value of OriginalTransactionId is Below:    Object is NULL  Value of GroupID =   Value of GroupSequence = 0  Value of CorrelationId =   Value of Persistent = 1  Value of Expiration = 1201683817204  Value of Priority = 4  Value of ReplyTo is Below:    Object is NULL  Value of Timestamp = 1201676617204  Value of Type =   Value of Content[0] = , check broker.</quote>\n\nVersions:\nActivemq-cpp-2.1.1\nActiveMq Broker 4.1.1\n\nthe application handles 17 write-mode queues, with a rather low messages/second rate.\nUsing 5.0.0 broker instead of 4.1.1 would most likely solve this problem, since the failed write attempts problem only occurs with 4.1.1 broker (i reported this bug before, but it seemed like no one was interested in taking care of it). however, the broker 5.0.0 won't start with preconfigured JAAS queues, so its not an option and we have to stick with 4.1.1. i will try the latest snapshot these days, however i dont feel good when using a snapshot server in production environment.", "comments": [], "text": "Core Dump on reconnect/open queue\n\nDescription:\nour activemq application core dumped several times during the last days when the connection to the broker was lost. each time it was either caused by the broker beeing restartet or write attempts failing (see exception below).\nin both cases the application catches a CMS exception, closes all queues and tries to re-open them after 60s. all activemq objects are destroyed after closing (see cleanup() from web example).\nthe core dumps seemed to happen when the application trys to re-open the connection, but fails because the broker is still unreachable. here is the backtrace:\n\n<quote>\n#0  activemq::connector::openwire::OpenWireConnector::closeResource (this=0x8b4a268, resource=0x8b4dde0) at activemq/connector/openwire/OpenWireConnector.cpp:1200\n#1  0x080da6fc in activemq::connector::BaseConnectorResource::close (this=0x8b4dde0) at activemq/connector/BaseConnectorResource.cpp:59\n#2  0x0812ff50 in ~OpenWireSessionInfo (this=0x8b4dde0) at OpenWireSessionInfo.h:56\n#3  0x0812d0c4 in activemq::connector::openwire::OpenWireConnector::createSession (this=0x8b4dde0, ackMode=cms::Session::AUTO_ACKNOWLEDGE)\n    at activemq/connector/openwire/OpenWireConnector.cpp:281\n#4  0x080e86c1 in activemq::core::ActiveMQConnection::createSession (this=0x8b4ded0, ackMode=137247624) at activemq/core/ActiveMQConnection.cpp:98\n#5  0x08059c19 in ActiveMqQueue::open (this=0x8b1d6b0, aQueueName=0x8ab925c \"outqueue\", aMode=ActiveMqQueue::modeWrite, aListenMode=0) at activemqqueue.cc:335\n</quote>\n\nDebuggin shows that at activemq/connector/openwire/OpenWireConnector.cpp:1200\n\n1200:  dataStructure = session->getSessionInfo()->getSessionId();\n\nthe session object is null, the previously dyn-casted resource object however is not null:\n\n<quote>\n(gdb) p session\n$1 = (activemq::connector::openwire::OpenWireSessionInfo *) 0x0\n(gdb) p resource\n$2 = (class activemq::connector::ConnectorResource *) 0x8b4dde0</quote>\n(corrupt memory?)\n\nException when write attempts fail:\n<quote>No valid response received for command: Begin Class = ActiveMQTextMessage Begin Class = ActiveMQMessageBase  Value of ackHandler = 0  Value of redeliveryCount = 0  Value of properties = Begin Class PrimitiveMap: Begin Class PrimitiveMap:  Begin Class = Message  Value of Message::ID_MESSAGE = 0  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of Destination is Below: Begin Class = ActiveMQQueue Begin Class = ActiveMQDestination  Value of exclusive = false  Value of ordered = false  Value of advisory = false  Value of orderedTarget = coordinator  Value of physicalName = ffs_out  Value of options = Begin Class activemq::util::Properties: End Class activemq::util::Properties:  No Data for Class BaseDataStructure End Class = ActiveMQDestination End Class = ActiveMQQueue   Value of TransactionId is Below:    Object is NULL  Value of OriginalDestination is Below:    Object is NULL  Value of MessageId is Below: Begin Class = MessageId  Value of MessageId::ID_MESSAGEID = 110  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of ProducerSequenceId = 4  Value of BrokerSequenceId = 0 No Data for Class BaseDataStructure End Class = MessageId   Value of OriginalTransactionId is Below:    Object is NULL  Value of GroupID =   Value of GroupSequence = 0  Value of CorrelationId =   Value of Persistent = 1  Value of Expiration = 1201683817204  Value of Priority = 4  Value of ReplyTo is Below:    Object is NULL  Value of Timestamp = 1201676617204  Value of Type =   Value of Content[0] = , check broker.</quote>\n\nVersions:\nActivemq-cpp-2.1.1\nActiveMq Broker 4.1.1\n\nthe application handles 17 write-mode queues, with a rather low messages/second rate.\nUsing 5.0.0 broker instead of 4.1.1 would most likely solve this problem, since the failed write attempts problem only occurs with 4.1.1 broker (i reported this bug before, but it seemed like no one was interested in taking care of it). however, the broker 5.0.0 won't start with preconfigured JAAS queues, so its not an option and we have to stick with 4.1.1. i will try the latest snapshot these days, however i dont feel good when using a snapshot server in production environment.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Core Dump on reconnect/open queue\n\nDescription:\nour activemq application core dumped several times during the last days when the connection to the broker was lost. each time it was either caused by the broker beeing restartet or write attempts failing (see exception below).\nin both cases the application catches a CMS exception, closes all queues and tries to re-open them after 60s. all activemq objects are destroyed after closing (see cleanup() from web example).\nthe core dumps seemed to happen when the application trys to re-open the connection, but fails because the broker is still unreachable. here is the backtrace:\n\n<quote>\n#0  activemq::connector::openwire::OpenWireConnector::closeResource (this=0x8b4a268, resource=0x8b4dde0) at activemq/connector/openwire/OpenWireConnector.cpp:1200\n#1  0x080da6fc in activemq::connector::BaseConnectorResource::close (this=0x8b4dde0) at activemq/connector/BaseConnectorResource.cpp:59\n#2  0x0812ff50 in ~OpenWireSessionInfo (this=0x8b4dde0) at OpenWireSessionInfo.h:56\n#3  0x0812d0c4 in activemq::connector::openwire::OpenWireConnector::createSession (this=0x8b4dde0, ackMode=cms::Session::AUTO_ACKNOWLEDGE)\n    at activemq/connector/openwire/OpenWireConnector.cpp:281\n#4  0x080e86c1 in activemq::core::ActiveMQConnection::createSession (this=0x8b4ded0, ackMode=137247624) at activemq/core/ActiveMQConnection.cpp:98\n#5  0x08059c19 in ActiveMqQueue::open (this=0x8b1d6b0, aQueueName=0x8ab925c \"outqueue\", aMode=ActiveMqQueue::modeWrite, aListenMode=0) at activemqqueue.cc:335\n</quote>\n\nDebuggin shows that at activemq/connector/openwire/OpenWireConnector.cpp:1200\n\n1200:  dataStructure = session->getSessionInfo()->getSessionId();\n\nthe session object is null, the previously dyn-casted resource object however is not null:\n\n<quote>\n(gdb) p session\n$1 = (activemq::connector::openwire::OpenWireSessionInfo *) 0x0\n(gdb) p resource\n$2 = (class activemq::connector::ConnectorResource *) 0x8b4dde0</quote>\n(corrupt memory?)\n\nException when write attempts fail:\n<quote>No valid response received for command: Begin Class = ActiveMQTextMessage Begin Class = ActiveMQMessageBase  Value of ackHandler = 0  Value of redeliveryCount = 0  Value of properties = Begin Class PrimitiveMap: Begin Class PrimitiveMap:  Begin Class = Message  Value of Message::ID_MESSAGE = 0  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of Destination is Below: Begin Class = ActiveMQQueue Begin Class = ActiveMQDestination  Value of exclusive = false  Value of ordered = false  Value of advisory = false  Value of orderedTarget = coordinator  Value of physicalName = ffs_out  Value of options = Begin Class activemq::util::Properties: End Class activemq::util::Properties:  No Data for Class BaseDataStructure End Class = ActiveMQDestination End Class = ActiveMQQueue   Value of TransactionId is Below:    Object is NULL  Value of OriginalDestination is Below:    Object is NULL  Value of MessageId is Below: Begin Class = MessageId  Value of MessageId::ID_MESSAGEID = 110  Value of ProducerId is Below: Begin Class = ProducerId  Value of ProducerId::ID_PRODUCERID = 123  Value of ConnectionId = 0c00f32b-2269-4e0f-ace1-13fd0414b4b5  Value of Value = 0  Value of SessionId = 0 No Data for Class BaseDataStructure End Class = ProducerId   Value of ProducerSequenceId = 4  Value of BrokerSequenceId = 0 No Data for Class BaseDataStructure End Class = MessageId   Value of OriginalTransactionId is Below:    Object is NULL  Value of GroupID =   Value of GroupSequence = 0  Value of CorrelationId =   Value of Persistent = 1  Value of Expiration = 1201683817204  Value of Priority = 4  Value of ReplyTo is Below:    Object is NULL  Value of Timestamp = 1201676617204  Value of Type =   Value of Content[0] = , check broker.</quote>\n\nVersions:\nActivemq-cpp-2.1.1\nActiveMq Broker 4.1.1\n\nthe application handles 17 write-mode queues, with a rather low messages/second rate.\nUsing 5.0.0 broker instead of 4.1.1 would most likely solve this problem, since the failed write attempts problem only occurs with 4.1.1 broker (i reported this bug before, but it seemed like no one was interested in taking care of it). however, the broker 5.0.0 won't start with preconfigured JAAS queues, so its not an option and we have to stick with 4.1.1. i will try the latest snapshot these days, however i dont feel good when using a snapshot server in production environment.\n\nComments:\n", "classification": "Classify the issue 'Core Dump on reconnect/open queue' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-165?\nA: our activemq application core dumped several times during the last days when the connection to the broker was lost. each time it was either caused by the broker beeing restartet or write attempts failing (see exception below).\nin both cases the application catches a CMS exception, closes all queues and tries to re-open them after 60s. all activemq objects are destroyed after closing (see cleanup()"}}
{"issue_key": "AMQCPP-164", "project": "AMQCPP", "title": "Math functions don't all exist on the windows platform", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-02-03T22:55:52.000+0000", "updated": "2008-04-15T15:06:58.000+0000", "description": "Some of the Math functions that we use in the decaf lib don't seem to be supported on windows even though they are C99 functions.  So we need to find an alternative source for them on windows such as fdlibm", "comments": [], "text": "Math functions don't all exist on the windows platform\n\nDescription:\nSome of the Math functions that we use in the decaf lib don't seem to be supported on windows even though they are C99 functions.  So we need to find an alternative source for them on windows such as fdlibm\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Math functions don't all exist on the windows platform\n\nDescription:\nSome of the Math functions that we use in the decaf lib don't seem to be supported on windows even though they are C99 functions.  So we need to find an alternative source for them on windows such as fdlibm\n\n\nComments:\n", "classification": "Classify the issue 'Math functions don't all exist on the windows platform' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-164?\nA: Some of the Math functions that we use in the decaf lib don't seem to be supported on windows even though they are C99 functions.  So we need to find an alternative source for them on windows such as fdlibm\n"}}
{"issue_key": "AMQCPP-12", "project": "AMQCPP", "title": "Modified pom.xml for VS .net 2003 compilation", "status": "Resolved", "reporter": "Lalit Nagpal", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-09-13T20:34:46.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "The following tag \n        <activeByDefault>true</activeByDefault>\nwas moved from the profile release to profile debug\n\nThe following switch was added in the <compiler.options> for both debug and release\n/GR", "comments": [], "text": "Modified pom.xml for VS .net 2003 compilation\n\nDescription:\nThe following tag \n        <activeByDefault>true</activeByDefault>\nwas moved from the profile release to profile debug\n\nThe following switch was added in the <compiler.options> for both debug and release\n/GR \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Modified pom.xml for VS .net 2003 compilation\n\nDescription:\nThe following tag \n        <activeByDefault>true</activeByDefault>\nwas moved from the profile release to profile debug\n\nThe following switch was added in the <compiler.options> for both debug and release\n/GR \n\n\n\nComments:\n", "classification": "Classify the issue 'Modified pom.xml for VS .net 2003 compilation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-12?\nA: The following tag \n        <activeByDefault>true</activeByDefault>\nwas moved from the profile release to profile debug\n\nThe following switch was added in the <compiler.options> for both debug and release\n/GR \n\n"}}
{"issue_key": "AMQCPP-11", "project": "AMQCPP", "title": "Update to activemq-cpp source to enable documentation generation", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2006-08-01T14:49:41.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "This patch contains updated source files for the activemq-cpp project which expand the code documentation and clean up documentation that caused warnings when running the doxygen tool to document the code.  A set of generated documentation files is included in the new docs folder.  \n\nThis patch adds no new functionality.", "comments": [], "text": "Update to activemq-cpp source to enable documentation generation\n\nDescription:\nThis patch contains updated source files for the activemq-cpp project which expand the code documentation and clean up documentation that caused warnings when running the doxygen tool to document the code.  A set of generated documentation files is included in the new docs folder.  \n\nThis patch adds no new functionality.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update to activemq-cpp source to enable documentation generation\n\nDescription:\nThis patch contains updated source files for the activemq-cpp project which expand the code documentation and clean up documentation that caused warnings when running the doxygen tool to document the code.  A set of generated documentation files is included in the new docs folder.  \n\nThis patch adds no new functionality.\n\nComments:\n", "classification": "Classify the issue 'Update to activemq-cpp source to enable documentation generation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-11?\nA: This patch contains updated source files for the activemq-cpp project which expand the code documentation and clean up documentation that caused warnings when running the doxygen tool to document the code.  A set of generated documentation files is included in the new docs folder.  \n\nThis patch adds no new functionality."}}
{"issue_key": "AMQCPP-10", "project": "AMQCPP", "title": "Compiling fails under SuSe", "status": "Resolved", "reporter": "Tomas Lebovic", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-10-11T17:48:22.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "Hi,\n\nHas anyone been able to compile the latest source under linux? The reason i ask is there are some major issues (or is it just me) with paths/filenames:\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormatFactory.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormatFactory.cpp:18:63: activemq/connector/openwire/OpenwireFormatFactory.h: No such file or directory\n\nthe reason for this is the file is not actually named OpenwireFormatFactory.h but OpenWireFormatFactory.h notice the capital W. hence *nix system doesn't pick it up. Same goes for OpenWireFormat.h header file\n\nNext Issue.\n\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:36:70: activemq/connector/openwire/marshal/v2/MarshallerFactory.h: No such file or directory\n\nonce again this is due the refrence being v2 but under the file system its actually V2.\n\nNext issue:\n\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormat.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp: In member function `\n   activemq::connector::openwire::commands::DataStructure*\n   activemq::connector::openwire::OpenWireFormat::tightUnmarshalNestedObject(activemq::io::DataInputStream*,\n   activemq::connector::openwire::utils::BooleanStream*)':\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: `byte'\n   undeclared (first use this function)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: (Each\n   undeclared identifier is reported only once for each function it appears\n   in.)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: syntax\n   error before `=' token\nsrc/main/activemq/connector/openwire/Ope\n\nNow either im doing something wrong and hopefully thats the case. But can someone please post some more detailed instructions on the building process of the lib under linux?", "comments": [], "text": "Compiling fails under SuSe\n\nDescription:\nHi,\n\nHas anyone been able to compile the latest source under linux? The reason i ask is there are some major issues (or is it just me) with paths/filenames:\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormatFactory.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormatFactory.cpp:18:63: activemq/connector/openwire/OpenwireFormatFactory.h: No such file or directory\n\nthe reason for this is the file is not actually named OpenwireFormatFactory.h but OpenWireFormatFactory.h notice the capital W. hence *nix system doesn't pick it up. Same goes for OpenWireFormat.h header file\n\nNext Issue.\n\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:36:70: activemq/connector/openwire/marshal/v2/MarshallerFactory.h: No such file or directory\n\nonce again this is due the refrence being v2 but under the file system its actually V2.\n\nNext issue:\n\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormat.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp: In member function `\n   activemq::connector::openwire::commands::DataStructure*\n   activemq::connector::openwire::OpenWireFormat::tightUnmarshalNestedObject(activemq::io::DataInputStream*,\n   activemq::connector::openwire::utils::BooleanStream*)':\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: `byte'\n   undeclared (first use this function)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: (Each\n   undeclared identifier is reported only once for each function it appears\n   in.)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: syntax\n   error before `=' token\nsrc/main/activemq/connector/openwire/Ope\n\nNow either im doing something wrong and hopefully thats the case. But can someone please post some more detailed instructions on the building process of the lib under linux?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compiling fails under SuSe\n\nDescription:\nHi,\n\nHas anyone been able to compile the latest source under linux? The reason i ask is there are some major issues (or is it just me) with paths/filenames:\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormatFactory.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormatFactory.cpp:18:63: activemq/connector/openwire/OpenwireFormatFactory.h: No such file or directory\n\nthe reason for this is the file is not actually named OpenwireFormatFactory.h but OpenWireFormatFactory.h notice the capital W. hence *nix system doesn't pick it up. Same goes for OpenWireFormat.h header file\n\nNext Issue.\n\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:36:70: activemq/connector/openwire/marshal/v2/MarshallerFactory.h: No such file or directory\n\nonce again this is due the refrence being v2 but under the file system its actually V2.\n\nNext issue:\n\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormat.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp: In member function `\n   activemq::connector::openwire::commands::DataStructure*\n   activemq::connector::openwire::OpenWireFormat::tightUnmarshalNestedObject(activemq::io::DataInputStream*,\n   activemq::connector::openwire::utils::BooleanStream*)':\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: `byte'\n   undeclared (first use this function)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: (Each\n   undeclared identifier is reported only once for each function it appears\n   in.)\nsrc/main/activemq/connector/openwire/OpenWireFormat.cpp:344: error: syntax\n   error before `=' token\nsrc/main/activemq/connector/openwire/Ope\n\nNow either im doing something wrong and hopefully thats the case. But can someone please post some more detailed instructions on the building process of the lib under linux?\n\nComments:\n", "classification": "Classify the issue 'Compiling fails under SuSe' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-10?\nA: Hi,\n\nHas anyone been able to compile the latest source under linux? The reason i ask is there are some major issues (or is it just me) with paths/filenames:\n- g++ -frtti -pthread -O3 -DNDEBUG -D_REENTRANT 'src/main/activemq/connector/openwire/OpenWireFormatFactory.cpp'\nsrc/main/activemq/connector/openwire/OpenWireFormatFactory.cpp:18:63: activemq/connector/openwire/OpenwireFormatFactory.h: No such"}}
{"issue_key": "AMQCPP-9", "project": "AMQCPP", "title": "The Activemq-cpp example code no longer builds.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2006-08-11T12:20:24.000+0000", "updated": "2006-11-17T16:56:53.000+0000", "description": "Code in the Activemq-cpp example is no longer up to date with the latest version.  We need to clean this code up to match the samll changes in the CMS interface.", "comments": [], "text": "The Activemq-cpp example code no longer builds.\n\nDescription:\nCode in the Activemq-cpp example is no longer up to date with the latest version.  We need to clean this code up to match the samll changes in the CMS interface.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The Activemq-cpp example code no longer builds.\n\nDescription:\nCode in the Activemq-cpp example is no longer up to date with the latest version.  We need to clean this code up to match the samll changes in the CMS interface.\n\nComments:\n", "classification": "Classify the issue 'The Activemq-cpp example code no longer builds.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-9?\nA: Code in the Activemq-cpp example is no longer up to date with the latest version.  We need to clean this code up to match the samll changes in the CMS interface."}}
{"issue_key": "AMQCPP-8", "project": "AMQCPP", "title": "Code Drop for Version 0.0.2 of the activemq-cpp library", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-07-12T19:32:22.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "This issues addresses the code drop for Revision 0.0.2 of the ActiveMQ CPP library.  Changes are listed below.  \n\nNew Features:\n\n    * Destinations now support the Destination Options shown here:  http://www.activemq.org/site/destination-options.html\n\nAdditional Changes\n\n    * Extensive code cleanup, including expanded Java DOC comments and more consistant formatting.\n    * Memory leak checking with Rational Purify were done and several small leaks were fixed.\n    * Added additional Unit tests for new functionality, and additional tests for existing feature correctness\n    * Minor bug fixes\n\nKnown Issues\n\n    * Unchanged from version 0.0.1", "comments": [], "text": "Code Drop for Version 0.0.2 of the activemq-cpp library\n\nDescription:\nThis issues addresses the code drop for Revision 0.0.2 of the ActiveMQ CPP library.  Changes are listed below.  \n\nNew Features:\n\n    * Destinations now support the Destination Options shown here:  http://www.activemq.org/site/destination-options.html\n\nAdditional Changes\n\n    * Extensive code cleanup, including expanded Java DOC comments and more consistant formatting.\n    * Memory leak checking with Rational Purify were done and several small leaks were fixed.\n    * Added additional Unit tests for new functionality, and additional tests for existing feature correctness\n    * Minor bug fixes\n\nKnown Issues\n\n    * Unchanged from version 0.0.1 \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Code Drop for Version 0.0.2 of the activemq-cpp library\n\nDescription:\nThis issues addresses the code drop for Revision 0.0.2 of the ActiveMQ CPP library.  Changes are listed below.  \n\nNew Features:\n\n    * Destinations now support the Destination Options shown here:  http://www.activemq.org/site/destination-options.html\n\nAdditional Changes\n\n    * Extensive code cleanup, including expanded Java DOC comments and more consistant formatting.\n    * Memory leak checking with Rational Purify were done and several small leaks were fixed.\n    * Added additional Unit tests for new functionality, and additional tests for existing feature correctness\n    * Minor bug fixes\n\nKnown Issues\n\n    * Unchanged from version 0.0.1 \n\n\nComments:\n", "classification": "Classify the issue 'Code Drop for Version 0.0.2 of the activemq-cpp library' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-8?\nA: This issues addresses the code drop for Revision 0.0.2 of the ActiveMQ CPP library.  Changes are listed below.  \n\nNew Features:\n\n    * Destinations now support the Destination Options shown here:  http://www.activemq.org/site/destination-options.html\n\nAdditional Changes\n\n    * Extensive code cleanup, including expanded Java DOC comments and more consistant formatting.\n    * Memory leak checking wi"}}
{"issue_key": "AMQCPP-7", "project": "AMQCPP", "title": "ActiveMQ Cpp Windows Makefiles fail to link the test, and test-integration targets", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2006-07-05T22:26:35.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "The windows makefiles for the MinGW targets fail to link the test and test-integration targets.\n\nWhen the code was submitted the makefiles were changed to build the library with the libactivemq-cpp.a name, but the windows makefiles still try and link the tests against libactivemq.a", "comments": [], "text": "ActiveMQ Cpp Windows Makefiles fail to link the test, and test-integration targets\n\nDescription:\nThe windows makefiles for the MinGW targets fail to link the test and test-integration targets.\n\nWhen the code was submitted the makefiles were changed to build the library with the libactivemq-cpp.a name, but the windows makefiles still try and link the tests against libactivemq.a\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ Cpp Windows Makefiles fail to link the test, and test-integration targets\n\nDescription:\nThe windows makefiles for the MinGW targets fail to link the test and test-integration targets.\n\nWhen the code was submitted the makefiles were changed to build the library with the libactivemq-cpp.a name, but the windows makefiles still try and link the tests against libactivemq.a\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ Cpp Windows Makefiles fail to link the test, and test-integration targets' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-7?\nA: The windows makefiles for the MinGW targets fail to link the test and test-integration targets.\n\nWhen the code was submitted the makefiles were changed to build the library with the libactivemq-cpp.a name, but the windows makefiles still try and link the tests against libactivemq.a"}}
{"issue_key": "AMQCPP-6", "project": "AMQCPP", "title": "add createDurableSubscriber() methods to Session.h", "status": "Resolved", "reporter": "James Strachan", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-06-29T19:41:10.000+0000", "updated": "2006-11-17T16:56:53.000+0000", "description": "e.g.\n\nhttp://java.sun.com/j2ee/1.4/docs/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic,%20java.lang.String)", "comments": [], "text": "add createDurableSubscriber() methods to Session.h\n\nDescription:\ne.g.\n\nhttp://java.sun.com/j2ee/1.4/docs/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic,%20java.lang.String)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: add createDurableSubscriber() methods to Session.h\n\nDescription:\ne.g.\n\nhttp://java.sun.com/j2ee/1.4/docs/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic,%20java.lang.String)\n\nComments:\n", "classification": "Classify the issue 'add createDurableSubscriber() methods to Session.h' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-6?\nA: e.g.\n\nhttp://java.sun.com/j2ee/1.4/docs/api/javax/jms/Session.html#createDurableSubscriber(javax.jms.Topic,%20java.lang.String)"}}
{"issue_key": "AMQCPP-5", "project": "AMQCPP", "title": "Make Session.h more polymorphic like JMS 1.1 with createProducer/createConsumer methods on Session.h", "status": "Resolved", "reporter": "James Strachan", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-06-29T19:38:36.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "", "comments": [], "text": "Make Session.h more polymorphic like JMS 1.1 with createProducer/createConsumer methods on Session.h\n\nDescription:\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Make Session.h more polymorphic like JMS 1.1 with createProducer/createConsumer methods on Session.h\n\nDescription:\n\n\nComments:\n", "classification": "Classify the issue 'Make Session.h more polymorphic like JMS 1.1 with createProducer/createConsumer methods on Session.h' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-5?\nA: "}}
{"issue_key": "AMQCPP-4", "project": "AMQCPP", "title": "Compilation warning under windows for activemq-cpp", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2006-10-28T20:59:59.000+0000", "updated": "2006-11-17T16:56:53.000+0000", "description": "Under Windows, the following warning gets printed out:\n\nc:\\ActiveMQ\\activemq\\connector\\stomp\\commands\\AckCommand.h(102) : warning\nC4390: ';' : empty controlled statement found;", "comments": [], "text": "Compilation warning under windows for activemq-cpp\n\nDescription:\nUnder Windows, the following warning gets printed out:\n\nc:\\ActiveMQ\\activemq\\connector\\stomp\\commands\\AckCommand.h(102) : warning\nC4390: ';' : empty controlled statement found;\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compilation warning under windows for activemq-cpp\n\nDescription:\nUnder Windows, the following warning gets printed out:\n\nc:\\ActiveMQ\\activemq\\connector\\stomp\\commands\\AckCommand.h(102) : warning\nC4390: ';' : empty controlled statement found;\n\nComments:\n", "classification": "Classify the issue 'Compilation warning under windows for activemq-cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-4?\nA: Under Windows, the following warning gets printed out:\n\nc:\\ActiveMQ\\activemq\\connector\\stomp\\commands\\AckCommand.h(102) : warning\nC4390: ';' : empty controlled statement found;"}}
{"issue_key": "AMQCPP-3", "project": "AMQCPP", "title": "Receiving a  BytesMessage sent from Java using CMS listener causes exception thrown in class BufferedInputStream", "status": "Resolved", "reporter": "Mark Silberbauer", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-10-30T07:26:19.000+0000", "updated": "2006-12-04T22:59:52.000+0000", "description": "1) Setup a MessageListener to listen for messages on Topic X using CMS.\n2) Send a BytesMessage from ActiveMQ java JMS interface to Topic X\n3) An exception is thrown from BufferedInputStream::bufferData() with description \"failed reading bytes from stream\"\"\n\n    int bytesRead = stream->read( buffer+tail, bufferSize-tail );\n\n    if( bytesRead == 0 ){\n\n        throw IOException( __FILE__, __LINE__, \n\n            \"BufferedInputStream::read() - failed reading bytes from stream\");\n\n    }\n4) The operation of the CMS interface is broken thereafter.\n\nNote:\nThis only occurs when sending a BytesMessage from Java to C++\n\nSending a BytesMessage from C++ to Java or  C++ to C++ works perfectly.\nSending messages of Type TextMessage also works perfectly.", "comments": [], "text": "Receiving a  BytesMessage sent from Java using CMS listener causes exception thrown in class BufferedInputStream\n\nDescription:\n1) Setup a MessageListener to listen for messages on Topic X using CMS.\n2) Send a BytesMessage from ActiveMQ java JMS interface to Topic X\n3) An exception is thrown from BufferedInputStream::bufferData() with description \"failed reading bytes from stream\"\"\n\n    int bytesRead = stream->read( buffer+tail, bufferSize-tail );\n\n    if( bytesRead == 0 ){\n\n        throw IOException( __FILE__, __LINE__, \n\n            \"BufferedInputStream::read() - failed reading bytes from stream\");\n\n    }\n4) The operation of the CMS interface is broken thereafter.\n\nNote:\nThis only occurs when sending a BytesMessage from Java to C++\n\nSending a BytesMessage from C++ to Java or  C++ to C++ works perfectly.\nSending messages of Type TextMessage also works perfectly.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Receiving a  BytesMessage sent from Java using CMS listener causes exception thrown in class BufferedInputStream\n\nDescription:\n1) Setup a MessageListener to listen for messages on Topic X using CMS.\n2) Send a BytesMessage from ActiveMQ java JMS interface to Topic X\n3) An exception is thrown from BufferedInputStream::bufferData() with description \"failed reading bytes from stream\"\"\n\n    int bytesRead = stream->read( buffer+tail, bufferSize-tail );\n\n    if( bytesRead == 0 ){\n\n        throw IOException( __FILE__, __LINE__, \n\n            \"BufferedInputStream::read() - failed reading bytes from stream\");\n\n    }\n4) The operation of the CMS interface is broken thereafter.\n\nNote:\nThis only occurs when sending a BytesMessage from Java to C++\n\nSending a BytesMessage from C++ to Java or  C++ to C++ works perfectly.\nSending messages of Type TextMessage also works perfectly.\n\n\nComments:\n", "classification": "Classify the issue 'Receiving a  BytesMessage sent from Java using CMS listener causes exception thrown in class BufferedInputStream' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-3?\nA: 1) Setup a MessageListener to listen for messages on Topic X using CMS.\n2) Send a BytesMessage from ActiveMQ java JMS interface to Topic X\n3) An exception is thrown from BufferedInputStream::bufferData() with description \"failed reading bytes from stream\"\"\n\n    int bytesRead = stream->read( buffer+tail, bufferSize-tail );\n\n    if( bytesRead == 0 ){\n\n        throw IOException( __FILE__, __LINE__, \n"}}
{"issue_key": "AMQCPP-2", "project": "AMQCPP", "title": "Release build of ActiveMQ-CPP from trunk with Visual Studio 2005 fails due to Windows headers include order issue", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-11-02T11:32:29.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "Doing a release build of ActiveMQ-CPP from trunk with Visual Studio 2005 results in the following error when compiling DataInputStreamTest.cpp:\n\n{quote}\n1>------ Build started: Project: vc2005-activemq-unittests, Configuration: Release Win32 ------\n1>Compiling...\n1>DataInputStreamTest.cpp\n1>f:\\activemq-cpp\\src\\main\\activemq/io/ByteArrayInputStream.h(142) : warning C4244: 'return' : conversion from '__w64 int' to 'int', possible loss of data\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(112) : error C2011: 'fd_set' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(54) : see declaration of 'fd_set'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(147) : warning C4005: 'FD_SET' : macro redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(88) : see previous definition of 'FD_SET'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(156) : error C2011: 'timeval' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(97) : see declaration of 'timeval'\n...\n{quote}\n\nThis error happens when some combination of winsock.h, winsock2.h and windows.h is included in the wrong order. The following change fixes the problem and might provide some clue as to what is going on.\n\n{quote}\nIndex: DataInputStreamTest.h\n===================================================================\n--- DataInputStreamTest.h       (revision 470321)\n+++ DataInputStreamTest.h       (working copy)\n@@ -21,10 +21,10 @@\n #include <cppunit/TestFixture.h>\n #include <cppunit/extensions/HelperMacros.h>\n\n+#include <activemq/util/Endian.h>\n #include <activemq/exceptions/ActiveMQException.h>\n #include <activemq/io/BufferedInputStream.h>\n #include <activemq/io/ByteArrayInputStream.h>\n-#include <activemq/util/Endian.h>\n #include <activemq/io/DataInputStream.h>\n\n #ifdef min\n{quote}", "comments": [], "text": "Release build of ActiveMQ-CPP from trunk with Visual Studio 2005 fails due to Windows headers include order issue\n\nDescription:\nDoing a release build of ActiveMQ-CPP from trunk with Visual Studio 2005 results in the following error when compiling DataInputStreamTest.cpp:\n\n{quote}\n1>------ Build started: Project: vc2005-activemq-unittests, Configuration: Release Win32 ------\n1>Compiling...\n1>DataInputStreamTest.cpp\n1>f:\\activemq-cpp\\src\\main\\activemq/io/ByteArrayInputStream.h(142) : warning C4244: 'return' : conversion from '__w64 int' to 'int', possible loss of data\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(112) : error C2011: 'fd_set' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(54) : see declaration of 'fd_set'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(147) : warning C4005: 'FD_SET' : macro redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(88) : see previous definition of 'FD_SET'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(156) : error C2011: 'timeval' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(97) : see declaration of 'timeval'\n...\n{quote}\n\nThis error happens when some combination of winsock.h, winsock2.h and windows.h is included in the wrong order. The following change fixes the problem and might provide some clue as to what is going on.\n\n{quote}\nIndex: DataInputStreamTest.h\n===================================================================\n--- DataInputStreamTest.h       (revision 470321)\n+++ DataInputStreamTest.h       (working copy)\n@@ -21,10 +21,10 @@\n #include <cppunit/TestFixture.h>\n #include <cppunit/extensions/HelperMacros.h>\n\n+#include <activemq/util/Endian.h>\n #include <activemq/exceptions/ActiveMQException.h>\n #include <activemq/io/BufferedInputStream.h>\n #include <activemq/io/ByteArrayInputStream.h>\n-#include <activemq/util/Endian.h>\n #include <activemq/io/DataInputStream.h>\n\n #ifdef min\n{quote}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Release build of ActiveMQ-CPP from trunk with Visual Studio 2005 fails due to Windows headers include order issue\n\nDescription:\nDoing a release build of ActiveMQ-CPP from trunk with Visual Studio 2005 results in the following error when compiling DataInputStreamTest.cpp:\n\n{quote}\n1>------ Build started: Project: vc2005-activemq-unittests, Configuration: Release Win32 ------\n1>Compiling...\n1>DataInputStreamTest.cpp\n1>f:\\activemq-cpp\\src\\main\\activemq/io/ByteArrayInputStream.h(142) : warning C4244: 'return' : conversion from '__w64 int' to 'int', possible loss of data\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(112) : error C2011: 'fd_set' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(54) : see declaration of 'fd_set'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(147) : warning C4005: 'FD_SET' : macro redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(88) : see previous definition of 'FD_SET'\n1>C:\\Program Files\\Microsoft Platform SDK\\Include\\Winsock2.h(156) : error C2011: 'timeval' : 'struct' type redefinition\n1>        C:\\Program Files\\Microsoft Platform SDK\\Include\\winsock.h(97) : see declaration of 'timeval'\n...\n{quote}\n\nThis error happens when some combination of winsock.h, winsock2.h and windows.h is included in the wrong order. The following change fixes the problem and might provide some clue as to what is going on.\n\n{quote}\nIndex: DataInputStreamTest.h\n===================================================================\n--- DataInputStreamTest.h       (revision 470321)\n+++ DataInputStreamTest.h       (working copy)\n@@ -21,10 +21,10 @@\n #include <cppunit/TestFixture.h>\n #include <cppunit/extensions/HelperMacros.h>\n\n+#include <activemq/util/Endian.h>\n #include <activemq/exceptions/ActiveMQException.h>\n #include <activemq/io/BufferedInputStream.h>\n #include <activemq/io/ByteArrayInputStream.h>\n-#include <activemq/util/Endian.h>\n #include <activemq/io/DataInputStream.h>\n\n #ifdef min\n{quote}\n\nComments:\n", "classification": "Classify the issue 'Release build of ActiveMQ-CPP from trunk with Visual Studio 2005 fails due to Windows headers include order issue' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-2?\nA: Doing a release build of ActiveMQ-CPP from trunk with Visual Studio 2005 results in the following error when compiling DataInputStreamTest.cpp:\n\n{quote}\n1>------ Build started: Project: vc2005-activemq-unittests, Configuration: Release Win32 ------\n1>Compiling...\n1>DataInputStreamTest.cpp\n1>f:\\activemq-cpp\\src\\main\\activemq/io/ByteArrayInputStream.h(142) : warning C4244: 'return' : conversion from"}}
{"issue_key": "AMQCPP-1", "project": "AMQCPP", "title": "host_os env variable is empty in configure.ac", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Unassigned", "priority": "Minor", "labels": [], "created": "2006-11-04T22:58:56.000+0000", "updated": "2006-11-17T16:56:53.000+0000", "description": "The host_os environment variable is undefined when executing the configure.ac file.  As a result, the switch on os_host doesn't execute properly.  This seems to be fixed (at least on linux) by adding AC_CANONICAL_HOST at the top of the file.", "comments": [], "text": "host_os env variable is empty in configure.ac\n\nDescription:\nThe host_os environment variable is undefined when executing the configure.ac file.  As a result, the switch on os_host doesn't execute properly.  This seems to be fixed (at least on linux) by adding AC_CANONICAL_HOST at the top of the file.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: host_os env variable is empty in configure.ac\n\nDescription:\nThe host_os environment variable is undefined when executing the configure.ac file.  As a result, the switch on os_host doesn't execute properly.  This seems to be fixed (at least on linux) by adding AC_CANONICAL_HOST at the top of the file.\n\nComments:\n", "classification": "Classify the issue 'host_os env variable is empty in configure.ac' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-1?\nA: The host_os environment variable is undefined when executing the configure.ac file.  As a result, the switch on os_host doesn't execute properly.  This seems to be fixed (at least on linux) by adding AC_CANONICAL_HOST at the top of the file."}}
{"issue_key": "AMQCPP-113", "project": "AMQCPP", "title": "HTTP connector not supported", "status": "Closed", "reporter": "Eddie Epstein", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-04-27T20:45:47.000+0000", "updated": "2007-04-27T21:18:07.000+0000", "description": "When trying to send a message to an http connector, the result is:\n\nActiveMQConnectionFactory::createConnection - unknown transport factory\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 135\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 190\n\nI could not find any documentation saying that http was not supported.\n\nEddie Epstein", "comments": [], "text": "HTTP connector not supported\n\nDescription:\nWhen trying to send a message to an http connector, the result is:\n\nActiveMQConnectionFactory::createConnection - unknown transport factory\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 135\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 190\n\nI could not find any documentation saying that http was not supported.\n\nEddie Epstein\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: HTTP connector not supported\n\nDescription:\nWhen trying to send a message to an http connector, the result is:\n\nActiveMQConnectionFactory::createConnection - unknown transport factory\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 135\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 190\n\nI could not find any documentation saying that http was not supported.\n\nEddie Epstein\n\nComments:\n", "classification": "Classify the issue 'HTTP connector not supported' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-113?\nA: When trying to send a message to an http connector, the result is:\n\nActiveMQConnectionFactory::createConnection - unknown transport factory\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 135\n        FILE: \\activemq-cpp-2.0\\src\\main\\activemq\\core\\ActiveMQConnectionFactory.cpp, LINE: 190\n\nI could not find any documentation saying that http was not support"}}
{"issue_key": "AMQCPP-112", "project": "AMQCPP", "title": "Openwire Experiation Integration tests fail when fixed to actually use Openwire", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-04-27T14:40:47.000+0000", "updated": "2007-04-29T19:37:36.000+0000", "description": "While cleaning up some of the Integ tests I noticed that the Openwire Expiration tests was setting stomp as its wireformat.  Once I changed this to openwire the testNotExpired test fails.", "comments": [], "text": "Openwire Experiation Integration tests fail when fixed to actually use Openwire\n\nDescription:\nWhile cleaning up some of the Integ tests I noticed that the Openwire Expiration tests was setting stomp as its wireformat.  Once I changed this to openwire the testNotExpired test fails.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Openwire Experiation Integration tests fail when fixed to actually use Openwire\n\nDescription:\nWhile cleaning up some of the Integ tests I noticed that the Openwire Expiration tests was setting stomp as its wireformat.  Once I changed this to openwire the testNotExpired test fails.\n\nComments:\n", "classification": "Classify the issue 'Openwire Experiation Integration tests fail when fixed to actually use Openwire' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-112?\nA: While cleaning up some of the Integ tests I noticed that the Openwire Expiration tests was setting stomp as its wireformat.  Once I changed this to openwire the testNotExpired test fails."}}
{"issue_key": "AMQCPP-111", "project": "AMQCPP", "title": "Unable to ./configure under Suse Linux 64 bit", "status": "Closed", "reporter": "Tomas Lebovic", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-04-27T07:38:04.000+0000", "updated": "2007-09-30T10:24:19.000+0000", "description": "I ran ./autogen.sh which produced the following errors:\nMakefile.am:21: directory should not contain `/'\nsrc/examples/Makefile.am: installing `config/depcomp'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nMakefile.am:21: directory should not contain `/'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nautoreconf: automake failed with exit status: 1\n\n\nBut as i understand it these can be safely ignored so i went to the next step ./configure which dies with the following:\nchecking pthread.h presence... yes\nchecking for pthread.h... yes\nchecking for ioctl... yes\nchecking for select... yes\nchecking for gettimeofday... yes\nchecking for time... yes\nchecking for ftime... yes\nchecking for cppunit-config... /usr/local/bin/cppunit-config\nchecking for Cppunit - version >= 1.10.2... 1.12.0\nchecking for pthread_create in -lpthread... no\nconfigure: error: libpthread not found!\n\n\nI have used -lpthread in compilation of my programs so i know that library is present on the system. I am unsure how to circumvent this error any help would be greatly appreciated", "comments": [], "text": "Unable to ./configure under Suse Linux 64 bit\n\nDescription:\nI ran ./autogen.sh which produced the following errors:\nMakefile.am:21: directory should not contain `/'\nsrc/examples/Makefile.am: installing `config/depcomp'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nMakefile.am:21: directory should not contain `/'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nautoreconf: automake failed with exit status: 1\n\n\nBut as i understand it these can be safely ignored so i went to the next step ./configure which dies with the following:\nchecking pthread.h presence... yes\nchecking for pthread.h... yes\nchecking for ioctl... yes\nchecking for select... yes\nchecking for gettimeofday... yes\nchecking for time... yes\nchecking for ftime... yes\nchecking for cppunit-config... /usr/local/bin/cppunit-config\nchecking for Cppunit - version >= 1.10.2... 1.12.0\nchecking for pthread_create in -lpthread... no\nconfigure: error: libpthread not found!\n\n\nI have used -lpthread in compilation of my programs so i know that library is present on the system. I am unsure how to circumvent this error any help would be greatly appreciated \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unable to ./configure under Suse Linux 64 bit\n\nDescription:\nI ran ./autogen.sh which produced the following errors:\nMakefile.am:21: directory should not contain `/'\nsrc/examples/Makefile.am: installing `config/depcomp'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nMakefile.am:21: directory should not contain `/'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:106: use `AM_CXXFLAGS' instead.\nautoreconf: automake failed with exit status: 1\n\n\nBut as i understand it these can be safely ignored so i went to the next step ./configure which dies with the following:\nchecking pthread.h presence... yes\nchecking for pthread.h... yes\nchecking for ioctl... yes\nchecking for select... yes\nchecking for gettimeofday... yes\nchecking for time... yes\nchecking for ftime... yes\nchecking for cppunit-config... /usr/local/bin/cppunit-config\nchecking for Cppunit - version >= 1.10.2... 1.12.0\nchecking for pthread_create in -lpthread... no\nconfigure: error: libpthread not found!\n\n\nI have used -lpthread in compilation of my programs so i know that library is present on the system. I am unsure how to circumvent this error any help would be greatly appreciated \n\nComments:\n", "classification": "Classify the issue 'Unable to ./configure under Suse Linux 64 bit' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-111?\nA: I ran ./autogen.sh which produced the following errors:\nMakefile.am:21: directory should not contain `/'\nsrc/examples/Makefile.am: installing `config/depcomp'\nsrc/test-integration/Makefile.am:44: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:44: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:106: `CXXFLAGS' is a user variable, you should not override "}}
{"issue_key": "AMQCPP-110", "project": "AMQCPP", "title": "Create activemqcpp-openwire-generator build in our pom.xml, move code to src/main/java", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-25T14:31:56.000+0000", "updated": "2007-05-03T23:00:14.000+0000", "description": "Move the Openwire generator code out of the openwire-scripts folder and into src/main/java.  In the pom.xml add the ability to build this as an artifact, dependent on the necessary ActiveMQ artifacts.", "comments": [], "text": "Create activemqcpp-openwire-generator build in our pom.xml, move code to src/main/java\n\nDescription:\nMove the Openwire generator code out of the openwire-scripts folder and into src/main/java.  In the pom.xml add the ability to build this as an artifact, dependent on the necessary ActiveMQ artifacts.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create activemqcpp-openwire-generator build in our pom.xml, move code to src/main/java\n\nDescription:\nMove the Openwire generator code out of the openwire-scripts folder and into src/main/java.  In the pom.xml add the ability to build this as an artifact, dependent on the necessary ActiveMQ artifacts.\n\nComments:\n", "classification": "Classify the issue 'Create activemqcpp-openwire-generator build in our pom.xml, move code to src/main/java' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-110?\nA: Move the Openwire generator code out of the openwire-scripts folder and into src/main/java.  In the pom.xml add the ability to build this as an artifact, dependent on the necessary ActiveMQ artifacts."}}
{"issue_key": "AMQCPP-109", "project": "AMQCPP", "title": "Exception when acknowledging null messages, originating from the receipt of an ObjectMessage ", "status": "Resolved", "reporter": "Brendan Cashman", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-04-24T13:40:30.000+0000", "updated": "2007-04-28T18:47:08.000+0000", "description": "The single C++ client that wants to consume TextMessages and simply ignore the ObjectMessages.  In the current configuration the C++ app receives null messages for each ObjectMessage.  When using Openwire, the connector tries to\nacknowledge the null message and throws an OpenwireConnectionException (see line 973 of OpenWireConnector::acknowledge from release 2.0).\nThe acknowledge mode in the Session is set to DUPS_OK_ACKNOWLEDGE, but it appears (from looking at the source) that this issue will occur in other modes.\nIt looks like this problem won't occur using Stomp unless the acknowledge mode is set to CLIENT_ACKNOWLEDGE.", "comments": [], "text": "Exception when acknowledging null messages, originating from the receipt of an ObjectMessage \n\nDescription:\nThe single C++ client that wants to consume TextMessages and simply ignore the ObjectMessages.  In the current configuration the C++ app receives null messages for each ObjectMessage.  When using Openwire, the connector tries to\nacknowledge the null message and throws an OpenwireConnectionException (see line 973 of OpenWireConnector::acknowledge from release 2.0).\nThe acknowledge mode in the Session is set to DUPS_OK_ACKNOWLEDGE, but it appears (from looking at the source) that this issue will occur in other modes.\nIt looks like this problem won't occur using Stomp unless the acknowledge mode is set to CLIENT_ACKNOWLEDGE. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception when acknowledging null messages, originating from the receipt of an ObjectMessage \n\nDescription:\nThe single C++ client that wants to consume TextMessages and simply ignore the ObjectMessages.  In the current configuration the C++ app receives null messages for each ObjectMessage.  When using Openwire, the connector tries to\nacknowledge the null message and throws an OpenwireConnectionException (see line 973 of OpenWireConnector::acknowledge from release 2.0).\nThe acknowledge mode in the Session is set to DUPS_OK_ACKNOWLEDGE, but it appears (from looking at the source) that this issue will occur in other modes.\nIt looks like this problem won't occur using Stomp unless the acknowledge mode is set to CLIENT_ACKNOWLEDGE. \n\nComments:\n", "classification": "Classify the issue 'Exception when acknowledging null messages, originating from the receipt of an ObjectMessage ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-109?\nA: The single C++ client that wants to consume TextMessages and simply ignore the ObjectMessages.  In the current configuration the C++ app receives null messages for each ObjectMessage.  When using Openwire, the connector tries to\nacknowledge the null message and throws an OpenwireConnectionException (see line 973 of OpenWireConnector::acknowledge from release 2.0).\nThe acknowledge mode in the Sessi"}}
{"issue_key": "AMQCPP-108", "project": "AMQCPP", "title": "Make stomp connector more generic", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-24T11:20:18.000+0000", "updated": "2007-05-25T15:36:16.000+0000", "description": "The current stomp implementation requires a few activemq extensions.  We should change it so that it could work with any stomp broker, not just activemq.", "comments": [], "text": "Make stomp connector more generic\n\nDescription:\nThe current stomp implementation requires a few activemq extensions.  We should change it so that it could work with any stomp broker, not just activemq.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Make stomp connector more generic\n\nDescription:\nThe current stomp implementation requires a few activemq extensions.  We should change it so that it could work with any stomp broker, not just activemq.\n\nComments:\n", "classification": "Classify the issue 'Make stomp connector more generic' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-108?\nA: The current stomp implementation requires a few activemq extensions.  We should change it so that it could work with any stomp broker, not just activemq."}}
{"issue_key": "AMQCPP-107", "project": "AMQCPP", "title": "SocketInputStream::read() doesn't check for EINTR error", "status": "Resolved", "reporter": "Matvey Aizenshtat", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-04-23T13:46:51.000+0000", "updated": "2007-04-23T16:46:21.000+0000", "description": "From SocketInputSream.cpp:\n\n    int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    // Check for a closed socket.\n    if( len == 0 ){\n        throw IOException( __FILE__, __LINE__,\n            \"activemq::io::SocketInputStream::read - The connection is broken\" );\n    }\n   \n    // Check for error.\n    if( len == -1 ){\n       \n        // Otherwise, this was a bad error - throw an exception.\n        throw IOException( __FILE__, __LINE__,\n                \"activemq::io::SocketInputStream::read - %s\", SocketError::getErrorString().c_str() );\n    }\n\nIt's really worth to replace the condition check with smth like this:\n\nwhile( errno == EINTR)\n{\n      int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    if( len == 0 ){\n    ...\n    }\n   \n    if( len == -1 ){\n    ...\n    }\n\n}\n\nThe above is needed to avoid the situation when blocking read() call was failed due to the interruption by a signal.", "comments": [], "text": "SocketInputStream::read() doesn't check for EINTR error\n\nDescription:\nFrom SocketInputSream.cpp:\n\n    int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    // Check for a closed socket.\n    if( len == 0 ){\n        throw IOException( __FILE__, __LINE__,\n            \"activemq::io::SocketInputStream::read - The connection is broken\" );\n    }\n   \n    // Check for error.\n    if( len == -1 ){\n       \n        // Otherwise, this was a bad error - throw an exception.\n        throw IOException( __FILE__, __LINE__,\n                \"activemq::io::SocketInputStream::read - %s\", SocketError::getErrorString().c_str() );\n    }\n\nIt's really worth to replace the condition check with smth like this:\n\nwhile( errno == EINTR)\n{\n      int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    if( len == 0 ){\n    ...\n    }\n   \n    if( len == -1 ){\n    ...\n    }\n\n}\n\nThe above is needed to avoid the situation when blocking read() call was failed due to the interruption by a signal. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: SocketInputStream::read() doesn't check for EINTR error\n\nDescription:\nFrom SocketInputSream.cpp:\n\n    int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    // Check for a closed socket.\n    if( len == 0 ){\n        throw IOException( __FILE__, __LINE__,\n            \"activemq::io::SocketInputStream::read - The connection is broken\" );\n    }\n   \n    // Check for error.\n    if( len == -1 ){\n       \n        // Otherwise, this was a bad error - throw an exception.\n        throw IOException( __FILE__, __LINE__,\n                \"activemq::io::SocketInputStream::read - %s\", SocketError::getErrorString().c_str() );\n    }\n\nIt's really worth to replace the condition check with smth like this:\n\nwhile( errno == EINTR)\n{\n      int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    if( len == 0 ){\n    ...\n    }\n   \n    if( len == -1 ){\n    ...\n    }\n\n}\n\nThe above is needed to avoid the situation when blocking read() call was failed due to the interruption by a signal. \n\nComments:\n", "classification": "Classify the issue 'SocketInputStream::read() doesn't check for EINTR error' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-107?\nA: From SocketInputSream.cpp:\n\n    int len = ::recv(socket, (char*)buffer, (int)bufferSize, 0);\n   \n    // Check for a closed socket.\n    if( len == 0 ){\n        throw IOException( __FILE__, __LINE__,\n            \"activemq::io::SocketInputStream::read - The connection is broken\" );\n    }\n   \n    // Check for error.\n    if( len == -1 ){\n       \n        // Otherwise, this was a bad error - throw an exc"}}
{"issue_key": "AMQCPP-106", "project": "AMQCPP", "title": "reorganize subversion", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-04-23T13:43:27.000+0000", "updated": "2007-05-03T23:17:25.000+0000", "description": "As an artifact of the previous svn structure where there where multiple projects under the activemq-cpp umbrella, we currently have a trunk structure that  is as follows:\n\n\nhttps://svn.apache.org/repos/asf/activemq/activemq-cpp/trunk/activemq-cpp/\n\nWe should remove the final \"activemq-cpp\" from the structure and update any links from the wiki that reference the source code url.", "comments": [], "text": "reorganize subversion\n\nDescription:\nAs an artifact of the previous svn structure where there where multiple projects under the activemq-cpp umbrella, we currently have a trunk structure that  is as follows:\n\n\nhttps://svn.apache.org/repos/asf/activemq/activemq-cpp/trunk/activemq-cpp/\n\nWe should remove the final \"activemq-cpp\" from the structure and update any links from the wiki that reference the source code url.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: reorganize subversion\n\nDescription:\nAs an artifact of the previous svn structure where there where multiple projects under the activemq-cpp umbrella, we currently have a trunk structure that  is as follows:\n\n\nhttps://svn.apache.org/repos/asf/activemq/activemq-cpp/trunk/activemq-cpp/\n\nWe should remove the final \"activemq-cpp\" from the structure and update any links from the wiki that reference the source code url.\n\nComments:\n", "classification": "Classify the issue 'reorganize subversion' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-106?\nA: As an artifact of the previous svn structure where there where multiple projects under the activemq-cpp umbrella, we currently have a trunk structure that  is as follows:\n\n\nhttps://svn.apache.org/repos/asf/activemq/activemq-cpp/trunk/activemq-cpp/\n\nWe should remove the final \"activemq-cpp\" from the structure and update any links from the wiki that reference the source code url."}}
{"issue_key": "AMQCPP-105", "project": "AMQCPP", "title": "Openwire ActiveMQMessage sets Persistant flag incorrectly", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-04-22T15:55:46.000+0000", "updated": "2007-04-23T13:35:07.000+0000", "description": "The class ActiveMQMessageBase sets the Persistant flag incorrectly.\n\nits check for mode != 0 which is wrong should be mode == 0", "comments": [], "text": "Openwire ActiveMQMessage sets Persistant flag incorrectly\n\nDescription:\nThe class ActiveMQMessageBase sets the Persistant flag incorrectly.\n\nits check for mode != 0 which is wrong should be mode == 0\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Openwire ActiveMQMessage sets Persistant flag incorrectly\n\nDescription:\nThe class ActiveMQMessageBase sets the Persistant flag incorrectly.\n\nits check for mode != 0 which is wrong should be mode == 0\n\nComments:\n", "classification": "Classify the issue 'Openwire ActiveMQMessage sets Persistant flag incorrectly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-105?\nA: The class ActiveMQMessageBase sets the Persistant flag incorrectly.\n\nits check for mode != 0 which is wrong should be mode == 0"}}
{"issue_key": "AMQCPP-104", "project": "AMQCPP", "title": "Enabling async send prevents program from terminating properly on Windows", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-04-22T15:25:49.000+0000", "updated": "2007-05-25T15:40:48.000+0000", "description": "Setting transport.useAsyncSend=true prevents programs using AMQCPP on Windows from terminating properly. Simple example attached. I think this also explains why the integration tests don't quit properly on Windows.", "comments": [], "text": "Enabling async send prevents program from terminating properly on Windows\n\nDescription:\nSetting transport.useAsyncSend=true prevents programs using AMQCPP on Windows from terminating properly. Simple example attached. I think this also explains why the integration tests don't quit properly on Windows.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Enabling async send prevents program from terminating properly on Windows\n\nDescription:\nSetting transport.useAsyncSend=true prevents programs using AMQCPP on Windows from terminating properly. Simple example attached. I think this also explains why the integration tests don't quit properly on Windows.\n\nComments:\n", "classification": "Classify the issue 'Enabling async send prevents program from terminating properly on Windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-104?\nA: Setting transport.useAsyncSend=true prevents programs using AMQCPP on Windows from terminating properly. Simple example attached. I think this also explains why the integration tests don't quit properly on Windows."}}
{"issue_key": "AMQCPP-103", "project": "AMQCPP", "title": "Pull out generic libraries from activemq-cpp namespace", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-04-18T19:35:27.000+0000", "updated": "2008-05-01T21:56:26.000+0000", "description": "Since many of the libraries in activemq-cpp are not activemq-specific, we should move them to their own namespace.  Eventually, it would be nice for these classes to become their own project, similar to APR.  Since the classes mirror Java classes, we're proposing the name \"decaf\" for the new namespace :).", "comments": [], "text": "Pull out generic libraries from activemq-cpp namespace\n\nDescription:\nSince many of the libraries in activemq-cpp are not activemq-specific, we should move them to their own namespace.  Eventually, it would be nice for these classes to become their own project, similar to APR.  Since the classes mirror Java classes, we're proposing the name \"decaf\" for the new namespace :).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Pull out generic libraries from activemq-cpp namespace\n\nDescription:\nSince many of the libraries in activemq-cpp are not activemq-specific, we should move them to their own namespace.  Eventually, it would be nice for these classes to become their own project, similar to APR.  Since the classes mirror Java classes, we're proposing the name \"decaf\" for the new namespace :).\n\nComments:\n", "classification": "Classify the issue 'Pull out generic libraries from activemq-cpp namespace' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-103?\nA: Since many of the libraries in activemq-cpp are not activemq-specific, we should move them to their own namespace.  Eventually, it would be nice for these classes to become their own project, similar to APR.  Since the classes mirror Java classes, we're proposing the name \"decaf\" for the new namespace :)."}}
{"issue_key": "AMQCPP-102", "project": "AMQCPP", "title": "Create a Tag for CMS", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-04-18T19:32:29.000+0000", "updated": "2007-04-23T19:00:28.000+0000", "description": "In order to decouple the CMS API from the ActiveMQ-CPP source, we should copy the CMS source code (.h files) to their own svn tag (calling it version 1.0 should be sufficient).  The activemq-cpp source code can still bundle the CMS API for simplicity of download, but this way CMS could be downloaded independently, if desired.", "comments": [], "text": "Create a Tag for CMS\n\nDescription:\nIn order to decouple the CMS API from the ActiveMQ-CPP source, we should copy the CMS source code (.h files) to their own svn tag (calling it version 1.0 should be sufficient).  The activemq-cpp source code can still bundle the CMS API for simplicity of download, but this way CMS could be downloaded independently, if desired.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create a Tag for CMS\n\nDescription:\nIn order to decouple the CMS API from the ActiveMQ-CPP source, we should copy the CMS source code (.h files) to their own svn tag (calling it version 1.0 should be sufficient).  The activemq-cpp source code can still bundle the CMS API for simplicity of download, but this way CMS could be downloaded independently, if desired.\n\nComments:\n", "classification": "Classify the issue 'Create a Tag for CMS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-102?\nA: In order to decouple the CMS API from the ActiveMQ-CPP source, we should copy the CMS source code (.h files) to their own svn tag (calling it version 1.0 should be sufficient).  The activemq-cpp source code can still bundle the CMS API for simplicity of download, but this way CMS could be downloaded independently, if desired."}}
{"issue_key": "AMQCPP-101", "project": "AMQCPP", "title": "Add the Ability to set the TcpNoDelay flag of a TCP Socket", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-04-18T17:34:39.000+0000", "updated": "2007-04-23T13:34:51.000+0000", "description": "Add setter and getter to TCPSocket for setting the TCP_NODELAY flag and add a transport param check for something like transport.tcpNolDelay with values read as boolean \"true\" or \"false\"", "comments": [], "text": "Add the Ability to set the TcpNoDelay flag of a TCP Socket\n\nDescription:\nAdd setter and getter to TCPSocket for setting the TCP_NODELAY flag and add a transport param check for something like transport.tcpNolDelay with values read as boolean \"true\" or \"false\"\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add the Ability to set the TcpNoDelay flag of a TCP Socket\n\nDescription:\nAdd setter and getter to TCPSocket for setting the TCP_NODELAY flag and add a transport param check for something like transport.tcpNolDelay with values read as boolean \"true\" or \"false\"\n\nComments:\n", "classification": "Classify the issue 'Add the Ability to set the TcpNoDelay flag of a TCP Socket' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-101?\nA: Add setter and getter to TCPSocket for setting the TCP_NODELAY flag and add a transport param check for something like transport.tcpNolDelay with values read as boolean \"true\" or \"false\""}}
{"issue_key": "AMQCPP-100", "project": "AMQCPP", "title": "Implement a Failover Transport", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-18T11:48:44.000+0000", "updated": "2009-03-26T20:46:10.000+0000", "description": "Implement a Failover Transport similar to that of the one in the Java Client.", "comments": [], "text": "Implement a Failover Transport\n\nDescription:\nImplement a Failover Transport similar to that of the one in the Java Client.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement a Failover Transport\n\nDescription:\nImplement a Failover Transport similar to that of the one in the Java Client.\n\nComments:\n", "classification": "Classify the issue 'Implement a Failover Transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-100?\nA: Implement a Failover Transport similar to that of the one in the Java Client."}}
{"issue_key": "AMQCPP-99", "project": "AMQCPP", "title": "Incorporate APR for generation of GUIDs", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-12T15:03:35.000+0000", "updated": "2007-09-30T10:26:01.000+0000", "description": "It has been brought up that the standard UUID method calls are not supported by all platforms.  To resolve this, we should use the APR for UUID generation.", "comments": [], "text": "Incorporate APR for generation of GUIDs\n\nDescription:\nIt has been brought up that the standard UUID method calls are not supported by all platforms.  To resolve this, we should use the APR for UUID generation.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Incorporate APR for generation of GUIDs\n\nDescription:\nIt has been brought up that the standard UUID method calls are not supported by all platforms.  To resolve this, we should use the APR for UUID generation.\n\nComments:\n", "classification": "Classify the issue 'Incorporate APR for generation of GUIDs' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-99?\nA: It has been brought up that the standard UUID method calls are not supported by all platforms.  To resolve this, we should use the APR for UUID generation."}}
{"issue_key": "AMQCPP-98", "project": "AMQCPP", "title": "ack handler not set for messages", "status": "Resolved", "reporter": "Corey Olsen", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-04-11T23:03:55.000+0000", "updated": "2007-04-12T12:58:15.000+0000", "description": "When I call receive() on a MessageConsumer the message that I get back does not have an ackHandler.  If I change the code in ActiveMQConsumer::receive() to call beforeMessageIsConsumed with the clonedMsg that gets returned from receive then the ackHandler is setup.", "comments": [], "text": "ack handler not set for messages\n\nDescription:\nWhen I call receive() on a MessageConsumer the message that I get back does not have an ackHandler.  If I change the code in ActiveMQConsumer::receive() to call beforeMessageIsConsumed with the clonedMsg that gets returned from receive then the ackHandler is setup.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ack handler not set for messages\n\nDescription:\nWhen I call receive() on a MessageConsumer the message that I get back does not have an ackHandler.  If I change the code in ActiveMQConsumer::receive() to call beforeMessageIsConsumed with the clonedMsg that gets returned from receive then the ackHandler is setup.\n\nComments:\n", "classification": "Classify the issue 'ack handler not set for messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-98?\nA: When I call receive() on a MessageConsumer the message that I get back does not have an ackHandler.  If I change the code in ActiveMQConsumer::receive() to call beforeMessageIsConsumed with the clonedMsg that gets returned from receive then the ackHandler is setup."}}
{"issue_key": "AMQCPP-97", "project": "AMQCPP", "title": "ThreadPoolTest fails when run under Valgrind 2.4.0 on Fedora Core 4", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-05T20:07:46.000+0000", "updated": "2007-04-06T14:14:25.000+0000", "description": "The unit tests fail when run under Valgrind 2.4.0 on Fedora Core 4 with the following output:\n\nactivemq::concurrent::ThreadPoolTest::test1. : errorE\nactivemq::concurrent::ThreadPoolTest::test2terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Thread::join() called without having called Thread::start()\n.==9261== \n==9261== Process terminating with default action of signal 6 (SIGABRT)\n==9261==    at 0x59FF90: raise (in /lib/libc-2.3.6.so)\n==9261==    by 0x5A1677: abort (in /lib/libc-2.3.6.so)\n==9261==    by 0x29E483: __gnu_cxx::__verbose_terminate_handler() (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C114: (within /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C0E1: __gxx_personality_v0 (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x75BFD6: (within /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x75C090: _Unwind_Resume (in /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x81C83E1: activemq::concurrent::ThreadPool::~ThreadPool() (PooledThreadListener.h:34)\n==9261==    by 0x8056DB6: activemq::concurrent::ThreadPoolTest::test2() (ThreadPoolTest.h:195)\n==9261==    by 0xD31555: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD20507: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2ACDC: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2A85B: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3CA60: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3087F: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD41BC3: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n\nMaybe the test code is thrown off by the longer time it takes to run when executing with Valgrind.", "comments": [], "text": "ThreadPoolTest fails when run under Valgrind 2.4.0 on Fedora Core 4\n\nDescription:\nThe unit tests fail when run under Valgrind 2.4.0 on Fedora Core 4 with the following output:\n\nactivemq::concurrent::ThreadPoolTest::test1. : errorE\nactivemq::concurrent::ThreadPoolTest::test2terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Thread::join() called without having called Thread::start()\n.==9261== \n==9261== Process terminating with default action of signal 6 (SIGABRT)\n==9261==    at 0x59FF90: raise (in /lib/libc-2.3.6.so)\n==9261==    by 0x5A1677: abort (in /lib/libc-2.3.6.so)\n==9261==    by 0x29E483: __gnu_cxx::__verbose_terminate_handler() (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C114: (within /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C0E1: __gxx_personality_v0 (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x75BFD6: (within /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x75C090: _Unwind_Resume (in /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x81C83E1: activemq::concurrent::ThreadPool::~ThreadPool() (PooledThreadListener.h:34)\n==9261==    by 0x8056DB6: activemq::concurrent::ThreadPoolTest::test2() (ThreadPoolTest.h:195)\n==9261==    by 0xD31555: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD20507: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2ACDC: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2A85B: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3CA60: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3087F: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD41BC3: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n\nMaybe the test code is thrown off by the longer time it takes to run when executing with Valgrind.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ThreadPoolTest fails when run under Valgrind 2.4.0 on Fedora Core 4\n\nDescription:\nThe unit tests fail when run under Valgrind 2.4.0 on Fedora Core 4 with the following output:\n\nactivemq::concurrent::ThreadPoolTest::test1. : errorE\nactivemq::concurrent::ThreadPoolTest::test2terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Thread::join() called without having called Thread::start()\n.==9261== \n==9261== Process terminating with default action of signal 6 (SIGABRT)\n==9261==    at 0x59FF90: raise (in /lib/libc-2.3.6.so)\n==9261==    by 0x5A1677: abort (in /lib/libc-2.3.6.so)\n==9261==    by 0x29E483: __gnu_cxx::__verbose_terminate_handler() (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C114: (within /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x29C0E1: __gxx_personality_v0 (in /usr/lib/libstdc++.so.6.0.7)\n==9261==    by 0x75BFD6: (within /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x75C090: _Unwind_Resume (in /lib/libgcc_s-4.0.2-20051126.so.1)\n==9261==    by 0x81C83E1: activemq::concurrent::ThreadPool::~ThreadPool() (PooledThreadListener.h:34)\n==9261==    by 0x8056DB6: activemq::concurrent::ThreadPoolTest::test2() (ThreadPoolTest.h:195)\n==9261==    by 0xD31555: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD20507: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2ACDC: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD2A85B: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3CA60: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD3087F: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31D72: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD31C6D: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n==9261==    by 0xD41BC3: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.11.so.0.0.0)\n\nMaybe the test code is thrown off by the longer time it takes to run when executing with Valgrind.\n\nComments:\n", "classification": "Classify the issue 'ThreadPoolTest fails when run under Valgrind 2.4.0 on Fedora Core 4' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-97?\nA: The unit tests fail when run under Valgrind 2.4.0 on Fedora Core 4 with the following output:\n\nactivemq::concurrent::ThreadPoolTest::test1. : errorE\nactivemq::concurrent::ThreadPoolTest::test2terminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Thread::join() called without having called Thread::start()\n.==9261== \n==9261== Process terminating with def"}}
{"issue_key": "AMQCPP-96", "project": "AMQCPP", "title": "Setting property \"JMSXGroupID\" on a stomp message yields IllegalArgumentException", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-04-05T19:13:26.000+0000", "updated": "2007-04-06T14:21:06.000+0000", "description": "We have defined all of the standard stomp headers as well as AMQ extensions as predefined stomp headers.  This causes an IllegalArgumentException for settting any of these properties.  We currently have no other way to set the AMQ extension for JMSXGroupID, yet it also can't be set via setStringProperty().\n\nWe should see how the AMQ Java code handles the AMQ-specific properties and try to model our code after that.", "comments": [], "text": "Setting property \"JMSXGroupID\" on a stomp message yields IllegalArgumentException\n\nDescription:\nWe have defined all of the standard stomp headers as well as AMQ extensions as predefined stomp headers.  This causes an IllegalArgumentException for settting any of these properties.  We currently have no other way to set the AMQ extension for JMSXGroupID, yet it also can't be set via setStringProperty().\n\nWe should see how the AMQ Java code handles the AMQ-specific properties and try to model our code after that.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Setting property \"JMSXGroupID\" on a stomp message yields IllegalArgumentException\n\nDescription:\nWe have defined all of the standard stomp headers as well as AMQ extensions as predefined stomp headers.  This causes an IllegalArgumentException for settting any of these properties.  We currently have no other way to set the AMQ extension for JMSXGroupID, yet it also can't be set via setStringProperty().\n\nWe should see how the AMQ Java code handles the AMQ-specific properties and try to model our code after that.\n\nComments:\n", "classification": "Classify the issue 'Setting property \"JMSXGroupID\" on a stomp message yields IllegalArgumentException' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-96?\nA: We have defined all of the standard stomp headers as well as AMQ extensions as predefined stomp headers.  This causes an IllegalArgumentException for settting any of these properties.  We currently have no other way to set the AMQ extension for JMSXGroupID, yet it also can't be set via setStringProperty().\n\nWe should see how the AMQ Java code handles the AMQ-specific properties and try to model ou"}}
{"issue_key": "AMQCPP-95", "project": "AMQCPP", "title": "Perform Memory Leak testing on 2.0 codebase", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-03-18T21:50:04.000+0000", "updated": "2007-03-29T23:25:36.000+0000", "description": "Before releasing v2.0 we need to run memory leak testing on the new code.", "comments": [], "text": "Perform Memory Leak testing on 2.0 codebase\n\nDescription:\nBefore releasing v2.0 we need to run memory leak testing on the new code.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Perform Memory Leak testing on 2.0 codebase\n\nDescription:\nBefore releasing v2.0 we need to run memory leak testing on the new code.\n\nComments:\n", "classification": "Classify the issue 'Perform Memory Leak testing on 2.0 codebase' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-95?\nA: Before releasing v2.0 we need to run memory leak testing on the new code."}}
{"issue_key": "AMQCPP-94", "project": "AMQCPP", "title": "StompConnector should use Long::toString instead of Integer::toString", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-03-18T17:22:41.000+0000", "updated": "2007-03-18T17:57:37.000+0000", "description": "When compiling with Visual Studio 2005, I get warnings like the following:\n\nwarning C4244: 'argument' : conversion from '__int64' to 'int', possible loss of data\n\nPatch attached to fix these.", "comments": [], "text": "StompConnector should use Long::toString instead of Integer::toString\n\nDescription:\nWhen compiling with Visual Studio 2005, I get warnings like the following:\n\nwarning C4244: 'argument' : conversion from '__int64' to 'int', possible loss of data\n\nPatch attached to fix these.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: StompConnector should use Long::toString instead of Integer::toString\n\nDescription:\nWhen compiling with Visual Studio 2005, I get warnings like the following:\n\nwarning C4244: 'argument' : conversion from '__int64' to 'int', possible loss of data\n\nPatch attached to fix these.\n\nComments:\n", "classification": "Classify the issue 'StompConnector should use Long::toString instead of Integer::toString' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-94?\nA: When compiling with Visual Studio 2005, I get warnings like the following:\n\nwarning C4244: 'argument' : conversion from '__int64' to 'int', possible loss of data\n\nPatch attached to fix these."}}
{"issue_key": "AMQCPP-93", "project": "AMQCPP", "title": "Performance analysis", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-03-18T13:59:58.000+0000", "updated": "2013-04-19T10:27:06.000+0000", "description": "Do a performance analysis on openwire vs stomp.", "comments": [], "text": "Performance analysis\n\nDescription:\nDo a performance analysis on openwire vs stomp.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Performance analysis\n\nDescription:\nDo a performance analysis on openwire vs stomp.\n\nComments:\n", "classification": "Classify the issue 'Performance analysis' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-93?\nA: Do a performance analysis on openwire vs stomp."}}
{"issue_key": "AMQCPP-92", "project": "AMQCPP", "title": "memory leak in openwire session info", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-03-18T01:36:02.000+0000", "updated": "2007-03-18T14:04:26.000+0000", "description": "The current trunk after AMQCPP-78 has been fixed shows a memory leak in session info (two blocks due to two sessions created).\n\n==30586== 381 (208 direct, 173 indirect) bytes in 2 blocks are definitely lost \\\nin loss record 141 of 163\n==30586==    at 0x4A1F02E: operator new(unsigned long) (in /usr/lib64/valgrind/\\\namd64-linux/vgpreload_memcheck.so)\n==30586==    by 0xCC7A114: activemq::connector::openwire::OpenWireConnector::cr\\\neateSession(cms::Session::AcknowledgeMode) (OpenWireConnector.cpp:332)\n==30586==    by 0xCC0F2F9: activemq::core::ActiveMQConnection::createSession(cm\\\ns::Session::AcknowledgeMode) (ActiveMQConnection.cpp:80)", "comments": [], "text": "memory leak in openwire session info\n\nDescription:\nThe current trunk after AMQCPP-78 has been fixed shows a memory leak in session info (two blocks due to two sessions created).\n\n==30586== 381 (208 direct, 173 indirect) bytes in 2 blocks are definitely lost \\\nin loss record 141 of 163\n==30586==    at 0x4A1F02E: operator new(unsigned long) (in /usr/lib64/valgrind/\\\namd64-linux/vgpreload_memcheck.so)\n==30586==    by 0xCC7A114: activemq::connector::openwire::OpenWireConnector::cr\\\neateSession(cms::Session::AcknowledgeMode) (OpenWireConnector.cpp:332)\n==30586==    by 0xCC0F2F9: activemq::core::ActiveMQConnection::createSession(cm\\\ns::Session::AcknowledgeMode) (ActiveMQConnection.cpp:80)\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: memory leak in openwire session info\n\nDescription:\nThe current trunk after AMQCPP-78 has been fixed shows a memory leak in session info (two blocks due to two sessions created).\n\n==30586== 381 (208 direct, 173 indirect) bytes in 2 blocks are definitely lost \\\nin loss record 141 of 163\n==30586==    at 0x4A1F02E: operator new(unsigned long) (in /usr/lib64/valgrind/\\\namd64-linux/vgpreload_memcheck.so)\n==30586==    by 0xCC7A114: activemq::connector::openwire::OpenWireConnector::cr\\\neateSession(cms::Session::AcknowledgeMode) (OpenWireConnector.cpp:332)\n==30586==    by 0xCC0F2F9: activemq::core::ActiveMQConnection::createSession(cm\\\ns::Session::AcknowledgeMode) (ActiveMQConnection.cpp:80)\n\n\nComments:\n", "classification": "Classify the issue 'memory leak in openwire session info' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-92?\nA: The current trunk after AMQCPP-78 has been fixed shows a memory leak in session info (two blocks due to two sessions created).\n\n==30586== 381 (208 direct, 173 indirect) bytes in 2 blocks are definitely lost \\\nin loss record 141 of 163\n==30586==    at 0x4A1F02E: operator new(unsigned long) (in /usr/lib64/valgrind/\\\namd64-linux/vgpreload_memcheck.so)\n==30586==    by 0xCC7A114: activemq::connector::o"}}
{"issue_key": "AMQCPP-91", "project": "AMQCPP", "title": "A few more Openwire memory leaks", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-03-16T12:55:11.000+0000", "updated": "2007-03-18T13:53:40.000+0000", "description": "I've found a few memory leaks in the Openwire code when running the unit tests for our library. I'll report the first few now (the ones I think I've figured out), and I'll add info on further leaks in separate comments.\n\nFirst possible leak:\n\n==22866== 1728 (864 direct, 864 indirect) bytes in 12 blocks are definitely lost in loss record 25 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81943CA: activemq::connector::openwire::OpenWireConnector::createConsumerInfo(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:621)\n==22866==    by 0x81994FD: activemq::connector::openwire::OpenWireConnector::createConsumer(cms::Destination const*, activemq::connector::SessionInfo*, std::string const&, bool) (OpenWireConnector.cpp:382)\n==22866==    by 0x8148B89: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&, bool) (ActiveMQSession.cpp:236)\n==22866==    by 0x8146CAB: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&) (ActiveMQSession.cpp:208)\n\nOpenWireConnector::createConsumerInfo allocates a commands::ConsumerInfo which is returned to OpenWireConnector::createConsumer which does a few things with it, but doesn't delete it if the member function returns normally.\n\nNext possible leak:\n\n==22866== 1232 (440 direct, 792 indirect) bytes in 11 blocks are definitely lost in loss record 27 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81989F7: activemq::connector::openwire::OpenWireConnector::createProducer(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:680)\n==22866==    by 0x8149324: activemq::core::ActiveMQSession::createProducer(cms::Destination const*) (ActiveMQSession.cpp:309)\n\nOpenWireConnector::createProducer allocates a OpenWireProducerInfo which isn't deleted if the member function returns normally.", "comments": [], "text": "A few more Openwire memory leaks\n\nDescription:\nI've found a few memory leaks in the Openwire code when running the unit tests for our library. I'll report the first few now (the ones I think I've figured out), and I'll add info on further leaks in separate comments.\n\nFirst possible leak:\n\n==22866== 1728 (864 direct, 864 indirect) bytes in 12 blocks are definitely lost in loss record 25 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81943CA: activemq::connector::openwire::OpenWireConnector::createConsumerInfo(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:621)\n==22866==    by 0x81994FD: activemq::connector::openwire::OpenWireConnector::createConsumer(cms::Destination const*, activemq::connector::SessionInfo*, std::string const&, bool) (OpenWireConnector.cpp:382)\n==22866==    by 0x8148B89: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&, bool) (ActiveMQSession.cpp:236)\n==22866==    by 0x8146CAB: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&) (ActiveMQSession.cpp:208)\n\nOpenWireConnector::createConsumerInfo allocates a commands::ConsumerInfo which is returned to OpenWireConnector::createConsumer which does a few things with it, but doesn't delete it if the member function returns normally.\n\nNext possible leak:\n\n==22866== 1232 (440 direct, 792 indirect) bytes in 11 blocks are definitely lost in loss record 27 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81989F7: activemq::connector::openwire::OpenWireConnector::createProducer(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:680)\n==22866==    by 0x8149324: activemq::core::ActiveMQSession::createProducer(cms::Destination const*) (ActiveMQSession.cpp:309)\n\nOpenWireConnector::createProducer allocates a OpenWireProducerInfo which isn't deleted if the member function returns normally.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: A few more Openwire memory leaks\n\nDescription:\nI've found a few memory leaks in the Openwire code when running the unit tests for our library. I'll report the first few now (the ones I think I've figured out), and I'll add info on further leaks in separate comments.\n\nFirst possible leak:\n\n==22866== 1728 (864 direct, 864 indirect) bytes in 12 blocks are definitely lost in loss record 25 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81943CA: activemq::connector::openwire::OpenWireConnector::createConsumerInfo(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:621)\n==22866==    by 0x81994FD: activemq::connector::openwire::OpenWireConnector::createConsumer(cms::Destination const*, activemq::connector::SessionInfo*, std::string const&, bool) (OpenWireConnector.cpp:382)\n==22866==    by 0x8148B89: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&, bool) (ActiveMQSession.cpp:236)\n==22866==    by 0x8146CAB: activemq::core::ActiveMQSession::createConsumer(cms::Destination const*, std::string const&) (ActiveMQSession.cpp:208)\n\nOpenWireConnector::createConsumerInfo allocates a commands::ConsumerInfo which is returned to OpenWireConnector::createConsumer which does a few things with it, but doesn't delete it if the member function returns normally.\n\nNext possible leak:\n\n==22866== 1232 (440 direct, 792 indirect) bytes in 11 blocks are definitely lost in loss record 27 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) (vg_replace_malloc.c:132)\n==22866==    by 0x81989F7: activemq::connector::openwire::OpenWireConnector::createProducer(cms::Destination const*, activemq::connector::SessionInfo*) (OpenWireConnector.cpp:680)\n==22866==    by 0x8149324: activemq::core::ActiveMQSession::createProducer(cms::Destination const*) (ActiveMQSession.cpp:309)\n\nOpenWireConnector::createProducer allocates a OpenWireProducerInfo which isn't deleted if the member function returns normally.\n\n\nComments:\n", "classification": "Classify the issue 'A few more Openwire memory leaks' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-91?\nA: I've found a few memory leaks in the Openwire code when running the unit tests for our library. I'll report the first few now (the ones I think I've figured out), and I'll add info on further leaks in separate comments.\n\nFirst possible leak:\n\n==22866== 1728 (864 direct, 864 indirect) bytes in 12 blocks are definitely lost in loss record 25 of 40\n==22866==    at 0x1B90939A: operator new(unsigned) ("}}
{"issue_key": "AMQCPP-90", "project": "AMQCPP", "title": "Openwire Session doesn't run its MessageListeners from a single thread", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-03-16T10:26:22.000+0000", "updated": "2007-03-18T21:43:47.000+0000", "description": "According to the JMS 1.1 specification, section 4.4.14 Serial Execution of Client Code:\n\nFor this reason, JMS does not cause concurrent execution of client code unless\na client explicitly requests it. One way this is done is to define that a session\nserializes all asynchronous delivery of messages.\n\nTo receive messages asynchronously, a client registers an object that\nimplements the JMS MessageListener interface with a MessageConsumer. In effect,\na Session uses a single thread to run all its MessageListeners. While the thread is\nbusy executing one listener, all other messages to be asynchronously delivered\nto the session must wait.\n\nIn the attached code I have 5 consumers created from the same session, all with the same message listener instance that receives a message, prints something and then sleeps for a while. When running the C++ code, one sees that 5 messages (there are 5 consumers) are delivered at approximately the same time. Under Java, one only sees 1 message delivered per interval.\n\nThis seems to indicate that the Openwire Session doesn't run its MessageListeners from a single thread. This can cause problems if the user's MessageListener isn't thread safe.", "comments": [], "text": "Openwire Session doesn't run its MessageListeners from a single thread\n\nDescription:\nAccording to the JMS 1.1 specification, section 4.4.14 Serial Execution of Client Code:\n\nFor this reason, JMS does not cause concurrent execution of client code unless\na client explicitly requests it. One way this is done is to define that a session\nserializes all asynchronous delivery of messages.\n\nTo receive messages asynchronously, a client registers an object that\nimplements the JMS MessageListener interface with a MessageConsumer. In effect,\na Session uses a single thread to run all its MessageListeners. While the thread is\nbusy executing one listener, all other messages to be asynchronously delivered\nto the session must wait.\n\nIn the attached code I have 5 consumers created from the same session, all with the same message listener instance that receives a message, prints something and then sleeps for a while. When running the C++ code, one sees that 5 messages (there are 5 consumers) are delivered at approximately the same time. Under Java, one only sees 1 message delivered per interval.\n\nThis seems to indicate that the Openwire Session doesn't run its MessageListeners from a single thread. This can cause problems if the user's MessageListener isn't thread safe.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Openwire Session doesn't run its MessageListeners from a single thread\n\nDescription:\nAccording to the JMS 1.1 specification, section 4.4.14 Serial Execution of Client Code:\n\nFor this reason, JMS does not cause concurrent execution of client code unless\na client explicitly requests it. One way this is done is to define that a session\nserializes all asynchronous delivery of messages.\n\nTo receive messages asynchronously, a client registers an object that\nimplements the JMS MessageListener interface with a MessageConsumer. In effect,\na Session uses a single thread to run all its MessageListeners. While the thread is\nbusy executing one listener, all other messages to be asynchronously delivered\nto the session must wait.\n\nIn the attached code I have 5 consumers created from the same session, all with the same message listener instance that receives a message, prints something and then sleeps for a while. When running the C++ code, one sees that 5 messages (there are 5 consumers) are delivered at approximately the same time. Under Java, one only sees 1 message delivered per interval.\n\nThis seems to indicate that the Openwire Session doesn't run its MessageListeners from a single thread. This can cause problems if the user's MessageListener isn't thread safe.\n\nComments:\n", "classification": "Classify the issue 'Openwire Session doesn't run its MessageListeners from a single thread' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-90?\nA: According to the JMS 1.1 specification, section 4.4.14 Serial Execution of Client Code:\n\nFor this reason, JMS does not cause concurrent execution of client code unless\na client explicitly requests it. One way this is done is to define that a session\nserializes all asynchronous delivery of messages.\n\nTo receive messages asynchronously, a client registers an object that\nimplements the JMS MessageLis"}}
{"issue_key": "AMQCPP-89", "project": "AMQCPP", "title": "Case of cms::Message getter and setter names are not consistent with case of JMS Message getter and setter names", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-03-16T09:30:40.000+0000", "updated": "2007-03-16T12:07:09.000+0000", "description": "The cms::Message getter and setter names could be more consistent with the JMS Message getter and setter names. It makes sense that JMS is replaced with CMS, but there are case inconsistencies that are slightly suboptimal.\n\n * getJMSCorrelationID vs getCMSCorrelationId\n * setJMSCorrelationID vs setCMSCorrelationId\n * getJMSMessageID vs setCMSMessageId\n * getJMSTimestamp vs getCMSTimeStamp\n\nI think it might be worth fixing these for the 2.0 release. It's especially useful when one quickly wants to port over a bit of JMS code to CMS.", "comments": [], "text": "Case of cms::Message getter and setter names are not consistent with case of JMS Message getter and setter names\n\nDescription:\nThe cms::Message getter and setter names could be more consistent with the JMS Message getter and setter names. It makes sense that JMS is replaced with CMS, but there are case inconsistencies that are slightly suboptimal.\n\n * getJMSCorrelationID vs getCMSCorrelationId\n * setJMSCorrelationID vs setCMSCorrelationId\n * getJMSMessageID vs setCMSMessageId\n * getJMSTimestamp vs getCMSTimeStamp\n\nI think it might be worth fixing these for the 2.0 release. It's especially useful when one quickly wants to port over a bit of JMS code to CMS.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Case of cms::Message getter and setter names are not consistent with case of JMS Message getter and setter names\n\nDescription:\nThe cms::Message getter and setter names could be more consistent with the JMS Message getter and setter names. It makes sense that JMS is replaced with CMS, but there are case inconsistencies that are slightly suboptimal.\n\n * getJMSCorrelationID vs getCMSCorrelationId\n * setJMSCorrelationID vs setCMSCorrelationId\n * getJMSMessageID vs setCMSMessageId\n * getJMSTimestamp vs getCMSTimeStamp\n\nI think it might be worth fixing these for the 2.0 release. It's especially useful when one quickly wants to port over a bit of JMS code to CMS.\n\nComments:\n", "classification": "Classify the issue 'Case of cms::Message getter and setter names are not consistent with case of JMS Message getter and setter names' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-89?\nA: The cms::Message getter and setter names could be more consistent with the JMS Message getter and setter names. It makes sense that JMS is replaced with CMS, but there are case inconsistencies that are slightly suboptimal.\n\n * getJMSCorrelationID vs getCMSCorrelationId\n * setJMSCorrelationID vs setCMSCorrelationId\n * getJMSMessageID vs setCMSMessageId\n * getJMSTimestamp vs getCMSTimeStamp\n\nI think"}}
{"issue_key": "AMQCPP-88", "project": "AMQCPP", "title": "Remove setCMSMessageId from CMS API", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-03-14T14:24:28.000+0000", "updated": "2007-03-16T12:08:58.000+0000", "description": "Message ID is a provider defined value and should not be settable from the CMS API.  Although this deviates from JMS, the NMS client already makes this property read-only.\n\nThe JMS API says the following for the setJMSMessageId method:\n\n\"JMS providers set this field when a message is sent. This method can be used to change the value for a message that has been received.\"", "comments": [], "text": "Remove setCMSMessageId from CMS API\n\nDescription:\nMessage ID is a provider defined value and should not be settable from the CMS API.  Although this deviates from JMS, the NMS client already makes this property read-only.\n\nThe JMS API says the following for the setJMSMessageId method:\n\n\"JMS providers set this field when a message is sent. This method can be used to change the value for a message that has been received.\"\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Remove setCMSMessageId from CMS API\n\nDescription:\nMessage ID is a provider defined value and should not be settable from the CMS API.  Although this deviates from JMS, the NMS client already makes this property read-only.\n\nThe JMS API says the following for the setJMSMessageId method:\n\n\"JMS providers set this field when a message is sent. This method can be used to change the value for a message that has been received.\"\n\nComments:\n", "classification": "Classify the issue 'Remove setCMSMessageId from CMS API' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-88?\nA: Message ID is a provider defined value and should not be settable from the CMS API.  Although this deviates from JMS, the NMS client already makes this property read-only.\n\nThe JMS API says the following for the setJMSMessageId method:\n\n\"JMS providers set this field when a message is sent. This method can be used to change the value for a message that has been received.\""}}
{"issue_key": "AMQCPP-87", "project": "AMQCPP", "title": "ActiveMQConnectionFactory creates only one unique clientId", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-03-13T17:12:15.000+0000", "updated": "2007-03-13T20:41:03.000+0000", "description": "ActiveMQConnectionFactory creates only one unique clientId.  This prevents creating multiple connections using the same factory.\n\nThe attached patch creates uuid once, and adds a counter to it if needed.  It is just a proposal, and I have only very quickly tested it on linux/gcc 4.1.", "comments": [], "text": "ActiveMQConnectionFactory creates only one unique clientId\n\nDescription:\nActiveMQConnectionFactory creates only one unique clientId.  This prevents creating multiple connections using the same factory.\n\nThe attached patch creates uuid once, and adds a counter to it if needed.  It is just a proposal, and I have only very quickly tested it on linux/gcc 4.1.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQConnectionFactory creates only one unique clientId\n\nDescription:\nActiveMQConnectionFactory creates only one unique clientId.  This prevents creating multiple connections using the same factory.\n\nThe attached patch creates uuid once, and adds a counter to it if needed.  It is just a proposal, and I have only very quickly tested it on linux/gcc 4.1.\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQConnectionFactory creates only one unique clientId' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-87?\nA: ActiveMQConnectionFactory creates only one unique clientId.  This prevents creating multiple connections using the same factory.\n\nThe attached patch creates uuid once, and adds a counter to it if needed.  It is just a proposal, and I have only very quickly tested it on linux/gcc 4.1.\n"}}
{"issue_key": "AMQCPP-86", "project": "AMQCPP", "title": "Valgrind reports memory leaks in unit tests", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-03-13T15:07:42.000+0000", "updated": "2007-03-13T16:08:28.000+0000", "description": "Valgrind reports a memory leak when running the unit tests.\n\nHowever is calling cloneDataStructure probably isn't deleting the message that is returned.\n\n==20515== 61 (44 direct, 17 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 4\n==20515==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20515==    by 0x81266BD: activemq::connector::openwire::commands::ActiveMQDestinationTest::test() (ActiveMQDestinationTest2.h:55)\n==20515==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4A813D: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2302: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2054: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BEC70: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B60AC: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C111F: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BE8D9: CppUnit::TestResult::runTest(CppUnit::Test*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C0F5F: CppUnit::TestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C46AA: CppUnit::TextTestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x81C0206: main (main.cpp:34)", "comments": [], "text": "Valgrind reports memory leaks in unit tests\n\nDescription:\nValgrind reports a memory leak when running the unit tests.\n\nHowever is calling cloneDataStructure probably isn't deleting the message that is returned.\n\n==20515== 61 (44 direct, 17 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 4\n==20515==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20515==    by 0x81266BD: activemq::connector::openwire::commands::ActiveMQDestinationTest::test() (ActiveMQDestinationTest2.h:55)\n==20515==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4A813D: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2302: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2054: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BEC70: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B60AC: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C111F: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BE8D9: CppUnit::TestResult::runTest(CppUnit::Test*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C0F5F: CppUnit::TestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C46AA: CppUnit::TextTestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x81C0206: main (main.cpp:34)\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Valgrind reports memory leaks in unit tests\n\nDescription:\nValgrind reports a memory leak when running the unit tests.\n\nHowever is calling cloneDataStructure probably isn't deleting the message that is returned.\n\n==20515== 61 (44 direct, 17 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 4\n==20515==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20515==    by 0x81266BD: activemq::connector::openwire::commands::ActiveMQDestinationTest::test() (ActiveMQDestinationTest2.h:55)\n==20515==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4A813D: CppUnit::DefaultProtector::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2302: CppUnit::ProtectorChain::ProtectFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B2054: CppUnit::ProtectorChain::protect(CppUnit::Functor const&, CppUnit::ProtectorContext const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BEC70: CppUnit::TestResult::protect(CppUnit::Functor const&, CppUnit::Test*, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B60AC: CppUnit::TestCase::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6D6E: CppUnit::TestComposite::doRunChildTests(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4B6CA9: CppUnit::TestComposite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C111F: CppUnit::TestRunner::WrappingSuite::run(CppUnit::TestResult*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4BE8D9: CppUnit::TestResult::runTest(CppUnit::Test*) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C0F5F: CppUnit::TestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C46AA: CppUnit::TextTestRunner::run(CppUnit::TestResult&, std::string const&) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n==20515==    by 0x81C0206: main (main.cpp:34)\n\nComments:\n", "classification": "Classify the issue 'Valgrind reports memory leaks in unit tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-86?\nA: Valgrind reports a memory leak when running the unit tests.\n\nHowever is calling cloneDataStructure probably isn't deleting the message that is returned.\n\n==20515== 61 (44 direct, 17 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 4\n==20515==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20515==    by 0x81266BD: activemq::connector::openwire::commands::Acti"}}
{"issue_key": "AMQCPP-85", "project": "AMQCPP", "title": "activemq/util/Character.h not being installed by automake", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2007-03-13T14:49:46.000+0000", "updated": "2007-03-13T14:58:54.000+0000", "description": "It seems the activemq/util/Character.h header is not being installed when one does a make install.\n\nTested with AMQCPP revision 517702.", "comments": [], "text": "activemq/util/Character.h not being installed by automake\n\nDescription:\nIt seems the activemq/util/Character.h header is not being installed when one does a make install.\n\nTested with AMQCPP revision 517702.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq/util/Character.h not being installed by automake\n\nDescription:\nIt seems the activemq/util/Character.h header is not being installed when one does a make install.\n\nTested with AMQCPP revision 517702.\n\nComments:\n", "classification": "Classify the issue 'activemq/util/Character.h not being installed by automake' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-85?\nA: It seems the activemq/util/Character.h header is not being installed when one does a make install.\n\nTested with AMQCPP revision 517702."}}
{"issue_key": "AMQCPP-84", "project": "AMQCPP", "title": "add unit/integration tests", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-03-13T13:38:16.000+0000", "updated": "2007-03-18T13:02:36.000+0000", "description": "Add unit/integ tests for the following:\n\n1) producers with null destinations\n2) temp destinations\n3) sync receive\n4) creating multiple connections from the same connection factory", "comments": [], "text": "add unit/integration tests\n\nDescription:\nAdd unit/integ tests for the following:\n\n1) producers with null destinations\n2) temp destinations\n3) sync receive\n4) creating multiple connections from the same connection factory\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: add unit/integration tests\n\nDescription:\nAdd unit/integ tests for the following:\n\n1) producers with null destinations\n2) temp destinations\n3) sync receive\n4) creating multiple connections from the same connection factory\n\nComments:\n", "classification": "Classify the issue 'add unit/integration tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-84?\nA: Add unit/integ tests for the following:\n\n1) producers with null destinations\n2) temp destinations\n3) sync receive\n4) creating multiple connections from the same connection factory"}}
{"issue_key": "AMQCPP-83", "project": "AMQCPP", "title": "Integration tests fail for openwire", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-03-13T11:07:49.000+0000", "updated": "2007-04-03T23:12:47.000+0000", "description": "Currently the durable and transaction tests fail.  \n\nIn the durable test, the consumer never receives any messages.\n\nThe transaction test hangs forever.", "comments": [], "text": "Integration tests fail for openwire\n\nDescription:\nCurrently the durable and transaction tests fail.  \n\nIn the durable test, the consumer never receives any messages.\n\nThe transaction test hangs forever.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Integration tests fail for openwire\n\nDescription:\nCurrently the durable and transaction tests fail.  \n\nIn the durable test, the consumer never receives any messages.\n\nThe transaction test hangs forever.\n\n\n\nComments:\n", "classification": "Classify the issue 'Integration tests fail for openwire' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-83?\nA: Currently the durable and transaction tests fail.  \n\nIn the durable test, the consumer never receives any messages.\n\nThe transaction test hangs forever.\n\n"}}
{"issue_key": "AMQCPP-82", "project": "AMQCPP", "title": "Make openwire the default protocol", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-03-13T10:19:50.000+0000", "updated": "2007-03-29T23:34:02.000+0000", "description": "Before 2.0 is released, we need to switch over the default protocol (which is currently stomp) to openwire.", "comments": [], "text": "Make openwire the default protocol\n\nDescription:\nBefore 2.0 is released, we need to switch over the default protocol (which is currently stomp) to openwire.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Make openwire the default protocol\n\nDescription:\nBefore 2.0 is released, we need to switch over the default protocol (which is currently stomp) to openwire.\n\nComments:\n", "classification": "Classify the issue 'Make openwire the default protocol' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-82?\nA: Before 2.0 is released, we need to switch over the default protocol (which is currently stomp) to openwire."}}
{"issue_key": "AMQCPP-81", "project": "AMQCPP", "title": "openwire consumer never receives messages already in queue", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-03-12T22:58:07.000+0000", "updated": "2007-03-18T14:04:06.000+0000", "description": "When starting an openwire consumer, it will never not receive messages already in queue.  However, if a new message is sent to the queue, all previous and new messages are received.\n\nThe attached program fails to receive the message the producer sends to the queue.  If the consumer is created before sending the message, it is received just fine.\n\nThe same problem can be reproduced with separate processes.  The problem does not appear if using stomp.", "comments": [], "text": "openwire consumer never receives messages already in queue\n\nDescription:\nWhen starting an openwire consumer, it will never not receive messages already in queue.  However, if a new message is sent to the queue, all previous and new messages are received.\n\nThe attached program fails to receive the message the producer sends to the queue.  If the consumer is created before sending the message, it is received just fine.\n\nThe same problem can be reproduced with separate processes.  The problem does not appear if using stomp.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: openwire consumer never receives messages already in queue\n\nDescription:\nWhen starting an openwire consumer, it will never not receive messages already in queue.  However, if a new message is sent to the queue, all previous and new messages are received.\n\nThe attached program fails to receive the message the producer sends to the queue.  If the consumer is created before sending the message, it is received just fine.\n\nThe same problem can be reproduced with separate processes.  The problem does not appear if using stomp.\n\nComments:\n", "classification": "Classify the issue 'openwire consumer never receives messages already in queue' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-81?\nA: When starting an openwire consumer, it will never not receive messages already in queue.  However, if a new message is sent to the queue, all previous and new messages are received.\n\nThe attached program fails to receive the message the producer sends to the queue.  If the consumer is created before sending the message, it is received just fine.\n\nThe same problem can be reproduced with separate pr"}}
{"issue_key": "AMQCPP-80", "project": "AMQCPP", "title": "sending with explicit message id hangs", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-03-12T20:48:51.000+0000", "updated": "2007-03-17T12:23:31.000+0000", "description": "By disabling automatic message id and setting one explicitly causes send to hang.\n\nThe attached program tries to send a message and receive it, but never finishes.", "comments": [], "text": "sending with explicit message id hangs\n\nDescription:\nBy disabling automatic message id and setting one explicitly causes send to hang.\n\nThe attached program tries to send a message and receive it, but never finishes.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: sending with explicit message id hangs\n\nDescription:\nBy disabling automatic message id and setting one explicitly causes send to hang.\n\nThe attached program tries to send a message and receive it, but never finishes.\n\n\nComments:\n", "classification": "Classify the issue 'sending with explicit message id hangs' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-80?\nA: By disabling automatic message id and setting one explicitly causes send to hang.\n\nThe attached program tries to send a message and receive it, but never finishes.\n"}}
{"issue_key": "AMQCPP-79", "project": "AMQCPP", "title": "allow createProducer to accept null destination ", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-03-12T20:41:16.000+0000", "updated": "2007-03-13T20:41:49.000+0000", "description": "Currently createProducer does not accept null destination as parameter.  It it sometimes useful to have anonymous producers where you specify the destination at the send time.", "comments": [], "text": "allow createProducer to accept null destination \n\nDescription:\nCurrently createProducer does not accept null destination as parameter.  It it sometimes useful to have anonymous producers where you specify the destination at the send time.  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: allow createProducer to accept null destination \n\nDescription:\nCurrently createProducer does not accept null destination as parameter.  It it sometimes useful to have anonymous producers where you specify the destination at the send time.  \n\nComments:\n", "classification": "Classify the issue 'allow createProducer to accept null destination ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-79?\nA: Currently createProducer does not accept null destination as parameter.  It it sometimes useful to have anonymous producers where you specify the destination at the send time.  "}}
{"issue_key": "AMQCPP-78", "project": "AMQCPP", "title": "session tries to destroy already destroyed temporary queue", "status": "Closed", "reporter": "Teemu Torma", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-03-12T20:33:41.000+0000", "updated": "2007-03-18T01:33:54.000+0000", "description": "If using a temporary queue (or topic) and deleting it, session will try to delete it again.  This does not happen with named queues, nor if the temporary queue is never deleted.\n\nThe attached program will fail on Linux /gcc with \n\npure virtual method called\nterminate called without an active exception", "comments": [], "text": "session tries to destroy already destroyed temporary queue\n\nDescription:\nIf using a temporary queue (or topic) and deleting it, session will try to delete it again.  This does not happen with named queues, nor if the temporary queue is never deleted.\n\nThe attached program will fail on Linux /gcc with \n\npure virtual method called\nterminate called without an active exception\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: session tries to destroy already destroyed temporary queue\n\nDescription:\nIf using a temporary queue (or topic) and deleting it, session will try to delete it again.  This does not happen with named queues, nor if the temporary queue is never deleted.\n\nThe attached program will fail on Linux /gcc with \n\npure virtual method called\nterminate called without an active exception\n\n\nComments:\n", "classification": "Classify the issue 'session tries to destroy already destroyed temporary queue' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-78?\nA: If using a temporary queue (or topic) and deleting it, session will try to delete it again.  This does not happen with named queues, nor if the temporary queue is never deleted.\n\nThe attached program will fail on Linux /gcc with \n\npure virtual method called\nterminate called without an active exception\n"}}
{"issue_key": "AMQCPP-77", "project": "AMQCPP", "title": "Inconsistency when getting string property between Stomp and Openwire", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-03-12T20:31:47.000+0000", "updated": "2007-03-13T14:12:09.000+0000", "description": "In our current code we call getStringProperty on a BytesMessage for a property that might not exist. When running with Stomp, this returns an empty string. When running with Openwire, a NoSuchElementException is thrown.\n\nWe could easily change our code to first check whether the property exists with propertyExists prior to getting it, but Stomp and Openwire should probably handle missing string properties in the same way.\n\nI think this default empty string value was added at some point to avoid null pointers elsewhere in the code. Refer to AMQCPP-43.", "comments": [], "text": "Inconsistency when getting string property between Stomp and Openwire\n\nDescription:\nIn our current code we call getStringProperty on a BytesMessage for a property that might not exist. When running with Stomp, this returns an empty string. When running with Openwire, a NoSuchElementException is thrown.\n\nWe could easily change our code to first check whether the property exists with propertyExists prior to getting it, but Stomp and Openwire should probably handle missing string properties in the same way.\n\nI think this default empty string value was added at some point to avoid null pointers elsewhere in the code. Refer to AMQCPP-43.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Inconsistency when getting string property between Stomp and Openwire\n\nDescription:\nIn our current code we call getStringProperty on a BytesMessage for a property that might not exist. When running with Stomp, this returns an empty string. When running with Openwire, a NoSuchElementException is thrown.\n\nWe could easily change our code to first check whether the property exists with propertyExists prior to getting it, but Stomp and Openwire should probably handle missing string properties in the same way.\n\nI think this default empty string value was added at some point to avoid null pointers elsewhere in the code. Refer to AMQCPP-43.\n\nComments:\n", "classification": "Classify the issue 'Inconsistency when getting string property between Stomp and Openwire' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-77?\nA: In our current code we call getStringProperty on a BytesMessage for a property that might not exist. When running with Stomp, this returns an empty string. When running with Openwire, a NoSuchElementException is thrown.\n\nWe could easily change our code to first check whether the property exists with propertyExists prior to getting it, but Stomp and Openwire should probably handle missing string pr"}}
{"issue_key": "AMQCPP-76", "project": "AMQCPP", "title": "Integer property not propagated when using Openwire", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-03-11T22:35:00.000+0000", "updated": "2007-03-12T18:12:48.000+0000", "description": "We have a unit test that sends a BytesMessage with an integer property set on it. When using Stomp, the integer property is available on the received message.\n\nWhen using Openwire, the valueNodeMap field inside properties is empty, so properties.getInt(name) fails.\n\nIf you can't reproduce this, I'll see if I can extract a simple test case from our code.\n\nTested with AMQCPP 2.0 snapshot revision 517012.", "comments": [], "text": "Integer property not propagated when using Openwire\n\nDescription:\nWe have a unit test that sends a BytesMessage with an integer property set on it. When using Stomp, the integer property is available on the received message.\n\nWhen using Openwire, the valueNodeMap field inside properties is empty, so properties.getInt(name) fails.\n\nIf you can't reproduce this, I'll see if I can extract a simple test case from our code.\n\nTested with AMQCPP 2.0 snapshot revision 517012.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Integer property not propagated when using Openwire\n\nDescription:\nWe have a unit test that sends a BytesMessage with an integer property set on it. When using Stomp, the integer property is available on the received message.\n\nWhen using Openwire, the valueNodeMap field inside properties is empty, so properties.getInt(name) fails.\n\nIf you can't reproduce this, I'll see if I can extract a simple test case from our code.\n\nTested with AMQCPP 2.0 snapshot revision 517012.\n\nComments:\n", "classification": "Classify the issue 'Integer property not propagated when using Openwire' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-76?\nA: We have a unit test that sends a BytesMessage with an integer property set on it. When using Stomp, the integer property is available on the received message.\n\nWhen using Openwire, the valueNodeMap field inside properties is empty, so properties.getInt(name) fails.\n\nIf you can't reproduce this, I'll see if I can extract a simple test case from our code.\n\nTested with AMQCPP 2.0 snapshot revision 51"}}
{"issue_key": "AMQCPP-75", "project": "AMQCPP", "title": "setCMSReplyTo with null destination segfaults when using Openwire wire format", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-03-11T22:13:35.000+0000", "updated": "2007-03-12T00:06:19.000+0000", "description": "In our code we call setCMSReplyTo with a null destination in a few places. This works fine with Stomp, which does a check for null destination argument, and if the argument is not null, deletes the existing destination and clones the argument.\n\nOpenwire simply does this->setReplyTo(dynamic_cast<ActiveMQDestination*>(destination->clone())); which doesn't work if the argument is null.", "comments": [], "text": "setCMSReplyTo with null destination segfaults when using Openwire wire format\n\nDescription:\nIn our code we call setCMSReplyTo with a null destination in a few places. This works fine with Stomp, which does a check for null destination argument, and if the argument is not null, deletes the existing destination and clones the argument.\n\nOpenwire simply does this->setReplyTo(dynamic_cast<ActiveMQDestination*>(destination->clone())); which doesn't work if the argument is null.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: setCMSReplyTo with null destination segfaults when using Openwire wire format\n\nDescription:\nIn our code we call setCMSReplyTo with a null destination in a few places. This works fine with Stomp, which does a check for null destination argument, and if the argument is not null, deletes the existing destination and clones the argument.\n\nOpenwire simply does this->setReplyTo(dynamic_cast<ActiveMQDestination*>(destination->clone())); which doesn't work if the argument is null.\n\nComments:\n", "classification": "Classify the issue 'setCMSReplyTo with null destination segfaults when using Openwire wire format' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-75?\nA: In our code we call setCMSReplyTo with a null destination in a few places. This works fine with Stomp, which does a check for null destination argument, and if the argument is not null, deletes the existing destination and clones the argument.\n\nOpenwire simply does this->setReplyTo(dynamic_cast<ActiveMQDestination*>(destination->clone())); which doesn't work if the argument is null."}}
{"issue_key": "AMQCPP-74", "project": "AMQCPP", "title": "Segmentation Fault in apache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap", "status": "Closed", "reporter": "Tomas Lebovic", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2006-10-09T12:55:09.000+0000", "updated": "2007-04-23T14:19:34.000+0000", "description": "Segmentation Fault:\n\nI keep recieving a segmentation fault here is the gdb output.\napache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap (this=<value optimized out>, mode=<value optimized out>,\n    istream=Cannot access memory at address 0x69\n) at basic_string.h:249\n249           { return  _M_dataplus._M_p; }\n\nIf you need more information let me know and i will try and gather some more.", "comments": [], "text": "Segmentation Fault in apache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap\n\nDescription:\nSegmentation Fault:\n\nI keep recieving a segmentation fault here is the gdb output.\napache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap (this=<value optimized out>, mode=<value optimized out>,\n    istream=Cannot access memory at address 0x69\n) at basic_string.h:249\n249           { return  _M_dataplus._M_p; }\n\nIf you need more information let me know and i will try and gather some more.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Segmentation Fault in apache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap\n\nDescription:\nSegmentation Fault:\n\nI keep recieving a segmentation fault here is the gdb output.\napache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap (this=<value optimized out>, mode=<value optimized out>,\n    istream=Cannot access memory at address 0x69\n) at basic_string.h:249\n249           { return  _M_dataplus._M_p; }\n\nIf you need more information let me know and i will try and gather some more.\n\n\nComments:\n", "classification": "Classify the issue 'Segmentation Fault in apache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-74?\nA: Segmentation Fault:\n\nI keep recieving a segmentation fault here is the gdb output.\napache::activemq::protocol::openwire::OpenWireMarshaller::unmarshalMap (this=<value optimized out>, mode=<value optimized out>,\n    istream=Cannot access memory at address 0x69\n) at basic_string.h:249\n249           { return  _M_dataplus._M_p; }\n\nIf you need more information let me know and i will try and gather some"}}
{"issue_key": "AMQCPP-73", "project": "AMQCPP", "title": "The JMSConsumerTest interminitently failed on linux systems.", "status": "Resolved", "reporter": "Hiram R. Chirino", "assignee": "Hiram R. Chirino", "priority": "Major", "labels": [], "created": "2006-11-10T20:55:37.000+0000", "updated": "2007-02-27T12:27:31.000+0000", "description": "JMSConsumerTest fails on linux sometimes.", "comments": [], "text": "The JMSConsumerTest interminitently failed on linux systems.\n\nDescription:\nJMSConsumerTest fails on linux sometimes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: The JMSConsumerTest interminitently failed on linux systems.\n\nDescription:\nJMSConsumerTest fails on linux sometimes.\n\nComments:\n", "classification": "Classify the issue 'The JMSConsumerTest interminitently failed on linux systems.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-73?\nA: JMSConsumerTest fails on linux sometimes."}}
{"issue_key": "AMQCPP-72", "project": "AMQCPP", "title": "Incorect handling of message size in ByteArrayOutputStream::write", "status": "Resolved", "reporter": "Radek Sedmak", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-07-14T11:53:07.000+0000", "updated": "2007-02-27T12:28:26.000+0000", "description": "when you are sending message via openwire protocol, ByteArrayOutputStream::write is called in certain moment ...\nwhen message size is greater then defaul CHUNK space is reallocated and there is \"check for EOF offset\".\n\n  \n   if( offset > bodySize )\n            expandBody() ;\n\n but should be there \n\n  if ( offset >= bodySize ) \n            expandBody();", "comments": [], "text": "Incorect handling of message size in ByteArrayOutputStream::write\n\nDescription:\nwhen you are sending message via openwire protocol, ByteArrayOutputStream::write is called in certain moment ...\nwhen message size is greater then defaul CHUNK space is reallocated and there is \"check for EOF offset\".\n\n  \n   if( offset > bodySize )\n            expandBody() ;\n\n but should be there \n\n  if ( offset >= bodySize ) \n            expandBody();\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Incorect handling of message size in ByteArrayOutputStream::write\n\nDescription:\nwhen you are sending message via openwire protocol, ByteArrayOutputStream::write is called in certain moment ...\nwhen message size is greater then defaul CHUNK space is reallocated and there is \"check for EOF offset\".\n\n  \n   if( offset > bodySize )\n            expandBody() ;\n\n but should be there \n\n  if ( offset >= bodySize ) \n            expandBody();\n\n\nComments:\n", "classification": "Classify the issue 'Incorect handling of message size in ByteArrayOutputStream::write' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-72?\nA: when you are sending message via openwire protocol, ByteArrayOutputStream::write is called in certain moment ...\nwhen message size is greater then defaul CHUNK space is reallocated and there is \"check for EOF offset\".\n\n  \n   if( offset > bodySize )\n            expandBody() ;\n\n but should be there \n\n  if ( offset >= bodySize ) \n            expandBody();\n"}}
{"issue_key": "AMQCPP-71", "project": "AMQCPP", "title": "Missing NULL pointer check in  MessageConsumer::autoAcknowledge", "status": "Resolved", "reporter": "Radek Sedmak", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-07-14T12:01:24.000+0000", "updated": "2007-02-27T12:27:55.000+0000", "description": "When you call consumer->receive() on empty queue receive method returns NULL message but before return MessageConsumer::autoAcknowledge method is invoked. This method doesn't check message against NULL, this cause coredump is message is NULL.\n\nPatch: \np<IMessage> MessageConsumer::autoAcknowledge(p<IMessage> message)\n{\n    try\n    {\n        if ( message != NULL ) {   // <------ Check NULL here !!!!!\n          // Is the message an ActiveMQMessage? (throws bad_cast otherwise)\n          p<ActiveMQMessage> activeMessage = p_dyncast<ActiveMQMessage> (message) ;\n\n          // Register the handler for client acknowledgment\n          activeMessage->setAcknowledger( smartify(this) ) ;\n\n          if( acknowledgementMode != ClientAckMode )\n              doAcknowledge(activeMessage) ;\n        }\n    }\n    catch( bad_cast& bc )\n    {\n        // ignore\n    }\n    return message ;", "comments": [], "text": "Missing NULL pointer check in  MessageConsumer::autoAcknowledge\n\nDescription:\nWhen you call consumer->receive() on empty queue receive method returns NULL message but before return MessageConsumer::autoAcknowledge method is invoked. This method doesn't check message against NULL, this cause coredump is message is NULL.\n\nPatch: \np<IMessage> MessageConsumer::autoAcknowledge(p<IMessage> message)\n{\n    try\n    {\n        if ( message != NULL ) {   // <------ Check NULL here !!!!!\n          // Is the message an ActiveMQMessage? (throws bad_cast otherwise)\n          p<ActiveMQMessage> activeMessage = p_dyncast<ActiveMQMessage> (message) ;\n\n          // Register the handler for client acknowledgment\n          activeMessage->setAcknowledger( smartify(this) ) ;\n\n          if( acknowledgementMode != ClientAckMode )\n              doAcknowledge(activeMessage) ;\n        }\n    }\n    catch( bad_cast& bc )\n    {\n        // ignore\n    }\n    return message ;\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Missing NULL pointer check in  MessageConsumer::autoAcknowledge\n\nDescription:\nWhen you call consumer->receive() on empty queue receive method returns NULL message but before return MessageConsumer::autoAcknowledge method is invoked. This method doesn't check message against NULL, this cause coredump is message is NULL.\n\nPatch: \np<IMessage> MessageConsumer::autoAcknowledge(p<IMessage> message)\n{\n    try\n    {\n        if ( message != NULL ) {   // <------ Check NULL here !!!!!\n          // Is the message an ActiveMQMessage? (throws bad_cast otherwise)\n          p<ActiveMQMessage> activeMessage = p_dyncast<ActiveMQMessage> (message) ;\n\n          // Register the handler for client acknowledgment\n          activeMessage->setAcknowledger( smartify(this) ) ;\n\n          if( acknowledgementMode != ClientAckMode )\n              doAcknowledge(activeMessage) ;\n        }\n    }\n    catch( bad_cast& bc )\n    {\n        // ignore\n    }\n    return message ;\n\n\nComments:\n", "classification": "Classify the issue 'Missing NULL pointer check in  MessageConsumer::autoAcknowledge' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-71?\nA: When you call consumer->receive() on empty queue receive method returns NULL message but before return MessageConsumer::autoAcknowledge method is invoked. This method doesn't check message against NULL, this cause coredump is message is NULL.\n\nPatch: \np<IMessage> MessageConsumer::autoAcknowledge(p<IMessage> message)\n{\n    try\n    {\n        if ( message != NULL ) {   // <------ Check NULL here !!!!"}}
{"issue_key": "AMQCPP-69", "project": "AMQCPP", "title": "typo in C client", "status": "Resolved", "reporter": "James Strachan", "assignee": "Unassigned", "priority": "Major", "labels": [], "created": "2006-07-12T00:57:07.000+0000", "updated": "2007-02-27T12:27:00.000+0000", "description": "Contributed by BasharTeg on IRC...\n\now_marshal.c line 72, should be if( *object == 0 ) instead of if( object == 0 )", "comments": [], "text": "typo in C client\n\nDescription:\nContributed by BasharTeg on IRC...\n\now_marshal.c line 72, should be if( *object == 0 ) instead of if( object == 0 )\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: typo in C client\n\nDescription:\nContributed by BasharTeg on IRC...\n\now_marshal.c line 72, should be if( *object == 0 ) instead of if( object == 0 )\n\nComments:\n", "classification": "Classify the issue 'typo in C client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-69?\nA: Contributed by BasharTeg on IRC...\n\now_marshal.c line 72, should be if( *object == 0 ) instead of if( object == 0 )"}}
{"issue_key": "AMQCPP-68", "project": "AMQCPP", "title": "Memory Leak in Message transport / send / recieve C++ client", "status": "Closed", "reporter": "Tomas Lebovic", "assignee": "Unassigned", "priority": "Critical", "labels": [], "created": "2006-09-22T08:43:23.000+0000", "updated": "2007-04-23T14:19:13.000+0000", "description": "There seems to be a memory leak in the message transport. If we take the following simple code below and then monitor memory consumption we will see it steadily go up. \n\n<code>\n\n#include <exception>\n#include <iostream>\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <cms/IConnection.hpp>\n#include <cms/IConnectionFactory.hpp>\n#include <activemq/ConnectionFactory.hpp>\n#include <activemq/Connection.hpp>\n#include <ppr/TraceException.hpp>\n#include <ppr/net/Uri.hpp>\n#include <ppr/util/ifr/p>\n\nusing namespace apache::activemq;\nusing namespace apache::ppr::net;\n\nclass TestAsynchTopic :public IMessageListener\n{\nprivate:\n\npublic:\n\tvoid onMessage(p<IMessage> message)\n\t{\n\t\tp<IMapMessage> msg = p_dyncast<IMapMessage> (message) ;\n\n\t\tprintf(\"got %s\\n\",msg->getString(\"msg\")->c_str());\n\t\tmsg = NULL;\n\t}\n} ;\n\nchar * bunk = \"memory leak?\";\n\nint main()\n{\n        TestAsynchTopic list1;\n \n        p<Uri> uri = new Uri(\"tcp://localhost:61616\");\n\tp<ConnectionFactory> factory = new ConnectionFactory(uri);\n\n\tp<ISession>    session  = NULL;\n        p<ITopic>           topic = NULL ;\n\tp<IMessageConsumer> consumer1 = NULL;\n\tp<IMapMessage>      message = NULL ;\n\tp<IMessageProducer> producer = NULL ;\n\n\ttry\n\t{\n\t\tp<IConnection> connection  = factory->createConnection();\n\t\tsession= connection->createSession();\n\t} \n\tcatch(ConnectionException &e)\n\t{\t\n\t\tprintf(\"%s\\n\",e.what());\n\t}\n    \n        topic = session->getTopic(\"memory.leak\") ;\n        producer = session->createProducer(topic) ;\n\tconsumer1 = session->createConsumer(topic) ;\n\tconsumer1->setMessageListener( smartify(&list1) ) ;\n\n       while(1)\n\t{\n\t\tmessage = session->createMapMessage();\n\t\tmessage->setString(\"msg\", (char*)bunk);\n\t\tproducer->send(message);\n\t\tmessage = NULL;\n\t}\n\n        return 0;\n}\n\n</code>\n\nNow i haven't been using c++ api for a long time but i can't see any way to destroy the messages other then letting them go out of scope or when refrence count = 0. So if there is a way to destroy the messages after they are sent / recieved please let me know.", "comments": [], "text": "Memory Leak in Message transport / send / recieve C++ client\n\nDescription:\nThere seems to be a memory leak in the message transport. If we take the following simple code below and then monitor memory consumption we will see it steadily go up. \n\n<code>\n\n#include <exception>\n#include <iostream>\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <cms/IConnection.hpp>\n#include <cms/IConnectionFactory.hpp>\n#include <activemq/ConnectionFactory.hpp>\n#include <activemq/Connection.hpp>\n#include <ppr/TraceException.hpp>\n#include <ppr/net/Uri.hpp>\n#include <ppr/util/ifr/p>\n\nusing namespace apache::activemq;\nusing namespace apache::ppr::net;\n\nclass TestAsynchTopic :public IMessageListener\n{\nprivate:\n\npublic:\n\tvoid onMessage(p<IMessage> message)\n\t{\n\t\tp<IMapMessage> msg = p_dyncast<IMapMessage> (message) ;\n\n\t\tprintf(\"got %s\\n\",msg->getString(\"msg\")->c_str());\n\t\tmsg = NULL;\n\t}\n} ;\n\nchar * bunk = \"memory leak?\";\n\nint main()\n{\n        TestAsynchTopic list1;\n \n        p<Uri> uri = new Uri(\"tcp://localhost:61616\");\n\tp<ConnectionFactory> factory = new ConnectionFactory(uri);\n\n\tp<ISession>    session  = NULL;\n        p<ITopic>           topic = NULL ;\n\tp<IMessageConsumer> consumer1 = NULL;\n\tp<IMapMessage>      message = NULL ;\n\tp<IMessageProducer> producer = NULL ;\n\n\ttry\n\t{\n\t\tp<IConnection> connection  = factory->createConnection();\n\t\tsession= connection->createSession();\n\t} \n\tcatch(ConnectionException &e)\n\t{\t\n\t\tprintf(\"%s\\n\",e.what());\n\t}\n    \n        topic = session->getTopic(\"memory.leak\") ;\n        producer = session->createProducer(topic) ;\n\tconsumer1 = session->createConsumer(topic) ;\n\tconsumer1->setMessageListener( smartify(&list1) ) ;\n\n       while(1)\n\t{\n\t\tmessage = session->createMapMessage();\n\t\tmessage->setString(\"msg\", (char*)bunk);\n\t\tproducer->send(message);\n\t\tmessage = NULL;\n\t}\n\n        return 0;\n}\n\n</code>\n\nNow i haven't been using c++ api for a long time but i can't see any way to destroy the messages other then letting them go out of scope or when refrence count = 0. So if there is a way to destroy the messages after they are sent / recieved please let me know.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory Leak in Message transport / send / recieve C++ client\n\nDescription:\nThere seems to be a memory leak in the message transport. If we take the following simple code below and then monitor memory consumption we will see it steadily go up. \n\n<code>\n\n#include <exception>\n#include <iostream>\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <cms/IConnection.hpp>\n#include <cms/IConnectionFactory.hpp>\n#include <activemq/ConnectionFactory.hpp>\n#include <activemq/Connection.hpp>\n#include <ppr/TraceException.hpp>\n#include <ppr/net/Uri.hpp>\n#include <ppr/util/ifr/p>\n\nusing namespace apache::activemq;\nusing namespace apache::ppr::net;\n\nclass TestAsynchTopic :public IMessageListener\n{\nprivate:\n\npublic:\n\tvoid onMessage(p<IMessage> message)\n\t{\n\t\tp<IMapMessage> msg = p_dyncast<IMapMessage> (message) ;\n\n\t\tprintf(\"got %s\\n\",msg->getString(\"msg\")->c_str());\n\t\tmsg = NULL;\n\t}\n} ;\n\nchar * bunk = \"memory leak?\";\n\nint main()\n{\n        TestAsynchTopic list1;\n \n        p<Uri> uri = new Uri(\"tcp://localhost:61616\");\n\tp<ConnectionFactory> factory = new ConnectionFactory(uri);\n\n\tp<ISession>    session  = NULL;\n        p<ITopic>           topic = NULL ;\n\tp<IMessageConsumer> consumer1 = NULL;\n\tp<IMapMessage>      message = NULL ;\n\tp<IMessageProducer> producer = NULL ;\n\n\ttry\n\t{\n\t\tp<IConnection> connection  = factory->createConnection();\n\t\tsession= connection->createSession();\n\t} \n\tcatch(ConnectionException &e)\n\t{\t\n\t\tprintf(\"%s\\n\",e.what());\n\t}\n    \n        topic = session->getTopic(\"memory.leak\") ;\n        producer = session->createProducer(topic) ;\n\tconsumer1 = session->createConsumer(topic) ;\n\tconsumer1->setMessageListener( smartify(&list1) ) ;\n\n       while(1)\n\t{\n\t\tmessage = session->createMapMessage();\n\t\tmessage->setString(\"msg\", (char*)bunk);\n\t\tproducer->send(message);\n\t\tmessage = NULL;\n\t}\n\n        return 0;\n}\n\n</code>\n\nNow i haven't been using c++ api for a long time but i can't see any way to destroy the messages other then letting them go out of scope or when refrence count = 0. So if there is a way to destroy the messages after they are sent / recieved please let me know.\n\n\n\nComments:\n", "classification": "Classify the issue 'Memory Leak in Message transport / send / recieve C++ client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-68?\nA: There seems to be a memory leak in the message transport. If we take the following simple code below and then monitor memory consumption we will see it steadily go up. \n\n<code>\n\n#include <exception>\n#include <iostream>\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <cms/IConnection.hpp>\n#include <cms/IConnectionFactory.hpp>\n#include <activemq/ConnectionFactory.hpp>\n#include <activemq"}}
{"issue_key": "AMQCPP-67", "project": "AMQCPP", "title": "Get warning \" 'e' : unreferenced local variable\" in the example main.cpp", "status": "Resolved", "reporter": "Greg Griffin", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-02-16T09:44:36.000+0000", "updated": "2007-02-16T15:25:38.000+0000", "description": "occurs in method cleanup(), e.g.\n\ntry {                        \n     if( destination != NULL ) delete destination;\n} catch ( CMSException& e ) {}\ndestination = NULL;\n\nTo solve, can just add something with \"e\" inside the catch. e.g.:\n   ...catch ( CMSException& e ) {e.printStackTrace();}", "comments": [], "text": "Get warning \" 'e' : unreferenced local variable\" in the example main.cpp\n\nDescription:\noccurs in method cleanup(), e.g.\n\ntry {                        \n     if( destination != NULL ) delete destination;\n} catch ( CMSException& e ) {}\ndestination = NULL;\n\nTo solve, can just add something with \"e\" inside the catch. e.g.:\n   ...catch ( CMSException& e ) {e.printStackTrace();}\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Get warning \" 'e' : unreferenced local variable\" in the example main.cpp\n\nDescription:\noccurs in method cleanup(), e.g.\n\ntry {                        \n     if( destination != NULL ) delete destination;\n} catch ( CMSException& e ) {}\ndestination = NULL;\n\nTo solve, can just add something with \"e\" inside the catch. e.g.:\n   ...catch ( CMSException& e ) {e.printStackTrace();}\n\n\nComments:\n", "classification": "Classify the issue 'Get warning \" 'e' : unreferenced local variable\" in the example main.cpp' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-67?\nA: occurs in method cleanup(), e.g.\n\ntry {                        \n     if( destination != NULL ) delete destination;\n} catch ( CMSException& e ) {}\ndestination = NULL;\n\nTo solve, can just add something with \"e\" inside the catch. e.g.:\n   ...catch ( CMSException& e ) {e.printStackTrace();}\n"}}
{"issue_key": "AMQCPP-66", "project": "AMQCPP", "title": "Refactor the Async send to happen in an Async Transport instead of in ActiveMQSession", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-01-31T14:44:18.000+0000", "updated": "2007-05-24T13:16:41.000+0000", "description": "We should re-factor the code that implements the Async Send feature to use an TransportFilter dervied class that handles the async send stuff.  This would reduce the overhead as right now, each session creates a thread for sends, where this class would only need one thread and everyone would just make use of it.  \n\nWe need this issue to get done first I think so that we can cleanly implement this.\nhttps://issues.apache.org/activemq/browse/AMQCPP-65\n\nOne other thing we might want to think about here is the lifetime of objects that are sent when in async mode.  Currently all messages are cloned and deleted by the session.  We may want to think about changing the CMS API to require that objects are owned by us once you pass them to a send call.  Then we can control the lifetime and delete it when we are done with it without having to clone the message.", "comments": [], "text": "Refactor the Async send to happen in an Async Transport instead of in ActiveMQSession\n\nDescription:\nWe should re-factor the code that implements the Async Send feature to use an TransportFilter dervied class that handles the async send stuff.  This would reduce the overhead as right now, each session creates a thread for sends, where this class would only need one thread and everyone would just make use of it.  \n\nWe need this issue to get done first I think so that we can cleanly implement this.\nhttps://issues.apache.org/activemq/browse/AMQCPP-65\n\nOne other thing we might want to think about here is the lifetime of objects that are sent when in async mode.  Currently all messages are cloned and deleted by the session.  We may want to think about changing the CMS API to require that objects are owned by us once you pass them to a send call.  Then we can control the lifetime and delete it when we are done with it without having to clone the message.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Refactor the Async send to happen in an Async Transport instead of in ActiveMQSession\n\nDescription:\nWe should re-factor the code that implements the Async Send feature to use an TransportFilter dervied class that handles the async send stuff.  This would reduce the overhead as right now, each session creates a thread for sends, where this class would only need one thread and everyone would just make use of it.  \n\nWe need this issue to get done first I think so that we can cleanly implement this.\nhttps://issues.apache.org/activemq/browse/AMQCPP-65\n\nOne other thing we might want to think about here is the lifetime of objects that are sent when in async mode.  Currently all messages are cloned and deleted by the session.  We may want to think about changing the CMS API to require that objects are owned by us once you pass them to a send call.  Then we can control the lifetime and delete it when we are done with it without having to clone the message.\n\n\nComments:\n", "classification": "Classify the issue 'Refactor the Async send to happen in an Async Transport instead of in ActiveMQSession' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-66?\nA: We should re-factor the code that implements the Async Send feature to use an TransportFilter dervied class that handles the async send stuff.  This would reduce the overhead as right now, each session creates a thread for sends, where this class would only need one thread and everyone would just make use of it.  \n\nWe need this issue to get done first I think so that we can cleanly implement this."}}
{"issue_key": "AMQCPP-65", "project": "AMQCPP", "title": "Refactor transport creation", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-31T14:33:46.000+0000", "updated": "2007-05-03T22:59:24.000+0000", "description": "Currently, the chain of transports (TcpTransport, ResponseCorrelator, IOTransport, etc) is wired together in the TcpTransportFactory class.  It would be cleaner to have an AggregateTransportFactory that is responsible for \"wiring\" the chain.\n\nThe current chain of transports is as follows:\nResponseCorrelator->TcpTransport->IOTransport\n\nIn addition, by moving the task of wiring outside of the TcpTransportFactory, we give ourselves the ability to support multiple network protocols such as UDP.\n\nThe new AggregateTransportFactory would always be used by the library, regardless of the transport options provided by the user.  It would be responsible for reading the options and adjusting its wiring accordingly.  A list of notional parameters might include:\n\ntransport.networkProtocol - Currently could only be \"tcp\".  If not provided, defaults to \"tcp\".\ntransport.useAsyncSend - If \"true\" an AsyncSendTransport is wired into the chain.  Defaults to \"false\".\ntransport.enableLogging  - If \"true\" adds a transport filter that logs the data being sent/received.  Defaults to \"false\".\n\nPerhaps we could even define the order in which the transports are wired.  Maybe a configuration file could be read in that defines where to stick the transports in the chain.", "comments": [], "text": "Refactor transport creation\n\nDescription:\nCurrently, the chain of transports (TcpTransport, ResponseCorrelator, IOTransport, etc) is wired together in the TcpTransportFactory class.  It would be cleaner to have an AggregateTransportFactory that is responsible for \"wiring\" the chain.\n\nThe current chain of transports is as follows:\nResponseCorrelator->TcpTransport->IOTransport\n\nIn addition, by moving the task of wiring outside of the TcpTransportFactory, we give ourselves the ability to support multiple network protocols such as UDP.\n\nThe new AggregateTransportFactory would always be used by the library, regardless of the transport options provided by the user.  It would be responsible for reading the options and adjusting its wiring accordingly.  A list of notional parameters might include:\n\ntransport.networkProtocol - Currently could only be \"tcp\".  If not provided, defaults to \"tcp\".\ntransport.useAsyncSend - If \"true\" an AsyncSendTransport is wired into the chain.  Defaults to \"false\".\ntransport.enableLogging  - If \"true\" adds a transport filter that logs the data being sent/received.  Defaults to \"false\".\n\nPerhaps we could even define the order in which the transports are wired.  Maybe a configuration file could be read in that defines where to stick the transports in the chain.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Refactor transport creation\n\nDescription:\nCurrently, the chain of transports (TcpTransport, ResponseCorrelator, IOTransport, etc) is wired together in the TcpTransportFactory class.  It would be cleaner to have an AggregateTransportFactory that is responsible for \"wiring\" the chain.\n\nThe current chain of transports is as follows:\nResponseCorrelator->TcpTransport->IOTransport\n\nIn addition, by moving the task of wiring outside of the TcpTransportFactory, we give ourselves the ability to support multiple network protocols such as UDP.\n\nThe new AggregateTransportFactory would always be used by the library, regardless of the transport options provided by the user.  It would be responsible for reading the options and adjusting its wiring accordingly.  A list of notional parameters might include:\n\ntransport.networkProtocol - Currently could only be \"tcp\".  If not provided, defaults to \"tcp\".\ntransport.useAsyncSend - If \"true\" an AsyncSendTransport is wired into the chain.  Defaults to \"false\".\ntransport.enableLogging  - If \"true\" adds a transport filter that logs the data being sent/received.  Defaults to \"false\".\n\nPerhaps we could even define the order in which the transports are wired.  Maybe a configuration file could be read in that defines where to stick the transports in the chain.\n\n\n\nComments:\n", "classification": "Classify the issue 'Refactor transport creation' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-65?\nA: Currently, the chain of transports (TcpTransport, ResponseCorrelator, IOTransport, etc) is wired together in the TcpTransportFactory class.  It would be cleaner to have an AggregateTransportFactory that is responsible for \"wiring\" the chain.\n\nThe current chain of transports is as follows:\nResponseCorrelator->TcpTransport->IOTransport\n\nIn addition, by moving the task of wiring outside of the TcpTra"}}
{"issue_key": "AMQCPP-64", "project": "AMQCPP", "title": "Inconsistency in topic names when creating topics", "status": "Closed", "reporter": "Lalit Nagpal", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-31T12:23:11.000+0000", "updated": "2007-02-02T11:19:25.000+0000", "description": "Hi \n\nI am using the activemq-cpp cms api 1.0 release. The problem I am facing is like this- \nMy producer sends a message to the consumer and a message should be sent from the receiving end as a reply after this - consider a situation where a loginRequest message has been sent and now a loginReply message should be sent from the receiving end. \n\nAttached is a sample main that can reproduce the problem I am facing - I have modified the sample helloproducer helloconsumer code available at \nhttp://activemq.org/site/activemq-cpp-client.html  \nto reproduce my problem so that its easier for you to see. Please see attached cpp file = DestProbs.cpp.\n\nIf you execute this piece of code you will see the output as in the attached image file (see attachments = DestinationProblem.JPG)\n\nThis is what the code does \nproducer lets call it xxx sends a \"Hello world! from thread xxxx\" to the consumer \nconsumer lets call it yyy receives the message and displays it \nthis is the normal behavior as given in the example on http://activemq.org/site/activemq-cpp-client.html \nFollowing extra needs to be done now \nfrom yyy a reply should go back to xxx ... for this i registered a producer at yyy by creating a topic using the message->getCMSReplyTo() and then replying back to that destination. \n\nThe mismatch can be easily see by doing a bstat .... when I created the consumer yyy initially it created a topic by name say ABCDEFGH (which is a random id) and later on when I used the message->getCMSReplyTo() to create a topic the topic was registered with the name /topic/ABCDEFGH ..... the additional /topic/ that has got added is doing a mess up here and the replies from yyy to xxx are not reaching xxx (getting enqueued and not dequeued) ... \n\nthe /topic/ gets added due to the following statement in HelloWorldProducer - run method \nmessage->setCMSReplyTo(replyTopic->toProviderString()); \nhere the toProviderString method adds it actually ... if you replace this method with just the toString() method ... you will get a stomp exception saying that destinations should start with either /topic/ or /queue/ \n\nCan somebody make this code work please. \n\nFor every message sent by the producer to consumer \"Hello world! from thread xxxx\" there should be a reply coming back as \"Thank you for Hello World !!!\" \n\nPlease help me urgently here. \n\nThank you in advance \n\nLalit Nagpal \nCSA, SunGard", "comments": [], "text": "Inconsistency in topic names when creating topics\n\nDescription:\nHi \n\nI am using the activemq-cpp cms api 1.0 release. The problem I am facing is like this- \nMy producer sends a message to the consumer and a message should be sent from the receiving end as a reply after this - consider a situation where a loginRequest message has been sent and now a loginReply message should be sent from the receiving end. \n\nAttached is a sample main that can reproduce the problem I am facing - I have modified the sample helloproducer helloconsumer code available at \nhttp://activemq.org/site/activemq-cpp-client.html  \nto reproduce my problem so that its easier for you to see. Please see attached cpp file = DestProbs.cpp.\n\nIf you execute this piece of code you will see the output as in the attached image file (see attachments = DestinationProblem.JPG)\n\nThis is what the code does \nproducer lets call it xxx sends a \"Hello world! from thread xxxx\" to the consumer \nconsumer lets call it yyy receives the message and displays it \nthis is the normal behavior as given in the example on http://activemq.org/site/activemq-cpp-client.html \nFollowing extra needs to be done now \nfrom yyy a reply should go back to xxx ... for this i registered a producer at yyy by creating a topic using the message->getCMSReplyTo() and then replying back to that destination. \n\nThe mismatch can be easily see by doing a bstat .... when I created the consumer yyy initially it created a topic by name say ABCDEFGH (which is a random id) and later on when I used the message->getCMSReplyTo() to create a topic the topic was registered with the name /topic/ABCDEFGH ..... the additional /topic/ that has got added is doing a mess up here and the replies from yyy to xxx are not reaching xxx (getting enqueued and not dequeued) ... \n\nthe /topic/ gets added due to the following statement in HelloWorldProducer - run method \nmessage->setCMSReplyTo(replyTopic->toProviderString()); \nhere the toProviderString method adds it actually ... if you replace this method with just the toString() method ... you will get a stomp exception saying that destinations should start with either /topic/ or /queue/ \n\nCan somebody make this code work please. \n\nFor every message sent by the producer to consumer \"Hello world! from thread xxxx\" there should be a reply coming back as \"Thank you for Hello World !!!\" \n\nPlease help me urgently here. \n\nThank you in advance \n\nLalit Nagpal \nCSA, SunGard \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Inconsistency in topic names when creating topics\n\nDescription:\nHi \n\nI am using the activemq-cpp cms api 1.0 release. The problem I am facing is like this- \nMy producer sends a message to the consumer and a message should be sent from the receiving end as a reply after this - consider a situation where a loginRequest message has been sent and now a loginReply message should be sent from the receiving end. \n\nAttached is a sample main that can reproduce the problem I am facing - I have modified the sample helloproducer helloconsumer code available at \nhttp://activemq.org/site/activemq-cpp-client.html  \nto reproduce my problem so that its easier for you to see. Please see attached cpp file = DestProbs.cpp.\n\nIf you execute this piece of code you will see the output as in the attached image file (see attachments = DestinationProblem.JPG)\n\nThis is what the code does \nproducer lets call it xxx sends a \"Hello world! from thread xxxx\" to the consumer \nconsumer lets call it yyy receives the message and displays it \nthis is the normal behavior as given in the example on http://activemq.org/site/activemq-cpp-client.html \nFollowing extra needs to be done now \nfrom yyy a reply should go back to xxx ... for this i registered a producer at yyy by creating a topic using the message->getCMSReplyTo() and then replying back to that destination. \n\nThe mismatch can be easily see by doing a bstat .... when I created the consumer yyy initially it created a topic by name say ABCDEFGH (which is a random id) and later on when I used the message->getCMSReplyTo() to create a topic the topic was registered with the name /topic/ABCDEFGH ..... the additional /topic/ that has got added is doing a mess up here and the replies from yyy to xxx are not reaching xxx (getting enqueued and not dequeued) ... \n\nthe /topic/ gets added due to the following statement in HelloWorldProducer - run method \nmessage->setCMSReplyTo(replyTopic->toProviderString()); \nhere the toProviderString method adds it actually ... if you replace this method with just the toString() method ... you will get a stomp exception saying that destinations should start with either /topic/ or /queue/ \n\nCan somebody make this code work please. \n\nFor every message sent by the producer to consumer \"Hello world! from thread xxxx\" there should be a reply coming back as \"Thank you for Hello World !!!\" \n\nPlease help me urgently here. \n\nThank you in advance \n\nLalit Nagpal \nCSA, SunGard \n\nComments:\n", "classification": "Classify the issue 'Inconsistency in topic names when creating topics' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-64?\nA: Hi \n\nI am using the activemq-cpp cms api 1.0 release. The problem I am facing is like this- \nMy producer sends a message to the consumer and a message should be sent from the receiving end as a reply after this - consider a situation where a loginRequest message has been sent and now a loginReply message should be sent from the receiving end. \n\nAttached is a sample main that can reproduce the prob"}}
{"issue_key": "AMQCPP-63", "project": "AMQCPP", "title": "asynchronous send", "status": "Resolved", "reporter": "L:esha Masterov", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-01-30T15:55:17.000+0000", "updated": "2007-01-31T14:29:30.000+0000", "description": "Please allow for asynchronous send in the C++ client.", "comments": [], "text": "asynchronous send\n\nDescription:\nPlease allow for asynchronous send in the C++ client.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: asynchronous send\n\nDescription:\nPlease allow for asynchronous send in the C++ client.\n\nComments:\n", "classification": "Classify the issue 'asynchronous send' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-63?\nA: Please allow for asynchronous send in the C++ client."}}
{"issue_key": "AMQCPP-62", "project": "AMQCPP", "title": "Broken CLIENT_ACKNOWLEDGE", "status": "Resolved", "reporter": "Manuel Vivo", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-30T12:12:21.000+0000", "updated": "2007-03-11T00:43:30.000+0000", "description": "We've been trying to use the CLIENT_ACKNOWLEDGE mode without success. As a test, we've modified the example code in the distribution so it uses CLIENT_ACKNOWLEDGE, and it gives an error. I'm attaching the modified C++ code, and the output.\n\nWe're using the release versions of ActiveMQ (4.1.0) and ActiveMQ CPP (1.0)\n\nWe've tried also with the latest snapshot of ActiveMQ (apache-activemq-4.2-incubator-20070120.082020-21.zip) and the version 1.1 of ActiveMQ CPP, downloaded with\n\nsvn co https://svn.apache.org/repos/asf/incubator/activemq/activemq-cpp/tags/activemq-cpp-1.1 \n\nIt doesn't work either, but the error message is different. I'm attaching the modified code and the related output also.", "comments": [], "text": "Broken CLIENT_ACKNOWLEDGE\n\nDescription:\nWe've been trying to use the CLIENT_ACKNOWLEDGE mode without success. As a test, we've modified the example code in the distribution so it uses CLIENT_ACKNOWLEDGE, and it gives an error. I'm attaching the modified C++ code, and the output.\n\nWe're using the release versions of ActiveMQ (4.1.0) and ActiveMQ CPP (1.0)\n\nWe've tried also with the latest snapshot of ActiveMQ (apache-activemq-4.2-incubator-20070120.082020-21.zip) and the version 1.1 of ActiveMQ CPP, downloaded with\n\nsvn co https://svn.apache.org/repos/asf/incubator/activemq/activemq-cpp/tags/activemq-cpp-1.1 \n\nIt doesn't work either, but the error message is different. I'm attaching the modified code and the related output also. \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Broken CLIENT_ACKNOWLEDGE\n\nDescription:\nWe've been trying to use the CLIENT_ACKNOWLEDGE mode without success. As a test, we've modified the example code in the distribution so it uses CLIENT_ACKNOWLEDGE, and it gives an error. I'm attaching the modified C++ code, and the output.\n\nWe're using the release versions of ActiveMQ (4.1.0) and ActiveMQ CPP (1.0)\n\nWe've tried also with the latest snapshot of ActiveMQ (apache-activemq-4.2-incubator-20070120.082020-21.zip) and the version 1.1 of ActiveMQ CPP, downloaded with\n\nsvn co https://svn.apache.org/repos/asf/incubator/activemq/activemq-cpp/tags/activemq-cpp-1.1 \n\nIt doesn't work either, but the error message is different. I'm attaching the modified code and the related output also. \n\n\n\nComments:\n", "classification": "Classify the issue 'Broken CLIENT_ACKNOWLEDGE' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-62?\nA: We've been trying to use the CLIENT_ACKNOWLEDGE mode without success. As a test, we've modified the example code in the distribution so it uses CLIENT_ACKNOWLEDGE, and it gives an error. I'm attaching the modified C++ code, and the output.\n\nWe're using the release versions of ActiveMQ (4.1.0) and ActiveMQ CPP (1.0)\n\nWe've tried also with the latest snapshot of ActiveMQ (apache-activemq-4.2-incubat"}}
{"issue_key": "AMQCPP-61", "project": "AMQCPP", "title": "CMSException::what returns c_str of temporary std::string", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-29T10:43:34.000+0000", "updated": "2007-01-29T12:47:25.000+0000", "description": "In my debugging to figure out what's going on with AMQCPP-59, I'm sometimes seeing invalid stuff getting printed out when I do printStackTrace on some exceptions. I think this might be because CMSException::what returns getMessage().c_str(), i.e. it seems to be returning the c_str of a std::string that is allocated on the stack, since getMessage returns std::string.\n\nAn example of where what() is being called that seems to be causing problems is on line 84 of ActiveMQConsumer.cpp. When I catch this exception later on and print its stack trace or call its getMessage, I get garbage.", "comments": [], "text": "CMSException::what returns c_str of temporary std::string\n\nDescription:\nIn my debugging to figure out what's going on with AMQCPP-59, I'm sometimes seeing invalid stuff getting printed out when I do printStackTrace on some exceptions. I think this might be because CMSException::what returns getMessage().c_str(), i.e. it seems to be returning the c_str of a std::string that is allocated on the stack, since getMessage returns std::string.\n\nAn example of where what() is being called that seems to be causing problems is on line 84 of ActiveMQConsumer.cpp. When I catch this exception later on and print its stack trace or call its getMessage, I get garbage.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMSException::what returns c_str of temporary std::string\n\nDescription:\nIn my debugging to figure out what's going on with AMQCPP-59, I'm sometimes seeing invalid stuff getting printed out when I do printStackTrace on some exceptions. I think this might be because CMSException::what returns getMessage().c_str(), i.e. it seems to be returning the c_str of a std::string that is allocated on the stack, since getMessage returns std::string.\n\nAn example of where what() is being called that seems to be causing problems is on line 84 of ActiveMQConsumer.cpp. When I catch this exception later on and print its stack trace or call its getMessage, I get garbage.\n\nComments:\n", "classification": "Classify the issue 'CMSException::what returns c_str of temporary std::string' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-61?\nA: In my debugging to figure out what's going on with AMQCPP-59, I'm sometimes seeing invalid stuff getting printed out when I do printStackTrace on some exceptions. I think this might be because CMSException::what returns getMessage().c_str(), i.e. it seems to be returning the c_str of a std::string that is allocated on the stack, since getMessage returns std::string.\n\nAn example of where what() is "}}
{"issue_key": "AMQCPP-60", "project": "AMQCPP", "title": "message information is lost from stomp message to jms", "status": "Closed", "reporter": "Kay Stanke", "assignee": "Nathan Christopher Mittler", "priority": "Critical", "labels": [], "created": "2007-01-29T10:17:39.000+0000", "updated": "2007-02-15T00:07:27.000+0000", "description": "As my producer is a cpp server program i downloaded and compiled activemq-cpp 1.0. I managed to make activemq-cpp compile and link as shared lib / dll under vc 7.1 (Visual Studio .NET 2003). My consumer is located on a bea wls 8.1 I use the jms to jms bridge to forward the messages. For other reasons (see AMQ-1141) the forward fails. I can see in the dumped message:\n\nmessage: ActiveMQTextMessage {commandId = 3, responseRequired = false, \nmessageId = ID:KStanke-2844-1170064566619-5:0:-1:1:1, \noriginalDestination = null, \noriginalTransactionId = null, \nproducerId = ID:KStanke-2844-1170064566619-5:0:-1:1, \ndestination = queue://TEST.FOO, \ntransactionId = null, expiration = 0, \ntimestamp = 1170064774288, \narrival = 0, \ncorrelationId = null, \nreplyTo = null, \npersistent = false, \ntype = null, \npriority = 4, \ngroupID = null, \ngroupSequence = 0, targetConsumerId = null, compressed = false, \nuserID = null, content = org.apache.activemq.util.ByteSequence@12f9924, \nmarshalledProperties = org.apache.activemq.util.ByteSequence@1ef3212, dataStructure = null, \nredeliveryCounter = 0, size = 0, properties = {request-id=2}, readOnlyProperties = true, \nreadOnlyBody = true, droppable = false, text = null}\n\ni'm missing the persistence as i used pProducer->setDeliveryMode( DeliveryMode::PERSISTANT ); As my message is a text message i'm missing the message text as well. I created the message with: pMessage = pSession->createTextMessage(messageText); with an nonempty string.", "comments": [], "text": "message information is lost from stomp message to jms\n\nDescription:\nAs my producer is a cpp server program i downloaded and compiled activemq-cpp 1.0. I managed to make activemq-cpp compile and link as shared lib / dll under vc 7.1 (Visual Studio .NET 2003). My consumer is located on a bea wls 8.1 I use the jms to jms bridge to forward the messages. For other reasons (see AMQ-1141) the forward fails. I can see in the dumped message:\n\nmessage: ActiveMQTextMessage {commandId = 3, responseRequired = false, \nmessageId = ID:KStanke-2844-1170064566619-5:0:-1:1:1, \noriginalDestination = null, \noriginalTransactionId = null, \nproducerId = ID:KStanke-2844-1170064566619-5:0:-1:1, \ndestination = queue://TEST.FOO, \ntransactionId = null, expiration = 0, \ntimestamp = 1170064774288, \narrival = 0, \ncorrelationId = null, \nreplyTo = null, \npersistent = false, \ntype = null, \npriority = 4, \ngroupID = null, \ngroupSequence = 0, targetConsumerId = null, compressed = false, \nuserID = null, content = org.apache.activemq.util.ByteSequence@12f9924, \nmarshalledProperties = org.apache.activemq.util.ByteSequence@1ef3212, dataStructure = null, \nredeliveryCounter = 0, size = 0, properties = {request-id=2}, readOnlyProperties = true, \nreadOnlyBody = true, droppable = false, text = null}\n\ni'm missing the persistence as i used pProducer->setDeliveryMode( DeliveryMode::PERSISTANT ); As my message is a text message i'm missing the message text as well. I created the message with: pMessage = pSession->createTextMessage(messageText); with an nonempty string. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: message information is lost from stomp message to jms\n\nDescription:\nAs my producer is a cpp server program i downloaded and compiled activemq-cpp 1.0. I managed to make activemq-cpp compile and link as shared lib / dll under vc 7.1 (Visual Studio .NET 2003). My consumer is located on a bea wls 8.1 I use the jms to jms bridge to forward the messages. For other reasons (see AMQ-1141) the forward fails. I can see in the dumped message:\n\nmessage: ActiveMQTextMessage {commandId = 3, responseRequired = false, \nmessageId = ID:KStanke-2844-1170064566619-5:0:-1:1:1, \noriginalDestination = null, \noriginalTransactionId = null, \nproducerId = ID:KStanke-2844-1170064566619-5:0:-1:1, \ndestination = queue://TEST.FOO, \ntransactionId = null, expiration = 0, \ntimestamp = 1170064774288, \narrival = 0, \ncorrelationId = null, \nreplyTo = null, \npersistent = false, \ntype = null, \npriority = 4, \ngroupID = null, \ngroupSequence = 0, targetConsumerId = null, compressed = false, \nuserID = null, content = org.apache.activemq.util.ByteSequence@12f9924, \nmarshalledProperties = org.apache.activemq.util.ByteSequence@1ef3212, dataStructure = null, \nredeliveryCounter = 0, size = 0, properties = {request-id=2}, readOnlyProperties = true, \nreadOnlyBody = true, droppable = false, text = null}\n\ni'm missing the persistence as i used pProducer->setDeliveryMode( DeliveryMode::PERSISTANT ); As my message is a text message i'm missing the message text as well. I created the message with: pMessage = pSession->createTextMessage(messageText); with an nonempty string. \n\nComments:\n", "classification": "Classify the issue 'message information is lost from stomp message to jms' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-60?\nA: As my producer is a cpp server program i downloaded and compiled activemq-cpp 1.0. I managed to make activemq-cpp compile and link as shared lib / dll under vc 7.1 (Visual Studio .NET 2003). My consumer is located on a bea wls 8.1 I use the jms to jms bridge to forward the messages. For other reasons (see AMQ-1141) the forward fails. I can see in the dumped message:\n\nmessage: ActiveMQTextMessage {"}}
{"issue_key": "AMQCPP-59", "project": "AMQCPP", "title": "Exception is thrown when destroying consumer after connection failure", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-26T16:37:29.000+0000", "updated": "2007-01-29T12:19:45.000+0000", "description": "Brought over from AMQCPP-46.\n\nIn a program that reconnects when it detects a connection failure using an exception listener, there seem to be two different places where exceptions can originate.\n\nIn most cases when I shut down the broker and the exception listener fires properly and I can clean up everything (without deletes throwing exceptions), the stack trace that gets printed on the console looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - The connection is broken\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 137\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nThe message is printed twice with different tids, from the two threads that are active.\n\nSometimes when I shut down the broker and the exception handler fires and I clean up everything but then the consumer's destructor throws an exception. In that case, the stack trace that is printed looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - An existing connection was forcibly closed by the remote host.\n\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nAgain I see this message from both threads. Note the slightly different line numbers in SocketInputStream.cpp and the slighty different error message (this is on Windows XP SP2). In this case the failure of the socket is probably being detected in a slightly different place.\n\nIf the socket failure happens in the second way, it seems that destructors of consumers (and possibly producers and sessions) don't properly catch the exception when being destroying, causing their destructors to throw an exception, which isn't what we want.", "comments": [], "text": "Exception is thrown when destroying consumer after connection failure\n\nDescription:\nBrought over from AMQCPP-46.\n\nIn a program that reconnects when it detects a connection failure using an exception listener, there seem to be two different places where exceptions can originate.\n\nIn most cases when I shut down the broker and the exception listener fires properly and I can clean up everything (without deletes throwing exceptions), the stack trace that gets printed on the console looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - The connection is broken\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 137\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nThe message is printed twice with different tids, from the two threads that are active.\n\nSometimes when I shut down the broker and the exception handler fires and I clean up everything but then the consumer's destructor throws an exception. In that case, the stack trace that is printed looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - An existing connection was forcibly closed by the remote host.\n\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nAgain I see this message from both threads. Note the slightly different line numbers in SocketInputStream.cpp and the slighty different error message (this is on Windows XP SP2). In this case the failure of the socket is probably being detected in a slightly different place.\n\nIf the socket failure happens in the second way, it seems that destructors of consumers (and possibly producers and sessions) don't properly catch the exception when being destroying, causing their destructors to throw an exception, which isn't what we want.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception is thrown when destroying consumer after connection failure\n\nDescription:\nBrought over from AMQCPP-46.\n\nIn a program that reconnects when it detects a connection failure using an exception listener, there seem to be two different places where exceptions can originate.\n\nIn most cases when I shut down the broker and the exception listener fires properly and I can clean up everything (without deletes throwing exceptions), the stack trace that gets printed on the console looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - The connection is broken\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 137\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nThe message is printed twice with different tids, from the two threads that are active.\n\nSometimes when I shut down the broker and the exception handler fires and I clean up everything but then the consumer's destructor throws an exception. In that case, the stack trace that is printed looks like this:\n\n{noformat}\nWARNING: activemq::io::SocketInputStream::read - An existing connection was forcibly closed by the remote host.\n\n        FILE: ..\\src\\main\\activemq\\network\\SocketInputStream.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 199\n        FILE: ..\\src\\main\\activemq\\io\\BufferedInputStream.cpp, LINE: 83\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 216\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 120\n        FILE: ..\\src\\main\\activemq\\connector\\stomp\\StompCommandReader.cpp, LINE: 71\n        FILE: ..\\src\\main\\activemq\\transport\\IOTransport.cpp, LINE: 175\n{noformat}\n\nAgain I see this message from both threads. Note the slightly different line numbers in SocketInputStream.cpp and the slighty different error message (this is on Windows XP SP2). In this case the failure of the socket is probably being detected in a slightly different place.\n\nIf the socket failure happens in the second way, it seems that destructors of consumers (and possibly producers and sessions) don't properly catch the exception when being destroying, causing their destructors to throw an exception, which isn't what we want.\n\n\nComments:\n", "classification": "Classify the issue 'Exception is thrown when destroying consumer after connection failure' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-59?\nA: Brought over from AMQCPP-46.\n\nIn a program that reconnects when it detects a connection failure using an exception listener, there seem to be two different places where exceptions can originate.\n\nIn most cases when I shut down the broker and the exception listener fires properly and I can clean up everything (without deletes throwing exceptions), the stack trace that gets printed on the console lo"}}
{"issue_key": "AMQCPP-58", "project": "AMQCPP", "title": "Possible memory leak when reestablishing connection", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-26T16:32:20.000+0000", "updated": "2007-03-18T21:53:34.000+0000", "description": "Brought over from AMQCPP-46.\n\nThere seems to be a memory leak when running the example program from AMQCPP-46 which reconnects whenever the broker goes down.\n\nValgrind says:\n\n{noformat}\n==15493== 149,520 (89,712 direct, 59,808 indirect) bytes in 1,869 blocks are definitely lost in loss record 55 of 55\n==15493==    at 0x4A19DE3: operator new(unsigned long) (vg_replace_malloc.c:168)\n==15493==    by 0x45DEDD: activemq::network::SocketFactory::createSocket(activemq::util::Properties const&) (SocketFactory.cpp:96)\n==15493==    by 0x458D0C: activemq::transport::TcpTransport::TcpTransport(activemq::util::Properties const&, activemq::transport::Transport*, bool) (TcpTransport.cpp:42)\n==15493==    by 0x42B3EE: activemq::transport::TcpTransportFactory::createTransport(activemq::util::Properties const&) (TcpTransportFactory.cpp:55)\n==15493==    by 0x404CC0: activemq::core::ActiveMQConnectionFactory::createConnection(std::string const&, std::string const&, std::string const&) (ActiveMQConnectionFactory.cpp:130)\n==15493==    by 0x4042D5: activemq::core::ActiveMQConnectionFactory::createConnection() (ActiveMQConnectionFactory.cpp:69)\n==15493==    by 0x403D67: main (main.cpp:30)\n{noformat}\n\nPurify also seems to indicate that there is a link, along with with possibly spurious leaks or leaks that might be related to the leak reported by Valgrind.", "comments": [], "text": "Possible memory leak when reestablishing connection\n\nDescription:\nBrought over from AMQCPP-46.\n\nThere seems to be a memory leak when running the example program from AMQCPP-46 which reconnects whenever the broker goes down.\n\nValgrind says:\n\n{noformat}\n==15493== 149,520 (89,712 direct, 59,808 indirect) bytes in 1,869 blocks are definitely lost in loss record 55 of 55\n==15493==    at 0x4A19DE3: operator new(unsigned long) (vg_replace_malloc.c:168)\n==15493==    by 0x45DEDD: activemq::network::SocketFactory::createSocket(activemq::util::Properties const&) (SocketFactory.cpp:96)\n==15493==    by 0x458D0C: activemq::transport::TcpTransport::TcpTransport(activemq::util::Properties const&, activemq::transport::Transport*, bool) (TcpTransport.cpp:42)\n==15493==    by 0x42B3EE: activemq::transport::TcpTransportFactory::createTransport(activemq::util::Properties const&) (TcpTransportFactory.cpp:55)\n==15493==    by 0x404CC0: activemq::core::ActiveMQConnectionFactory::createConnection(std::string const&, std::string const&, std::string const&) (ActiveMQConnectionFactory.cpp:130)\n==15493==    by 0x4042D5: activemq::core::ActiveMQConnectionFactory::createConnection() (ActiveMQConnectionFactory.cpp:69)\n==15493==    by 0x403D67: main (main.cpp:30)\n{noformat}\n\nPurify also seems to indicate that there is a link, along with with possibly spurious leaks or leaks that might be related to the leak reported by Valgrind.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Possible memory leak when reestablishing connection\n\nDescription:\nBrought over from AMQCPP-46.\n\nThere seems to be a memory leak when running the example program from AMQCPP-46 which reconnects whenever the broker goes down.\n\nValgrind says:\n\n{noformat}\n==15493== 149,520 (89,712 direct, 59,808 indirect) bytes in 1,869 blocks are definitely lost in loss record 55 of 55\n==15493==    at 0x4A19DE3: operator new(unsigned long) (vg_replace_malloc.c:168)\n==15493==    by 0x45DEDD: activemq::network::SocketFactory::createSocket(activemq::util::Properties const&) (SocketFactory.cpp:96)\n==15493==    by 0x458D0C: activemq::transport::TcpTransport::TcpTransport(activemq::util::Properties const&, activemq::transport::Transport*, bool) (TcpTransport.cpp:42)\n==15493==    by 0x42B3EE: activemq::transport::TcpTransportFactory::createTransport(activemq::util::Properties const&) (TcpTransportFactory.cpp:55)\n==15493==    by 0x404CC0: activemq::core::ActiveMQConnectionFactory::createConnection(std::string const&, std::string const&, std::string const&) (ActiveMQConnectionFactory.cpp:130)\n==15493==    by 0x4042D5: activemq::core::ActiveMQConnectionFactory::createConnection() (ActiveMQConnectionFactory.cpp:69)\n==15493==    by 0x403D67: main (main.cpp:30)\n{noformat}\n\nPurify also seems to indicate that there is a link, along with with possibly spurious leaks or leaks that might be related to the leak reported by Valgrind.\n\nComments:\n", "classification": "Classify the issue 'Possible memory leak when reestablishing connection' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-58?\nA: Brought over from AMQCPP-46.\n\nThere seems to be a memory leak when running the example program from AMQCPP-46 which reconnects whenever the broker goes down.\n\nValgrind says:\n\n{noformat}\n==15493== 149,520 (89,712 direct, 59,808 indirect) bytes in 1,869 blocks are definitely lost in loss record 55 of 55\n==15493==    at 0x4A19DE3: operator new(unsigned long) (vg_replace_malloc.c:168)\n==15493==    by "}}
{"issue_key": "AMQCPP-57", "project": "AMQCPP", "title": "Typo in names of delivery modes", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-01-26T12:18:50.000+0000", "updated": "2007-01-26T21:18:51.000+0000", "description": "The delivery mode enums are spelled incorrectly, i.e. they should be PERSISTENT and NON_PERSISTENT, not PERSISTANT and NON_PERSISTANT.\n\nYou might consider adding the \"-TENT\" versions in addition to the \"-TANT\" versions to avoid break backward compatibility.", "comments": [], "text": "Typo in names of delivery modes\n\nDescription:\nThe delivery mode enums are spelled incorrectly, i.e. they should be PERSISTENT and NON_PERSISTENT, not PERSISTANT and NON_PERSISTANT.\n\nYou might consider adding the \"-TENT\" versions in addition to the \"-TANT\" versions to avoid break backward compatibility.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Typo in names of delivery modes\n\nDescription:\nThe delivery mode enums are spelled incorrectly, i.e. they should be PERSISTENT and NON_PERSISTENT, not PERSISTANT and NON_PERSISTANT.\n\nYou might consider adding the \"-TENT\" versions in addition to the \"-TANT\" versions to avoid break backward compatibility.\n\nComments:\n", "classification": "Classify the issue 'Typo in names of delivery modes' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-57?\nA: The delivery mode enums are spelled incorrectly, i.e. they should be PERSISTENT and NON_PERSISTENT, not PERSISTANT and NON_PERSISTANT.\n\nYou might consider adding the \"-TENT\" versions in addition to the \"-TANT\" versions to avoid break backward compatibility."}}
{"issue_key": "AMQCPP-56", "project": "AMQCPP", "title": "GCC warnings and possible SocketFactory bug on 64-bit Linux", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-26T09:49:17.000+0000", "updated": "2007-01-27T09:09:40.000+0000", "description": "When compiling on 64-bit Linux with GCC 4.0.3, I see the following warnings:\n\n{noformat}\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$first' may be used uninitialized in this function\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$second' may be used uninitialized in this function\nactivemq/network/SocketFactory.cpp:46: warning: comparison is always false due to limited range of data type\nactivemq/connector/openwire/marshal/v2/ConnectionControlMarshaller.cpp:82: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/IntegerResponseMarshaller.cpp:60: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ReplayCommandMarshaller.cpp:61: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ResponseMarshaller.cpp:60: warning: unused variable 'info'\n{noformat}\n\nThe first three warnings probably need to be looked at, especially the one in SocketFactory.\n\nIn my opinion, AMQCPP is using ints and unsigned ints in places where std::size_t might be more appropriate. MSVC's warning level 3 catches many of these issues, so we might consider upping the warning level and properly dealing with the type conversion issues: mostly use std::size_t and static_cast where we really intend to convert. I can prepare a few patches along these lines if you think this is worthwhile.", "comments": [], "text": "GCC warnings and possible SocketFactory bug on 64-bit Linux\n\nDescription:\nWhen compiling on 64-bit Linux with GCC 4.0.3, I see the following warnings:\n\n{noformat}\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$first' may be used uninitialized in this function\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$second' may be used uninitialized in this function\nactivemq/network/SocketFactory.cpp:46: warning: comparison is always false due to limited range of data type\nactivemq/connector/openwire/marshal/v2/ConnectionControlMarshaller.cpp:82: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/IntegerResponseMarshaller.cpp:60: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ReplayCommandMarshaller.cpp:61: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ResponseMarshaller.cpp:60: warning: unused variable 'info'\n{noformat}\n\nThe first three warnings probably need to be looked at, especially the one in SocketFactory.\n\nIn my opinion, AMQCPP is using ints and unsigned ints in places where std::size_t might be more appropriate. MSVC's warning level 3 catches many of these issues, so we might consider upping the warning level and properly dealing with the type conversion issues: mostly use std::size_t and static_cast where we really intend to convert. I can prepare a few patches along these lines if you think this is worthwhile.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: GCC warnings and possible SocketFactory bug on 64-bit Linux\n\nDescription:\nWhen compiling on 64-bit Linux with GCC 4.0.3, I see the following warnings:\n\n{noformat}\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$first' may be used uninitialized in this function\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$second' may be used uninitialized in this function\nactivemq/network/SocketFactory.cpp:46: warning: comparison is always false due to limited range of data type\nactivemq/connector/openwire/marshal/v2/ConnectionControlMarshaller.cpp:82: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/IntegerResponseMarshaller.cpp:60: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ReplayCommandMarshaller.cpp:61: warning: unused variable 'info'\nactivemq/connector/openwire/marshal/v2/ResponseMarshaller.cpp:60: warning: unused variable 'info'\n{noformat}\n\nThe first three warnings probably need to be looked at, especially the one in SocketFactory.\n\nIn my opinion, AMQCPP is using ints and unsigned ints in places where std::size_t might be more appropriate. MSVC's warning level 3 catches many of these issues, so we might consider upping the warning level and properly dealing with the type conversion issues: mostly use std::size_t and static_cast where we really intend to convert. I can prepare a few patches along these lines if you think this is worthwhile.\n\nComments:\n", "classification": "Classify the issue 'GCC warnings and possible SocketFactory bug on 64-bit Linux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-56?\nA: When compiling on 64-bit Linux with GCC 4.0.3, I see the following warnings:\n\n{noformat}\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$first' may be used uninitialized in this function\nactivemq/concurrent/PooledThread.cpp:56: warning: 'task$second' may be used uninitialized in this function\nactivemq/network/SocketFactory.cpp:46: warning: comparison is always false due to limited range of"}}
{"issue_key": "AMQCPP-55", "project": "AMQCPP", "title": "Need close() to propagate to child resources", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-25T01:00:48.000+0000", "updated": "2007-01-25T22:48:58.000+0000", "description": "Currently, the user is required to close CMS resources in the following order:\n\nconsumer/producer\nsession\nconnection\n\nWe should make this more like the JMS API which allows you to only close parent resources.  For example, closing session should automatically close all child producers and consumers.  Likewise, closing a connection should close child sessions, and their consumers and producers.", "comments": [], "text": "Need close() to propagate to child resources\n\nDescription:\nCurrently, the user is required to close CMS resources in the following order:\n\nconsumer/producer\nsession\nconnection\n\nWe should make this more like the JMS API which allows you to only close parent resources.  For example, closing session should automatically close all child producers and consumers.  Likewise, closing a connection should close child sessions, and their consumers and producers.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Need close() to propagate to child resources\n\nDescription:\nCurrently, the user is required to close CMS resources in the following order:\n\nconsumer/producer\nsession\nconnection\n\nWe should make this more like the JMS API which allows you to only close parent resources.  For example, closing session should automatically close all child producers and consumers.  Likewise, closing a connection should close child sessions, and their consumers and producers.\n\nComments:\n", "classification": "Classify the issue 'Need close() to propagate to child resources' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-55?\nA: Currently, the user is required to close CMS resources in the following order:\n\nconsumer/producer\nsession\nconnection\n\nWe should make this more like the JMS API which allows you to only close parent resources.  For example, closing session should automatically close all child producers and consumers.  Likewise, closing a connection should close child sessions, and their consumers and producers."}}
{"issue_key": "AMQCPP-54", "project": "AMQCPP", "title": "Build broken due to autoconf problem?", "status": "Closed", "reporter": "Wilfred Springer", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-01-24T21:06:32.000+0000", "updated": "2007-01-24T21:57:16.000+0000", "description": "Running autogen.sh gives:\n\nsrc/test-integration/Makefile.am:34: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:34: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:88: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:88: use `AM_CXXFLAGS' instead.", "comments": [], "text": "Build broken due to autoconf problem?\n\nDescription:\nRunning autogen.sh gives:\n\nsrc/test-integration/Makefile.am:34: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:34: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:88: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:88: use `AM_CXXFLAGS' instead.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Build broken due to autoconf problem?\n\nDescription:\nRunning autogen.sh gives:\n\nsrc/test-integration/Makefile.am:34: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:34: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:88: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:88: use `AM_CXXFLAGS' instead.\n\n\nComments:\n", "classification": "Classify the issue 'Build broken due to autoconf problem?' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-54?\nA: Running autogen.sh gives:\n\nsrc/test-integration/Makefile.am:34: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test-integration/Makefile.am:34: use `AM_CXXFLAGS' instead.\nsrc/test/Makefile.am:88: `CXXFLAGS' is a user variable, you should not override it;\nsrc/test/Makefile.am:88: use `AM_CXXFLAGS' instead.\n"}}
{"issue_key": "AMQCPP-53", "project": "AMQCPP", "title": "Declaration of extern int errno after including errno.h doesn't compile", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-24T07:39:33.000+0000", "updated": "2007-01-24T11:31:49.000+0000", "description": "A few places in AMQCPP declare extern int errno after includes errno.h. This fails to compile on Fedora Core 4 and Fedora Core 6 with the following error:\n\n{noformat}\nactivemq/concurrent/Thread.cpp:23: error: declaration of 'int* __errno_location()' throws different exceptions\n/usr/include/bits/errno.h:38: error: than previous declaration 'int* __errno_location() throw ()'\n{noformat}\n\nAs far as I know, including errno.h should be sufficient -- the extra declaration of errno is unnecessary. However, maybe you know of some older platforms where it has to be declared explicitly, even after the header has been included?\n\nThe places in the library where this issue crops up are:\n\n* src/main/activemq/concurrent/Thread.cpp\n* src/main/activemq/network/SocketError.cpp", "comments": [], "text": "Declaration of extern int errno after including errno.h doesn't compile\n\nDescription:\nA few places in AMQCPP declare extern int errno after includes errno.h. This fails to compile on Fedora Core 4 and Fedora Core 6 with the following error:\n\n{noformat}\nactivemq/concurrent/Thread.cpp:23: error: declaration of 'int* __errno_location()' throws different exceptions\n/usr/include/bits/errno.h:38: error: than previous declaration 'int* __errno_location() throw ()'\n{noformat}\n\nAs far as I know, including errno.h should be sufficient -- the extra declaration of errno is unnecessary. However, maybe you know of some older platforms where it has to be declared explicitly, even after the header has been included?\n\nThe places in the library where this issue crops up are:\n\n* src/main/activemq/concurrent/Thread.cpp\n* src/main/activemq/network/SocketError.cpp\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Declaration of extern int errno after including errno.h doesn't compile\n\nDescription:\nA few places in AMQCPP declare extern int errno after includes errno.h. This fails to compile on Fedora Core 4 and Fedora Core 6 with the following error:\n\n{noformat}\nactivemq/concurrent/Thread.cpp:23: error: declaration of 'int* __errno_location()' throws different exceptions\n/usr/include/bits/errno.h:38: error: than previous declaration 'int* __errno_location() throw ()'\n{noformat}\n\nAs far as I know, including errno.h should be sufficient -- the extra declaration of errno is unnecessary. However, maybe you know of some older platforms where it has to be declared explicitly, even after the header has been included?\n\nThe places in the library where this issue crops up are:\n\n* src/main/activemq/concurrent/Thread.cpp\n* src/main/activemq/network/SocketError.cpp\n\n\nComments:\n", "classification": "Classify the issue 'Declaration of extern int errno after including errno.h doesn't compile' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-53?\nA: A few places in AMQCPP declare extern int errno after includes errno.h. This fails to compile on Fedora Core 4 and Fedora Core 6 with the following error:\n\n{noformat}\nactivemq/concurrent/Thread.cpp:23: error: declaration of 'int* __errno_location()' throws different exceptions\n/usr/include/bits/errno.h:38: error: than previous declaration 'int* __errno_location() throw ()'\n{noformat}\n\nAs far as I "}}
{"issue_key": "AMQCPP-52", "project": "AMQCPP", "title": "Valgrind reports memory leaks when running PrimitiveMapTest", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-23T21:53:16.000+0000", "updated": "2007-01-23T23:04:20.000+0000", "description": "Valgrind reports the following leaks when running PrimitiveMapTest from r499127.\n\n==30238== 16 (12 direct, 4 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x8173256: activemq::util::PrimitiveMapTest::testValueNode() (PrimitiveMap.h:311)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 7 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD009: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:311)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 8 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD176: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:110)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 9 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CEEFF: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::setValue(std::string const&, activemq::util::PrimitiveMap::ValueNode) (PrimitiveMap.h:110)\n==30238==    by 0x81CD0BE: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.cpp:218)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 10 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CE182: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::getValue(std::string const&) const (PrimitiveMap.h:110)\n==30238==    by 0x81CBAB2: activemq::util::PrimitiveMap::getValue(std::string const&) const (PrimitiveMap.cpp:242)\n==30238==    by 0x81C00B4: activemq::connector::openwire::marshal::PrimitiveMapMarshaller::marshal(activemq::util::PrimitiveMap const*, std::vector<unsigned char, std::allocator<unsigned char> >&) (PrimitiveMapMarshaller.cpp:59)\n==30238==    by 0x80FC717: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:70)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)", "comments": [], "text": "Valgrind reports memory leaks when running PrimitiveMapTest\n\nDescription:\nValgrind reports the following leaks when running PrimitiveMapTest from r499127.\n\n==30238== 16 (12 direct, 4 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x8173256: activemq::util::PrimitiveMapTest::testValueNode() (PrimitiveMap.h:311)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 7 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD009: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:311)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 8 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD176: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:110)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 9 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CEEFF: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::setValue(std::string const&, activemq::util::PrimitiveMap::ValueNode) (PrimitiveMap.h:110)\n==30238==    by 0x81CD0BE: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.cpp:218)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 10 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CE182: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::getValue(std::string const&) const (PrimitiveMap.h:110)\n==30238==    by 0x81CBAB2: activemq::util::PrimitiveMap::getValue(std::string const&) const (PrimitiveMap.cpp:242)\n==30238==    by 0x81C00B4: activemq::connector::openwire::marshal::PrimitiveMapMarshaller::marshal(activemq::util::PrimitiveMap const*, std::vector<unsigned char, std::allocator<unsigned char> >&) (PrimitiveMapMarshaller.cpp:59)\n==30238==    by 0x80FC717: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:70)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Valgrind reports memory leaks when running PrimitiveMapTest\n\nDescription:\nValgrind reports the following leaks when running PrimitiveMapTest from r499127.\n\n==30238== 16 (12 direct, 4 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x8173256: activemq::util::PrimitiveMapTest::testValueNode() (PrimitiveMap.h:311)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 7 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD009: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:311)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 8 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CD176: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.h:110)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 9 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CEEFF: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::setValue(std::string const&, activemq::util::PrimitiveMap::ValueNode) (PrimitiveMap.h:110)\n==30238==    by 0x81CD0BE: activemq::util::PrimitiveMap::setByteArray(std::string const&, std::vector<unsigned char, std::allocator<unsigned char> > const&) (PrimitiveMap.cpp:218)\n==30238==    by 0x80FC6CB: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:65)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x818EE36: main (main.cpp:34)\n----\n==30238== 50 (36 direct, 14 indirect) bytes in 3 blocks are definitely lost in loss record 10 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x81CE182: activemq::util::Map<std::string, activemq::util::PrimitiveMap::ValueNode>::getValue(std::string const&) const (PrimitiveMap.h:110)\n==30238==    by 0x81CBAB2: activemq::util::PrimitiveMap::getValue(std::string const&) const (PrimitiveMap.cpp:242)\n==30238==    by 0x81C00B4: activemq::connector::openwire::marshal::PrimitiveMapMarshaller::marshal(activemq::util::PrimitiveMap const*, std::vector<unsigned char, std::allocator<unsigned char> >&) (PrimitiveMapMarshaller.cpp:59)\n==30238==    by 0x80FC717: activemq::connector::openwire::marshal::PrimitiveMapMarshallerTest::test() (PrimitiveMapMarshallerTest.cpp:70)\n==30238==    by 0x4B6706: CppUnit::TestCaseMethodFunctor::operator()() const (in /usr/lib/libcppunit-1.12.so.0.0.0)\n...\n==30238==    by 0x4C4724: CppUnit::TextTestRunner::run(std::string, bool, bool, bool) (in /usr/lib/libcppunit-1.12.so.0.0.0)\n\n\nComments:\n", "classification": "Classify the issue 'Valgrind reports memory leaks when running PrimitiveMapTest' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-52?\nA: Valgrind reports the following leaks when running PrimitiveMapTest from r499127.\n\n==30238== 16 (12 direct, 4 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 11\n==30238==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==30238==    by 0x8173256: activemq::util::PrimitiveMapTest::testValueNode() (PrimitiveMap.h:311)\n...\n==30238==    by 0x818EE36: main (main.cpp:"}}
{"issue_key": "AMQCPP-51", "project": "AMQCPP", "title": "Autoconf is not properly setting CXXFLAGS on Linux", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-23T21:34:49.000+0000", "updated": "2007-01-23T23:07:09.000+0000", "description": "I'm running Fedora Core 6 with autoconf 2.59 and automake 1.9.6.\n\nIt seems the CXXFLAGS stuff in configure.ac isn't actually setting CXXFLAGS used to compile.\n\nIf you check the generated src/main/Makefile, you'll only see:\n\n{noformat}\nCXXFLAGS = -D HAVE_ACTIVEMQ_CONFIG\n{noformat}\n\nand when running make you get\n\n{noformat}\nmake  all-recursive\nmake[1]: Entering directory `/home/albert/work/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/home/albert/work/activemq-cpp/src/main'\nif g++ -DHAVE_CONFIG_H -I. -I. -I../..     -D HAVE_ACTIVEMQ_CONFIG -MT ActiveMQConsumer.o -MD -MP -MF \".deps/ActiveMQConsumer.Tpo\" -c -o ActiveMQConsumer.o `test -f 'activemq/core/ActiveMQConsumer.cpp' || echo './'`activemq/core/ActiveMQConsumer.cpp; \\\n        then mv -f \".deps/ActiveMQConsumer.Tpo\" \".deps/ActiveMQConsumer.Po\"; else rm -f \".deps/ActiveMQConsumer.Tpo\"; exit 1; fi\n{noformat}\n\nwhich is missing all the options specified in configure.ac.\n\nBy the way, you might consider adding -g and -O2.", "comments": [], "text": "Autoconf is not properly setting CXXFLAGS on Linux\n\nDescription:\nI'm running Fedora Core 6 with autoconf 2.59 and automake 1.9.6.\n\nIt seems the CXXFLAGS stuff in configure.ac isn't actually setting CXXFLAGS used to compile.\n\nIf you check the generated src/main/Makefile, you'll only see:\n\n{noformat}\nCXXFLAGS = -D HAVE_ACTIVEMQ_CONFIG\n{noformat}\n\nand when running make you get\n\n{noformat}\nmake  all-recursive\nmake[1]: Entering directory `/home/albert/work/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/home/albert/work/activemq-cpp/src/main'\nif g++ -DHAVE_CONFIG_H -I. -I. -I../..     -D HAVE_ACTIVEMQ_CONFIG -MT ActiveMQConsumer.o -MD -MP -MF \".deps/ActiveMQConsumer.Tpo\" -c -o ActiveMQConsumer.o `test -f 'activemq/core/ActiveMQConsumer.cpp' || echo './'`activemq/core/ActiveMQConsumer.cpp; \\\n        then mv -f \".deps/ActiveMQConsumer.Tpo\" \".deps/ActiveMQConsumer.Po\"; else rm -f \".deps/ActiveMQConsumer.Tpo\"; exit 1; fi\n{noformat}\n\nwhich is missing all the options specified in configure.ac.\n\nBy the way, you might consider adding -g and -O2.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Autoconf is not properly setting CXXFLAGS on Linux\n\nDescription:\nI'm running Fedora Core 6 with autoconf 2.59 and automake 1.9.6.\n\nIt seems the CXXFLAGS stuff in configure.ac isn't actually setting CXXFLAGS used to compile.\n\nIf you check the generated src/main/Makefile, you'll only see:\n\n{noformat}\nCXXFLAGS = -D HAVE_ACTIVEMQ_CONFIG\n{noformat}\n\nand when running make you get\n\n{noformat}\nmake  all-recursive\nmake[1]: Entering directory `/home/albert/work/activemq-cpp'\nMaking all in src/main\nmake[2]: Entering directory `/home/albert/work/activemq-cpp/src/main'\nif g++ -DHAVE_CONFIG_H -I. -I. -I../..     -D HAVE_ACTIVEMQ_CONFIG -MT ActiveMQConsumer.o -MD -MP -MF \".deps/ActiveMQConsumer.Tpo\" -c -o ActiveMQConsumer.o `test -f 'activemq/core/ActiveMQConsumer.cpp' || echo './'`activemq/core/ActiveMQConsumer.cpp; \\\n        then mv -f \".deps/ActiveMQConsumer.Tpo\" \".deps/ActiveMQConsumer.Po\"; else rm -f \".deps/ActiveMQConsumer.Tpo\"; exit 1; fi\n{noformat}\n\nwhich is missing all the options specified in configure.ac.\n\nBy the way, you might consider adding -g and -O2.\n\nComments:\n", "classification": "Classify the issue 'Autoconf is not properly setting CXXFLAGS on Linux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-51?\nA: I'm running Fedora Core 6 with autoconf 2.59 and automake 1.9.6.\n\nIt seems the CXXFLAGS stuff in configure.ac isn't actually setting CXXFLAGS used to compile.\n\nIf you check the generated src/main/Makefile, you'll only see:\n\n{noformat}\nCXXFLAGS = -D HAVE_ACTIVEMQ_CONFIG\n{noformat}\n\nand when running make you get\n\n{noformat}\nmake  all-recursive\nmake[1]: Entering directory `/home/albert/work/activemq-"}}
{"issue_key": "AMQCPP-50", "project": "AMQCPP", "title": "Derive cms::CMSException from std::exception", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-21T22:05:02.000+0000", "updated": "2007-01-22T21:19:11.000+0000", "description": "It would be nice if cms::CMSException were derived from std::exception. std::exception's what can just call through to cms::CMSException's getMessage.\n\nHaving this inheritance would be useful to people who already have logging functions or other bits and pieces in place in their programs that understand std::exceptions.", "comments": [], "text": "Derive cms::CMSException from std::exception\n\nDescription:\nIt would be nice if cms::CMSException were derived from std::exception. std::exception's what can just call through to cms::CMSException's getMessage.\n\nHaving this inheritance would be useful to people who already have logging functions or other bits and pieces in place in their programs that understand std::exceptions.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Derive cms::CMSException from std::exception\n\nDescription:\nIt would be nice if cms::CMSException were derived from std::exception. std::exception's what can just call through to cms::CMSException's getMessage.\n\nHaving this inheritance would be useful to people who already have logging functions or other bits and pieces in place in their programs that understand std::exceptions.\n\nComments:\n", "classification": "Classify the issue 'Derive cms::CMSException from std::exception' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-50?\nA: It would be nice if cms::CMSException were derived from std::exception. std::exception's what can just call through to cms::CMSException's getMessage.\n\nHaving this inheritance would be useful to people who already have logging functions or other bits and pieces in place in their programs that understand std::exceptions."}}
{"issue_key": "AMQCPP-49", "project": "AMQCPP", "title": "Add -W -Wall compile options", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-01-20T20:03:21.000+0000", "updated": "2007-01-24T12:11:28.000+0000", "description": "Add -W -Wall compile options and clean up resulting warnings", "comments": [], "text": "Add -W -Wall compile options\n\nDescription:\nAdd -W -Wall compile options and clean up resulting warnings\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add -W -Wall compile options\n\nDescription:\nAdd -W -Wall compile options and clean up resulting warnings\n\nComments:\n", "classification": "Classify the issue 'Add -W -Wall compile options' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-49?\nA: Add -W -Wall compile options and clean up resulting warnings"}}
{"issue_key": "AMQCPP-48", "project": "AMQCPP", "title": "Fix compilation with Visual Studio .NET 2003", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-01-19T09:02:01.000+0000", "updated": "2007-01-21T20:12:54.000+0000", "description": "The attached patch contains a few minor changes to make the AMQCPP library compile with Visual Studio .NET 2003.\n\nThis will be very useful for the [Python wrapper|http://code.google.com/p/pyactivemq/] I'm working on, since Python 2.4 and Python 2.5 still need their extension modules compiled with VS .NET 2003.\n\nIf you're interested, I can also submit project files for VS .NET 2003.", "comments": [], "text": "Fix compilation with Visual Studio .NET 2003\n\nDescription:\nThe attached patch contains a few minor changes to make the AMQCPP library compile with Visual Studio .NET 2003.\n\nThis will be very useful for the [Python wrapper|http://code.google.com/p/pyactivemq/] I'm working on, since Python 2.4 and Python 2.5 still need their extension modules compiled with VS .NET 2003.\n\nIf you're interested, I can also submit project files for VS .NET 2003.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Fix compilation with Visual Studio .NET 2003\n\nDescription:\nThe attached patch contains a few minor changes to make the AMQCPP library compile with Visual Studio .NET 2003.\n\nThis will be very useful for the [Python wrapper|http://code.google.com/p/pyactivemq/] I'm working on, since Python 2.4 and Python 2.5 still need their extension modules compiled with VS .NET 2003.\n\nIf you're interested, I can also submit project files for VS .NET 2003.\n\nComments:\n", "classification": "Classify the issue 'Fix compilation with Visual Studio .NET 2003' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-48?\nA: The attached patch contains a few minor changes to make the AMQCPP library compile with Visual Studio .NET 2003.\n\nThis will be very useful for the [Python wrapper|http://code.google.com/p/pyactivemq/] I'm working on, since Python 2.4 and Python 2.5 still need their extension modules compiled with VS .NET 2003.\n\nIf you're interested, I can also submit project files for VS .NET 2003."}}
{"issue_key": "AMQCPP-47", "project": "AMQCPP", "title": "MapMessage getters should be const", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-18T22:53:34.000+0000", "updated": "2007-01-21T21:58:08.000+0000", "description": "It looks to me like the cms::MapMessage getter functions can all be const?\n\nI'm guessing there isn't a MapMessage implementation yet, but I'm guessing it'll probably be implemented on top of a C++ STL map?\n\nHaving the getters const will mean that people won't have to clone a MapMessage in a MessageListener if they want to read its fields.", "comments": [], "text": "MapMessage getters should be const\n\nDescription:\nIt looks to me like the cms::MapMessage getter functions can all be const?\n\nI'm guessing there isn't a MapMessage implementation yet, but I'm guessing it'll probably be implemented on top of a C++ STL map?\n\nHaving the getters const will mean that people won't have to clone a MapMessage in a MessageListener if they want to read its fields.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: MapMessage getters should be const\n\nDescription:\nIt looks to me like the cms::MapMessage getter functions can all be const?\n\nI'm guessing there isn't a MapMessage implementation yet, but I'm guessing it'll probably be implemented on top of a C++ STL map?\n\nHaving the getters const will mean that people won't have to clone a MapMessage in a MessageListener if they want to read its fields.\n\nComments:\n", "classification": "Classify the issue 'MapMessage getters should be const' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-47?\nA: It looks to me like the cms::MapMessage getter functions can all be const?\n\nI'm guessing there isn't a MapMessage implementation yet, but I'm guessing it'll probably be implemented on top of a C++ STL map?\n\nHaving the getters const will mean that people won't have to clone a MapMessage in a MessageListener if they want to read its fields."}}
{"issue_key": "AMQCPP-46", "project": "AMQCPP", "title": "ActiveMQConnection doesn't propagate exception listener to underlying connector", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-17T14:27:30.000+0000", "updated": "2007-01-26T16:38:29.000+0000", "description": "My program is doing the following:\n\n# Create connection using ActiveMQConnectionFactory\n# Set a simple exception listener that sets a boolean flag\n# Block in receive on consumer\n\nIf I then kill the broker, various exceptions happen, but they are never sent to the exception listener, because the exception listener in StompConnector is null. It seems to me that ActiveMQConnection should set and get its exception listener on its underlying connector and probably doesn't have to contain a pointer to the listener itself.\n\nIf I change ActiveMQConnection as in the attached patch to also set the exception listener on the underlying connector, my exception listener gets called when the broker dies.\n\nOnce I detect the failure, I delete the producer, consumer, session and connection that failed. Looks like an uncaught exception is getting thrown during the destruction of the producer (which is the first thing I delete when cleaning up). The problem here is probably that the connection is trying to close down a socket that is already broken and something goes awry. I'm not quite sure how to fix this problem.\n\nStack trace (with useless bits stripped out):\n{noformat}\n \tkernel32.dll!7c812a5b() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n \tkernel32.dll!7c812a5b() \t\n>\tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,14297048), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012b920()\t\n \tmyapp.exe!activemq::core::ActiveMQConsumer::close()  Line 84 + 0x34 bytes\tC++\n \tmsvcr80d.dll!102418b7() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(<Bad Ptr>,1886220148))  Line 1105 + 0x18 bytes\tC++\n \tmyapp!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012bf74()\t\n \tmyapp.exe!activemq::core::ActiveMQSession::onDestroySessionResource(activemq::core::ActiveMQSessionResource * resource=0x00000001)  Line 558 + 0x37 bytes\tC++\n \tmsvcr80d.dll!10241a10() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,1886220148), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"<<U\",4832632))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n{noformat}", "comments": [], "text": "ActiveMQConnection doesn't propagate exception listener to underlying connector\n\nDescription:\nMy program is doing the following:\n\n# Create connection using ActiveMQConnectionFactory\n# Set a simple exception listener that sets a boolean flag\n# Block in receive on consumer\n\nIf I then kill the broker, various exceptions happen, but they are never sent to the exception listener, because the exception listener in StompConnector is null. It seems to me that ActiveMQConnection should set and get its exception listener on its underlying connector and probably doesn't have to contain a pointer to the listener itself.\n\nIf I change ActiveMQConnection as in the attached patch to also set the exception listener on the underlying connector, my exception listener gets called when the broker dies.\n\nOnce I detect the failure, I delete the producer, consumer, session and connection that failed. Looks like an uncaught exception is getting thrown during the destruction of the producer (which is the first thing I delete when cleaning up). The problem here is probably that the connection is trying to close down a socket that is already broken and something goes awry. I'm not quite sure how to fix this problem.\n\nStack trace (with useless bits stripped out):\n{noformat}\n \tkernel32.dll!7c812a5b() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n \tkernel32.dll!7c812a5b() \t\n>\tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,14297048), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012b920()\t\n \tmyapp.exe!activemq::core::ActiveMQConsumer::close()  Line 84 + 0x34 bytes\tC++\n \tmsvcr80d.dll!102418b7() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(<Bad Ptr>,1886220148))  Line 1105 + 0x18 bytes\tC++\n \tmyapp!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012bf74()\t\n \tmyapp.exe!activemq::core::ActiveMQSession::onDestroySessionResource(activemq::core::ActiveMQSessionResource * resource=0x00000001)  Line 558 + 0x37 bytes\tC++\n \tmsvcr80d.dll!10241a10() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,1886220148), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"<<U\",4832632))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n{noformat}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQConnection doesn't propagate exception listener to underlying connector\n\nDescription:\nMy program is doing the following:\n\n# Create connection using ActiveMQConnectionFactory\n# Set a simple exception listener that sets a boolean flag\n# Block in receive on consumer\n\nIf I then kill the broker, various exceptions happen, but they are never sent to the exception listener, because the exception listener in StompConnector is null. It seems to me that ActiveMQConnection should set and get its exception listener on its underlying connector and probably doesn't have to contain a pointer to the listener itself.\n\nIf I change ActiveMQConnection as in the attached patch to also set the exception listener on the underlying connector, my exception listener gets called when the broker dies.\n\nOnce I detect the failure, I delete the producer, consumer, session and connection that failed. Looks like an uncaught exception is getting thrown during the destruction of the producer (which is the first thing I delete when cleaning up). The problem here is probably that the connection is trying to close down a socket that is already broken and something goes awry. I'm not quite sure how to fix this problem.\n\nStack trace (with useless bits stripped out):\n{noformat}\n \tkernel32.dll!7c812a5b() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n \tkernel32.dll!7c812a5b() \t\n>\tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,14297048), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"..\\src\\main\\activemq\\connector\\stomp\\StompSessionManager.cpp\",254))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012b920()\t\n \tmyapp.exe!activemq::core::ActiveMQConsumer::close()  Line 84 + 0x34 bytes\tC++\n \tmsvcr80d.dll!102418b7() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(<Bad Ptr>,1886220148))  Line 1105 + 0x18 bytes\tC++\n \tmyapp!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n \t0012bf74()\t\n \tmyapp.exe!activemq::core::ActiveMQSession::onDestroySessionResource(activemq::core::ActiveMQSessionResource * resource=0x00000001)  Line 558 + 0x37 bytes\tC++\n \tmsvcr80d.dll!10241a10() \t\n        ...\t\n \tkernel32.dll!7c812a5b() \t\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::_Ucopy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> *>(std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _First=(<Bad Ptr>,1886220148), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Last=(<Bad Ptr>,-17891602), std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> * _Ptr=(\"<<U\",4832632))  Line 1105 + 0x18 bytes\tC++\n \tmyapp.exe!std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator=(const std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > > & _Right={...})  Line 582 + 0x1d bytes\tC++\n{noformat}\n\nComments:\n", "classification": "Classify the issue 'ActiveMQConnection doesn't propagate exception listener to underlying connector' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-46?\nA: My program is doing the following:\n\n# Create connection using ActiveMQConnectionFactory\n# Set a simple exception listener that sets a boolean flag\n# Block in receive on consumer\n\nIf I then kill the broker, various exceptions happen, but they are never sent to the exception listener, because the exception listener in StompConnector is null. It seems to me that ActiveMQConnection should set and get "}}
{"issue_key": "AMQCPP-45", "project": "AMQCPP", "title": "Update configure.ac with release version", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-01-15T23:49:24.000+0000", "updated": "2007-01-16T12:28:14.000+0000", "description": "configure.ac for the 1.1 release should be updated. The ACTIVEMQ_VERSION variable needs to be changed (the 1.x part). This should fix the headers install directory.\n\nACTIVEMQ_LIBRARY_VERSION could also be set to some value (not sure what the best value is here, http://people.redhat.com/drepper/dsohowto.pdf might have some ideas).\n\nBy the way, the ACTIVEMQ_RELEASE variable seems to be unused?", "comments": [], "text": "Update configure.ac with release version\n\nDescription:\nconfigure.ac for the 1.1 release should be updated. The ACTIVEMQ_VERSION variable needs to be changed (the 1.x part). This should fix the headers install directory.\n\nACTIVEMQ_LIBRARY_VERSION could also be set to some value (not sure what the best value is here, http://people.redhat.com/drepper/dsohowto.pdf might have some ideas).\n\nBy the way, the ACTIVEMQ_RELEASE variable seems to be unused?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Update configure.ac with release version\n\nDescription:\nconfigure.ac for the 1.1 release should be updated. The ACTIVEMQ_VERSION variable needs to be changed (the 1.x part). This should fix the headers install directory.\n\nACTIVEMQ_LIBRARY_VERSION could also be set to some value (not sure what the best value is here, http://people.redhat.com/drepper/dsohowto.pdf might have some ideas).\n\nBy the way, the ACTIVEMQ_RELEASE variable seems to be unused?\n\nComments:\n", "classification": "Classify the issue 'Update configure.ac with release version' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-45?\nA: configure.ac for the 1.1 release should be updated. The ACTIVEMQ_VERSION variable needs to be changed (the 1.x part). This should fix the headers install directory.\n\nACTIVEMQ_LIBRARY_VERSION could also be set to some value (not sure what the best value is here, http://people.redhat.com/drepper/dsohowto.pdf might have some ideas).\n\nBy the way, the ACTIVEMQ_RELEASE variable seems to be unused?"}}
{"issue_key": "AMQCPP-44", "project": "AMQCPP", "title": "Reason for socket errors not reported correctly on Windows", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-01-14T18:01:33.000+0000", "updated": "2007-01-22T23:11:16.000+0000", "description": "Socket errors aren't reported correctly on Windows. When the broker is down and the TcpTransport fails to connect, I get an exception saying \"Socket::connect - No error\". strerror of errno might not be the right way to get the error description for socket errors on Windows. Maybe one needs to look at what WSAGetLastError returns, but I'm not sure.", "comments": [], "text": "Reason for socket errors not reported correctly on Windows\n\nDescription:\nSocket errors aren't reported correctly on Windows. When the broker is down and the TcpTransport fails to connect, I get an exception saying \"Socket::connect - No error\". strerror of errno might not be the right way to get the error description for socket errors on Windows. Maybe one needs to look at what WSAGetLastError returns, but I'm not sure.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Reason for socket errors not reported correctly on Windows\n\nDescription:\nSocket errors aren't reported correctly on Windows. When the broker is down and the TcpTransport fails to connect, I get an exception saying \"Socket::connect - No error\". strerror of errno might not be the right way to get the error description for socket errors on Windows. Maybe one needs to look at what WSAGetLastError returns, but I'm not sure.\n\nComments:\n", "classification": "Classify the issue 'Reason for socket errors not reported correctly on Windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-44?\nA: Socket errors aren't reported correctly on Windows. When the broker is down and the TcpTransport fails to connect, I get an exception saying \"Socket::connect - No error\". strerror of errno might not be the right way to get the error description for socket errors on Windows. Maybe one needs to look at what WSAGetLastError returns, but I'm not sure."}}
{"issue_key": "AMQCPP-43", "project": "AMQCPP", "title": "Crash when getting string property that doesn't exist", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-01-12T14:12:53.000+0000", "updated": "2007-01-12T15:32:05.000+0000", "description": "In the case when one calls getStringProperty for a property that doesn't exist, a crash occurs because SimpleProperties returns NULL. I think it should return \"\".\n\nTest code on Linux:\n\n{noformat}\n#include <string>\nint main(int argc, char* argv)\n{\n    std::string str(0);\n    return 0;\n}\n{noformat}\n\nThis dies with the following when run on FC6:\n\n{noformat}\nterminate called after throwing an instance of 'std::logic_error'\n  what():  basic_string::_S_construct NULL not valid\nAborted\n{noformat}\n\nProposed patch:\n\n{noformat}\n===================================================================\n--- src/main/activemq/util/SimpleProperties.h   (revision 495567)\n+++ src/main/activemq/util/SimpleProperties.h   (working copy)\n@@ -55,7 +55,7 @@\n             std::map< std::string, std::string >::const_iterator iter =\n             properties.find( name );\n             if( iter == properties.end() ){\n-                return NULL;\n+                return \"\";\n             }\n\n             return iter->second.c_str();\n{noformat}", "comments": [], "text": "Crash when getting string property that doesn't exist\n\nDescription:\nIn the case when one calls getStringProperty for a property that doesn't exist, a crash occurs because SimpleProperties returns NULL. I think it should return \"\".\n\nTest code on Linux:\n\n{noformat}\n#include <string>\nint main(int argc, char* argv)\n{\n    std::string str(0);\n    return 0;\n}\n{noformat}\n\nThis dies with the following when run on FC6:\n\n{noformat}\nterminate called after throwing an instance of 'std::logic_error'\n  what():  basic_string::_S_construct NULL not valid\nAborted\n{noformat}\n\nProposed patch:\n\n{noformat}\n===================================================================\n--- src/main/activemq/util/SimpleProperties.h   (revision 495567)\n+++ src/main/activemq/util/SimpleProperties.h   (working copy)\n@@ -55,7 +55,7 @@\n             std::map< std::string, std::string >::const_iterator iter =\n             properties.find( name );\n             if( iter == properties.end() ){\n-                return NULL;\n+                return \"\";\n             }\n\n             return iter->second.c_str();\n{noformat}\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash when getting string property that doesn't exist\n\nDescription:\nIn the case when one calls getStringProperty for a property that doesn't exist, a crash occurs because SimpleProperties returns NULL. I think it should return \"\".\n\nTest code on Linux:\n\n{noformat}\n#include <string>\nint main(int argc, char* argv)\n{\n    std::string str(0);\n    return 0;\n}\n{noformat}\n\nThis dies with the following when run on FC6:\n\n{noformat}\nterminate called after throwing an instance of 'std::logic_error'\n  what():  basic_string::_S_construct NULL not valid\nAborted\n{noformat}\n\nProposed patch:\n\n{noformat}\n===================================================================\n--- src/main/activemq/util/SimpleProperties.h   (revision 495567)\n+++ src/main/activemq/util/SimpleProperties.h   (working copy)\n@@ -55,7 +55,7 @@\n             std::map< std::string, std::string >::const_iterator iter =\n             properties.find( name );\n             if( iter == properties.end() ){\n-                return NULL;\n+                return \"\";\n             }\n\n             return iter->second.c_str();\n{noformat}\n\nComments:\n", "classification": "Classify the issue 'Crash when getting string property that doesn't exist' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-43?\nA: In the case when one calls getStringProperty for a property that doesn't exist, a crash occurs because SimpleProperties returns NULL. I think it should return \"\".\n\nTest code on Linux:\n\n{noformat}\n#include <string>\nint main(int argc, char* argv)\n{\n    std::string str(0);\n    return 0;\n}\n{noformat}\n\nThis dies with the following when run on FC6:\n\n{noformat}\nterminate called after throwing an instance"}}
{"issue_key": "AMQCPP-42", "project": "AMQCPP", "title": "A few more strict aliasing warnings", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-11T23:07:11.000+0000", "updated": "2007-01-12T00:30:42.000+0000", "description": "Brought over from AMQCPP-25.\n\nWe might consider using -Wstrict-aliasing=2. Warns in more cases, with some chance of false positives.\n\nI still get the following warnings with GCC 4.1.1 on FC6 with revision 495335:\n\n{noformat}\nactivemq/network/ServerSocket.cpp: In member function 'virtual void activemq::network::ServerSocket::bind(const char*, int, int)':\nactivemq/network/ServerSocket.cpp:162: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/network/ServerSocket.cpp: In member function 'virtual activemq::network::Socket* activemq::network::ServerSocket::accept()':\nactivemq/network/ServerSocket.cpp:208: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:85: warning: dereferencing type-punned pointer will break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:86: warning: dereferencing type-punned pointer will break strict-aliasing rules\n{noformat}\n\nI noticed you used a memcpys to fix this issue. Did you consider trying a union? Without knowing for certain (maybe we'll do some benchmarks tomorrow), a union might be faster than a call to memcpy.", "comments": [], "text": "A few more strict aliasing warnings\n\nDescription:\nBrought over from AMQCPP-25.\n\nWe might consider using -Wstrict-aliasing=2. Warns in more cases, with some chance of false positives.\n\nI still get the following warnings with GCC 4.1.1 on FC6 with revision 495335:\n\n{noformat}\nactivemq/network/ServerSocket.cpp: In member function 'virtual void activemq::network::ServerSocket::bind(const char*, int, int)':\nactivemq/network/ServerSocket.cpp:162: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/network/ServerSocket.cpp: In member function 'virtual activemq::network::Socket* activemq::network::ServerSocket::accept()':\nactivemq/network/ServerSocket.cpp:208: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:85: warning: dereferencing type-punned pointer will break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:86: warning: dereferencing type-punned pointer will break strict-aliasing rules\n{noformat}\n\nI noticed you used a memcpys to fix this issue. Did you consider trying a union? Without knowing for certain (maybe we'll do some benchmarks tomorrow), a union might be faster than a call to memcpy.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: A few more strict aliasing warnings\n\nDescription:\nBrought over from AMQCPP-25.\n\nWe might consider using -Wstrict-aliasing=2. Warns in more cases, with some chance of false positives.\n\nI still get the following warnings with GCC 4.1.1 on FC6 with revision 495335:\n\n{noformat}\nactivemq/network/ServerSocket.cpp: In member function 'virtual void activemq::network::ServerSocket::bind(const char*, int, int)':\nactivemq/network/ServerSocket.cpp:162: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/network/ServerSocket.cpp: In member function 'virtual activemq::network::Socket* activemq::network::ServerSocket::accept()':\nactivemq/network/ServerSocket.cpp:208: warning: dereferencing type-punned pointer might break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:85: warning: dereferencing type-punned pointer will break strict-aliasing rules\nactivemq/io/DataInputStreamTest.h:86: warning: dereferencing type-punned pointer will break strict-aliasing rules\n{noformat}\n\nI noticed you used a memcpys to fix this issue. Did you consider trying a union? Without knowing for certain (maybe we'll do some benchmarks tomorrow), a union might be faster than a call to memcpy.\n\nComments:\n", "classification": "Classify the issue 'A few more strict aliasing warnings' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-42?\nA: Brought over from AMQCPP-25.\n\nWe might consider using -Wstrict-aliasing=2. Warns in more cases, with some chance of false positives.\n\nI still get the following warnings with GCC 4.1.1 on FC6 with revision 495335:\n\n{noformat}\nactivemq/network/ServerSocket.cpp: In member function 'virtual void activemq::network::ServerSocket::bind(const char*, int, int)':\nactivemq/network/ServerSocket.cpp:162: warni"}}
{"issue_key": "AMQCPP-41", "project": "AMQCPP", "title": "Byte swap on float and double truncates values", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2007-01-10T15:19:59.000+0000", "updated": "2007-01-11T12:27:19.000+0000", "description": "activemq::util::Endian::byteSwap truncates float and double values due to the C-style cast it uses.\n\nPatch for BytesMessageCommandTest is attached that shows the problem. One might consider expanding this test to check that the minimum, maximum, -1, 0, 1 (and -inf and inf where appropriate) and a few other values can successfully be serialised and deserialised for each of the types.\n\nAlso in the patch is our attempt at fixing byteSwap. You'll notice that we do something very strange: we take the argument of byteSwap and make a copy on the heap. The reason for this is that simply doing:\n\n{noformat}\nconst uintxx_t swapped_val = byteSwap( *(uintxx_t*)(&value) );\n{noformat}\n\ni.e. taking the address of value instead of using the copy on the heap, fails with GCC 4.0.2 and GCC 4.0.3. I'm guessing GCC might be trying to inline the call to byteSwap and then something goes very wrong when taking the address of a variable on the stack. Hopefully someone has a better idea for a workaround.", "comments": [], "text": "Byte swap on float and double truncates values\n\nDescription:\nactivemq::util::Endian::byteSwap truncates float and double values due to the C-style cast it uses.\n\nPatch for BytesMessageCommandTest is attached that shows the problem. One might consider expanding this test to check that the minimum, maximum, -1, 0, 1 (and -inf and inf where appropriate) and a few other values can successfully be serialised and deserialised for each of the types.\n\nAlso in the patch is our attempt at fixing byteSwap. You'll notice that we do something very strange: we take the argument of byteSwap and make a copy on the heap. The reason for this is that simply doing:\n\n{noformat}\nconst uintxx_t swapped_val = byteSwap( *(uintxx_t*)(&value) );\n{noformat}\n\ni.e. taking the address of value instead of using the copy on the heap, fails with GCC 4.0.2 and GCC 4.0.3. I'm guessing GCC might be trying to inline the call to byteSwap and then something goes very wrong when taking the address of a variable on the stack. Hopefully someone has a better idea for a workaround.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Byte swap on float and double truncates values\n\nDescription:\nactivemq::util::Endian::byteSwap truncates float and double values due to the C-style cast it uses.\n\nPatch for BytesMessageCommandTest is attached that shows the problem. One might consider expanding this test to check that the minimum, maximum, -1, 0, 1 (and -inf and inf where appropriate) and a few other values can successfully be serialised and deserialised for each of the types.\n\nAlso in the patch is our attempt at fixing byteSwap. You'll notice that we do something very strange: we take the argument of byteSwap and make a copy on the heap. The reason for this is that simply doing:\n\n{noformat}\nconst uintxx_t swapped_val = byteSwap( *(uintxx_t*)(&value) );\n{noformat}\n\ni.e. taking the address of value instead of using the copy on the heap, fails with GCC 4.0.2 and GCC 4.0.3. I'm guessing GCC might be trying to inline the call to byteSwap and then something goes very wrong when taking the address of a variable on the stack. Hopefully someone has a better idea for a workaround.\n\n\nComments:\n", "classification": "Classify the issue 'Byte swap on float and double truncates values' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-41?\nA: activemq::util::Endian::byteSwap truncates float and double values due to the C-style cast it uses.\n\nPatch for BytesMessageCommandTest is attached that shows the problem. One might consider expanding this test to check that the minimum, maximum, -1, 0, 1 (and -inf and inf where appropriate) and a few other values can successfully be serialised and deserialised for each of the types.\n\nAlso in the p"}}
{"issue_key": "AMQCPP-40", "project": "AMQCPP", "title": "A few stray unix and sun defines", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-01-10T14:51:11.000+0000", "updated": "2007-01-22T20:52:58.000+0000", "description": "The AMQCPP code still contains a few references to the unix and sun defines.\n\n{noformat}\n./src/main/activemq/concurrent/Mutex.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX)) && !defined(USG)\n./src/main/activemq/concurrent/Thread.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX) || defined(__APPLE__)) && !defined(USG)\n./src/main/activemq/util/Guid.h:        #if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Config.h:      // used by unix like systems (including cygwin)\n./src/main/activemq/util/Config.h:      #elif defined( unix )\n./src/main/activemq/util/Endian.h:#if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Endian.h:# if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/network/ServerSocket.h:      #if !defined( unix ) || defined( __CYGWIN__ )\n./src/main/activemq/network/SocketOutputStream.cpp:#elif defined( unix ) && !defined( __CYGWIN__ ) && !defined( sun )\n{noformat}\n\nThese should probably be replaced by some kind of AMQ_ variant. It would nice if one could define a single AMQ_something per platform, akin to Windows's _WIN32 define.", "comments": [], "text": "A few stray unix and sun defines\n\nDescription:\nThe AMQCPP code still contains a few references to the unix and sun defines.\n\n{noformat}\n./src/main/activemq/concurrent/Mutex.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX)) && !defined(USG)\n./src/main/activemq/concurrent/Thread.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX) || defined(__APPLE__)) && !defined(USG)\n./src/main/activemq/util/Guid.h:        #if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Config.h:      // used by unix like systems (including cygwin)\n./src/main/activemq/util/Config.h:      #elif defined( unix )\n./src/main/activemq/util/Endian.h:#if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Endian.h:# if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/network/ServerSocket.h:      #if !defined( unix ) || defined( __CYGWIN__ )\n./src/main/activemq/network/SocketOutputStream.cpp:#elif defined( unix ) && !defined( __CYGWIN__ ) && !defined( sun )\n{noformat}\n\nThese should probably be replaced by some kind of AMQ_ variant. It would nice if one could define a single AMQ_something per platform, akin to Windows's _WIN32 define.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: A few stray unix and sun defines\n\nDescription:\nThe AMQCPP code still contains a few references to the unix and sun defines.\n\n{noformat}\n./src/main/activemq/concurrent/Mutex.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX)) && !defined(USG)\n./src/main/activemq/concurrent/Thread.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX) || defined(__APPLE__)) && !defined(USG)\n./src/main/activemq/util/Guid.h:        #if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Config.h:      // used by unix like systems (including cygwin)\n./src/main/activemq/util/Config.h:      #elif defined( unix )\n./src/main/activemq/util/Endian.h:#if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/util/Endian.h:# if defined( unix ) || defined(__APPLE__)\n./src/main/activemq/network/ServerSocket.h:      #if !defined( unix ) || defined( __CYGWIN__ )\n./src/main/activemq/network/SocketOutputStream.cpp:#elif defined( unix ) && !defined( __CYGWIN__ ) && !defined( sun )\n{noformat}\n\nThese should probably be replaced by some kind of AMQ_ variant. It would nice if one could define a single AMQ_something per platform, akin to Windows's _WIN32 define.\n\nComments:\n", "classification": "Classify the issue 'A few stray unix and sun defines' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-40?\nA: The AMQCPP code still contains a few references to the unix and sun defines.\n\n{noformat}\n./src/main/activemq/concurrent/Mutex.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX)) && !defined(USG)\n./src/main/activemq/concurrent/Thread.h:#if (defined(__unix__) || defined(unix) || defined(MACOSX) || defined(__APPLE__)) && !defined(USG)\n./src/main/activemq/util/Guid.h:        #if defined( uni"}}
{"issue_key": "AMQCPP-39", "project": "AMQCPP", "title": "Some AMQCPP includes not installed when doing make install on Linux", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-01-10T14:47:19.000+0000", "updated": "2007-01-10T15:05:07.000+0000", "description": "On Linux with the autotools build system, it seems that some headers aren't being installed.\n\nPatch for src/main/Makefile.am attached that fixes those that we ran into. There might be more -- maybe you want to make a script that checks that Makefile.am lists all the headers (or maybe use some kind of glob if that's possible).", "comments": [], "text": "Some AMQCPP includes not installed when doing make install on Linux\n\nDescription:\nOn Linux with the autotools build system, it seems that some headers aren't being installed.\n\nPatch for src/main/Makefile.am attached that fixes those that we ran into. There might be more -- maybe you want to make a script that checks that Makefile.am lists all the headers (or maybe use some kind of glob if that's possible).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Some AMQCPP includes not installed when doing make install on Linux\n\nDescription:\nOn Linux with the autotools build system, it seems that some headers aren't being installed.\n\nPatch for src/main/Makefile.am attached that fixes those that we ran into. There might be more -- maybe you want to make a script that checks that Makefile.am lists all the headers (or maybe use some kind of glob if that's possible).\n\nComments:\n", "classification": "Classify the issue 'Some AMQCPP includes not installed when doing make install on Linux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-39?\nA: On Linux with the autotools build system, it seems that some headers aren't being installed.\n\nPatch for src/main/Makefile.am attached that fixes those that we ran into. There might be more -- maybe you want to make a script that checks that Makefile.am lists all the headers (or maybe use some kind of glob if that's possible)."}}
{"issue_key": "AMQCPP-38", "project": "AMQCPP", "title": "Async error on broker when running integration tests", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-26T01:23:07.000+0000", "updated": "2007-01-22T22:53:06.000+0000", "description": "Brought over from the comments in AMQCPP-28.\n\nSometimes when running the integration tests against the AMQ broker from trunk, ones sees the following message from the broker:\n\nERROR Service - Async error occurred:\njava.lang.IllegalStateException: Cannot remove a consumer that had not been registered: ID:xxx-36153-1166305227288-5:16:-1:1\nat org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:593)\nat org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:64)\nat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:287)\nat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:178)\nat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:65)\nat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)\nat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:74)\nat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:119)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompUnsubscribe(ProtocolConverter.java:379)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommad(ProtocolConverter.java:151)\nat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:64)\nat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\nat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:137)\nat java.lang.Thread.run(Thread.java:595)\n\n\n\nUsing the default activemq.xml, I can reproduce the IllegalStateException quite reliabily:\n\n1. Start a fresh copy of the broker (4.2 from yesterday's trunk)\n2. Run the integration test under Valgrind\n3. IllegalStateException happens at the end of integration::durable::DurableTester::test or at the start of integration::expiration::ExpirationTest::testExpired.\n\nSubsequent test runs don't yield the error, until the broker is restarted. I don't know if this issue could be time-dependent - if it is, it could explain why I only see it when running under Valgrind.\n\nOn Linux, I also just got the following test failure for the first time (not running under Valgrind):\n\n1) test: integration::durable::DurableTester::test (E)\nuncaught exception of unknown type", "comments": [], "text": "Async error on broker when running integration tests\n\nDescription:\nBrought over from the comments in AMQCPP-28.\n\nSometimes when running the integration tests against the AMQ broker from trunk, ones sees the following message from the broker:\n\nERROR Service - Async error occurred:\njava.lang.IllegalStateException: Cannot remove a consumer that had not been registered: ID:xxx-36153-1166305227288-5:16:-1:1\nat org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:593)\nat org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:64)\nat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:287)\nat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:178)\nat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:65)\nat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)\nat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:74)\nat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:119)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompUnsubscribe(ProtocolConverter.java:379)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommad(ProtocolConverter.java:151)\nat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:64)\nat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\nat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:137)\nat java.lang.Thread.run(Thread.java:595)\n\n\n\nUsing the default activemq.xml, I can reproduce the IllegalStateException quite reliabily:\n\n1. Start a fresh copy of the broker (4.2 from yesterday's trunk)\n2. Run the integration test under Valgrind\n3. IllegalStateException happens at the end of integration::durable::DurableTester::test or at the start of integration::expiration::ExpirationTest::testExpired.\n\nSubsequent test runs don't yield the error, until the broker is restarted. I don't know if this issue could be time-dependent - if it is, it could explain why I only see it when running under Valgrind.\n\nOn Linux, I also just got the following test failure for the first time (not running under Valgrind):\n\n1) test: integration::durable::DurableTester::test (E)\nuncaught exception of unknown type\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Async error on broker when running integration tests\n\nDescription:\nBrought over from the comments in AMQCPP-28.\n\nSometimes when running the integration tests against the AMQ broker from trunk, ones sees the following message from the broker:\n\nERROR Service - Async error occurred:\njava.lang.IllegalStateException: Cannot remove a consumer that had not been registered: ID:xxx-36153-1166305227288-5:16:-1:1\nat org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:593)\nat org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:64)\nat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:287)\nat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:178)\nat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:65)\nat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)\nat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:74)\nat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:119)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompUnsubscribe(ProtocolConverter.java:379)\nat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommad(ProtocolConverter.java:151)\nat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:64)\nat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\nat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:137)\nat java.lang.Thread.run(Thread.java:595)\n\n\n\nUsing the default activemq.xml, I can reproduce the IllegalStateException quite reliabily:\n\n1. Start a fresh copy of the broker (4.2 from yesterday's trunk)\n2. Run the integration test under Valgrind\n3. IllegalStateException happens at the end of integration::durable::DurableTester::test or at the start of integration::expiration::ExpirationTest::testExpired.\n\nSubsequent test runs don't yield the error, until the broker is restarted. I don't know if this issue could be time-dependent - if it is, it could explain why I only see it when running under Valgrind.\n\nOn Linux, I also just got the following test failure for the first time (not running under Valgrind):\n\n1) test: integration::durable::DurableTester::test (E)\nuncaught exception of unknown type\n\n\nComments:\n", "classification": "Classify the issue 'Async error on broker when running integration tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-38?\nA: Brought over from the comments in AMQCPP-28.\n\nSometimes when running the integration tests against the AMQ broker from trunk, ones sees the following message from the broker:\n\nERROR Service - Async error occurred:\njava.lang.IllegalStateException: Cannot remove a consumer that had not been registered: ID:xxx-36153-1166305227288-5:16:-1:1\nat org.apache.activemq.broker.TransportConnection.processRemo"}}
{"issue_key": "AMQCPP-37", "project": "AMQCPP", "title": "readUTF and writeUTF for BytesMessage", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-25T20:36:05.000+0000", "updated": "2006-12-28T19:38:56.000+0000", "description": "It seems the existing writeString function doesn't allow one to send strings to Java, as readUTF there expects a unsigned short (for length) followed by string data (not null terminated).\n\nWith the attached patch applied, I am able to send strings between Java and C++.", "comments": [], "text": "readUTF and writeUTF for BytesMessage\n\nDescription:\nIt seems the existing writeString function doesn't allow one to send strings to Java, as readUTF there expects a unsigned short (for length) followed by string data (not null terminated).\n\nWith the attached patch applied, I am able to send strings between Java and C++.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: readUTF and writeUTF for BytesMessage\n\nDescription:\nIt seems the existing writeString function doesn't allow one to send strings to Java, as readUTF there expects a unsigned short (for length) followed by string data (not null terminated).\n\nWith the attached patch applied, I am able to send strings between Java and C++.\n\nComments:\n", "classification": "Classify the issue 'readUTF and writeUTF for BytesMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-37?\nA: It seems the existing writeString function doesn't allow one to send strings to Java, as readUTF there expects a unsigned short (for length) followed by string data (not null terminated).\n\nWith the attached patch applied, I am able to send strings between Java and C++."}}
{"issue_key": "AMQCPP-36", "project": "AMQCPP", "title": "Cleanup whitespace and member function definitions in header files", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-12-25T07:53:04.000+0000", "updated": "2007-01-11T09:02:46.000+0000", "description": "The AMQCPP code looks great in general, but many files have some stray whitespace. Also, there are quite a few headers that contain member function definitions. Some are simple, but there's also some big ones in there. I usually follow the rule that anything that can go into the .cpp should.\n\nAttached is a patch to clean up the files in activemq::concurrent. If Timothy/Nathan agrees that doing this is useful, I'll submit patches for the rest.", "comments": [], "text": "Cleanup whitespace and member function definitions in header files\n\nDescription:\nThe AMQCPP code looks great in general, but many files have some stray whitespace. Also, there are quite a few headers that contain member function definitions. Some are simple, but there's also some big ones in there. I usually follow the rule that anything that can go into the .cpp should.\n\nAttached is a patch to clean up the files in activemq::concurrent. If Timothy/Nathan agrees that doing this is useful, I'll submit patches for the rest.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Cleanup whitespace and member function definitions in header files\n\nDescription:\nThe AMQCPP code looks great in general, but many files have some stray whitespace. Also, there are quite a few headers that contain member function definitions. Some are simple, but there's also some big ones in there. I usually follow the rule that anything that can go into the .cpp should.\n\nAttached is a patch to clean up the files in activemq::concurrent. If Timothy/Nathan agrees that doing this is useful, I'll submit patches for the rest.\n\nComments:\n", "classification": "Classify the issue 'Cleanup whitespace and member function definitions in header files' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-36?\nA: The AMQCPP code looks great in general, but many files have some stray whitespace. Also, there are quite a few headers that contain member function definitions. Some are simple, but there's also some big ones in there. I usually follow the rule that anything that can go into the .cpp should.\n\nAttached is a patch to clean up the files in activemq::concurrent. If Timothy/Nathan agrees that doing thi"}}
{"issue_key": "AMQCPP-35", "project": "AMQCPP", "title": "Stomp content-length header not being set on BytesMessage", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-25T00:28:30.000+0000", "updated": "2007-01-02T17:53:01.000+0000", "description": "Not sure if this is a bug or if I'm just doing something wrong, but here goes.\n\nOn a cms::Session I'm calling createBytesMessage and getting back a cms::BytesMessage which is an activemq::connector::stomp::commands::BytesMessageCommand underneath. On this message I set an int property and write a string using writeString. Then I send the message to my producer. At no point does it seem as if the content-length header is set in this case. I verified by checking the properties written out for this message in StompCommandWriter::writeCommand. Due to the absence of this header, when AMQCPP receives this message, it assumes it is a TextMessageCommand instead of a BytesMessageCommand.\n\nThe only way the header can get set is by something calling setBytes on the BytesMessageCommand which calls through to setBytes of AbstractCommand which sets the header. I don't think this happens when one only does a writeString.", "comments": [], "text": "Stomp content-length header not being set on BytesMessage\n\nDescription:\nNot sure if this is a bug or if I'm just doing something wrong, but here goes.\n\nOn a cms::Session I'm calling createBytesMessage and getting back a cms::BytesMessage which is an activemq::connector::stomp::commands::BytesMessageCommand underneath. On this message I set an int property and write a string using writeString. Then I send the message to my producer. At no point does it seem as if the content-length header is set in this case. I verified by checking the properties written out for this message in StompCommandWriter::writeCommand. Due to the absence of this header, when AMQCPP receives this message, it assumes it is a TextMessageCommand instead of a BytesMessageCommand.\n\nThe only way the header can get set is by something calling setBytes on the BytesMessageCommand which calls through to setBytes of AbstractCommand which sets the header. I don't think this happens when one only does a writeString.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stomp content-length header not being set on BytesMessage\n\nDescription:\nNot sure if this is a bug or if I'm just doing something wrong, but here goes.\n\nOn a cms::Session I'm calling createBytesMessage and getting back a cms::BytesMessage which is an activemq::connector::stomp::commands::BytesMessageCommand underneath. On this message I set an int property and write a string using writeString. Then I send the message to my producer. At no point does it seem as if the content-length header is set in this case. I verified by checking the properties written out for this message in StompCommandWriter::writeCommand. Due to the absence of this header, when AMQCPP receives this message, it assumes it is a TextMessageCommand instead of a BytesMessageCommand.\n\nThe only way the header can get set is by something calling setBytes on the BytesMessageCommand which calls through to setBytes of AbstractCommand which sets the header. I don't think this happens when one only does a writeString.\n\nComments:\n", "classification": "Classify the issue 'Stomp content-length header not being set on BytesMessage' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-35?\nA: Not sure if this is a bug or if I'm just doing something wrong, but here goes.\n\nOn a cms::Session I'm calling createBytesMessage and getting back a cms::BytesMessage which is an activemq::connector::stomp::commands::BytesMessageCommand underneath. On this message I set an int property and write a string using writeString. Then I send the message to my producer. At no point does it seem as if the c"}}
{"issue_key": "AMQCPP-34", "project": "AMQCPP", "title": "Use covariant return type for clone()", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-24T22:15:03.000+0000", "updated": "2006-12-28T14:23:12.000+0000", "description": "The cms::Message type has a pure virtual clone() method that returns a cms::Message*. cms::BytesMessage doesn't have a clone method. So it continues down the inheritance chain until we get to classes like activemq::connector::stomp::commands::TextMessageCommand which implement clone() and define it to return cms::Message*.\n\nThis means that in my message listener I have to cast the result of a BytesMessage->clone() (which I already know is a BytesMessage) to BytesMessage before I can use it as such.\n\nInstead, BytesMessage should override clone() with another pure virtual that returns cms::BytesMessage. I think this is called a covariant return type. After that, TextMessageCommand's clone should probably be modified to return TextMessageCommand*. I don't know if there's anything in between that warrants a clone with a covariant return type.\n\nFixing this will make the library slightly easier to use.\n\nBasic patch attached. There's probably more places to fix. Patch also has a few typo fixes.", "comments": [], "text": "Use covariant return type for clone()\n\nDescription:\nThe cms::Message type has a pure virtual clone() method that returns a cms::Message*. cms::BytesMessage doesn't have a clone method. So it continues down the inheritance chain until we get to classes like activemq::connector::stomp::commands::TextMessageCommand which implement clone() and define it to return cms::Message*.\n\nThis means that in my message listener I have to cast the result of a BytesMessage->clone() (which I already know is a BytesMessage) to BytesMessage before I can use it as such.\n\nInstead, BytesMessage should override clone() with another pure virtual that returns cms::BytesMessage. I think this is called a covariant return type. After that, TextMessageCommand's clone should probably be modified to return TextMessageCommand*. I don't know if there's anything in between that warrants a clone with a covariant return type.\n\nFixing this will make the library slightly easier to use.\n\nBasic patch attached. There's probably more places to fix. Patch also has a few typo fixes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Use covariant return type for clone()\n\nDescription:\nThe cms::Message type has a pure virtual clone() method that returns a cms::Message*. cms::BytesMessage doesn't have a clone method. So it continues down the inheritance chain until we get to classes like activemq::connector::stomp::commands::TextMessageCommand which implement clone() and define it to return cms::Message*.\n\nThis means that in my message listener I have to cast the result of a BytesMessage->clone() (which I already know is a BytesMessage) to BytesMessage before I can use it as such.\n\nInstead, BytesMessage should override clone() with another pure virtual that returns cms::BytesMessage. I think this is called a covariant return type. After that, TextMessageCommand's clone should probably be modified to return TextMessageCommand*. I don't know if there's anything in between that warrants a clone with a covariant return type.\n\nFixing this will make the library slightly easier to use.\n\nBasic patch attached. There's probably more places to fix. Patch also has a few typo fixes.\n\nComments:\n", "classification": "Classify the issue 'Use covariant return type for clone()' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-34?\nA: The cms::Message type has a pure virtual clone() method that returns a cms::Message*. cms::BytesMessage doesn't have a clone method. So it continues down the inheritance chain until we get to classes like activemq::connector::stomp::commands::TextMessageCommand which implement clone() and define it to return cms::Message*.\n\nThis means that in my message listener I have to cast the result of a Byte"}}
{"issue_key": "AMQCPP-33", "project": "AMQCPP", "title": "Integration tests crash if broker isn't running", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2006-12-24T00:50:37.000+0000", "updated": "2006-12-24T02:36:29.000+0000", "description": "The AMQCPP integration tests crash on my Windows system if a broker isn't running. I'm guessing it's an uncaught exception from the connection attempt that's causing problems. It should probably be caught and do some kind of CPPUNIT_ASSERT(false).", "comments": [], "text": "Integration tests crash if broker isn't running\n\nDescription:\nThe AMQCPP integration tests crash on my Windows system if a broker isn't running. I'm guessing it's an uncaught exception from the connection attempt that's causing problems. It should probably be caught and do some kind of CPPUNIT_ASSERT(false).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Integration tests crash if broker isn't running\n\nDescription:\nThe AMQCPP integration tests crash on my Windows system if a broker isn't running. I'm guessing it's an uncaught exception from the connection attempt that's causing problems. It should probably be caught and do some kind of CPPUNIT_ASSERT(false).\n\nComments:\n", "classification": "Classify the issue 'Integration tests crash if broker isn't running' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-33?\nA: The AMQCPP integration tests crash on my Windows system if a broker isn't running. I'm guessing it's an uncaught exception from the connection attempt that's causing problems. It should probably be caught and do some kind of CPPUNIT_ASSERT(false)."}}
{"issue_key": "AMQCPP-32", "project": "AMQCPP", "title": "Stomp messages don't preserve property types: please document this behaviour", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2006-12-23T15:58:30.000+0000", "updated": "2007-01-08T14:53:54.000+0000", "description": "I am producing messages from Java and C++ using ActiveMQ and AMQCPP, respectively. Messages I produce have an int property set on them which I want to select on, again in Java or C++.\n\nAs far as I can tell from the [Stomp Protocol specification|http://stomp.codehaus.org/Protocol] there is no way to specify the types of message headers. As a result, all the messages end up with String properties as can be be seen in the unmarshal method of [org.apache.activemq.transport.stomp|http://svn.apache.org/viewvc/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/transport/stomp/StompWireFormat.java?revision=470398&view=markup].\n\nI can work around this problem by selecting on id=123||id='123' in both Java and C++, but it seems a bit suboptimal.\n\nAt least, this issue should be documented somewhere in activemq::connector::stomp::commands::StompMessage to help other people who can't figure out why their selectors don't work.\n\nWe could consider adding a function that allows the user to specify that Stomp message properties should be sent in a type safe manner, and then prepend some kind of string to the property name to indicate the type. StompWireFormat on the Java side could check for this case and set the typed properties accordingly. This is probably too much of a hack -- people who want typed properties to work right can use Openwire in the (hopefully) near future.", "comments": [], "text": "Stomp messages don't preserve property types: please document this behaviour\n\nDescription:\nI am producing messages from Java and C++ using ActiveMQ and AMQCPP, respectively. Messages I produce have an int property set on them which I want to select on, again in Java or C++.\n\nAs far as I can tell from the [Stomp Protocol specification|http://stomp.codehaus.org/Protocol] there is no way to specify the types of message headers. As a result, all the messages end up with String properties as can be be seen in the unmarshal method of [org.apache.activemq.transport.stomp|http://svn.apache.org/viewvc/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/transport/stomp/StompWireFormat.java?revision=470398&view=markup].\n\nI can work around this problem by selecting on id=123||id='123' in both Java and C++, but it seems a bit suboptimal.\n\nAt least, this issue should be documented somewhere in activemq::connector::stomp::commands::StompMessage to help other people who can't figure out why their selectors don't work.\n\nWe could consider adding a function that allows the user to specify that Stomp message properties should be sent in a type safe manner, and then prepend some kind of string to the property name to indicate the type. StompWireFormat on the Java side could check for this case and set the typed properties accordingly. This is probably too much of a hack -- people who want typed properties to work right can use Openwire in the (hopefully) near future.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Stomp messages don't preserve property types: please document this behaviour\n\nDescription:\nI am producing messages from Java and C++ using ActiveMQ and AMQCPP, respectively. Messages I produce have an int property set on them which I want to select on, again in Java or C++.\n\nAs far as I can tell from the [Stomp Protocol specification|http://stomp.codehaus.org/Protocol] there is no way to specify the types of message headers. As a result, all the messages end up with String properties as can be be seen in the unmarshal method of [org.apache.activemq.transport.stomp|http://svn.apache.org/viewvc/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/transport/stomp/StompWireFormat.java?revision=470398&view=markup].\n\nI can work around this problem by selecting on id=123||id='123' in both Java and C++, but it seems a bit suboptimal.\n\nAt least, this issue should be documented somewhere in activemq::connector::stomp::commands::StompMessage to help other people who can't figure out why their selectors don't work.\n\nWe could consider adding a function that allows the user to specify that Stomp message properties should be sent in a type safe manner, and then prepend some kind of string to the property name to indicate the type. StompWireFormat on the Java side could check for this case and set the typed properties accordingly. This is probably too much of a hack -- people who want typed properties to work right can use Openwire in the (hopefully) near future.\n\n\nComments:\n", "classification": "Classify the issue 'Stomp messages don't preserve property types: please document this behaviour' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-32?\nA: I am producing messages from Java and C++ using ActiveMQ and AMQCPP, respectively. Messages I produce have an int property set on them which I want to select on, again in Java or C++.\n\nAs far as I can tell from the [Stomp Protocol specification|http://stomp.codehaus.org/Protocol] there is no way to specify the types of message headers. As a result, all the messages end up with String properties as"}}
{"issue_key": "AMQCPP-31", "project": "AMQCPP", "title": "Consider giving the unix #define a more unique name", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-22T23:25:29.000+0000", "updated": "2006-12-23T01:47:36.000+0000", "description": "src\\main\\activemq\\concurrent\\Mutex.h and src\\main\\activemq\\concurrent\\Thread.cpp check if \"unix\" is defined to enable UNIX-specific functionality.\n\nFrom what I've seen in other projects, it's considered a good practice to \"scope\" your defines, i.e. unix should rather be something like ACTIVEMQ_CPP_UNIX. This virtually eliminates problems when integrating multiple libraries, where defines like \"unix\" might mean different things to different libraries, meaning the user will have to do some messy preprocessor gymnastics when trying to include headers from multiple libraries in the same file.\n\nThis also provides an obvious naming convention for other defines. Need, e.g., OpenBSD-specific code? Use ACTIVEMQ_CPP_OPENBSD. On Unix systems, autoconf can probably take care of this kind of thing.", "comments": [], "text": "Consider giving the unix #define a more unique name\n\nDescription:\nsrc\\main\\activemq\\concurrent\\Mutex.h and src\\main\\activemq\\concurrent\\Thread.cpp check if \"unix\" is defined to enable UNIX-specific functionality.\n\nFrom what I've seen in other projects, it's considered a good practice to \"scope\" your defines, i.e. unix should rather be something like ACTIVEMQ_CPP_UNIX. This virtually eliminates problems when integrating multiple libraries, where defines like \"unix\" might mean different things to different libraries, meaning the user will have to do some messy preprocessor gymnastics when trying to include headers from multiple libraries in the same file.\n\nThis also provides an obvious naming convention for other defines. Need, e.g., OpenBSD-specific code? Use ACTIVEMQ_CPP_OPENBSD. On Unix systems, autoconf can probably take care of this kind of thing.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Consider giving the unix #define a more unique name\n\nDescription:\nsrc\\main\\activemq\\concurrent\\Mutex.h and src\\main\\activemq\\concurrent\\Thread.cpp check if \"unix\" is defined to enable UNIX-specific functionality.\n\nFrom what I've seen in other projects, it's considered a good practice to \"scope\" your defines, i.e. unix should rather be something like ACTIVEMQ_CPP_UNIX. This virtually eliminates problems when integrating multiple libraries, where defines like \"unix\" might mean different things to different libraries, meaning the user will have to do some messy preprocessor gymnastics when trying to include headers from multiple libraries in the same file.\n\nThis also provides an obvious naming convention for other defines. Need, e.g., OpenBSD-specific code? Use ACTIVEMQ_CPP_OPENBSD. On Unix systems, autoconf can probably take care of this kind of thing.\n\nComments:\n", "classification": "Classify the issue 'Consider giving the unix #define a more unique name' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-31?\nA: src\\main\\activemq\\concurrent\\Mutex.h and src\\main\\activemq\\concurrent\\Thread.cpp check if \"unix\" is defined to enable UNIX-specific functionality.\n\nFrom what I've seen in other projects, it's considered a good practice to \"scope\" your defines, i.e. unix should rather be something like ACTIVEMQ_CPP_UNIX. This virtually eliminates problems when integrating multiple libraries, where defines like \"uni"}}
{"issue_key": "AMQCPP-30", "project": "AMQCPP", "title": "Add support to activemq-cpp to support the openwire protocol", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Critical", "labels": [], "created": "2006-12-17T14:05:26.000+0000", "updated": "2007-03-13T10:16:21.000+0000", "description": "Need to complete the first cut at the implementation of the openwire transport", "comments": [], "text": "Add support to activemq-cpp to support the openwire protocol\n\nDescription:\nNeed to complete the first cut at the implementation of the openwire transport\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support to activemq-cpp to support the openwire protocol\n\nDescription:\nNeed to complete the first cut at the implementation of the openwire transport\n\nComments:\n", "classification": "Classify the issue 'Add support to activemq-cpp to support the openwire protocol' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-30?\nA: Need to complete the first cut at the implementation of the openwire transport"}}
{"issue_key": "AMQCPP-29", "project": "AMQCPP", "title": "Projects in MSVC build building on top of one another", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-12-17T01:31:48.000+0000", "updated": "2006-12-21T14:33:29.000+0000", "description": "After I've done a complete Debug build on Windows with MSVC 2005, building the solution again still yields the following each time I build:\n\n1>------ Build started: Project: vs2005-activemq-example, Configuration: Debug Win32 ------\n1>Linking...\n1>Embedding manifest...\n1>Build log was saved at \"file://c:\\home\\albert\\work5\\activemq-cpp\\Debug\\BuildLog.htm\"\n1>vs2005-activemq-example - 0 error(s), 0 warning(s)\n========== Build: 1 succeeded, 0 failed, 3 up-to-date, 0 skipped ==========\n\nI think this relinking might have something to do with the tests and activemq-example all containing a main.cpp with is built as main.obj in the Debug directory.\n\nYou might consider setting up the Windows builds as follows (idea borrowed from many other projects I've looked at):\n\ntop level of project\n   \\win_build\n   \\win_build\\solution.sln\n   \\win_build\\project1.sln\n   \\win_build\\project2.sln\n   \\win_build\\Debug (output directory)\n   \\win_build\\Release (output directory)\n   \\win_build\\project1\\Debug (intermediate directory)\n   \\win_build\\project1\\Release (intermediate directory)\n   \\win_build\\project2\\Debug (intermediate directory)\n   \\win_build\\project2\\Release (intermediate directory)\n\nTo achieve this, each project's output directory for each build is set to (SolutionDir)$(ConfigurationName)  and the intermediate directory is set to $(SolutionDir)$(ProjectName)\\$(ConfigurationName) (note the extra \\).\n\nThis setup keeps all the Windows output out of the top level directory, and prevents projects from building on top of one another.\n\nWith this setup, you need to refer to src\\main as ..\\src\\main, etc.", "comments": [], "text": "Projects in MSVC build building on top of one another\n\nDescription:\nAfter I've done a complete Debug build on Windows with MSVC 2005, building the solution again still yields the following each time I build:\n\n1>------ Build started: Project: vs2005-activemq-example, Configuration: Debug Win32 ------\n1>Linking...\n1>Embedding manifest...\n1>Build log was saved at \"file://c:\\home\\albert\\work5\\activemq-cpp\\Debug\\BuildLog.htm\"\n1>vs2005-activemq-example - 0 error(s), 0 warning(s)\n========== Build: 1 succeeded, 0 failed, 3 up-to-date, 0 skipped ==========\n\nI think this relinking might have something to do with the tests and activemq-example all containing a main.cpp with is built as main.obj in the Debug directory.\n\nYou might consider setting up the Windows builds as follows (idea borrowed from many other projects I've looked at):\n\ntop level of project\n   \\win_build\n   \\win_build\\solution.sln\n   \\win_build\\project1.sln\n   \\win_build\\project2.sln\n   \\win_build\\Debug (output directory)\n   \\win_build\\Release (output directory)\n   \\win_build\\project1\\Debug (intermediate directory)\n   \\win_build\\project1\\Release (intermediate directory)\n   \\win_build\\project2\\Debug (intermediate directory)\n   \\win_build\\project2\\Release (intermediate directory)\n\nTo achieve this, each project's output directory for each build is set to (SolutionDir)$(ConfigurationName)  and the intermediate directory is set to $(SolutionDir)$(ProjectName)\\$(ConfigurationName) (note the extra \\).\n\nThis setup keeps all the Windows output out of the top level directory, and prevents projects from building on top of one another.\n\nWith this setup, you need to refer to src\\main as ..\\src\\main, etc.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Projects in MSVC build building on top of one another\n\nDescription:\nAfter I've done a complete Debug build on Windows with MSVC 2005, building the solution again still yields the following each time I build:\n\n1>------ Build started: Project: vs2005-activemq-example, Configuration: Debug Win32 ------\n1>Linking...\n1>Embedding manifest...\n1>Build log was saved at \"file://c:\\home\\albert\\work5\\activemq-cpp\\Debug\\BuildLog.htm\"\n1>vs2005-activemq-example - 0 error(s), 0 warning(s)\n========== Build: 1 succeeded, 0 failed, 3 up-to-date, 0 skipped ==========\n\nI think this relinking might have something to do with the tests and activemq-example all containing a main.cpp with is built as main.obj in the Debug directory.\n\nYou might consider setting up the Windows builds as follows (idea borrowed from many other projects I've looked at):\n\ntop level of project\n   \\win_build\n   \\win_build\\solution.sln\n   \\win_build\\project1.sln\n   \\win_build\\project2.sln\n   \\win_build\\Debug (output directory)\n   \\win_build\\Release (output directory)\n   \\win_build\\project1\\Debug (intermediate directory)\n   \\win_build\\project1\\Release (intermediate directory)\n   \\win_build\\project2\\Debug (intermediate directory)\n   \\win_build\\project2\\Release (intermediate directory)\n\nTo achieve this, each project's output directory for each build is set to (SolutionDir)$(ConfigurationName)  and the intermediate directory is set to $(SolutionDir)$(ProjectName)\\$(ConfigurationName) (note the extra \\).\n\nThis setup keeps all the Windows output out of the top level directory, and prevents projects from building on top of one another.\n\nWith this setup, you need to refer to src\\main as ..\\src\\main, etc.\n\nComments:\n", "classification": "Classify the issue 'Projects in MSVC build building on top of one another' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-29?\nA: After I've done a complete Debug build on Windows with MSVC 2005, building the solution again still yields the following each time I build:\n\n1>------ Build started: Project: vs2005-activemq-example, Configuration: Debug Win32 ------\n1>Linking...\n1>Embedding manifest...\n1>Build log was saved at \"file://c:\\home\\albert\\work5\\activemq-cpp\\Debug\\BuildLog.htm\"\n1>vs2005-activemq-example - 0 error(s), 0 w"}}
{"issue_key": "AMQCPP-28", "project": "AMQCPP", "title": "Purify and Valgrind warnings when running integration tests", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-16T21:50:42.000+0000", "updated": "2007-01-07T14:51:48.000+0000", "description": "Warnings from Purify when running the integration test (latest from trunk) against latest trunk of the broker.", "comments": [], "text": "Purify and Valgrind warnings when running integration tests\n\nDescription:\nWarnings from Purify when running the integration test (latest from trunk) against latest trunk of the broker.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Purify and Valgrind warnings when running integration tests\n\nDescription:\nWarnings from Purify when running the integration test (latest from trunk) against latest trunk of the broker.\n\n\nComments:\n", "classification": "Classify the issue 'Purify and Valgrind warnings when running integration tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-28?\nA: Warnings from Purify when running the integration test (latest from trunk) against latest trunk of the broker.\n"}}
{"issue_key": "AMQCPP-27", "project": "AMQCPP", "title": "Issues reported by Valgrind when running unit tests", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-16T01:14:50.000+0000", "updated": "2007-01-07T14:48:37.000+0000", "description": "Valgrind 3.2.1 reported a few issues when running the ActiveMQ C++ unit tests.\n\nSome of them were simple cases of mismatched new[] and delete[] (patch attached).\n\nValgrind also reports a few memory leaks, some probably the same as found by Rational Purify.\n\nComplete Valgrind log attached (after I fixed the deletes). I ran Valgrind as follows:\n\nvalgrind \\\n        --tool=memcheck \\\n        --leak-check=yes \\\n        --error-limit=no \\\n        --num-callers=20 \\\n        --freelist-vol=536870912 \\\n        -v \\\n        ./activemq-test", "comments": [], "text": "Issues reported by Valgrind when running unit tests\n\nDescription:\nValgrind 3.2.1 reported a few issues when running the ActiveMQ C++ unit tests.\n\nSome of them were simple cases of mismatched new[] and delete[] (patch attached).\n\nValgrind also reports a few memory leaks, some probably the same as found by Rational Purify.\n\nComplete Valgrind log attached (after I fixed the deletes). I ran Valgrind as follows:\n\nvalgrind \\\n        --tool=memcheck \\\n        --leak-check=yes \\\n        --error-limit=no \\\n        --num-callers=20 \\\n        --freelist-vol=536870912 \\\n        -v \\\n        ./activemq-test\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Issues reported by Valgrind when running unit tests\n\nDescription:\nValgrind 3.2.1 reported a few issues when running the ActiveMQ C++ unit tests.\n\nSome of them were simple cases of mismatched new[] and delete[] (patch attached).\n\nValgrind also reports a few memory leaks, some probably the same as found by Rational Purify.\n\nComplete Valgrind log attached (after I fixed the deletes). I ran Valgrind as follows:\n\nvalgrind \\\n        --tool=memcheck \\\n        --leak-check=yes \\\n        --error-limit=no \\\n        --num-callers=20 \\\n        --freelist-vol=536870912 \\\n        -v \\\n        ./activemq-test\n\n\n\nComments:\n", "classification": "Classify the issue 'Issues reported by Valgrind when running unit tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-27?\nA: Valgrind 3.2.1 reported a few issues when running the ActiveMQ C++ unit tests.\n\nSome of them were simple cases of mismatched new[] and delete[] (patch attached).\n\nValgrind also reports a few memory leaks, some probably the same as found by Rational Purify.\n\nComplete Valgrind log attached (after I fixed the deletes). I ran Valgrind as follows:\n\nvalgrind \\\n        --tool=memcheck \\\n        --leak-ch"}}
{"issue_key": "AMQCPP-26", "project": "AMQCPP", "title": "Memory leaks reported by Rational Purify when running unit tests", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-16T00:45:17.000+0000", "updated": "2006-12-16T17:18:44.000+0000", "description": "Rational Purify reports two potential memory leaks in the latest ActiveMQ C++ code from SVN. I've attached the complete Purfiy output.\n\nLook for the following:\n\nMPK: Potential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nPotential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nI think the createConnection leak has also been reported on the mailing list.\n\nComplete Purify output attached.", "comments": [], "text": "Memory leaks reported by Rational Purify when running unit tests\n\nDescription:\nRational Purify reports two potential memory leaks in the latest ActiveMQ C++ code from SVN. I've attached the complete Purfiy output.\n\nLook for the following:\n\nMPK: Potential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nPotential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nI think the createConnection leak has also been reported on the mailing list.\n\nComplete Purify output attached.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Memory leaks reported by Rational Purify when running unit tests\n\nDescription:\nRational Purify reports two potential memory leaks in the latest ActiveMQ C++ code from SVN. I've attached the complete Purfiy output.\n\nLook for the following:\n\nMPK: Potential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nPotential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&) [vc2005-activemq-unittests.exe]\n\nI think the createConnection leak has also been reported on the mailing list.\n\nComplete Purify output attached.\n\nComments:\n", "classification": "Classify the issue 'Memory leaks reported by Rational Purify when running unit tests' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-26?\nA: Rational Purify reports two potential memory leaks in the latest ActiveMQ C++ code from SVN. I've attached the complete Purfiy output.\n\nLook for the following:\n\nMPK: Potential memory leak of 116 bytes from 1 block allocated in activemq::core::ActiveMQConnectionFactory::createConnection(basic_string<char,char_traits<char>::std,allocator<char>::std>::std const&,basic_string<char,char_traits<char>::s"}}
{"issue_key": "AMQCPP-25", "project": "AMQCPP", "title": "Bus error on Solaris OS from DataInput and DataOutput streams", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-12-13T12:40:46.000+0000", "updated": "2007-01-11T20:24:08.000+0000", "description": "Due to misaligned memory reads, there is a bus error that can occur in using the new DataInputStream and DataOutputStream classes.", "comments": [], "text": "Bus error on Solaris OS from DataInput and DataOutput streams\n\nDescription:\nDue to misaligned memory reads, there is a bus error that can occur in using the new DataInputStream and DataOutputStream classes.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Bus error on Solaris OS from DataInput and DataOutput streams\n\nDescription:\nDue to misaligned memory reads, there is a bus error that can occur in using the new DataInputStream and DataOutputStream classes.\n\nComments:\n", "classification": "Classify the issue 'Bus error on Solaris OS from DataInput and DataOutput streams' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-25?\nA: Due to misaligned memory reads, there is a bus error that can occur in using the new DataInputStream and DataOutputStream classes."}}
{"issue_key": "AMQCPP-24", "project": "AMQCPP", "title": "activemq::util::Boolean::parseBoolean should return bool not int", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-11T23:57:49.000+0000", "updated": "2006-12-12T00:13:23.000+0000", "description": "activemq::util::Boolean::parseBoolean should return bool not int.", "comments": [], "text": "activemq::util::Boolean::parseBoolean should return bool not int\n\nDescription:\nactivemq::util::Boolean::parseBoolean should return bool not int.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: activemq::util::Boolean::parseBoolean should return bool not int\n\nDescription:\nactivemq::util::Boolean::parseBoolean should return bool not int.\n\nComments:\n", "classification": "Classify the issue 'activemq::util::Boolean::parseBoolean should return bool not int' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-24?\nA: activemq::util::Boolean::parseBoolean should return bool not int."}}
{"issue_key": "AMQCPP-23", "project": "AMQCPP", "title": "active-cpp persistent problem", "status": "Resolved", "reporter": "james nomingo", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-08T21:32:17.000+0000", "updated": "2006-12-12T14:09:09.000+0000", "description": "I'm struggling with persistent option in activemq-cpp client. (my java client does the trick)\npart of my code looks like:\n\nproducer->setDeliveryMode( DeliveryMode::PERSISTANT );\n\nThe problem is after I send a message, and stop the broker. The message is gone.\nIf I send a lot of message exceeding the memory size the broker handles, I got resource unavailable exception.\n\nIt looks to me the message I send over using cpp doesn't instruct the broker to use persistent.\nI'm using ActiveMQ 4.0.2, and activemq-cpp-1.0.", "comments": [], "text": "active-cpp persistent problem\n\nDescription:\nI'm struggling with persistent option in activemq-cpp client. (my java client does the trick)\npart of my code looks like:\n\nproducer->setDeliveryMode( DeliveryMode::PERSISTANT );\n\nThe problem is after I send a message, and stop the broker. The message is gone.\nIf I send a lot of message exceeding the memory size the broker handles, I got resource unavailable exception.\n\nIt looks to me the message I send over using cpp doesn't instruct the broker to use persistent.\nI'm using ActiveMQ 4.0.2, and activemq-cpp-1.0.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: active-cpp persistent problem\n\nDescription:\nI'm struggling with persistent option in activemq-cpp client. (my java client does the trick)\npart of my code looks like:\n\nproducer->setDeliveryMode( DeliveryMode::PERSISTANT );\n\nThe problem is after I send a message, and stop the broker. The message is gone.\nIf I send a lot of message exceeding the memory size the broker handles, I got resource unavailable exception.\n\nIt looks to me the message I send over using cpp doesn't instruct the broker to use persistent.\nI'm using ActiveMQ 4.0.2, and activemq-cpp-1.0.\n\n\nComments:\n", "classification": "Classify the issue 'active-cpp persistent problem' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-23?\nA: I'm struggling with persistent option in activemq-cpp client. (my java client does the trick)\npart of my code looks like:\n\nproducer->setDeliveryMode( DeliveryMode::PERSISTANT );\n\nThe problem is after I send a message, and stop the broker. The message is gone.\nIf I send a lot of message exceeding the memory size the broker handles, I got resource unavailable exception.\n\nIt looks to me the message I"}}
{"issue_key": "AMQCPP-22", "project": "AMQCPP", "title": "Use common name for ActiveMQ C++ library on Windows and Linux", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-05T12:48:42.000+0000", "updated": "2006-12-15T12:52:55.000+0000", "description": "We're using SCons to build our application that links against the ActiveMQ-CPP library on Windows and Linux.\n\nThe Visual Studio files included with ActiveMQ-CPP builds a library called \"activemq.lib\" whereas the Linux Autotools build builds a library called \"libactivemq-cpp.a\". SCons takes care of the platform-specific prefix (lib or nothing) and the suffix (.a or .lib), but the base names of the library still differs, i.e. activemq vs activemq-cpp.\n\nI think it would make sense to standardise on one library name across all platforms. Personally, I'd go for \"activemq\", but \"activemq-cpp\" is fine, as long as it's the same everywhere.", "comments": [], "text": "Use common name for ActiveMQ C++ library on Windows and Linux\n\nDescription:\nWe're using SCons to build our application that links against the ActiveMQ-CPP library on Windows and Linux.\n\nThe Visual Studio files included with ActiveMQ-CPP builds a library called \"activemq.lib\" whereas the Linux Autotools build builds a library called \"libactivemq-cpp.a\". SCons takes care of the platform-specific prefix (lib or nothing) and the suffix (.a or .lib), but the base names of the library still differs, i.e. activemq vs activemq-cpp.\n\nI think it would make sense to standardise on one library name across all platforms. Personally, I'd go for \"activemq\", but \"activemq-cpp\" is fine, as long as it's the same everywhere.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Use common name for ActiveMQ C++ library on Windows and Linux\n\nDescription:\nWe're using SCons to build our application that links against the ActiveMQ-CPP library on Windows and Linux.\n\nThe Visual Studio files included with ActiveMQ-CPP builds a library called \"activemq.lib\" whereas the Linux Autotools build builds a library called \"libactivemq-cpp.a\". SCons takes care of the platform-specific prefix (lib or nothing) and the suffix (.a or .lib), but the base names of the library still differs, i.e. activemq vs activemq-cpp.\n\nI think it would make sense to standardise on one library name across all platforms. Personally, I'd go for \"activemq\", but \"activemq-cpp\" is fine, as long as it's the same everywhere.\n\nComments:\n", "classification": "Classify the issue 'Use common name for ActiveMQ C++ library on Windows and Linux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-22?\nA: We're using SCons to build our application that links against the ActiveMQ-CPP library on Windows and Linux.\n\nThe Visual Studio files included with ActiveMQ-CPP builds a library called \"activemq.lib\" whereas the Linux Autotools build builds a library called \"libactivemq-cpp.a\". SCons takes care of the platform-specific prefix (lib or nothing) and the suffix (.a or .lib), but the base names of the "}}
{"issue_key": "AMQCPP-21", "project": "AMQCPP", "title": "Minor Linux Build Issues", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-12-04T21:01:08.000+0000", "updated": "2006-12-04T21:50:02.000+0000", "description": "We've picked up two minor issues with the build on Linux. Firstly:\n\nsrc\\main\\activemq\\connector\\openwire\\marshal\\v2\\MarshallerFactory.cpp(17): #include <activemq/connector/openwire/marshal/V2/MarshallerFactory.h>\n\nThat should be v2, not V2.\n\nSecondly, src/main/Makefile.am does not seem to install activemq/util/Config.h.", "comments": [], "text": "Minor Linux Build Issues\n\nDescription:\nWe've picked up two minor issues with the build on Linux. Firstly:\n\nsrc\\main\\activemq\\connector\\openwire\\marshal\\v2\\MarshallerFactory.cpp(17): #include <activemq/connector/openwire/marshal/V2/MarshallerFactory.h>\n\nThat should be v2, not V2.\n\nSecondly, src/main/Makefile.am does not seem to install activemq/util/Config.h.\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Minor Linux Build Issues\n\nDescription:\nWe've picked up two minor issues with the build on Linux. Firstly:\n\nsrc\\main\\activemq\\connector\\openwire\\marshal\\v2\\MarshallerFactory.cpp(17): #include <activemq/connector/openwire/marshal/V2/MarshallerFactory.h>\n\nThat should be v2, not V2.\n\nSecondly, src/main/Makefile.am does not seem to install activemq/util/Config.h.\n\n\n\nComments:\n", "classification": "Classify the issue 'Minor Linux Build Issues' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-21?\nA: We've picked up two minor issues with the build on Linux. Firstly:\n\nsrc\\main\\activemq\\connector\\openwire\\marshal\\v2\\MarshallerFactory.cpp(17): #include <activemq/connector/openwire/marshal/V2/MarshallerFactory.h>\n\nThat should be v2, not V2.\n\nSecondly, src/main/Makefile.am does not seem to install activemq/util/Config.h.\n\n"}}
{"issue_key": "AMQCPP-20", "project": "AMQCPP", "title": "Deadlock when in stomp connector close", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-01T15:33:24.000+0000", "updated": "2006-12-01T16:11:33.000+0000", "description": "When a broken socket occurs, the stomp connector attempts to asynchronously close itself.  This can cause a deadlock if the main thread is in the close method and is performing a join on the transport thread.", "comments": [], "text": "Deadlock when in stomp connector close\n\nDescription:\nWhen a broken socket occurs, the stomp connector attempts to asynchronously close itself.  This can cause a deadlock if the main thread is in the close method and is performing a join on the transport thread.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Deadlock when in stomp connector close\n\nDescription:\nWhen a broken socket occurs, the stomp connector attempts to asynchronously close itself.  This can cause a deadlock if the main thread is in the close method and is performing a join on the transport thread.\n\nComments:\n", "classification": "Classify the issue 'Deadlock when in stomp connector close' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-20?\nA: When a broken socket occurs, the stomp connector attempts to asynchronously close itself.  This can cause a deadlock if the main thread is in the close method and is performing a join on the transport thread."}}
{"issue_key": "AMQCPP-19", "project": "AMQCPP", "title": "Uuid class probably shouldn't use exception specifications", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2006-12-01T12:59:52.000+0000", "updated": "2006-12-02T12:59:38.000+0000", "description": "activemq/util/Uuid.h contains exception specifications. This causes the Microsoft compiler to warn:\n\nG:\\activemq/util/Guid.h(46) : warning C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)\n\nIn my experience, C++ code typically doesn't use exception specifications. Instead the exceptions that can be thrown are simply documented with the relevant doxygen tag.\n\nSome references:\n\nhttp://www.gotw.ca/publications/mill22.htm\nhttp://www.gotw.ca/gotw/082.htm\nhttp://www.boost.org/more/lib_guide.htm#Exception-specification", "comments": [], "text": "Uuid class probably shouldn't use exception specifications\n\nDescription:\nactivemq/util/Uuid.h contains exception specifications. This causes the Microsoft compiler to warn:\n\nG:\\activemq/util/Guid.h(46) : warning C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)\n\nIn my experience, C++ code typically doesn't use exception specifications. Instead the exceptions that can be thrown are simply documented with the relevant doxygen tag.\n\nSome references:\n\nhttp://www.gotw.ca/publications/mill22.htm\nhttp://www.gotw.ca/gotw/082.htm\nhttp://www.boost.org/more/lib_guide.htm#Exception-specification\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Uuid class probably shouldn't use exception specifications\n\nDescription:\nactivemq/util/Uuid.h contains exception specifications. This causes the Microsoft compiler to warn:\n\nG:\\activemq/util/Guid.h(46) : warning C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)\n\nIn my experience, C++ code typically doesn't use exception specifications. Instead the exceptions that can be thrown are simply documented with the relevant doxygen tag.\n\nSome references:\n\nhttp://www.gotw.ca/publications/mill22.htm\nhttp://www.gotw.ca/gotw/082.htm\nhttp://www.boost.org/more/lib_guide.htm#Exception-specification\n\n\nComments:\n", "classification": "Classify the issue 'Uuid class probably shouldn't use exception specifications' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-19?\nA: activemq/util/Uuid.h contains exception specifications. This causes the Microsoft compiler to warn:\n\nG:\\activemq/util/Guid.h(46) : warning C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)\n\nIn my experience, C++ code typically doesn't use exception specifications. Instead the exceptions that can be thrown are simply documented with the relevant dox"}}
{"issue_key": "AMQCPP-18", "project": "AMQCPP", "title": "ActiveMQConnection.close() causes app to crash", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2006-12-01T02:04:14.000+0000", "updated": "2006-12-01T02:24:22.000+0000", "description": "We currently have a flawed exception handling model in StompCommandReader.  It propagates different exceptions than the ones that are advertised, which causes the exception to slip through and crash the application.", "comments": [], "text": "ActiveMQConnection.close() causes app to crash\n\nDescription:\nWe currently have a flawed exception handling model in StompCommandReader.  It propagates different exceptions than the ones that are advertised, which causes the exception to slip through and crash the application.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQConnection.close() causes app to crash\n\nDescription:\nWe currently have a flawed exception handling model in StompCommandReader.  It propagates different exceptions than the ones that are advertised, which causes the exception to slip through and crash the application.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQConnection.close() causes app to crash' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-18?\nA: We currently have a flawed exception handling model in StompCommandReader.  It propagates different exceptions than the ones that are advertised, which causes the exception to slip through and crash the application."}}
{"issue_key": "AMQCPP-17", "project": "AMQCPP", "title": "Visual Studio project files shouldn't contain absolute include paths", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-11-27T23:40:47.000+0000", "updated": "2006-12-14T23:35:15.000+0000", "description": "The Visual Studio 2005 project files contain some absolute paths to ActiveMQ includes that should simply be paths relative to the project files.\n\nPatch for main library and example attached. Tests probably need to still be fixed.", "comments": [], "text": "Visual Studio project files shouldn't contain absolute include paths\n\nDescription:\nThe Visual Studio 2005 project files contain some absolute paths to ActiveMQ includes that should simply be paths relative to the project files.\n\nPatch for main library and example attached. Tests probably need to still be fixed.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Visual Studio project files shouldn't contain absolute include paths\n\nDescription:\nThe Visual Studio 2005 project files contain some absolute paths to ActiveMQ includes that should simply be paths relative to the project files.\n\nPatch for main library and example attached. Tests probably need to still be fixed.\n\nComments:\n", "classification": "Classify the issue 'Visual Studio project files shouldn't contain absolute include paths' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-17?\nA: The Visual Studio 2005 project files contain some absolute paths to ActiveMQ includes that should simply be paths relative to the project files.\n\nPatch for main library and example attached. Tests probably need to still be fixed."}}
{"issue_key": "AMQCPP-16", "project": "AMQCPP", "title": "CMS API needs updates to more closely follow JMS API", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2006-11-26T15:28:41.000+0000", "updated": "2006-12-17T13:50:59.000+0000", "description": "The CMS API interfaces need updates so that they more closely follow the JMS API:\n\n1.  Change longs to long long types.\n2.  The ReplyTo accessors should handle cms::Destination pointers, not strings", "comments": [], "text": "CMS API needs updates to more closely follow JMS API\n\nDescription:\nThe CMS API interfaces need updates so that they more closely follow the JMS API:\n\n1.  Change longs to long long types.\n2.  The ReplyTo accessors should handle cms::Destination pointers, not strings\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS API needs updates to more closely follow JMS API\n\nDescription:\nThe CMS API interfaces need updates so that they more closely follow the JMS API:\n\n1.  Change longs to long long types.\n2.  The ReplyTo accessors should handle cms::Destination pointers, not strings\n\nComments:\n", "classification": "Classify the issue 'CMS API needs updates to more closely follow JMS API' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-16?\nA: The CMS API interfaces need updates so that they more closely follow the JMS API:\n\n1.  Change longs to long long types.\n2.  The ReplyTo accessors should handle cms::Destination pointers, not strings"}}
{"issue_key": "AMQCPP-15", "project": "AMQCPP", "title": "Add other versions of send method to CMS MessageProducer", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2006-11-26T13:45:36.000+0000", "updated": "2006-11-26T18:48:06.000+0000", "description": "There are two versions of the send method in JMS that are not currently part of the CMS API.\n\nsend(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) \n\nsend(Message message, int deliveryMode, int priority, long timeToLive)", "comments": [], "text": "Add other versions of send method to CMS MessageProducer\n\nDescription:\nThere are two versions of the send method in JMS that are not currently part of the CMS API.\n\nsend(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) \n\nsend(Message message, int deliveryMode, int priority, long timeToLive) \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add other versions of send method to CMS MessageProducer\n\nDescription:\nThere are two versions of the send method in JMS that are not currently part of the CMS API.\n\nsend(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) \n\nsend(Message message, int deliveryMode, int priority, long timeToLive) \n\nComments:\n", "classification": "Classify the issue 'Add other versions of send method to CMS MessageProducer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-15?\nA: There are two versions of the send method in JMS that are not currently part of the CMS API.\n\nsend(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) \n\nsend(Message message, int deliveryMode, int priority, long timeToLive) "}}
{"issue_key": "AMQCPP-14", "project": "AMQCPP", "title": "CMSExpiration not handled properly in ActiveMQProducer", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-11-26T13:13:41.000+0000", "updated": "2006-12-06T14:52:22.000+0000", "description": "ActiveMQProducer.send method is overwriting the CMSExpiration in the message with its default timeToLive value.  This is incorrect - it should set the expiry to (expiry + timeToLive).  An example of this is in ActiveMQ's ActiveMQSession:\n\nhttps://svn.apache.org/repos/asf/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/ActiveMQSession.java\n\nA work-around is to specify the timeToLive value in the producer.", "comments": [], "text": "CMSExpiration not handled properly in ActiveMQProducer\n\nDescription:\nActiveMQProducer.send method is overwriting the CMSExpiration in the message with its default timeToLive value.  This is incorrect - it should set the expiry to (expiry + timeToLive).  An example of this is in ActiveMQ's ActiveMQSession:\n\nhttps://svn.apache.org/repos/asf/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/ActiveMQSession.java\n\nA work-around is to specify the timeToLive value in the producer. \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMSExpiration not handled properly in ActiveMQProducer\n\nDescription:\nActiveMQProducer.send method is overwriting the CMSExpiration in the message with its default timeToLive value.  This is incorrect - it should set the expiry to (expiry + timeToLive).  An example of this is in ActiveMQ's ActiveMQSession:\n\nhttps://svn.apache.org/repos/asf/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/ActiveMQSession.java\n\nA work-around is to specify the timeToLive value in the producer. \n\nComments:\n", "classification": "Classify the issue 'CMSExpiration not handled properly in ActiveMQProducer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-14?\nA: ActiveMQProducer.send method is overwriting the CMSExpiration in the message with its default timeToLive value.  This is incorrect - it should set the expiry to (expiry + timeToLive).  An example of this is in ActiveMQ's ActiveMQSession:\n\nhttps://svn.apache.org/repos/asf/incubator/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/ActiveMQSession.java\n\nA work-around is to specify the t"}}
{"issue_key": "AMQCPP-13", "project": "AMQCPP", "title": "Patch to make activemq-cpp compile under sun studio 11", "status": "Resolved", "reporter": "Chris Knight", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2006-09-14T18:35:11.000+0000", "updated": "2006-11-17T16:56:54.000+0000", "description": "Fixes compilation of activemq-cpp for studio 11 C++ compiler. Mostly additions of #include <string.h> and added namespace qualifiers std::", "comments": [], "text": "Patch to make activemq-cpp compile under sun studio 11\n\nDescription:\nFixes compilation of activemq-cpp for studio 11 C++ compiler. Mostly additions of #include <string.h> and added namespace qualifiers std::\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Patch to make activemq-cpp compile under sun studio 11\n\nDescription:\nFixes compilation of activemq-cpp for studio 11 C++ compiler. Mostly additions of #include <string.h> and added namespace qualifiers std::\n\nComments:\n", "classification": "Classify the issue 'Patch to make activemq-cpp compile under sun studio 11' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-13?\nA: Fixes compilation of activemq-cpp for studio 11 C++ compiler. Mostly additions of #include <string.h> and added namespace qualifiers std::"}}
{"issue_key": "AMQCPP-163", "project": "AMQCPP", "title": "Durable Subscriber test fails consistantly on linux and windows", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-02-02T23:03:53.000+0000", "updated": "2008-05-20T22:55:36.000+0000", "description": "The durable subscriber test seems to fail pretty consistently on windows and linux (not sure about Mac).", "comments": [], "text": "Durable Subscriber test fails consistantly on linux and windows\n\nDescription:\nThe durable subscriber test seems to fail pretty consistently on windows and linux (not sure about Mac).  \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Durable Subscriber test fails consistantly on linux and windows\n\nDescription:\nThe durable subscriber test seems to fail pretty consistently on windows and linux (not sure about Mac).  \n\nComments:\n", "classification": "Classify the issue 'Durable Subscriber test fails consistantly on linux and windows' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-163?\nA: The durable subscriber test seems to fail pretty consistently on windows and linux (not sure about Mac).  "}}
{"issue_key": "AMQCPP-162", "project": "AMQCPP", "title": "Fix for spelling mistake in main C++ sample", "status": "Resolved", "reporter": "Gustav Mauer", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2008-01-30T09:39:56.000+0000", "updated": "2008-01-30T12:07:21.000+0000", "description": "-    void waitUnitlReady() {\n  should be\n+    void waitUntilReady() {", "comments": [], "text": "Fix for spelling mistake in main C++ sample\n\nDescription:\n-    void waitUnitlReady() {\n  should be\n+    void waitUntilReady() {\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Fix for spelling mistake in main C++ sample\n\nDescription:\n-    void waitUnitlReady() {\n  should be\n+    void waitUntilReady() {\n\nComments:\n", "classification": "Classify the issue 'Fix for spelling mistake in main C++ sample' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-162?\nA: -    void waitUnitlReady() {\n  should be\n+    void waitUntilReady() {"}}
{"issue_key": "AMQCPP-161", "project": "AMQCPP", "title": "CMS does not support prefetchSize=0 correctly", "status": "Resolved", "reporter": "Dominic Tulley", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2008-01-28T16:32:55.000+0000", "updated": "2008-02-03T18:35:43.000+0000", "description": "AMQ-850 introduced the ability to set the message prefetch size to 0.\nThis means that no messages are prefetched and every receive() call goes all the way to the broker to get the next message.\nIt was only a valid option for synchronous message receivers.\n\nIn CMS it does not appear to work.  Instead, a client set to use this simply receives no messages, and the messages remain on the queue.\n\nWithout this patch, it is possible for a slow consumer to hide an important message from other consumers because it has prefetched it.", "comments": [], "text": "CMS does not support prefetchSize=0 correctly\n\nDescription:\nAMQ-850 introduced the ability to set the message prefetch size to 0.\nThis means that no messages are prefetched and every receive() call goes all the way to the broker to get the next message.\nIt was only a valid option for synchronous message receivers.\n\nIn CMS it does not appear to work.  Instead, a client set to use this simply receives no messages, and the messages remain on the queue.\n\nWithout this patch, it is possible for a slow consumer to hide an important message from other consumers because it has prefetched it.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CMS does not support prefetchSize=0 correctly\n\nDescription:\nAMQ-850 introduced the ability to set the message prefetch size to 0.\nThis means that no messages are prefetched and every receive() call goes all the way to the broker to get the next message.\nIt was only a valid option for synchronous message receivers.\n\nIn CMS it does not appear to work.  Instead, a client set to use this simply receives no messages, and the messages remain on the queue.\n\nWithout this patch, it is possible for a slow consumer to hide an important message from other consumers because it has prefetched it.\n\nComments:\n", "classification": "Classify the issue 'CMS does not support prefetchSize=0 correctly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-161?\nA: AMQ-850 introduced the ability to set the message prefetch size to 0.\nThis means that no messages are prefetched and every receive() call goes all the way to the broker to get the next message.\nIt was only a valid option for synchronous message receivers.\n\nIn CMS it does not appear to work.  Instead, a client set to use this simply receives no messages, and the messages remain on the queue.\n\nWitho"}}
{"issue_key": "AMQCPP-160", "project": "AMQCPP", "title": "Add MessageTransformer", "status": "Resolved", "reporter": "Phillip Weisberg", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-12-20T15:00:20.000+0000", "updated": "2012-05-07T22:06:00.000+0000", "description": "Add support for the ActiveMQ MessageTransformer interface.  This allows for messages to be transformed within the JMS provider.  Specifically, it allows you to:\n\n  *  enrich or transform a message before it is sent to the message bus within the JMS provider\n  * enrich or transform a message as it is received from the message bus but before it is dispatched to the consumer\n\nMessageTransformer Interface Overview:\nhttp://activemq.apache.org/message-transformation.html\n\nActiveMQ-5.0 MessageTransformer API:\nhttp://activemq.apache.org/maven/activemq-core/apidocs/org/apache/activemq/MessageTransformer.html", "comments": [], "text": "Add MessageTransformer\n\nDescription:\nAdd support for the ActiveMQ MessageTransformer interface.  This allows for messages to be transformed within the JMS provider.  Specifically, it allows you to:\n\n  *  enrich or transform a message before it is sent to the message bus within the JMS provider\n  * enrich or transform a message as it is received from the message bus but before it is dispatched to the consumer\n\nMessageTransformer Interface Overview:\nhttp://activemq.apache.org/message-transformation.html\n\nActiveMQ-5.0 MessageTransformer API:\nhttp://activemq.apache.org/maven/activemq-core/apidocs/org/apache/activemq/MessageTransformer.html\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add MessageTransformer\n\nDescription:\nAdd support for the ActiveMQ MessageTransformer interface.  This allows for messages to be transformed within the JMS provider.  Specifically, it allows you to:\n\n  *  enrich or transform a message before it is sent to the message bus within the JMS provider\n  * enrich or transform a message as it is received from the message bus but before it is dispatched to the consumer\n\nMessageTransformer Interface Overview:\nhttp://activemq.apache.org/message-transformation.html\n\nActiveMQ-5.0 MessageTransformer API:\nhttp://activemq.apache.org/maven/activemq-core/apidocs/org/apache/activemq/MessageTransformer.html\n\nComments:\n", "classification": "Classify the issue 'Add MessageTransformer' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-160?\nA: Add support for the ActiveMQ MessageTransformer interface.  This allows for messages to be transformed within the JMS provider.  Specifically, it allows you to:\n\n  *  enrich or transform a message before it is sent to the message bus within the JMS provider\n  * enrich or transform a message as it is received from the message bus but before it is dispatched to the consumer\n\nMessageTransformer Inter"}}
{"issue_key": "AMQCPP-159", "project": "AMQCPP", "title": "autogen.sh fails to create configure", "status": "Resolved", "reporter": "Simone Piunno", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-12-18T14:14:29.000+0000", "updated": "2007-12-29T17:39:19.000+0000", "description": "simone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ autoconf --version|head -n1\nautoconf (GNU Autoconf) 2.61\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ automake --version|head -n1\nautomake (GNU automake) 1.10\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ libtool --version|head -n1\nltmain.sh (GNU libtool) 1.5.24 (1.1220.2.456 2007/06/24 02:25:32)\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ ./autogen.sh\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nPutting files in AC_CONFIG_AUX_DIR, `config'.\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nUnmatched [ in regex; marked by <-- HERE in m/^AS_FLAGS$|^SHELL$|^PATH_SEPARATOR$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^exec_prefix$|^prefix$|^program_transform_name$|^bindir$|^sbindir$|^libexecdir$|^datarootdir$|^datadir$|^sysconfdir$|^sharedstatedir$|^localstatedir$|^includedir$|^oldincludedir$|^docdir$|^infodir$|^htmldir$|^dvidir$|^pdfdir$|^psdir$|^libdir$|^localedir$|^mandir$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^DEFS$|^ECHO_C$|^ECHO_N$|^ECHO_T$|^LIBS$|^build_alias$|^host_alias$|^target_alias$|^ACTIVEMQ_LIBRARY_NAME$|^ACTIVEMQ_VERSION$|^ACTIVEMQ_LIBRARY_VERSION$|^ACTIVEMQ_RELEASE$|^ACTIVEMQ_API_VERSION$|^AM_[A-Z]+FLAGS$|^INSTALL_PROGRAM$|^INSTALL_SCRIPT$|^INSTALL_DATA$|^am__isrc$|^CYGPATH_W$|^PACKAGE$|^VERSION$|^PACKAGE$|^VERSION$|^ACLOCAL$|^AUTOCONF$|^AUTOMAKE$|^AUTOHEADER$|^MAKEINFO$|^install_sh$|^STRIP$|^INSTALL_STRIP_PROGRAM$|^mkdir_p$|^AWK$|^SET_MAKE$|^am__leading_dot$|^AMTAR$|^am__tar$|^am__untar$|^build$|^build_cpu$|^build_vendor$|^build_os$|^host$|^host_cpu$|^host_vendor$|^host_os$|^CC$|^CFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CC$|^CC$|^CC$|^CC$|^ac_ct_CC$|^EXEEXT$|^OBJEXT$|^DEPDIR$|^am__include$|^am__quote$|^AMDEP_TRUE$|^AMDEP_FALSE$|^AMDEPBACKSLASH$|^CCDEPMODE$|^am__fastdepCC_TRUE$|^am__fastdepCC_FALSE$|^CXX$|^CXXFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CXX$|^ac_ct_CXX$|^CXXDEPMODE$|^am__fastdepCXX_TRUE$|^am__fastdepCXX_FALSE$|^SED$|^GREP$|^GREP$|^EGREP$|^EGREP$|^LN_S$|^ECHO$|^AR$|^RANLIB$|^STRIP$|^DLLTOOL$|^AS$|^OBJDUMP$|^CPP$|^CPPFLAGS$|^CPP$|^STDC_HEADERS$|^CXXCPP$|^CPPFLAGS$|^CXXCPP$|^F77$|^FFLAGS$|^LDFLAGS$|^LIBS$|^F77$|^ac_ct_F77$|^LIBTOOL$|^LIBTOOL_DEPS$|^LIBOBJS$|^HAVE_DOPRNT$|^STDC_HEADERS$|^const$|^size_t$|^WORDS_BIGENDIAN$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG$|^SIZEOF_CHAR$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG_LONG$|^SIZEOF_FLOAT$|^SIZEOF_DOUBLE$|^HAVE_UUID_T$|^BUILD_CPPUNIT_TESTS_TRUE$|^BUILD_CPPUNIT_TESTS_FALSE$|^AMQ_CXXFLAGS$|^AMQ_LIBS$|^AMQ_TEST_CXXFLAGS$|^AMQ_TEST_LIBS$|^HAVE_VISIBILITY_OPTIONS$|^HAVE_STRUCT_ADDRINFO$|^DX_PROJECT$|^DX_CONFIG$|^DX_DOCDIR$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_DOXYGEN$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PERL$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_ENV$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DOT$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_ENV$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_HHC$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_LATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DVIPS$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PDFLATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[ <-- HERE ]DX_CURRENT_FEATURE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DOXYGEN_PAPER_SIZE$|^DOXYGEN_PAPER_SIZE$|^DX_ENV$|^LIBOBJS$|^LTLIBOBJS$/ at /usr/bin/autom4te-2.61 line 572, <GEN13> line 25961.\nautoreconf-2.61: /usr/bin/autoconf-2.61 failed with exit status: 1", "comments": [], "text": "autogen.sh fails to create configure\n\nDescription:\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ autoconf --version|head -n1\nautoconf (GNU Autoconf) 2.61\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ automake --version|head -n1\nautomake (GNU automake) 1.10\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ libtool --version|head -n1\nltmain.sh (GNU libtool) 1.5.24 (1.1220.2.456 2007/06/24 02:25:32)\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ ./autogen.sh\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nPutting files in AC_CONFIG_AUX_DIR, `config'.\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nUnmatched [ in regex; marked by <-- HERE in m/^AS_FLAGS$|^SHELL$|^PATH_SEPARATOR$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^exec_prefix$|^prefix$|^program_transform_name$|^bindir$|^sbindir$|^libexecdir$|^datarootdir$|^datadir$|^sysconfdir$|^sharedstatedir$|^localstatedir$|^includedir$|^oldincludedir$|^docdir$|^infodir$|^htmldir$|^dvidir$|^pdfdir$|^psdir$|^libdir$|^localedir$|^mandir$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^DEFS$|^ECHO_C$|^ECHO_N$|^ECHO_T$|^LIBS$|^build_alias$|^host_alias$|^target_alias$|^ACTIVEMQ_LIBRARY_NAME$|^ACTIVEMQ_VERSION$|^ACTIVEMQ_LIBRARY_VERSION$|^ACTIVEMQ_RELEASE$|^ACTIVEMQ_API_VERSION$|^AM_[A-Z]+FLAGS$|^INSTALL_PROGRAM$|^INSTALL_SCRIPT$|^INSTALL_DATA$|^am__isrc$|^CYGPATH_W$|^PACKAGE$|^VERSION$|^PACKAGE$|^VERSION$|^ACLOCAL$|^AUTOCONF$|^AUTOMAKE$|^AUTOHEADER$|^MAKEINFO$|^install_sh$|^STRIP$|^INSTALL_STRIP_PROGRAM$|^mkdir_p$|^AWK$|^SET_MAKE$|^am__leading_dot$|^AMTAR$|^am__tar$|^am__untar$|^build$|^build_cpu$|^build_vendor$|^build_os$|^host$|^host_cpu$|^host_vendor$|^host_os$|^CC$|^CFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CC$|^CC$|^CC$|^CC$|^ac_ct_CC$|^EXEEXT$|^OBJEXT$|^DEPDIR$|^am__include$|^am__quote$|^AMDEP_TRUE$|^AMDEP_FALSE$|^AMDEPBACKSLASH$|^CCDEPMODE$|^am__fastdepCC_TRUE$|^am__fastdepCC_FALSE$|^CXX$|^CXXFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CXX$|^ac_ct_CXX$|^CXXDEPMODE$|^am__fastdepCXX_TRUE$|^am__fastdepCXX_FALSE$|^SED$|^GREP$|^GREP$|^EGREP$|^EGREP$|^LN_S$|^ECHO$|^AR$|^RANLIB$|^STRIP$|^DLLTOOL$|^AS$|^OBJDUMP$|^CPP$|^CPPFLAGS$|^CPP$|^STDC_HEADERS$|^CXXCPP$|^CPPFLAGS$|^CXXCPP$|^F77$|^FFLAGS$|^LDFLAGS$|^LIBS$|^F77$|^ac_ct_F77$|^LIBTOOL$|^LIBTOOL_DEPS$|^LIBOBJS$|^HAVE_DOPRNT$|^STDC_HEADERS$|^const$|^size_t$|^WORDS_BIGENDIAN$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG$|^SIZEOF_CHAR$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG_LONG$|^SIZEOF_FLOAT$|^SIZEOF_DOUBLE$|^HAVE_UUID_T$|^BUILD_CPPUNIT_TESTS_TRUE$|^BUILD_CPPUNIT_TESTS_FALSE$|^AMQ_CXXFLAGS$|^AMQ_LIBS$|^AMQ_TEST_CXXFLAGS$|^AMQ_TEST_LIBS$|^HAVE_VISIBILITY_OPTIONS$|^HAVE_STRUCT_ADDRINFO$|^DX_PROJECT$|^DX_CONFIG$|^DX_DOCDIR$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_DOXYGEN$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PERL$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_ENV$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DOT$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_ENV$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_HHC$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_LATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DVIPS$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PDFLATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[ <-- HERE ]DX_CURRENT_FEATURE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DOXYGEN_PAPER_SIZE$|^DOXYGEN_PAPER_SIZE$|^DX_ENV$|^LIBOBJS$|^LTLIBOBJS$/ at /usr/bin/autom4te-2.61 line 572, <GEN13> line 25961.\nautoreconf-2.61: /usr/bin/autoconf-2.61 failed with exit status: 1\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: autogen.sh fails to create configure\n\nDescription:\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ autoconf --version|head -n1\nautoconf (GNU Autoconf) 2.61\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ automake --version|head -n1\nautomake (GNU automake) 1.10\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ libtool --version|head -n1\nltmain.sh (GNU libtool) 1.5.24 (1.1220.2.456 2007/06/24 02:25:32)\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ ./autogen.sh\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nPutting files in AC_CONFIG_AUX_DIR, `config'.\nconfigure.ac:83: warning: macro `AM_PATH_CPPUNIT' not found in library\nUnmatched [ in regex; marked by <-- HERE in m/^AS_FLAGS$|^SHELL$|^PATH_SEPARATOR$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^exec_prefix$|^prefix$|^program_transform_name$|^bindir$|^sbindir$|^libexecdir$|^datarootdir$|^datadir$|^sysconfdir$|^sharedstatedir$|^localstatedir$|^includedir$|^oldincludedir$|^docdir$|^infodir$|^htmldir$|^dvidir$|^pdfdir$|^psdir$|^libdir$|^localedir$|^mandir$|^PACKAGE_NAME$|^PACKAGE_TARNAME$|^PACKAGE_VERSION$|^PACKAGE_STRING$|^PACKAGE_BUGREPORT$|^DEFS$|^ECHO_C$|^ECHO_N$|^ECHO_T$|^LIBS$|^build_alias$|^host_alias$|^target_alias$|^ACTIVEMQ_LIBRARY_NAME$|^ACTIVEMQ_VERSION$|^ACTIVEMQ_LIBRARY_VERSION$|^ACTIVEMQ_RELEASE$|^ACTIVEMQ_API_VERSION$|^AM_[A-Z]+FLAGS$|^INSTALL_PROGRAM$|^INSTALL_SCRIPT$|^INSTALL_DATA$|^am__isrc$|^CYGPATH_W$|^PACKAGE$|^VERSION$|^PACKAGE$|^VERSION$|^ACLOCAL$|^AUTOCONF$|^AUTOMAKE$|^AUTOHEADER$|^MAKEINFO$|^install_sh$|^STRIP$|^INSTALL_STRIP_PROGRAM$|^mkdir_p$|^AWK$|^SET_MAKE$|^am__leading_dot$|^AMTAR$|^am__tar$|^am__untar$|^build$|^build_cpu$|^build_vendor$|^build_os$|^host$|^host_cpu$|^host_vendor$|^host_os$|^CC$|^CFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CC$|^CC$|^CC$|^CC$|^ac_ct_CC$|^EXEEXT$|^OBJEXT$|^DEPDIR$|^am__include$|^am__quote$|^AMDEP_TRUE$|^AMDEP_FALSE$|^AMDEPBACKSLASH$|^CCDEPMODE$|^am__fastdepCC_TRUE$|^am__fastdepCC_FALSE$|^CXX$|^CXXFLAGS$|^LDFLAGS$|^LIBS$|^CPPFLAGS$|^CXX$|^ac_ct_CXX$|^CXXDEPMODE$|^am__fastdepCXX_TRUE$|^am__fastdepCXX_FALSE$|^SED$|^GREP$|^GREP$|^EGREP$|^EGREP$|^LN_S$|^ECHO$|^AR$|^RANLIB$|^STRIP$|^DLLTOOL$|^AS$|^OBJDUMP$|^CPP$|^CPPFLAGS$|^CPP$|^STDC_HEADERS$|^CXXCPP$|^CPPFLAGS$|^CXXCPP$|^F77$|^FFLAGS$|^LDFLAGS$|^LIBS$|^F77$|^ac_ct_F77$|^LIBTOOL$|^LIBTOOL_DEPS$|^LIBOBJS$|^HAVE_DOPRNT$|^STDC_HEADERS$|^const$|^size_t$|^WORDS_BIGENDIAN$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG$|^SIZEOF_CHAR$|^SIZEOF_SHORT$|^SIZEOF_INT$|^SIZEOF_LONG_LONG$|^SIZEOF_FLOAT$|^SIZEOF_DOUBLE$|^HAVE_UUID_T$|^BUILD_CPPUNIT_TESTS_TRUE$|^BUILD_CPPUNIT_TESTS_FALSE$|^AMQ_CXXFLAGS$|^AMQ_LIBS$|^AMQ_TEST_CXXFLAGS$|^AMQ_TEST_LIBS$|^HAVE_VISIBILITY_OPTIONS$|^HAVE_STRUCT_ADDRINFO$|^DX_PROJECT$|^DX_CONFIG$|^DX_DOCDIR$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_FLAG_doc$|^DX_DOXYGEN$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PERL$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_ENV$|^DX_COND_doc_TRUE$|^DX_COND_doc_FALSE$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_dot$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DOT$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_ENV$|^DX_COND_dot_TRUE$|^DX_COND_dot_FALSE$|^DX_ENV$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_man$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_COND_man_TRUE$|^DX_COND_man_FALSE$|^DX_ENV$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_rtf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_COND_rtf_TRUE$|^DX_COND_rtf_FALSE$|^DX_ENV$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_xml$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_COND_xml_TRUE$|^DX_COND_xml_FALSE$|^DX_ENV$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_chm$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_HHC$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_ENV$|^DX_ENV$|^DX_COND_chm_TRUE$|^DX_COND_chm_FALSE$|^DX_ENV$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_chi$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_COND_chi_TRUE$|^DX_COND_chi_FALSE$|^DX_ENV$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_html$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_COND_html_TRUE$|^DX_COND_html_FALSE$|^DX_ENV$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_ps$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_LATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_DVIPS$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_COND_ps_TRUE$|^DX_COND_ps_FALSE$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_pdf$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_PDFLATEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_MAKEINDEX$|^DX_FLAG_[]DX_CURRENT_FEATURE$|^DX_EGREP$|^DX_FLAG_[ <-- HERE ]DX_CURRENT_FEATURE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_pdf_TRUE$|^DX_COND_pdf_FALSE$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DX_COND_latex_TRUE$|^DX_COND_latex_FALSE$|^DX_ENV$|^DOXYGEN_PAPER_SIZE$|^DOXYGEN_PAPER_SIZE$|^DX_ENV$|^LIBOBJS$|^LTLIBOBJS$/ at /usr/bin/autom4te-2.61 line 572, <GEN13> line 25961.\nautoreconf-2.61: /usr/bin/autoconf-2.61 failed with exit status: 1\n\n\nComments:\n", "classification": "Classify the issue 'autogen.sh fails to create configure' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-159?\nA: simone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ autoconf --version|head -n1\nautoconf (GNU Autoconf) 2.61\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ automake --version|head -n1\nautomake (GNU automake) 1.10\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ libtool --version|head -n1\nltmain.sh (GNU libtool) 1.5.24 (1.1220.2.456 2007/06/24 02:25:32)\nsimone@dunnottar ~/sandbox/activemq-cpp-2.1.3 $ ."}}
{"issue_key": "AMQCPP-158", "project": "AMQCPP", "title": "libtool release and version-info arguments need to be set correctly", "status": "Resolved", "reporter": "Daniel Pocock", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-12-14T19:40:22.000+0000", "updated": "2008-12-31T20:52:56.000+0000", "description": "When make is invoked, libtool is asked to build the library with this command line:\n\n/bin/sh ../../libtool --tag=CXX   --mode=link g++ -ansi -pedantic -W -Wall -fPIC  -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -version-info 2:1:2 -release 2.1.2  -o libactivemq-cpp.la -rpath /usr/lib activemq/core/libactivemq_cpp_la-ActiveMQConsumer.lo ...........\n\nNotice the `-release 2.1.2' argument to libtool?  Using a unique release number with each build means that applications will only run with one specific build, and no others.\n\nPerhaps `-release 2' might be more appropriate?  This would mean that an application that expects version 2.1.1 would still be willing to link with 2.2.0 (for example) at runtime.  Alternatively, it may be better to omit the release argument, and just use version-info.\n\nThe -version-info argument allows more fine-grained control - however, it is not meant to be written as MAJOR:MINOR:REVISION.  The three values mean `version:revision:age', where:\n- version = ABI version, an integer that is increment whenever binary compatibility changes\n- revision = implementation (this number is incremented when there is a code change that does not impact the binary interface)\n- age = how many previous versions are binary compatible, e.g if age = 2, then version, (version - 1) and (version - 2) are all binary compatible - the age value specified for this library (2) suggests that it is binary compatible to the original version (0).\n\nABI version numbers are not the same as product version numbers.  If the product number is 2.1.2, that does not mean the -version-info argument is 2:1:2.\n\nI have created some pages on the wiki to discuss version and packaging issues; these issues need to be agreed upon by the community before a version scheme can be implemented in the build system.\n\nI am willing to work on the details and contribute a patch for this once there has been some consensus on which is the best versioning scheme to adopt and what level of binary compatibility is expected.\n\nWiki pages:\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP+product+version+number\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP%2C+libtool+and+packaging+notes", "comments": [], "text": "libtool release and version-info arguments need to be set correctly\n\nDescription:\nWhen make is invoked, libtool is asked to build the library with this command line:\n\n/bin/sh ../../libtool --tag=CXX   --mode=link g++ -ansi -pedantic -W -Wall -fPIC  -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -version-info 2:1:2 -release 2.1.2  -o libactivemq-cpp.la -rpath /usr/lib activemq/core/libactivemq_cpp_la-ActiveMQConsumer.lo ...........\n\nNotice the `-release 2.1.2' argument to libtool?  Using a unique release number with each build means that applications will only run with one specific build, and no others.\n\nPerhaps `-release 2' might be more appropriate?  This would mean that an application that expects version 2.1.1 would still be willing to link with 2.2.0 (for example) at runtime.  Alternatively, it may be better to omit the release argument, and just use version-info.\n\nThe -version-info argument allows more fine-grained control - however, it is not meant to be written as MAJOR:MINOR:REVISION.  The three values mean `version:revision:age', where:\n- version = ABI version, an integer that is increment whenever binary compatibility changes\n- revision = implementation (this number is incremented when there is a code change that does not impact the binary interface)\n- age = how many previous versions are binary compatible, e.g if age = 2, then version, (version - 1) and (version - 2) are all binary compatible - the age value specified for this library (2) suggests that it is binary compatible to the original version (0).\n\nABI version numbers are not the same as product version numbers.  If the product number is 2.1.2, that does not mean the -version-info argument is 2:1:2.\n\nI have created some pages on the wiki to discuss version and packaging issues; these issues need to be agreed upon by the community before a version scheme can be implemented in the build system.\n\nI am willing to work on the details and contribute a patch for this once there has been some consensus on which is the best versioning scheme to adopt and what level of binary compatibility is expected.\n\nWiki pages:\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP+product+version+number\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP%2C+libtool+and+packaging+notes\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: libtool release and version-info arguments need to be set correctly\n\nDescription:\nWhen make is invoked, libtool is asked to build the library with this command line:\n\n/bin/sh ../../libtool --tag=CXX   --mode=link g++ -ansi -pedantic -W -Wall -fPIC  -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -version-info 2:1:2 -release 2.1.2  -o libactivemq-cpp.la -rpath /usr/lib activemq/core/libactivemq_cpp_la-ActiveMQConsumer.lo ...........\n\nNotice the `-release 2.1.2' argument to libtool?  Using a unique release number with each build means that applications will only run with one specific build, and no others.\n\nPerhaps `-release 2' might be more appropriate?  This would mean that an application that expects version 2.1.1 would still be willing to link with 2.2.0 (for example) at runtime.  Alternatively, it may be better to omit the release argument, and just use version-info.\n\nThe -version-info argument allows more fine-grained control - however, it is not meant to be written as MAJOR:MINOR:REVISION.  The three values mean `version:revision:age', where:\n- version = ABI version, an integer that is increment whenever binary compatibility changes\n- revision = implementation (this number is incremented when there is a code change that does not impact the binary interface)\n- age = how many previous versions are binary compatible, e.g if age = 2, then version, (version - 1) and (version - 2) are all binary compatible - the age value specified for this library (2) suggests that it is binary compatible to the original version (0).\n\nABI version numbers are not the same as product version numbers.  If the product number is 2.1.2, that does not mean the -version-info argument is 2:1:2.\n\nI have created some pages on the wiki to discuss version and packaging issues; these issues need to be agreed upon by the community before a version scheme can be implemented in the build system.\n\nI am willing to work on the details and contribute a patch for this once there has been some consensus on which is the best versioning scheme to adopt and what level of binary compatibility is expected.\n\nWiki pages:\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP+product+version+number\n\nhttp://cwiki.apache.org/confluence/display/AMQCPP/ActiveMQ-CPP%2C+libtool+and+packaging+notes\n\n\nComments:\n", "classification": "Classify the issue 'libtool release and version-info arguments need to be set correctly' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-158?\nA: When make is invoked, libtool is asked to build the library with this command line:\n\n/bin/sh ../../libtool --tag=CXX   --mode=link g++ -ansi -pedantic -W -Wall -fPIC  -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -g -O2 -version-info 2:1:2 -release 2.1.2  -o libactivemq-cpp.la -rpath /usr/lib activemq/core/libactivemq_cpp_la-ActiveMQConsumer.lo ...........\n\nNotice the `-release 2.1.2' argum"}}
{"issue_key": "AMQCPP-157", "project": "AMQCPP", "title": "Interoperability issues between C++ and .NET", "status": "Closed", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-12-12T03:59:27.000+0000", "updated": "2008-02-03T22:44:08.000+0000", "description": "Taken from http://www.nabble.com/ActiveMQ-thoughts-to14262131s2354.html#a14278412\n\nAs promised I have created a c++ test program (TestProducerBug) that will\ncreate up to X producers. The class that does the work is\n(TestProducers.cpp).\n\nI am created a C# test program (TestConsumerBugCSharp) that will create up\nto X consumers using a MessageListener.  The class that does the work is\n(TestConsumers.cs).\n\nI have created a C++ test program (TestConsumerBug) that will create up to X\nconsumers.  The class that does the work(TestConsumers.cpp).\n\nHere is some information on my setup.\n\nCompiler MS 2005.\n\nActiveMQ\nRunning ActiveMQ 5.0 Dated Dec 7th 2007.  It is running on windows 2003\nServer 64 Bit.\nRunning Java 1.6.0_02 this version of Java is 64 bit. (Problem happens even\non a 32 bit version of JAVA).\n\nActiveMQ Settings\nBroker Settings (persistent=\"false\" advisorySupport=\"false\")\n\nTopic Policy\n<policyEntry topic=\"Test.>\" producerFlowControl=\"true\">\n\n           <!-- lets force old messages to be discarded for slow consumers\n-->\n           <pendingMessageLimitStrategy>\n             <constantPendingMessageLimitStrategy limit=\"5\"/>\n           </pendingMessageLimitStrategy>\n <messageEvictionStrategy> \n <oldestMessageEvictionStrategy /> \n </messageEvictionStrategy> \n\n         </policyEntry>\n\n\nClient API's\n\nCPP activemq-cpp-2.1.2-src\nC# ApacheActiveMQ (Not sure the version but latest trunk).\n\n\nWhen running these test remember to stop and restart the broker each test as\nthe test can and will cause the broker to hang.\n\nTests 1 -3 will show what is happening between the CPP and C# API.\n\nTest 4 will show what happens to a producer when a consumer is in a break\npoint in the MessageListener.\n\nTest 1\nTo recreate the issue build and run \nTestProducerBug\nTestConsumerBugCSharp.\n\nIf you set the number of producers and clients to 10 you should see the\nproblem happen in less then 5 min (About 2,000 messages per consumer).\nThe producer will throw an exception place a breakpoint on the catch block\nin the ThreadProc.  you will see the following information.\nNo valid response received for command: Begin Class = ActiveMQBytesMessage\n\nBegin Class = ActiveMQMessageBase\n\nValue of ackHandler = 00000000\n\nValue of redeliveryCount = 0\n\nValue of properties = Begin Class PrimitiveMap:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n\nValue of Message::ID_MESSAGE = 0\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of Destination is Below:\n\nBegin Class = ActiveMQTopic\n\nBegin Class = ActiveMQDestination\n\nValue of exclusive = false\n\nValue of ordered = false\n\nValue of advisory = false\n\nValue of orderedTarget = coordinator\n\nValue of physicalName = Test.20\n\nValue of options = Begin Class activemq::util::Properties:\n\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ActiveMQDestination\n\nEnd Class = ActiveMQTopic\n\nValue of TransactionId is Below:\n\nObject is NULL\n\nValue of OriginalDestination is Below:\n\nObject is NULL\n\nValue of MessageId is Below:\n\nBegin Class = MessageId\n\nValue of MessageId::ID_MESSAGEID = 110\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of ProducerSequenceId = 19025\n\nValue of BrokerSequenceId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = MessageId\n\nValue of OriginalTransactionId is Below:\n\nObject is NULL\n\nValue of GroupID = \n\nValue of GroupSequence = 0\n\nValue of CorrelationId = \n\nValue of Persistent = 0\n\nValue of Expiration = 1197392556357\n\nValue of Priority = 4\n\nValue of ReplyTo is Below:\n\nObject is NULL\n\nValue of Timestamp = 1197392551357\n\nValue of Type = \n\nValue of Content[0] = \n\nValue of Content[1] = , check broker.\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n146\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n154\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp,\nLINE: 105\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n1371\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n848\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n\n\nTest 2\nNow if you build and run\nTestProducerBug\nTestConsumerBug\n\nThese tests both use the C++ API and works as expected\n\n\nTest 3\nIn the CPP program TestProducerBug you will find a sleep commented out in\nthe ThreadProc uncomment this line.  Build Program.\nBuild TestConsumerCSharp.\n\nYou will find with the 100 ms sleep the application is stable.\n\n\nTest 4\nBuild TestProducerBug remember to comment out the sleep\nBuild TestConsumerCSharp.\n\nPlace a breakpoint on the MessageListner in the C# program.\n\nIn very little time the producer will throw an exception.", "comments": [], "text": "Interoperability issues between C++ and .NET\n\nDescription:\nTaken from http://www.nabble.com/ActiveMQ-thoughts-to14262131s2354.html#a14278412\n\nAs promised I have created a c++ test program (TestProducerBug) that will\ncreate up to X producers. The class that does the work is\n(TestProducers.cpp).\n\nI am created a C# test program (TestConsumerBugCSharp) that will create up\nto X consumers using a MessageListener.  The class that does the work is\n(TestConsumers.cs).\n\nI have created a C++ test program (TestConsumerBug) that will create up to X\nconsumers.  The class that does the work(TestConsumers.cpp).\n\nHere is some information on my setup.\n\nCompiler MS 2005.\n\nActiveMQ\nRunning ActiveMQ 5.0 Dated Dec 7th 2007.  It is running on windows 2003\nServer 64 Bit.\nRunning Java 1.6.0_02 this version of Java is 64 bit. (Problem happens even\non a 32 bit version of JAVA).\n\nActiveMQ Settings\nBroker Settings (persistent=\"false\" advisorySupport=\"false\")\n\nTopic Policy\n<policyEntry topic=\"Test.>\" producerFlowControl=\"true\">\n\n           <!-- lets force old messages to be discarded for slow consumers\n-->\n           <pendingMessageLimitStrategy>\n             <constantPendingMessageLimitStrategy limit=\"5\"/>\n           </pendingMessageLimitStrategy>\n <messageEvictionStrategy> \n <oldestMessageEvictionStrategy /> \n </messageEvictionStrategy> \n\n         </policyEntry>\n\n\nClient API's\n\nCPP activemq-cpp-2.1.2-src\nC# ApacheActiveMQ (Not sure the version but latest trunk).\n\n\nWhen running these test remember to stop and restart the broker each test as\nthe test can and will cause the broker to hang.\n\nTests 1 -3 will show what is happening between the CPP and C# API.\n\nTest 4 will show what happens to a producer when a consumer is in a break\npoint in the MessageListener.\n\nTest 1\nTo recreate the issue build and run \nTestProducerBug\nTestConsumerBugCSharp.\n\nIf you set the number of producers and clients to 10 you should see the\nproblem happen in less then 5 min (About 2,000 messages per consumer).\nThe producer will throw an exception place a breakpoint on the catch block\nin the ThreadProc.  you will see the following information.\nNo valid response received for command: Begin Class = ActiveMQBytesMessage\n\nBegin Class = ActiveMQMessageBase\n\nValue of ackHandler = 00000000\n\nValue of redeliveryCount = 0\n\nValue of properties = Begin Class PrimitiveMap:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n\nValue of Message::ID_MESSAGE = 0\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of Destination is Below:\n\nBegin Class = ActiveMQTopic\n\nBegin Class = ActiveMQDestination\n\nValue of exclusive = false\n\nValue of ordered = false\n\nValue of advisory = false\n\nValue of orderedTarget = coordinator\n\nValue of physicalName = Test.20\n\nValue of options = Begin Class activemq::util::Properties:\n\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ActiveMQDestination\n\nEnd Class = ActiveMQTopic\n\nValue of TransactionId is Below:\n\nObject is NULL\n\nValue of OriginalDestination is Below:\n\nObject is NULL\n\nValue of MessageId is Below:\n\nBegin Class = MessageId\n\nValue of MessageId::ID_MESSAGEID = 110\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of ProducerSequenceId = 19025\n\nValue of BrokerSequenceId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = MessageId\n\nValue of OriginalTransactionId is Below:\n\nObject is NULL\n\nValue of GroupID = \n\nValue of GroupSequence = 0\n\nValue of CorrelationId = \n\nValue of Persistent = 0\n\nValue of Expiration = 1197392556357\n\nValue of Priority = 4\n\nValue of ReplyTo is Below:\n\nObject is NULL\n\nValue of Timestamp = 1197392551357\n\nValue of Type = \n\nValue of Content[0] = \n\nValue of Content[1] = , check broker.\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n146\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n154\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp,\nLINE: 105\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n1371\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n848\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n\n\nTest 2\nNow if you build and run\nTestProducerBug\nTestConsumerBug\n\nThese tests both use the C++ API and works as expected\n\n\nTest 3\nIn the CPP program TestProducerBug you will find a sleep commented out in\nthe ThreadProc uncomment this line.  Build Program.\nBuild TestConsumerCSharp.\n\nYou will find with the 100 ms sleep the application is stable.\n\n\nTest 4\nBuild TestProducerBug remember to comment out the sleep\nBuild TestConsumerCSharp.\n\nPlace a breakpoint on the MessageListner in the C# program.\n\nIn very little time the producer will throw an exception.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Interoperability issues between C++ and .NET\n\nDescription:\nTaken from http://www.nabble.com/ActiveMQ-thoughts-to14262131s2354.html#a14278412\n\nAs promised I have created a c++ test program (TestProducerBug) that will\ncreate up to X producers. The class that does the work is\n(TestProducers.cpp).\n\nI am created a C# test program (TestConsumerBugCSharp) that will create up\nto X consumers using a MessageListener.  The class that does the work is\n(TestConsumers.cs).\n\nI have created a C++ test program (TestConsumerBug) that will create up to X\nconsumers.  The class that does the work(TestConsumers.cpp).\n\nHere is some information on my setup.\n\nCompiler MS 2005.\n\nActiveMQ\nRunning ActiveMQ 5.0 Dated Dec 7th 2007.  It is running on windows 2003\nServer 64 Bit.\nRunning Java 1.6.0_02 this version of Java is 64 bit. (Problem happens even\non a 32 bit version of JAVA).\n\nActiveMQ Settings\nBroker Settings (persistent=\"false\" advisorySupport=\"false\")\n\nTopic Policy\n<policyEntry topic=\"Test.>\" producerFlowControl=\"true\">\n\n           <!-- lets force old messages to be discarded for slow consumers\n-->\n           <pendingMessageLimitStrategy>\n             <constantPendingMessageLimitStrategy limit=\"5\"/>\n           </pendingMessageLimitStrategy>\n <messageEvictionStrategy> \n <oldestMessageEvictionStrategy /> \n </messageEvictionStrategy> \n\n         </policyEntry>\n\n\nClient API's\n\nCPP activemq-cpp-2.1.2-src\nC# ApacheActiveMQ (Not sure the version but latest trunk).\n\n\nWhen running these test remember to stop and restart the broker each test as\nthe test can and will cause the broker to hang.\n\nTests 1 -3 will show what is happening between the CPP and C# API.\n\nTest 4 will show what happens to a producer when a consumer is in a break\npoint in the MessageListener.\n\nTest 1\nTo recreate the issue build and run \nTestProducerBug\nTestConsumerBugCSharp.\n\nIf you set the number of producers and clients to 10 you should see the\nproblem happen in less then 5 min (About 2,000 messages per consumer).\nThe producer will throw an exception place a breakpoint on the catch block\nin the ThreadProc.  you will see the following information.\nNo valid response received for command: Begin Class = ActiveMQBytesMessage\n\nBegin Class = ActiveMQMessageBase\n\nValue of ackHandler = 00000000\n\nValue of redeliveryCount = 0\n\nValue of properties = Begin Class PrimitiveMap:\n\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n\nValue of Message::ID_MESSAGE = 0\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of Destination is Below:\n\nBegin Class = ActiveMQTopic\n\nBegin Class = ActiveMQDestination\n\nValue of exclusive = false\n\nValue of ordered = false\n\nValue of advisory = false\n\nValue of orderedTarget = coordinator\n\nValue of physicalName = Test.20\n\nValue of options = Begin Class activemq::util::Properties:\n\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ActiveMQDestination\n\nEnd Class = ActiveMQTopic\n\nValue of TransactionId is Below:\n\nObject is NULL\n\nValue of OriginalDestination is Below:\n\nObject is NULL\n\nValue of MessageId is Below:\n\nBegin Class = MessageId\n\nValue of MessageId::ID_MESSAGEID = 110\n\nValue of ProducerId is Below:\n\nBegin Class = ProducerId\n\nValue of ProducerId::ID_PRODUCERID = 123\n\nValue of ConnectionId = 752afa01-c256-45c2-84ad-c74b0578f199\n\nValue of Value = 19\n\nValue of SessionId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = ProducerId\n\nValue of ProducerSequenceId = 19025\n\nValue of BrokerSequenceId = 0\n\nNo Data for Class BaseDataStructure\n\nEnd Class = MessageId\n\nValue of OriginalTransactionId is Below:\n\nObject is NULL\n\nValue of GroupID = \n\nValue of GroupSequence = 0\n\nValue of CorrelationId = \n\nValue of Persistent = 0\n\nValue of Expiration = 1197392556357\n\nValue of Priority = 4\n\nValue of ReplyTo is Below:\n\nObject is NULL\n\nValue of Timestamp = 1197392551357\n\nValue of Type = \n\nValue of Content[0] = \n\nValue of Content[1] = , check broker.\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n146\n\nFILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE:\n154\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp,\nLINE: 105\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n1371\n\nFILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE:\n848\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 675\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\nFILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n\n\nTest 2\nNow if you build and run\nTestProducerBug\nTestConsumerBug\n\nThese tests both use the C++ API and works as expected\n\n\nTest 3\nIn the CPP program TestProducerBug you will find a sleep commented out in\nthe ThreadProc uncomment this line.  Build Program.\nBuild TestConsumerCSharp.\n\nYou will find with the 100 ms sleep the application is stable.\n\n\nTest 4\nBuild TestProducerBug remember to comment out the sleep\nBuild TestConsumerCSharp.\n\nPlace a breakpoint on the MessageListner in the C# program.\n\nIn very little time the producer will throw an exception.\n\nComments:\n", "classification": "Classify the issue 'Interoperability issues between C++ and .NET' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-157?\nA: Taken from http://www.nabble.com/ActiveMQ-thoughts-to14262131s2354.html#a14278412\n\nAs promised I have created a c++ test program (TestProducerBug) that will\ncreate up to X producers. The class that does the work is\n(TestProducers.cpp).\n\nI am created a C# test program (TestConsumerBugCSharp) that will create up\nto X consumers using a MessageListener.  The class that does the work is\n(TestConsumers."}}
{"issue_key": "AMQCPP-156", "project": "AMQCPP", "title": "Client excepction when sending messages", "status": "Closed", "reporter": "pfid", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-12-06T08:50:39.000+0000", "updated": "2007-12-07T15:15:20.000+0000", "description": "Using the example code from the website (only modification: use queues, number of messages = 20000, only create producer, no consumer. see attached file), i'll get the following error message:\n\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 9\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 9\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1195642676866\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1370\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 847\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n\ni'm using a 4.1.1 broker (re-downloaded, unedited original config files) and activemq-cpp 2.1.1. \nwhen running the program for the first time, it will successfully write 20.000 messages to the queue \"TEST.FOO\". when starting the program again, the program will stop at message #9291 with the above mentioned exception error. any further tries of running the program will fail, no more messages can be send to this queue. at this point, the broker's ram usage increased from initial 41mb to 71mb. memory leak?\nusing topics instead of queues will work without problems, and the broker's ram usage will barely increase. however this isn't an option, since we need to use queues.", "comments": [], "text": "Client excepction when sending messages\n\nDescription:\nUsing the example code from the website (only modification: use queues, number of messages = 20000, only create producer, no consumer. see attached file), i'll get the following error message:\n\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 9\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 9\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1195642676866\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1370\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 847\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n\ni'm using a 4.1.1 broker (re-downloaded, unedited original config files) and activemq-cpp 2.1.1. \nwhen running the program for the first time, it will successfully write 20.000 messages to the queue \"TEST.FOO\". when starting the program again, the program will stop at message #9291 with the above mentioned exception error. any further tries of running the program will fail, no more messages can be send to this queue. at this point, the broker's ram usage increased from initial 41mb to 71mb. memory leak?\nusing topics instead of queues will work without problems, and the broker's ram usage will barely increase. however this isn't an option, since we need to use queues.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Client excepction when sending messages\n\nDescription:\nUsing the example code from the website (only modification: use queues, number of messages = 20000, only create producer, no consumer. see attached file), i'll get the following error message:\n\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class PrimitiveMap:\nmap[Integer] = 9\nBegin Class PrimitiveMap:\n\nBegin Class = Message\n Value of Message::ID_MESSAGE = 0\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of Destination is Below:\nBegin Class = ActiveMQQueue\nBegin Class = ActiveMQDestination\n Value of exclusive = false\n Value of ordered = false\n Value of advisory = false\n Value of orderedTarget = coordinator\n Value of physicalName = TEST.FOO\n Value of options = Begin Class activemq::util::Properties:\nEnd Class activemq::util::Properties:\n\nNo Data for Class BaseDataStructure\nEnd Class = ActiveMQDestination\nEnd Class = ActiveMQQueue\n\n Value of TransactionId is Below:\n   Object is NULL\n Value of OriginalDestination is Below:\n   Object is NULL\n Value of MessageId is Below:\nBegin Class = MessageId\n Value of MessageId::ID_MESSAGEID = 110\n Value of ProducerId is Below:\nBegin Class = ProducerId\n Value of ProducerId::ID_PRODUCERID = 123\n Value of ConnectionId = e41c6cc2-2542-4577-bde0-7011ffd6ea5f\n Value of Value = 0\n Value of SessionId = 0\nNo Data for Class BaseDataStructure\nEnd Class = ProducerId\n\n Value of ProducerSequenceId = 9\n Value of BrokerSequenceId = 0\nNo Data for Class BaseDataStructure\nEnd Class = MessageId\n\n Value of OriginalTransactionId is Below:\n   Object is NULL\n Value of GroupID =\n Value of GroupSequence = 0\n Value of CorrelationId =\n Value of Persistent = 0\n Value of Expiration = 0\n Value of Priority = 4\n Value of ReplyTo is Below:\n   Object is NULL\n Value of Timestamp = 1195642676866\n Value of Type =\n Value of Content[0] = , check broker.\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 146\n        FILE: activemq/transport/filters/ResponseCorrelator.cpp, LINE: 154\n        FILE: activemq/connector/openwire/OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 1370\n        FILE: activemq/connector/openwire/OpenWireConnector.cpp, LINE: 847\n        FILE: activemq/core/ActiveMQSession.cpp, LINE: 675\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 194\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 149\n        FILE: activemq/core/ActiveMQProducer.cpp, LINE: 108\n\n\ni'm using a 4.1.1 broker (re-downloaded, unedited original config files) and activemq-cpp 2.1.1. \nwhen running the program for the first time, it will successfully write 20.000 messages to the queue \"TEST.FOO\". when starting the program again, the program will stop at message #9291 with the above mentioned exception error. any further tries of running the program will fail, no more messages can be send to this queue. at this point, the broker's ram usage increased from initial 41mb to 71mb. memory leak?\nusing topics instead of queues will work without problems, and the broker's ram usage will barely increase. however this isn't an option, since we need to use queues.\n\nComments:\n", "classification": "Classify the issue 'Client excepction when sending messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-156?\nA: Using the example code from the website (only modification: use queues, number of messages = 20000, only create producer, no consumer. see attached file), i'll get the following error message:\n\nNo valid response received for command: Begin Class = ActiveMQTextMessage\nBegin Class = ActiveMQMessageBase\n Value of ackHandler = 0\n Value of redeliveryCount = 0\n Value of properties = Begin Class Primitiv"}}
{"issue_key": "AMQCPP-155", "project": "AMQCPP", "title": "Problem changing from \"AUTO_ACKNOWLEDGE\" to \"SESSION_TRANSACTED\"", "status": "Closed", "reporter": "John Oldman", "assignee": "Timothy A. Bish", "priority": "Blocker", "labels": [], "created": "2007-11-21T13:51:43.000+0000", "updated": "2008-01-27T15:18:38.000+0000", "description": "Based on the sample code, have set up a simple client/server queue,  \nusing createSession with AUTO_ACKNOWLEDGE.\n\nMessages appear to work as expected.\n\nHowever, I want to eventually end up with a failover setup, with two servers, and therefore need to leave the message in the queue until it has been sucessfully processed by the working server.  \n\nI have tried using createSession with SESSION_TRANSACTED to keep the message in the queue, then calling commit() when the server has completed processing the message, but keep getting core dumps.\n\n Is this approach to using SESSION_TRANSACTED / commit() the correct way to be running CMS?", "comments": [], "text": "Problem changing from \"AUTO_ACKNOWLEDGE\" to \"SESSION_TRANSACTED\"\n\nDescription:\nBased on the sample code, have set up a simple client/server queue,  \nusing createSession with AUTO_ACKNOWLEDGE.\n\nMessages appear to work as expected.\n\nHowever, I want to eventually end up with a failover setup, with two servers, and therefore need to leave the message in the queue until it has been sucessfully processed by the working server.  \n\nI have tried using createSession with SESSION_TRANSACTED to keep the message in the queue, then calling commit() when the server has completed processing the message, but keep getting core dumps.\n\n Is this approach to using SESSION_TRANSACTED / commit() the correct way to be running CMS?\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Problem changing from \"AUTO_ACKNOWLEDGE\" to \"SESSION_TRANSACTED\"\n\nDescription:\nBased on the sample code, have set up a simple client/server queue,  \nusing createSession with AUTO_ACKNOWLEDGE.\n\nMessages appear to work as expected.\n\nHowever, I want to eventually end up with a failover setup, with two servers, and therefore need to leave the message in the queue until it has been sucessfully processed by the working server.  \n\nI have tried using createSession with SESSION_TRANSACTED to keep the message in the queue, then calling commit() when the server has completed processing the message, but keep getting core dumps.\n\n Is this approach to using SESSION_TRANSACTED / commit() the correct way to be running CMS?\n\n\n\nComments:\n", "classification": "Classify the issue 'Problem changing from \"AUTO_ACKNOWLEDGE\" to \"SESSION_TRANSACTED\"' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-155?\nA: Based on the sample code, have set up a simple client/server queue,  \nusing createSession with AUTO_ACKNOWLEDGE.\n\nMessages appear to work as expected.\n\nHowever, I want to eventually end up with a failover setup, with two servers, and therefore need to leave the message in the queue until it has been sucessfully processed by the working server.  \n\nI have tried using createSession with SESSION_TRANS"}}
{"issue_key": "AMQCPP-154", "project": "AMQCPP", "title": "Improve build compatibility (Solaris)", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-11-19T16:31:18.000+0000", "updated": "2007-12-05T23:11:35.000+0000", "description": "Add support for building, running on SPARC Solaris.", "comments": [], "text": "Improve build compatibility (Solaris)\n\nDescription:\nAdd support for building, running on SPARC Solaris.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Improve build compatibility (Solaris)\n\nDescription:\nAdd support for building, running on SPARC Solaris.\n\nComments:\n", "classification": "Classify the issue 'Improve build compatibility (Solaris)' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-154?\nA: Add support for building, running on SPARC Solaris."}}
{"issue_key": "AMQCPP-153", "project": "AMQCPP", "title": "Additional decaf classes to support SSL", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-11-10T15:55:18.000+0000", "updated": "2009-02-28T22:52:37.000+0000", "description": "This issue is a dumping ground for new classes needed by the decaf ssl implementation.   It is expected that this list will grow as the ssl task progresses.   Required classes:\n\nByteBuffer\nBigInteger", "comments": [], "text": "Additional decaf classes to support SSL\n\nDescription:\nThis issue is a dumping ground for new classes needed by the decaf ssl implementation.   It is expected that this list will grow as the ssl task progresses.   Required classes:\n\nByteBuffer\nBigInteger\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Additional decaf classes to support SSL\n\nDescription:\nThis issue is a dumping ground for new classes needed by the decaf ssl implementation.   It is expected that this list will grow as the ssl task progresses.   Required classes:\n\nByteBuffer\nBigInteger\n\n\nComments:\n", "classification": "Classify the issue 'Additional decaf classes to support SSL' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-153?\nA: This issue is a dumping ground for new classes needed by the decaf ssl implementation.   It is expected that this list will grow as the ssl task progresses.   Required classes:\n\nByteBuffer\nBigInteger\n"}}
{"issue_key": "AMQCPP-152", "project": "AMQCPP", "title": "Create a CmsTemplate class", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-11-09T17:56:16.000+0000", "updated": "2008-02-24T22:48:00.000+0000", "description": "Create a CmsTemplate (like Spring's JmsTemplate) that encapsulates the boilerplate CMS code involving creating/destruction of connections, sessions, producers, consumers, etc.\n\nIn particular, this should simplify the destruction sequence of the CMS objects.", "comments": [], "text": "Create a CmsTemplate class\n\nDescription:\nCreate a CmsTemplate (like Spring's JmsTemplate) that encapsulates the boilerplate CMS code involving creating/destruction of connections, sessions, producers, consumers, etc.\n\nIn particular, this should simplify the destruction sequence of the CMS objects.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Create a CmsTemplate class\n\nDescription:\nCreate a CmsTemplate (like Spring's JmsTemplate) that encapsulates the boilerplate CMS code involving creating/destruction of connections, sessions, producers, consumers, etc.\n\nIn particular, this should simplify the destruction sequence of the CMS objects.\n\nComments:\n", "classification": "Classify the issue 'Create a CmsTemplate class' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-152?\nA: Create a CmsTemplate (like Spring's JmsTemplate) that encapsulates the boilerplate CMS code involving creating/destruction of connections, sessions, producers, consumers, etc.\n\nIn particular, this should simplify the destruction sequence of the CMS objects."}}
{"issue_key": "AMQCPP-151", "project": "AMQCPP", "title": "Add a static create method to CMS ConnectionFactory", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-10-29T15:07:57.000+0000", "updated": "2007-10-29T15:21:52.000+0000", "description": "Create a new static method in CMS interface ConnectinFactory called createCMSConnectionFactory.  This method is to be left unimplemented in the CMS API and will be the responsibility of the Provider to implement it.  This allows users to create connection factories without knowing what provider library is linked with the application.\n\nClient then only needs to calls\n\n   ConnectionFactory::createCMSConnectionFactory( uri );", "comments": [], "text": "Add a static create method to CMS ConnectionFactory\n\nDescription:\nCreate a new static method in CMS interface ConnectinFactory called createCMSConnectionFactory.  This method is to be left unimplemented in the CMS API and will be the responsibility of the Provider to implement it.  This allows users to create connection factories without knowing what provider library is linked with the application.\n\nClient then only needs to calls\n\n   ConnectionFactory::createCMSConnectionFactory( uri ); \n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add a static create method to CMS ConnectionFactory\n\nDescription:\nCreate a new static method in CMS interface ConnectinFactory called createCMSConnectionFactory.  This method is to be left unimplemented in the CMS API and will be the responsibility of the Provider to implement it.  This allows users to create connection factories without knowing what provider library is linked with the application.\n\nClient then only needs to calls\n\n   ConnectionFactory::createCMSConnectionFactory( uri ); \n\n\n\nComments:\n", "classification": "Classify the issue 'Add a static create method to CMS ConnectionFactory' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-151?\nA: Create a new static method in CMS interface ConnectinFactory called createCMSConnectionFactory.  This method is to be left unimplemented in the CMS API and will be the responsibility of the Provider to implement it.  This allows users to create connection factories without knowing what provider library is linked with the application.\n\nClient then only needs to calls\n\n   ConnectionFactory::createCM"}}
{"issue_key": "AMQCPP-150", "project": "AMQCPP", "title": "ActiveMQ-CPP consumer client hanging after receiving 32767 messages.", "status": "Resolved", "reporter": "Omar Bashir", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-10-25T12:00:49.000+0000", "updated": "2007-10-27T14:11:02.000+0000", "description": "I was stress-testing an ActiveMQ-CPP consumer client by transmitting to it a large burst of messages (100 per second). I realised that the client hangs after receiving 32767 messages and the broker has a log message \n\nINFO PrefetchSubscription - Could not correlate acknowledgment with dispatched message: MessageAck ... \n\nI changed the size of the message from 40 bytes to over 600 bytes but it still behaved the same way. Behaviour remained the same when I reduced message frequency to one per second. I am using ActiveMQ-CPP-2.1 and ActiveMQ broker 4.1.1. \n\nI replaced the C++ consumer with the Java consumer and the problem disappeared. Then I ran both the Java and C++ consumers concurrently both listening to the same queue, the C++ client froze after 16 messages whereas the Java client continued to receive and process messages.\n\nNow, I have the C++ producer client that disconnects after sending 32000 messages, reconnects and then starts transmitting again. The problem disappears with this configuration. Both Java and C++ clients have now received in excess of 230k messages and are still running perfectly well.", "comments": [], "text": "ActiveMQ-CPP consumer client hanging after receiving 32767 messages.\n\nDescription:\nI was stress-testing an ActiveMQ-CPP consumer client by transmitting to it a large burst of messages (100 per second). I realised that the client hangs after receiving 32767 messages and the broker has a log message \n\nINFO PrefetchSubscription - Could not correlate acknowledgment with dispatched message: MessageAck ... \n\nI changed the size of the message from 40 bytes to over 600 bytes but it still behaved the same way. Behaviour remained the same when I reduced message frequency to one per second. I am using ActiveMQ-CPP-2.1 and ActiveMQ broker 4.1.1. \n\nI replaced the C++ consumer with the Java consumer and the problem disappeared. Then I ran both the Java and C++ consumers concurrently both listening to the same queue, the C++ client froze after 16 messages whereas the Java client continued to receive and process messages.\n\nNow, I have the C++ producer client that disconnects after sending 32000 messages, reconnects and then starts transmitting again. The problem disappears with this configuration. Both Java and C++ clients have now received in excess of 230k messages and are still running perfectly well.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQ-CPP consumer client hanging after receiving 32767 messages.\n\nDescription:\nI was stress-testing an ActiveMQ-CPP consumer client by transmitting to it a large burst of messages (100 per second). I realised that the client hangs after receiving 32767 messages and the broker has a log message \n\nINFO PrefetchSubscription - Could not correlate acknowledgment with dispatched message: MessageAck ... \n\nI changed the size of the message from 40 bytes to over 600 bytes but it still behaved the same way. Behaviour remained the same when I reduced message frequency to one per second. I am using ActiveMQ-CPP-2.1 and ActiveMQ broker 4.1.1. \n\nI replaced the C++ consumer with the Java consumer and the problem disappeared. Then I ran both the Java and C++ consumers concurrently both listening to the same queue, the C++ client froze after 16 messages whereas the Java client continued to receive and process messages.\n\nNow, I have the C++ producer client that disconnects after sending 32000 messages, reconnects and then starts transmitting again. The problem disappears with this configuration. Both Java and C++ clients have now received in excess of 230k messages and are still running perfectly well.\n\n\nComments:\n", "classification": "Classify the issue 'ActiveMQ-CPP consumer client hanging after receiving 32767 messages.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-150?\nA: I was stress-testing an ActiveMQ-CPP consumer client by transmitting to it a large burst of messages (100 per second). I realised that the client hangs after receiving 32767 messages and the broker has a log message \n\nINFO PrefetchSubscription - Could not correlate acknowledgment with dispatched message: MessageAck ... \n\nI changed the size of the message from 40 bytes to over 600 bytes but it stil"}}
{"issue_key": "AMQCPP-149", "project": "AMQCPP", "title": "Client crash when receiving message with empty string property from java", "status": "Resolved", "reporter": "Marco Renz", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-10-19T12:39:34.000+0000", "updated": "2007-10-24T18:46:39.000+0000", "description": "Send message from a java client with a string property whereas the value is the empty string.\nTry to receive this message with a C++ client.\nResult: C++ client crashs.\n\nReason:\n\nIn OpenwireStringSupport::readString a std::vector is initialized to the string length which is 0. Then DataInputStream::readFully is called with the vector as argument. But this method tries to get the element at index 0 of the vector without any check. But there is no element in the vector at all...\n\nProposed solution:\n\nDataInputStream::readFully  should check the size of the vector before accessing elements.\n\nFurther info:\n\nIf the message is send from C++ client then there is no problem. Maybe /0 is used so that the vector has at least a size of 1.\nI got that probelm with 2.0.1. I did not tried 2.1 but checked the code.", "comments": [], "text": "Client crash when receiving message with empty string property from java\n\nDescription:\nSend message from a java client with a string property whereas the value is the empty string.\nTry to receive this message with a C++ client.\nResult: C++ client crashs.\n\nReason:\n\nIn OpenwireStringSupport::readString a std::vector is initialized to the string length which is 0. Then DataInputStream::readFully is called with the vector as argument. But this method tries to get the element at index 0 of the vector without any check. But there is no element in the vector at all...\n\nProposed solution:\n\nDataInputStream::readFully  should check the size of the vector before accessing elements.\n\nFurther info:\n\nIf the message is send from C++ client then there is no problem. Maybe /0 is used so that the vector has at least a size of 1.\nI got that probelm with 2.0.1. I did not tried 2.1 but checked the code.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Client crash when receiving message with empty string property from java\n\nDescription:\nSend message from a java client with a string property whereas the value is the empty string.\nTry to receive this message with a C++ client.\nResult: C++ client crashs.\n\nReason:\n\nIn OpenwireStringSupport::readString a std::vector is initialized to the string length which is 0. Then DataInputStream::readFully is called with the vector as argument. But this method tries to get the element at index 0 of the vector without any check. But there is no element in the vector at all...\n\nProposed solution:\n\nDataInputStream::readFully  should check the size of the vector before accessing elements.\n\nFurther info:\n\nIf the message is send from C++ client then there is no problem. Maybe /0 is used so that the vector has at least a size of 1.\nI got that probelm with 2.0.1. I did not tried 2.1 but checked the code.\n\nComments:\n", "classification": "Classify the issue 'Client crash when receiving message with empty string property from java' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-149?\nA: Send message from a java client with a string property whereas the value is the empty string.\nTry to receive this message with a C++ client.\nResult: C++ client crashs.\n\nReason:\n\nIn OpenwireStringSupport::readString a std::vector is initialized to the string length which is 0. Then DataInputStream::readFully is called with the vector as argument. But this method tries to get the element at index 0 "}}
{"issue_key": "AMQCPP-148", "project": "AMQCPP", "title": "Add support for embedding environment variables in connection URI", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-10-17T13:25:19.000+0000", "updated": "2008-01-26T21:30:27.000+0000", "description": "Add support for embedding environment variables in the connection URI to allow things like this:\n\ncreateConnection(\"tcp://127.0.0.1:61616?wireFormat=${wireFormat}\");\n\nSuggest using the standard bash form for variables \"${...}\"", "comments": [], "text": "Add support for embedding environment variables in connection URI\n\nDescription:\nAdd support for embedding environment variables in the connection URI to allow things like this:\n\ncreateConnection(\"tcp://127.0.0.1:61616?wireFormat=${wireFormat}\");\n\nSuggest using the standard bash form for variables \"${...}\"\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add support for embedding environment variables in connection URI\n\nDescription:\nAdd support for embedding environment variables in the connection URI to allow things like this:\n\ncreateConnection(\"tcp://127.0.0.1:61616?wireFormat=${wireFormat}\");\n\nSuggest using the standard bash form for variables \"${...}\"\n\n\nComments:\n", "classification": "Classify the issue 'Add support for embedding environment variables in connection URI' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-148?\nA: Add support for embedding environment variables in the connection URI to allow things like this:\n\ncreateConnection(\"tcp://127.0.0.1:61616?wireFormat=${wireFormat}\");\n\nSuggest using the standard bash form for variables \"${...}\"\n"}}
{"issue_key": "AMQCPP-147", "project": "AMQCPP", "title": "Add Optimized Acknowledge support to the CPP client", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-10-15T14:37:07.000+0000", "updated": "2010-02-08T15:44:52.000+0000", "description": "Add an optimized message ack feature to allow the client to ack messages in batches when possible to reduce overhead.", "comments": [], "text": "Add Optimized Acknowledge support to the CPP client\n\nDescription:\nAdd an optimized message ack feature to allow the client to ack messages in batches when possible to reduce overhead.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add Optimized Acknowledge support to the CPP client\n\nDescription:\nAdd an optimized message ack feature to allow the client to ack messages in batches when possible to reduce overhead.\n\nComments:\n", "classification": "Classify the issue 'Add Optimized Acknowledge support to the CPP client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-147?\nA: Add an optimized message ack feature to allow the client to ack messages in batches when possible to reduce overhead."}}
{"issue_key": "AMQCPP-146", "project": "AMQCPP", "title": "Refactor sequence id generation in the connectors", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-10-15T13:05:59.000+0000", "updated": "2007-10-15T13:07:53.000+0000", "description": "Instead of having a methods in the connectors to create ids, create a class in activemq util called LongSequenceGenerator that will be used in the connectors to create the Ids.  This class will be thread safe.\n\nRefactor the connector code to use this generator class and remove all the getNextXXXId methods.", "comments": [], "text": "Refactor sequence id generation in the connectors\n\nDescription:\nInstead of having a methods in the connectors to create ids, create a class in activemq util called LongSequenceGenerator that will be used in the connectors to create the Ids.  This class will be thread safe.\n\nRefactor the connector code to use this generator class and remove all the getNextXXXId methods.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Refactor sequence id generation in the connectors\n\nDescription:\nInstead of having a methods in the connectors to create ids, create a class in activemq util called LongSequenceGenerator that will be used in the connectors to create the Ids.  This class will be thread safe.\n\nRefactor the connector code to use this generator class and remove all the getNextXXXId methods.\n\n\nComments:\n", "classification": "Classify the issue 'Refactor sequence id generation in the connectors' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-146?\nA: Instead of having a methods in the connectors to create ids, create a class in activemq util called LongSequenceGenerator that will be used in the connectors to create the Ids.  This class will be thread safe.\n\nRefactor the connector code to use this generator class and remove all the getNextXXXId methods.\n"}}
{"issue_key": "AMQCPP-145", "project": "AMQCPP", "title": "Compiler error concerning TRANSACTION_ROLLBACK", "status": "Resolved", "reporter": "Eddie Fast", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-10-13T00:26:02.000+0000", "updated": "2007-10-13T13:20:43.000+0000", "description": "With the latest activemq-cpp, using Visual Studio 2005 SP1, plus the latest Microsoft SDK, there's a compiler error with TRANSACTION_ROLLBACK, in OpenWireConnector.h.\n\nWinNT.h has a #define for TRANSACTION_ROLLBACK which causes the compiler error.\n\nSince the enum is private, I was able to rename it in OpenWireConnector.h without a problem.\n\nPlatform SDK - http://www.microsoft.com/downloads/details.aspx?FamilyID=C2B1E300-F358-4523-B479-F53D234CDCCF&displaylang=en\nMSDN doc on TRANSACTION_ROLLBACK - http://msdn2.microsoft.com/en-us/library/aa366384.aspx", "comments": [], "text": "Compiler error concerning TRANSACTION_ROLLBACK\n\nDescription:\nWith the latest activemq-cpp, using Visual Studio 2005 SP1, plus the latest Microsoft SDK, there's a compiler error with TRANSACTION_ROLLBACK, in OpenWireConnector.h.\n\nWinNT.h has a #define for TRANSACTION_ROLLBACK which causes the compiler error.\n\nSince the enum is private, I was able to rename it in OpenWireConnector.h without a problem.\n\nPlatform SDK - http://www.microsoft.com/downloads/details.aspx?FamilyID=C2B1E300-F358-4523-B479-F53D234CDCCF&displaylang=en\nMSDN doc on TRANSACTION_ROLLBACK - http://msdn2.microsoft.com/en-us/library/aa366384.aspx\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compiler error concerning TRANSACTION_ROLLBACK\n\nDescription:\nWith the latest activemq-cpp, using Visual Studio 2005 SP1, plus the latest Microsoft SDK, there's a compiler error with TRANSACTION_ROLLBACK, in OpenWireConnector.h.\n\nWinNT.h has a #define for TRANSACTION_ROLLBACK which causes the compiler error.\n\nSince the enum is private, I was able to rename it in OpenWireConnector.h without a problem.\n\nPlatform SDK - http://www.microsoft.com/downloads/details.aspx?FamilyID=C2B1E300-F358-4523-B479-F53D234CDCCF&displaylang=en\nMSDN doc on TRANSACTION_ROLLBACK - http://msdn2.microsoft.com/en-us/library/aa366384.aspx\n\n\nComments:\n", "classification": "Classify the issue 'Compiler error concerning TRANSACTION_ROLLBACK' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-145?\nA: With the latest activemq-cpp, using Visual Studio 2005 SP1, plus the latest Microsoft SDK, there's a compiler error with TRANSACTION_ROLLBACK, in OpenWireConnector.h.\n\nWinNT.h has a #define for TRANSACTION_ROLLBACK which causes the compiler error.\n\nSince the enum is private, I was able to rename it in OpenWireConnector.h without a problem.\n\nPlatform SDK - http://www.microsoft.com/downloads/details"}}
{"issue_key": "AMQCPP-144", "project": "AMQCPP", "title": "Decaf library build fails on OS X", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-10-05T15:59:57.000+0000", "updated": "2007-10-05T16:49:54.000+0000", "description": "Get the following error on OS X:\n\ndecaf/lang/System.cpp: In static member function 'static decaf::util::Map<std::string, std::string> decaf::lang::System::getenv()':\ndecaf/lang/System.cpp:153: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:162: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp: In static member function 'static char** decaf::lang::System::getEnvArray()':\ndecaf/lang/System.cpp:225: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:233: error: 'environ' was not declared in this scope\n\nIt appears that the environ gobal needs to be declared as an extern at the top of the file.", "comments": [], "text": "Decaf library build fails on OS X\n\nDescription:\nGet the following error on OS X:\n\ndecaf/lang/System.cpp: In static member function 'static decaf::util::Map<std::string, std::string> decaf::lang::System::getenv()':\ndecaf/lang/System.cpp:153: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:162: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp: In static member function 'static char** decaf::lang::System::getEnvArray()':\ndecaf/lang/System.cpp:225: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:233: error: 'environ' was not declared in this scope\n\nIt appears that the environ gobal needs to be declared as an extern at the top of the file.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Decaf library build fails on OS X\n\nDescription:\nGet the following error on OS X:\n\ndecaf/lang/System.cpp: In static member function 'static decaf::util::Map<std::string, std::string> decaf::lang::System::getenv()':\ndecaf/lang/System.cpp:153: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:162: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp: In static member function 'static char** decaf::lang::System::getEnvArray()':\ndecaf/lang/System.cpp:225: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:233: error: 'environ' was not declared in this scope\n\nIt appears that the environ gobal needs to be declared as an extern at the top of the file.\n\nComments:\n", "classification": "Classify the issue 'Decaf library build fails on OS X' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-144?\nA: Get the following error on OS X:\n\ndecaf/lang/System.cpp: In static member function 'static decaf::util::Map<std::string, std::string> decaf::lang::System::getenv()':\ndecaf/lang/System.cpp:153: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp:162: error: 'environ' was not declared in this scope\ndecaf/lang/System.cpp: In static member function 'static char** decaf::lang::System:"}}
{"issue_key": "AMQCPP-143", "project": "AMQCPP", "title": "declara BytesMessage::readXXX() methods as 'const' ", "status": "Resolved", "reporter": "Matvey Aizenshtat", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-09-21T11:39:54.000+0000", "updated": "2007-10-05T17:12:17.000+0000", "description": "BytesMessage readXXX() methods (readBytes() etc) aren't 'const' since the internal stream state is changed.\n\nBut if only the stream pointer is updated, I suppose we could have another solution here, i.e.\ndeclare inputStream field as 'mutable':\n\nmutable io::ByteArrayInputStream inputStream;\n\nIn that case we could keep read methods const.\n\nI am requesting for that because at the moment such non-const API forces app level either always deal with non-const objects or make const_cast<cms::BytesMessage *>(), that's not good.\n\nSee also:\n\nhttp://www.nabble.com/BytesMessage-methods-tf3833767s2354.html#a10853672", "comments": [], "text": "declara BytesMessage::readXXX() methods as 'const' \n\nDescription:\nBytesMessage readXXX() methods (readBytes() etc) aren't 'const' since the internal stream state is changed.\n\nBut if only the stream pointer is updated, I suppose we could have another solution here, i.e.\ndeclare inputStream field as 'mutable':\n\nmutable io::ByteArrayInputStream inputStream;\n\nIn that case we could keep read methods const.\n\nI am requesting for that because at the moment such non-const API forces app level either always deal with non-const objects or make const_cast<cms::BytesMessage *>(), that's not good.\n\nSee also:\n\nhttp://www.nabble.com/BytesMessage-methods-tf3833767s2354.html#a10853672\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: declara BytesMessage::readXXX() methods as 'const' \n\nDescription:\nBytesMessage readXXX() methods (readBytes() etc) aren't 'const' since the internal stream state is changed.\n\nBut if only the stream pointer is updated, I suppose we could have another solution here, i.e.\ndeclare inputStream field as 'mutable':\n\nmutable io::ByteArrayInputStream inputStream;\n\nIn that case we could keep read methods const.\n\nI am requesting for that because at the moment such non-const API forces app level either always deal with non-const objects or make const_cast<cms::BytesMessage *>(), that's not good.\n\nSee also:\n\nhttp://www.nabble.com/BytesMessage-methods-tf3833767s2354.html#a10853672\n\n\nComments:\n", "classification": "Classify the issue 'declara BytesMessage::readXXX() methods as 'const' ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-143?\nA: BytesMessage readXXX() methods (readBytes() etc) aren't 'const' since the internal stream state is changed.\n\nBut if only the stream pointer is updated, I suppose we could have another solution here, i.e.\ndeclare inputStream field as 'mutable':\n\nmutable io::ByteArrayInputStream inputStream;\n\nIn that case we could keep read methods const.\n\nI am requesting for that because at the moment such non-cons"}}
{"issue_key": "AMQCPP-142", "project": "AMQCPP", "title": "BufferedOutputStream flush called after BufferedOutputStream close resulting in unhandled exceptions", "status": "Resolved", "reporter": "Roger", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-09-06T09:12:13.000+0000", "updated": "2007-10-17T17:49:09.000+0000", "description": "After comms have been broken (shutting down the broker is an easy way to reproduce...) and the producer attempts to send a message a Transport IO exception is raised but after this point the session cannot be cleanly closed. The sessions closed flag indicates it is not already closed. The problem seems to be mainly in the BufferedOutputStream - this objects \"close\" method is called but after this the same objects \"flush\" method is called resulting in exceptions (attempts to access deleted memory). I'm presuming it is attempting to send cached data after the stream has been closed.\n\nThis is ActiveMQ-CPP 2.1, using Broker version 5.0:-\nhttp://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/apache-activemq/5.0-SNAPSHOT/apache-activemq-5.0-20070904.133257-1.zip\n\nThe following is an example snippet of code which demonstrates this problem:\n\nstatic Connection* connection = NULL;\nstatic Session* session = NULL;\nstatic Destination* destination = NULL;\nstatic MessageProducer* producer = NULL;\n\nstatic const std::string brokerURI = \"tcp://127.0.0.1:61616?wireFormat=openwire&transport.useAsyncSend=true&connectionTimeout=5000&soTimeout=1000\";\n\nbool initialise()\n{\n        bool result = false;\n\n        try {\n                ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( brokerURI );\n\n                // Create a Connection\n                connection = connectionFactory->createConnection();\n                connection->start();\n\n                delete connectionFactory;\n\n                // Create a Session\n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE );\n\n                // Create the destination\n                destination = session->createQueue( \"BARNEY\" );\n\n                // Create a MessageProducer from the Session to the Queue\n                producer = session->createProducer( destination );\n                producer->setDeliveryMode( DeliveryMode::NON_PERSISTENT);\n\n                result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) {\n                e.printStackTrace();\n        }\n\n        return result;\n}\n\n\nbool sendMessage(string msg)\n{\n        bool result = false;\n\n    try {\n            TextMessage* message = session->createTextMessage( msg );\n\n             producer->send( message );\n             delete message;\n               \n             result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) { // <------<<<< catches the exception after the broker has been shutdown (transport is closed)\n                // Close open resources.\n                try{\n                        if( session != NULL ){\n                                session->close();  // <--------<<<< Causes unhandled exceptions\n                        }\n            // close connection...\n                        // free everything else...\n                }\n        }\n\n        return result;\n}\n\nvoid main()\n{\n        if (initialise()){\n                while (1){\n                        // do things to create the data to send...\n\n                        // send data\n                        sendMessage(\"fred\");\n\n                         // sleep for a bit....\n\n                         // <<<< KILL THE BROKER SOMETIME DURING THIS LOOP >>>>\n                }\n\n                // clean up .....\n        }\n}", "comments": [], "text": "BufferedOutputStream flush called after BufferedOutputStream close resulting in unhandled exceptions\n\nDescription:\nAfter comms have been broken (shutting down the broker is an easy way to reproduce...) and the producer attempts to send a message a Transport IO exception is raised but after this point the session cannot be cleanly closed. The sessions closed flag indicates it is not already closed. The problem seems to be mainly in the BufferedOutputStream - this objects \"close\" method is called but after this the same objects \"flush\" method is called resulting in exceptions (attempts to access deleted memory). I'm presuming it is attempting to send cached data after the stream has been closed.\n\nThis is ActiveMQ-CPP 2.1, using Broker version 5.0:-\nhttp://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/apache-activemq/5.0-SNAPSHOT/apache-activemq-5.0-20070904.133257-1.zip\n\nThe following is an example snippet of code which demonstrates this problem:\n\nstatic Connection* connection = NULL;\nstatic Session* session = NULL;\nstatic Destination* destination = NULL;\nstatic MessageProducer* producer = NULL;\n\nstatic const std::string brokerURI = \"tcp://127.0.0.1:61616?wireFormat=openwire&transport.useAsyncSend=true&connectionTimeout=5000&soTimeout=1000\";\n\nbool initialise()\n{\n        bool result = false;\n\n        try {\n                ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( brokerURI );\n\n                // Create a Connection\n                connection = connectionFactory->createConnection();\n                connection->start();\n\n                delete connectionFactory;\n\n                // Create a Session\n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE );\n\n                // Create the destination\n                destination = session->createQueue( \"BARNEY\" );\n\n                // Create a MessageProducer from the Session to the Queue\n                producer = session->createProducer( destination );\n                producer->setDeliveryMode( DeliveryMode::NON_PERSISTENT);\n\n                result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) {\n                e.printStackTrace();\n        }\n\n        return result;\n}\n\n\nbool sendMessage(string msg)\n{\n        bool result = false;\n\n    try {\n            TextMessage* message = session->createTextMessage( msg );\n\n             producer->send( message );\n             delete message;\n               \n             result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) { // <------<<<< catches the exception after the broker has been shutdown (transport is closed)\n                // Close open resources.\n                try{\n                        if( session != NULL ){\n                                session->close();  // <--------<<<< Causes unhandled exceptions\n                        }\n            // close connection...\n                        // free everything else...\n                }\n        }\n\n        return result;\n}\n\nvoid main()\n{\n        if (initialise()){\n                while (1){\n                        // do things to create the data to send...\n\n                        // send data\n                        sendMessage(\"fred\");\n\n                         // sleep for a bit....\n\n                         // <<<< KILL THE BROKER SOMETIME DURING THIS LOOP >>>>\n                }\n\n                // clean up .....\n        }\n} \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: BufferedOutputStream flush called after BufferedOutputStream close resulting in unhandled exceptions\n\nDescription:\nAfter comms have been broken (shutting down the broker is an easy way to reproduce...) and the producer attempts to send a message a Transport IO exception is raised but after this point the session cannot be cleanly closed. The sessions closed flag indicates it is not already closed. The problem seems to be mainly in the BufferedOutputStream - this objects \"close\" method is called but after this the same objects \"flush\" method is called resulting in exceptions (attempts to access deleted memory). I'm presuming it is attempting to send cached data after the stream has been closed.\n\nThis is ActiveMQ-CPP 2.1, using Broker version 5.0:-\nhttp://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/apache-activemq/5.0-SNAPSHOT/apache-activemq-5.0-20070904.133257-1.zip\n\nThe following is an example snippet of code which demonstrates this problem:\n\nstatic Connection* connection = NULL;\nstatic Session* session = NULL;\nstatic Destination* destination = NULL;\nstatic MessageProducer* producer = NULL;\n\nstatic const std::string brokerURI = \"tcp://127.0.0.1:61616?wireFormat=openwire&transport.useAsyncSend=true&connectionTimeout=5000&soTimeout=1000\";\n\nbool initialise()\n{\n        bool result = false;\n\n        try {\n                ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( brokerURI );\n\n                // Create a Connection\n                connection = connectionFactory->createConnection();\n                connection->start();\n\n                delete connectionFactory;\n\n                // Create a Session\n                session = connection->createSession( Session::AUTO_ACKNOWLEDGE );\n\n                // Create the destination\n                destination = session->createQueue( \"BARNEY\" );\n\n                // Create a MessageProducer from the Session to the Queue\n                producer = session->createProducer( destination );\n                producer->setDeliveryMode( DeliveryMode::NON_PERSISTENT);\n\n                result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) {\n                e.printStackTrace();\n        }\n\n        return result;\n}\n\n\nbool sendMessage(string msg)\n{\n        bool result = false;\n\n    try {\n            TextMessage* message = session->createTextMessage( msg );\n\n             producer->send( message );\n             delete message;\n               \n             result = true;\n        }\n        catch (activemq::exceptions::ActiveMQException& e) { // <------<<<< catches the exception after the broker has been shutdown (transport is closed)\n                // Close open resources.\n                try{\n                        if( session != NULL ){\n                                session->close();  // <--------<<<< Causes unhandled exceptions\n                        }\n            // close connection...\n                        // free everything else...\n                }\n        }\n\n        return result;\n}\n\nvoid main()\n{\n        if (initialise()){\n                while (1){\n                        // do things to create the data to send...\n\n                        // send data\n                        sendMessage(\"fred\");\n\n                         // sleep for a bit....\n\n                         // <<<< KILL THE BROKER SOMETIME DURING THIS LOOP >>>>\n                }\n\n                // clean up .....\n        }\n} \n\nComments:\n", "classification": "Classify the issue 'BufferedOutputStream flush called after BufferedOutputStream close resulting in unhandled exceptions' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-142?\nA: After comms have been broken (shutting down the broker is an easy way to reproduce...) and the producer attempts to send a message a Transport IO exception is raised but after this point the session cannot be cleanly closed. The sessions closed flag indicates it is not already closed. The problem seems to be mainly in the BufferedOutputStream - this objects \"close\" method is called but after this "}}
{"issue_key": "AMQCPP-141", "project": "AMQCPP", "title": "ActiveMQTextMessage::getText() causes an index out of bounds assertion failure if trying to read a 0 length text message", "status": "Resolved", "reporter": "Rick Hobbs", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-08-22T14:22:19.000+0000", "updated": "2007-09-30T10:23:43.000+0000", "description": "If a client (in this case a java client) sends a TextMessage with an empty string, a C++ based client will fail when calling getText() on the message.\n\nThe reason for this being that a test is done against the length of the content of the underlying message as follows:\n\n if( getContent().size() < 4 ) (line 49 of main/activemq/connector/openwire/commands/ActiveMQTextMessage.cpp).\n\nIf this test fails it is assumed that the string is 0 length. However, as the length of the string is written as an 4 byte int at the begining of the content stream this test never fails. This then causes an exception on line:\n\nreturn std::string( (const char*)&getContent()[4], getContent().size()-4 );\n\nAs the \"getContent()[4]\" will cause an index out of bounds assertion if the string is 0 length.\n\nThe suggested fix would be to change the test on line 49 to:\n\n if( getContent().size() <= 4 ) \n\nA diff file is included.", "comments": [], "text": "ActiveMQTextMessage::getText() causes an index out of bounds assertion failure if trying to read a 0 length text message\n\nDescription:\nIf a client (in this case a java client) sends a TextMessage with an empty string, a C++ based client will fail when calling getText() on the message.\n\nThe reason for this being that a test is done against the length of the content of the underlying message as follows:\n\n if( getContent().size() < 4 ) (line 49 of main/activemq/connector/openwire/commands/ActiveMQTextMessage.cpp).\n\nIf this test fails it is assumed that the string is 0 length. However, as the length of the string is written as an 4 byte int at the begining of the content stream this test never fails. This then causes an exception on line:\n\nreturn std::string( (const char*)&getContent()[4], getContent().size()-4 );\n\nAs the \"getContent()[4]\" will cause an index out of bounds assertion if the string is 0 length.\n\nThe suggested fix would be to change the test on line 49 to:\n\n if( getContent().size() <= 4 ) \n\nA diff file is included.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQTextMessage::getText() causes an index out of bounds assertion failure if trying to read a 0 length text message\n\nDescription:\nIf a client (in this case a java client) sends a TextMessage with an empty string, a C++ based client will fail when calling getText() on the message.\n\nThe reason for this being that a test is done against the length of the content of the underlying message as follows:\n\n if( getContent().size() < 4 ) (line 49 of main/activemq/connector/openwire/commands/ActiveMQTextMessage.cpp).\n\nIf this test fails it is assumed that the string is 0 length. However, as the length of the string is written as an 4 byte int at the begining of the content stream this test never fails. This then causes an exception on line:\n\nreturn std::string( (const char*)&getContent()[4], getContent().size()-4 );\n\nAs the \"getContent()[4]\" will cause an index out of bounds assertion if the string is 0 length.\n\nThe suggested fix would be to change the test on line 49 to:\n\n if( getContent().size() <= 4 ) \n\nA diff file is included.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQTextMessage::getText() causes an index out of bounds assertion failure if trying to read a 0 length text message' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-141?\nA: If a client (in this case a java client) sends a TextMessage with an empty string, a C++ based client will fail when calling getText() on the message.\n\nThe reason for this being that a test is done against the length of the content of the underlying message as follows:\n\n if( getContent().size() < 4 ) (line 49 of main/activemq/connector/openwire/commands/ActiveMQTextMessage.cpp).\n\nIf this test fail"}}
{"issue_key": "AMQCPP-140", "project": "AMQCPP", "title": "Add SSL transport", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-08-04T17:55:41.000+0000", "updated": "2010-05-26T18:09:13.000+0000", "description": "Need a secure transport for activemq-cpp.  Some options for ssl support:\n\n1) OpenSSL - fairly robust set of ssl functions\n2) APR - trunk has added support for ssl sockets.  An attractive option, given that we're already starting to incorporate API in other areas.\n\nShould create a Java-like set of classes in decaf to add basic ssl support, then use those classes to make an SSLTransport in activemq-cpp.", "comments": [], "text": "Add SSL transport\n\nDescription:\nNeed a secure transport for activemq-cpp.  Some options for ssl support:\n\n1) OpenSSL - fairly robust set of ssl functions\n2) APR - trunk has added support for ssl sockets.  An attractive option, given that we're already starting to incorporate API in other areas.\n\nShould create a Java-like set of classes in decaf to add basic ssl support, then use those classes to make an SSLTransport in activemq-cpp.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Add SSL transport\n\nDescription:\nNeed a secure transport for activemq-cpp.  Some options for ssl support:\n\n1) OpenSSL - fairly robust set of ssl functions\n2) APR - trunk has added support for ssl sockets.  An attractive option, given that we're already starting to incorporate API in other areas.\n\nShould create a Java-like set of classes in decaf to add basic ssl support, then use those classes to make an SSLTransport in activemq-cpp.\n\nComments:\n", "classification": "Classify the issue 'Add SSL transport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-140?\nA: Need a secure transport for activemq-cpp.  Some options for ssl support:\n\n1) OpenSSL - fairly robust set of ssl functions\n2) APR - trunk has added support for ssl sockets.  An attractive option, given that we're already starting to incorporate API in other areas.\n\nShould create a Java-like set of classes in decaf to add basic ssl support, then use those classes to make an SSLTransport in activemq-"}}
{"issue_key": "AMQCPP-139", "project": "AMQCPP", "title": "Improvements for the Openwire Commands Generated Code", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-07-24T15:13:33.000+0000", "updated": "2007-10-24T23:22:14.000+0000", "description": "We need to make some improvements to the code that is generated for Openwire and the Scripts that generate them\n\n* Support Openwire V3 Commands ( Also V1 ? ) This requires some architecture changes in the Lib code as well.\n* Change clone methods to use covariant return types, to reduce to amount of dynamic casting in the connector.\n* Generate Unit tests for the Commands and Marshalers.", "comments": [], "text": "Improvements for the Openwire Commands Generated Code\n\nDescription:\nWe need to make some improvements to the code that is generated for Openwire and the Scripts that generate them\n\n* Support Openwire V3 Commands ( Also V1 ? ) This requires some architecture changes in the Lib code as well.\n* Change clone methods to use covariant return types, to reduce to amount of dynamic casting in the connector.\n* Generate Unit tests for the Commands and Marshalers.\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Improvements for the Openwire Commands Generated Code\n\nDescription:\nWe need to make some improvements to the code that is generated for Openwire and the Scripts that generate them\n\n* Support Openwire V3 Commands ( Also V1 ? ) This requires some architecture changes in the Lib code as well.\n* Change clone methods to use covariant return types, to reduce to amount of dynamic casting in the connector.\n* Generate Unit tests for the Commands and Marshalers.\n\n\nComments:\n", "classification": "Classify the issue 'Improvements for the Openwire Commands Generated Code' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-139?\nA: We need to make some improvements to the code that is generated for Openwire and the Scripts that generate them\n\n* Support Openwire V3 Commands ( Also V1 ? ) This requires some architecture changes in the Lib code as well.\n* Change clone methods to use covariant return types, to reduce to amount of dynamic casting in the connector.\n* Generate Unit tests for the Commands and Marshalers.\n"}}
{"issue_key": "AMQCPP-138", "project": "AMQCPP", "title": "Streams classes do not honor their Interface Contracts", "status": "Closed", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-07-24T15:09:34.000+0000", "updated": "2007-08-06T18:47:05.000+0000", "description": "There are several classes in the IO package that do not honor the contract of the InputStream interface.  ByteArrayInputstream among others doesn't properly throw an exception or return -1 based on the requirements of the Interface.\n\nWe should inspect the IO classes to ensure that they all properly follow the contract of the IO Stream interface.", "comments": [], "text": "Streams classes do not honor their Interface Contracts\n\nDescription:\nThere are several classes in the IO package that do not honor the contract of the InputStream interface.  ByteArrayInputstream among others doesn't properly throw an exception or return -1 based on the requirements of the Interface.\n\nWe should inspect the IO classes to ensure that they all properly follow the contract of the IO Stream interface.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Streams classes do not honor their Interface Contracts\n\nDescription:\nThere are several classes in the IO package that do not honor the contract of the InputStream interface.  ByteArrayInputstream among others doesn't properly throw an exception or return -1 based on the requirements of the Interface.\n\nWe should inspect the IO classes to ensure that they all properly follow the contract of the IO Stream interface.\n\nComments:\n", "classification": "Classify the issue 'Streams classes do not honor their Interface Contracts' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-138?\nA: There are several classes in the IO package that do not honor the contract of the InputStream interface.  ByteArrayInputstream among others doesn't properly throw an exception or return -1 based on the requirements of the Interface.\n\nWe should inspect the IO classes to ensure that they all properly follow the contract of the IO Stream interface."}}
{"issue_key": "AMQCPP-137", "project": "AMQCPP", "title": "Exception in ResponseCorrelator::onCommand() ", "status": "Resolved", "reporter": "Greg Griffin", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-07-20T03:28:55.000+0000", "updated": "2007-09-30T10:25:42.000+0000", "description": "EXCEPTION:\n\nResponseCorrelator::onCommand() - received unknown response for request: 179414\nException: writing msg\nresponse from futureResponse was invalid\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\n\nCODE SNIPPET:\n\n\ttry {\n\t\tmsgBytes = session->createBytesMessage();\n\t\tmsgBytes->writeInt(time);\n\t\tmsgBytes->writeByte(type);\n\t\tmsgBytes->writeDouble(price);\n\t\tmsgBytes->writeLong(size);\n\t\tkey.insert(0,topicBase);\n\t\ttmpTopic = getTopic( key );\n\t\tpublisher->send(tmpTopic, msgBytes);\n\t\tdelete msgBytes;\n\t} \n\tcatch (CMSException& e) {\n        std::cerr << \"Exception: writing msg\" << endl;\n        messenger->onException(e);\n\t\texit(-1);\n        return;\n    }\n\n\n\nException happened in code that has been processing hundreds of msgs per second for 5 hours a day, no problem. But occurred during time when had a runaway java process taking all of one CPU and lot's of memory.\n\nNo msgs in broker (4.1.1) logs", "comments": [], "text": "Exception in ResponseCorrelator::onCommand() \n\nDescription:\nEXCEPTION:\n\nResponseCorrelator::onCommand() - received unknown response for request: 179414\nException: writing msg\nresponse from futureResponse was invalid\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\n\nCODE SNIPPET:\n\n\ttry {\n\t\tmsgBytes = session->createBytesMessage();\n\t\tmsgBytes->writeInt(time);\n\t\tmsgBytes->writeByte(type);\n\t\tmsgBytes->writeDouble(price);\n\t\tmsgBytes->writeLong(size);\n\t\tkey.insert(0,topicBase);\n\t\ttmpTopic = getTopic( key );\n\t\tpublisher->send(tmpTopic, msgBytes);\n\t\tdelete msgBytes;\n\t} \n\tcatch (CMSException& e) {\n        std::cerr << \"Exception: writing msg\" << endl;\n        messenger->onException(e);\n\t\texit(-1);\n        return;\n    }\n\n\n\nException happened in code that has been processing hundreds of msgs per second for 5 hours a day, no problem. But occurred during time when had a runaway java process taking all of one CPU and lot's of memory.\n\nNo msgs in broker (4.1.1) logs\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Exception in ResponseCorrelator::onCommand() \n\nDescription:\nEXCEPTION:\n\nResponseCorrelator::onCommand() - received unknown response for request: 179414\nException: writing msg\nresponse from futureResponse was invalid\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n\n\nCODE SNIPPET:\n\n\ttry {\n\t\tmsgBytes = session->createBytesMessage();\n\t\tmsgBytes->writeInt(time);\n\t\tmsgBytes->writeByte(type);\n\t\tmsgBytes->writeDouble(price);\n\t\tmsgBytes->writeLong(size);\n\t\tkey.insert(0,topicBase);\n\t\ttmpTopic = getTopic( key );\n\t\tpublisher->send(tmpTopic, msgBytes);\n\t\tdelete msgBytes;\n\t} \n\tcatch (CMSException& e) {\n        std::cerr << \"Exception: writing msg\" << endl;\n        messenger->onException(e);\n\t\texit(-1);\n        return;\n    }\n\n\n\nException happened in code that has been processing hundreds of msgs per second for 5 hours a day, no problem. But occurred during time when had a runaway java process taking all of one CPU and lot's of memory.\n\nNo msgs in broker (4.1.1) logs\n\nComments:\n", "classification": "Classify the issue 'Exception in ResponseCorrelator::onCommand() ' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-137?\nA: EXCEPTION:\n\nResponseCorrelator::onCommand() - received unknown response for request: 179414\nException: writing msg\nresponse from futureResponse was invalid\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\"}}
{"issue_key": "AMQCPP-136", "project": "AMQCPP", "title": "Some IO Stream classes don't honor the stream interface contract", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-07-16T15:12:13.000+0000", "updated": "2007-11-05T19:36:56.000+0000", "description": "Some of the streams classes have read methods that do not honor the stream interface's contract to throw an IOException or return a minus one for specific circumstances.  We should take a look at all the io classes and make sure they are honoring their contract and create unit tests that properly test this.", "comments": [], "text": "Some IO Stream classes don't honor the stream interface contract\n\nDescription:\nSome of the streams classes have read methods that do not honor the stream interface's contract to throw an IOException or return a minus one for specific circumstances.  We should take a look at all the io classes and make sure they are honoring their contract and create unit tests that properly test this.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Some IO Stream classes don't honor the stream interface contract\n\nDescription:\nSome of the streams classes have read methods that do not honor the stream interface's contract to throw an IOException or return a minus one for specific circumstances.  We should take a look at all the io classes and make sure they are honoring their contract and create unit tests that properly test this.\n\nComments:\n", "classification": "Classify the issue 'Some IO Stream classes don't honor the stream interface contract' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-136?\nA: Some of the streams classes have read methods that do not honor the stream interface's contract to throw an IOException or return a minus one for specific circumstances.  We should take a look at all the io classes and make sure they are honoring their contract and create unit tests that properly test this."}}
{"issue_key": "AMQCPP-135", "project": "AMQCPP", "title": "CLONE -Transacted session crashes or loses messages", "status": "Closed", "reporter": "George payton", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-07-12T05:09:49.000+0000", "updated": "2007-07-12T11:07:56.000+0000", "description": "Attached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.", "comments": [], "text": "CLONE -Transacted session crashes or loses messages\n\nDescription:\nAttached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: CLONE -Transacted session crashes or loses messages\n\nDescription:\nAttached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.\n\nComments:\n", "classification": "Classify the issue 'CLONE -Transacted session crashes or loses messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-135?\nA: Attached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long "}}
{"issue_key": "AMQCPP-134", "project": "AMQCPP", "title": "Compiler warnings have returned for tests on gcc", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Trivial", "labels": [], "created": "2007-07-07T17:59:16.000+0000", "updated": "2007-07-07T21:58:02.000+0000", "description": "from recent changes to the confgure.ac and Makefile.in scripts, the compiler warnings for the test projects have returned. The changes are using the CXX_FLAGS variable to store the settings.  The expectation being that by specifying activemq_test_CXXFLAGS, you would override the CXX_FLAGS.  This, however, does not happen.  I believe the CXX_FLAGS, being user override flags, are appended at the end of activemq_test_CXXFLAGS by the autotools.  This has the affect of -Wall getting added to the gcc command line after all of our ignore directives - thus causing warnings to appear.\n\nI believe the solution is to use another variable in the configure.ac to store our parameters (e.g. AMQ_CXXFLAGS) and let CXX_FLAGS truly be user-defined.  In the Makefile.am, the c++ flags line would then look something like this: activemq_test_CXXFLAGS= $(AMQ_CXXFLAGS)...", "comments": [], "text": "Compiler warnings have returned for tests on gcc\n\nDescription:\nfrom recent changes to the confgure.ac and Makefile.in scripts, the compiler warnings for the test projects have returned. The changes are using the CXX_FLAGS variable to store the settings.  The expectation being that by specifying activemq_test_CXXFLAGS, you would override the CXX_FLAGS.  This, however, does not happen.  I believe the CXX_FLAGS, being user override flags, are appended at the end of activemq_test_CXXFLAGS by the autotools.  This has the affect of -Wall getting added to the gcc command line after all of our ignore directives - thus causing warnings to appear.\n\nI believe the solution is to use another variable in the configure.ac to store our parameters (e.g. AMQ_CXXFLAGS) and let CXX_FLAGS truly be user-defined.  In the Makefile.am, the c++ flags line would then look something like this: activemq_test_CXXFLAGS= $(AMQ_CXXFLAGS)...\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compiler warnings have returned for tests on gcc\n\nDescription:\nfrom recent changes to the confgure.ac and Makefile.in scripts, the compiler warnings for the test projects have returned. The changes are using the CXX_FLAGS variable to store the settings.  The expectation being that by specifying activemq_test_CXXFLAGS, you would override the CXX_FLAGS.  This, however, does not happen.  I believe the CXX_FLAGS, being user override flags, are appended at the end of activemq_test_CXXFLAGS by the autotools.  This has the affect of -Wall getting added to the gcc command line after all of our ignore directives - thus causing warnings to appear.\n\nI believe the solution is to use another variable in the configure.ac to store our parameters (e.g. AMQ_CXXFLAGS) and let CXX_FLAGS truly be user-defined.  In the Makefile.am, the c++ flags line would then look something like this: activemq_test_CXXFLAGS= $(AMQ_CXXFLAGS)...\n\n\nComments:\n", "classification": "Classify the issue 'Compiler warnings have returned for tests on gcc' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-134?\nA: from recent changes to the confgure.ac and Makefile.in scripts, the compiler warnings for the test projects have returned. The changes are using the CXX_FLAGS variable to store the settings.  The expectation being that by specifying activemq_test_CXXFLAGS, you would override the CXX_FLAGS.  This, however, does not happen.  I believe the CXX_FLAGS, being user override flags, are appended at the end"}}
{"issue_key": "AMQCPP-133", "project": "AMQCPP", "title": "Receive of plain Message with Openwire returns null", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-16T12:47:55.000+0000", "updated": "2007-06-16T13:05:36.000+0000", "description": "Receive of plain Message with Openwire returns null because ActiveMQMessage::clone tries to dynamic_cast something that isn't a cms::Message.\n\nPatch attached.", "comments": [], "text": "Receive of plain Message with Openwire returns null\n\nDescription:\nReceive of plain Message with Openwire returns null because ActiveMQMessage::clone tries to dynamic_cast something that isn't a cms::Message.\n\nPatch attached.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Receive of plain Message with Openwire returns null\n\nDescription:\nReceive of plain Message with Openwire returns null because ActiveMQMessage::clone tries to dynamic_cast something that isn't a cms::Message.\n\nPatch attached.\n\nComments:\n", "classification": "Classify the issue 'Receive of plain Message with Openwire returns null' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-133?\nA: Receive of plain Message with Openwire returns null because ActiveMQMessage::clone tries to dynamic_cast something that isn't a cms::Message.\n\nPatch attached."}}
{"issue_key": "AMQCPP-132", "project": "AMQCPP", "title": "Unsubscribe of durable subscription fails", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-15T22:56:18.000+0000", "updated": "2007-06-17T14:05:45.000+0000", "description": "Calling unsubscribe on an Openwire session fails. The C++ application throws the following exception:\n\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 153\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1250\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 788\n\nOn a recent ActiveMQ 5.0-SNAPSHOT broker the following is printed in the console:\n\nException in thread \"ActiveMQ Transport: tcp:///127.0.0.1:1900\" java.lang.OutOfMemoryError: Java heap space\n        at org.apache.activemq.openwire.v2.BaseDataStreamMarshaller.looseUnmarshalByteSequence(BaseDataStreamMarshaller.java:599)\n        at org.apache.activemq.openwire.v2.WireFormatInfoMarshaller.looseUnmarshal(WireFormatInfoMarshaller.java:132)\n        at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:351)\n        at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:275)\n        at org.apache.activemq.transport.tcp.TcpTransport.readCommand(TcpTransport.java:156)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)\n        at java.lang.Thread.run(Thread.java:619)\n\nA patch for the Openwire durable subscribe integration test is attached to perform an unsubscribe when everything is done. This reproduces the problem.\n\nIn a related matter, why is unsubscribe not supported for Stomp? Is it due to a protocol limitation?", "comments": [], "text": "Unsubscribe of durable subscription fails\n\nDescription:\nCalling unsubscribe on an Openwire session fails. The C++ application throws the following exception:\n\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 153\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1250\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 788\n\nOn a recent ActiveMQ 5.0-SNAPSHOT broker the following is printed in the console:\n\nException in thread \"ActiveMQ Transport: tcp:///127.0.0.1:1900\" java.lang.OutOfMemoryError: Java heap space\n        at org.apache.activemq.openwire.v2.BaseDataStreamMarshaller.looseUnmarshalByteSequence(BaseDataStreamMarshaller.java:599)\n        at org.apache.activemq.openwire.v2.WireFormatInfoMarshaller.looseUnmarshal(WireFormatInfoMarshaller.java:132)\n        at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:351)\n        at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:275)\n        at org.apache.activemq.transport.tcp.TcpTransport.readCommand(TcpTransport.java:156)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)\n        at java.lang.Thread.run(Thread.java:619)\n\nA patch for the Openwire durable subscribe integration test is attached to perform an unsubscribe when everything is done. This reproduces the problem.\n\nIn a related matter, why is unsubscribe not supported for Stomp? Is it due to a protocol limitation?\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Unsubscribe of durable subscription fails\n\nDescription:\nCalling unsubscribe on an Openwire session fails. The C++ application throws the following exception:\n\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 153\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LINE: 1250\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 788\n\nOn a recent ActiveMQ 5.0-SNAPSHOT broker the following is printed in the console:\n\nException in thread \"ActiveMQ Transport: tcp:///127.0.0.1:1900\" java.lang.OutOfMemoryError: Java heap space\n        at org.apache.activemq.openwire.v2.BaseDataStreamMarshaller.looseUnmarshalByteSequence(BaseDataStreamMarshaller.java:599)\n        at org.apache.activemq.openwire.v2.WireFormatInfoMarshaller.looseUnmarshal(WireFormatInfoMarshaller.java:132)\n        at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:351)\n        at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:275)\n        at org.apache.activemq.transport.tcp.TcpTransport.readCommand(TcpTransport.java:156)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)\n        at java.lang.Thread.run(Thread.java:619)\n\nA patch for the Openwire durable subscribe integration test is attached to perform an unsubscribe when everything is done. This reproduces the problem.\n\nIn a related matter, why is unsubscribe not supported for Stomp? Is it due to a protocol limitation?\n\nComments:\n", "classification": "Classify the issue 'Unsubscribe of durable subscription fails' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-132?\nA: Calling unsubscribe on an Openwire session fails. The C++ application throws the following exception:\n\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 146\n        FILE: ..\\src\\main\\activemq\\transport\\filters\\ResponseCorrelator.cpp, LINE: 153\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.cpp"}}
{"issue_key": "AMQCPP-131", "project": "AMQCPP", "title": "StompConnector doesn't rethrow UnsupportedOperationException", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-06-15T19:23:46.000+0000", "updated": "2007-06-15T20:02:59.000+0000", "description": "StompConnector is missing a few AMQ_CATCH_RETHROWs, causing the exceptions it throws to contain \"caught unknown exception\" instead of the actual message.", "comments": [], "text": "StompConnector doesn't rethrow UnsupportedOperationException\n\nDescription:\nStompConnector is missing a few AMQ_CATCH_RETHROWs, causing the exceptions it throws to contain \"caught unknown exception\" instead of the actual message.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: StompConnector doesn't rethrow UnsupportedOperationException\n\nDescription:\nStompConnector is missing a few AMQ_CATCH_RETHROWs, causing the exceptions it throws to contain \"caught unknown exception\" instead of the actual message.\n\nComments:\n", "classification": "Classify the issue 'StompConnector doesn't rethrow UnsupportedOperationException' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-131?\nA: StompConnector is missing a few AMQ_CATCH_RETHROWs, causing the exceptions it throws to contain \"caught unknown exception\" instead of the actual message."}}
{"issue_key": "AMQCPP-130", "project": "AMQCPP", "title": "Enhance the DummyTransport and rename it to MockTransport", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-06-15T18:56:26.000+0000", "updated": "2007-06-26T15:11:16.000+0000", "description": "ActiveMQ-CPP current has a class called DummyTransport that is part of the unit tests suite.  This class allows the creation of fake transports that mimic the various protocols that the client supports.  Recently some users have indicated that they wish to use this capability in their own unit tests.  As a result I propose that we change the DummyTransport to MockTransport and move it into the main source area so its built as part of the library.  The existing StompResponseBuilder should also be moved into the main source tree as well.  \n\nWe also need to create an OpenWireResponseBuilder so that the MockTransport can be used when testing against the openwire connector.  \n\nThese classes should be better documented to make it easier to use them, and the wiki should be updated to make their existence known.", "comments": [], "text": "Enhance the DummyTransport and rename it to MockTransport\n\nDescription:\nActiveMQ-CPP current has a class called DummyTransport that is part of the unit tests suite.  This class allows the creation of fake transports that mimic the various protocols that the client supports.  Recently some users have indicated that they wish to use this capability in their own unit tests.  As a result I propose that we change the DummyTransport to MockTransport and move it into the main source area so its built as part of the library.  The existing StompResponseBuilder should also be moved into the main source tree as well.  \n\nWe also need to create an OpenWireResponseBuilder so that the MockTransport can be used when testing against the openwire connector.  \n\nThese classes should be better documented to make it easier to use them, and the wiki should be updated to make their existence known.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Enhance the DummyTransport and rename it to MockTransport\n\nDescription:\nActiveMQ-CPP current has a class called DummyTransport that is part of the unit tests suite.  This class allows the creation of fake transports that mimic the various protocols that the client supports.  Recently some users have indicated that they wish to use this capability in their own unit tests.  As a result I propose that we change the DummyTransport to MockTransport and move it into the main source area so its built as part of the library.  The existing StompResponseBuilder should also be moved into the main source tree as well.  \n\nWe also need to create an OpenWireResponseBuilder so that the MockTransport can be used when testing against the openwire connector.  \n\nThese classes should be better documented to make it easier to use them, and the wiki should be updated to make their existence known.\n\nComments:\n", "classification": "Classify the issue 'Enhance the DummyTransport and rename it to MockTransport' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-130?\nA: ActiveMQ-CPP current has a class called DummyTransport that is part of the unit tests suite.  This class allows the creation of fake transports that mimic the various protocols that the client supports.  Recently some users have indicated that they wish to use this capability in their own unit tests.  As a result I propose that we change the DummyTransport to MockTransport and move it into the mai"}}
{"issue_key": "AMQCPP-129", "project": "AMQCPP", "title": "Implement QueueBrowser", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-06-14T22:55:44.000+0000", "updated": "2010-03-16T15:31:10.000+0000", "description": "From the JMS 1.1 spec:\n\n5.9 QueueBrowser\n\nA client uses a QueueBrowser to look at messages on a queue without removing\nthem. A QueueBrowser can be created from a Session or a QueueSession.\n\nThe browse methods return a java.util.Enumeration that is used to scan the\nqueue's messages. It may be an enumeration of the entire content of a queue,\nor it may contain only the messages matching a message selector.\n\nMessages may be arriving and expiring while the scan is done. JMS does not\nrequire the content of an enumeration to be a static snapshot of queue content.\nWhether these changes are visible or not depends on the JMS provider.\n\nI think I might tackle this in a few weeks' time.", "comments": [], "text": "Implement QueueBrowser\n\nDescription:\nFrom the JMS 1.1 spec:\n\n5.9 QueueBrowser\n\nA client uses a QueueBrowser to look at messages on a queue without removing\nthem. A QueueBrowser can be created from a Session or a QueueSession.\n\nThe browse methods return a java.util.Enumeration that is used to scan the\nqueue's messages. It may be an enumeration of the entire content of a queue,\nor it may contain only the messages matching a message selector.\n\nMessages may be arriving and expiring while the scan is done. JMS does not\nrequire the content of an enumeration to be a static snapshot of queue content.\nWhether these changes are visible or not depends on the JMS provider.\n\nI think I might tackle this in a few weeks' time.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Implement QueueBrowser\n\nDescription:\nFrom the JMS 1.1 spec:\n\n5.9 QueueBrowser\n\nA client uses a QueueBrowser to look at messages on a queue without removing\nthem. A QueueBrowser can be created from a Session or a QueueSession.\n\nThe browse methods return a java.util.Enumeration that is used to scan the\nqueue's messages. It may be an enumeration of the entire content of a queue,\nor it may contain only the messages matching a message selector.\n\nMessages may be arriving and expiring while the scan is done. JMS does not\nrequire the content of an enumeration to be a static snapshot of queue content.\nWhether these changes are visible or not depends on the JMS provider.\n\nI think I might tackle this in a few weeks' time.\n\nComments:\n", "classification": "Classify the issue 'Implement QueueBrowser' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-129?\nA: From the JMS 1.1 spec:\n\n5.9 QueueBrowser\n\nA client uses a QueueBrowser to look at messages on a queue without removing\nthem. A QueueBrowser can be created from a Session or a QueueSession.\n\nThe browse methods return a java.util.Enumeration that is used to scan the\nqueue's messages. It may be an enumeration of the entire content of a queue,\nor it may contain only the messages matching a message sel"}}
{"issue_key": "AMQCPP-128", "project": "AMQCPP", "title": "Transacted session crashes or loses messages", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-14T01:54:34.000+0000", "updated": "2007-07-07T11:56:46.000+0000", "description": "Attached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.", "comments": [], "text": "Transacted session crashes or loses messages\n\nDescription:\nAttached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Transacted session crashes or loses messages\n\nDescription:\nAttached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long timeout period). Cleanup goes fine.\n\n- Where I expect to receive a message, nothing turns up. Cleanup hangs.\n\n- Sometimes it prints:\n\nMutex::unlock - Failed, not Lock Owner!\n        FILE: ..\\src\\main\\activemq\\concurrent\\Mutex.cpp, LINE: 83\n        FILE: activemq-cpp\\src\\main\\activemq/concurrent/Lock.h, LINE: 110\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQConsumer.cpp, LINE: 443\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSessionExecutor.cpp, LINE: 192\n\nand keeps on going\n\n- Sometimes it crashes with the following when running a Debug build on Windows:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: ...\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\list\nLine: 776\n\nExpression: list erase iterator outside range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\n- Sometimes it crashes with something along these lines:\n\n---------------------------\nvs2005-activemq-example.exe - Application Error\n---------------------------\nThe instruction at \"0x0053dd80\" referenced memory at \"0xdddddddd\". The memory could not be \"read\".\n\n\nClick on OK to terminate the program\nClick on CANCEL to debug the program\n---------------------------\nOK   Cancel   \n---------------------------\n\nThe relevant thread's stack trace looks like this:\n\n>\tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::close()  Line 110 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::~ActiveMQSession()  Line 74 + 0x8 bytes\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQSession::`scalar deleting destructor'()  + 0xf bytes\tC++\n \tvs2005-activemq-example.exe!test_transaction(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & url=\"tcp://localhost:61613?wireFormat=stomp\")  Line 78 + 0x37 bytes\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x003558c8)  Line 85 + 0x30 bytes\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Line 597 + 0x19 bytes\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Line 414\tC\n\nIt crashes where it's doing resource->close() because resource points to garbage.\n\nComments:\n", "classification": "Classify the issue 'Transacted session crashes or loses messages' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-128?\nA: Attached is some code that does a few things with transacted sessions, in a loop. This sometimes reproduces the crash I mentioned in one of my latest comments in AMQCPP-122.\n\nI'm testing on Windows XP SP2 with Visual Studio 8 on Core 2 Duo machine.\n\nI've also seen all of the following happen in subsequent runs of the code:\n\n- Where I expect to receive a message, nothing turns up (even with a long "}}
{"issue_key": "AMQCPP-127", "project": "AMQCPP", "title": "ResponseCorrelator doesn't have a way to set max timeot from the properties uri.", "status": "Resolved", "reporter": "Timothy A. Bish", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-06-13T17:40:39.000+0000", "updated": "2007-06-13T22:38:25.000+0000", "description": "The ResponseCorrelator needs to have a way to set the desired max timeout for a response.  The factory should look in the properties for a property named. transport.ResponseCorrelator.maxResponseWaitTime to set the configured time.  The default of 3 seconds should be kept as the default when the property is not set.", "comments": [], "text": "ResponseCorrelator doesn't have a way to set max timeot from the properties uri.\n\nDescription:\nThe ResponseCorrelator needs to have a way to set the desired max timeout for a response.  The factory should look in the properties for a property named. transport.ResponseCorrelator.maxResponseWaitTime to set the configured time.  The default of 3 seconds should be kept as the default when the property is not set.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ResponseCorrelator doesn't have a way to set max timeot from the properties uri.\n\nDescription:\nThe ResponseCorrelator needs to have a way to set the desired max timeout for a response.  The factory should look in the properties for a property named. transport.ResponseCorrelator.maxResponseWaitTime to set the configured time.  The default of 3 seconds should be kept as the default when the property is not set.\n\nComments:\n", "classification": "Classify the issue 'ResponseCorrelator doesn't have a way to set max timeot from the properties uri.' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-127?\nA: The ResponseCorrelator needs to have a way to set the desired max timeout for a response.  The factory should look in the properties for a property named. transport.ResponseCorrelator.maxResponseWaitTime to set the configured time.  The default of 3 seconds should be kept as the default when the property is not set."}}
{"issue_key": "AMQCPP-126", "project": "AMQCPP", "title": "closing ressources after an IOException crashes the app", "status": "Resolved", "reporter": "olivier renaud", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-12T14:11:21.000+0000", "updated": "2007-06-19T15:18:05.000+0000", "description": "When a network error occurs, I want to clean up all the created objects and close the connection and the session.\nSo, when I catch an exception (activemq::io::IOException), either created by from producer.send, or by an asynchronous notification on the ExceptionListener object set for the Connection.\n\nHowever, closing ressources (Consumer, Producer, or Session) always crash the application. This can be seen with the Example code in ActiveMQCPP sources :\n\n- run the example program so that it connects to a distant host (not localhost)\n- physically unplug the network (or shutdown the network connection), and wait\n\nThe program stops with the following message :\n\n{quote}\n...\nSent message #334 from thread 1216\nSent message #335 from thread 1216\nMessage #335 Received: Hello world! from thread 1216\nJMS Exception occured.  Shutting down client.\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.c\npp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example, ignore errors from this\npoint on as the sockets breaks when we shutdown.\n=====================================================\n{quote}\n\nAnd it generates an access violation, with the following stack trace :\n\n{quote}\n \tNTDLL.DLL!784905a5() \t\n \t[Les frames ci-dessous sont peut-Ãªtre incorrects et/ou manquants, aucun symbole chargÃ© pour NTDLL.DLL]\t\n \tNTDLL.DLL!7847bd5a() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!784ab63e() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!7847c1ea() \t\n \tmsvcr80d.dll!1024db9c() \t\n \tmsvcr80d.dll!1020faa5() \t\n \tmsvcr80d.dll!1020f839() \t\n \tmsvcr80d.dll!1020f7b9() \t\n \tmsvcr80d.dll!1026902f() \t\n>\tvs2005-activemq-example.exe!std::_Iterator_base::_Adopt(const std::_Container_base * _Parent=0x00033540)  Ligne 166\tC++\n \tvs2005-activemq-example.exe!std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00cb5f21, const std::_Container_base * _Pvector=0x00033540)  Ligne 73\tC++\n \tvs2005-activemq-example.exe!std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00000009, const std::_Container_base * _Pvector=0x000336dc)  Ligne 309\tC++\n \t00cb5f18()\t\n \tvs2005-activemq-example.exe!std::vector<unsigned char,std::allocator<unsigned char> >::push_back(const unsigned char & _Val=0)  Ligne 800 + 0x24 octets\tC++\n \tvs2005-activemq-example.exe!activemq::io::ByteArrayOutputStream::write(unsigned char c=0)  Ligne 54\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::write(const unsigned char c=0)  Ligne 43\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUnsignedShort(unsigned short value=36)  Ligne 126\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUTF(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\")  Ligne 217\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalString(std::basic_string<char,std::char_traits<char>,std::allocator<char> > value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\", activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 307\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::ConsumerIdMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 131\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::looseMarshalNestedObject(activemq::connector::openwire::commands::DataStructure * o=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 458\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalCachedObject(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * data=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 98 + 0x10 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::RemoveInfoMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00034e7c, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 124 + 0x35 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::marshal(activemq::transport::Command * command=0x00034e78, activemq::io::DataOutputStream * dataOut=0x0031fd98)  Ligne 153\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireCommandWriter::writeCommand(activemq::transport::Command * command=0x00034e78)  Ligne 72\tC++\n \tvs2005-activemq-example.exe!activemq::transport::IOTransport::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 83 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::transport::TransportFilter::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 147\tC++\n \tvs2005-activemq-example.exe!activemq::transport::ResponseCorrelator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 87 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormatNegotiator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 73 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 1436 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::disposeOf(activemq::connector::openwire::commands::DataStructure * objectId=0x00c91b40)  Ligne 1483\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1315 + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n\t...\n\t[ here, the same message repeated about 50 times ]\n\t...\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::close()  Ligne 87 + 0x19 octets\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::~ActiveMQConsumer()  Ligne 64\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::cleanup()  Ligne 269 + 0x40 octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::~HelloWorldConsumer()  Ligne 180\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x00315b30)  Ligne 340 + 0x2d octets\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Ligne 586 + 0x19 octets\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Ligne 403\tC\n \tKERNEL32.DLL!77e98989() \t\n \tNTDLL.DLL!78465c09() \t\n{quote}\n\nI see no way of properly closing ressources when a disconnection happen", "comments": [], "text": "closing ressources after an IOException crashes the app\n\nDescription:\nWhen a network error occurs, I want to clean up all the created objects and close the connection and the session.\nSo, when I catch an exception (activemq::io::IOException), either created by from producer.send, or by an asynchronous notification on the ExceptionListener object set for the Connection.\n\nHowever, closing ressources (Consumer, Producer, or Session) always crash the application. This can be seen with the Example code in ActiveMQCPP sources :\n\n- run the example program so that it connects to a distant host (not localhost)\n- physically unplug the network (or shutdown the network connection), and wait\n\nThe program stops with the following message :\n\n{quote}\n...\nSent message #334 from thread 1216\nSent message #335 from thread 1216\nMessage #335 Received: Hello world! from thread 1216\nJMS Exception occured.  Shutting down client.\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.c\npp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example, ignore errors from this\npoint on as the sockets breaks when we shutdown.\n=====================================================\n{quote}\n\nAnd it generates an access violation, with the following stack trace :\n\n{quote}\n \tNTDLL.DLL!784905a5() \t\n \t[Les frames ci-dessous sont peut-Ãªtre incorrects et/ou manquants, aucun symbole chargÃ© pour NTDLL.DLL]\t\n \tNTDLL.DLL!7847bd5a() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!784ab63e() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!7847c1ea() \t\n \tmsvcr80d.dll!1024db9c() \t\n \tmsvcr80d.dll!1020faa5() \t\n \tmsvcr80d.dll!1020f839() \t\n \tmsvcr80d.dll!1020f7b9() \t\n \tmsvcr80d.dll!1026902f() \t\n>\tvs2005-activemq-example.exe!std::_Iterator_base::_Adopt(const std::_Container_base * _Parent=0x00033540)  Ligne 166\tC++\n \tvs2005-activemq-example.exe!std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00cb5f21, const std::_Container_base * _Pvector=0x00033540)  Ligne 73\tC++\n \tvs2005-activemq-example.exe!std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00000009, const std::_Container_base * _Pvector=0x000336dc)  Ligne 309\tC++\n \t00cb5f18()\t\n \tvs2005-activemq-example.exe!std::vector<unsigned char,std::allocator<unsigned char> >::push_back(const unsigned char & _Val=0)  Ligne 800 + 0x24 octets\tC++\n \tvs2005-activemq-example.exe!activemq::io::ByteArrayOutputStream::write(unsigned char c=0)  Ligne 54\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::write(const unsigned char c=0)  Ligne 43\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUnsignedShort(unsigned short value=36)  Ligne 126\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUTF(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\")  Ligne 217\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalString(std::basic_string<char,std::char_traits<char>,std::allocator<char> > value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\", activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 307\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::ConsumerIdMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 131\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::looseMarshalNestedObject(activemq::connector::openwire::commands::DataStructure * o=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 458\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalCachedObject(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * data=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 98 + 0x10 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::RemoveInfoMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00034e7c, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 124 + 0x35 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::marshal(activemq::transport::Command * command=0x00034e78, activemq::io::DataOutputStream * dataOut=0x0031fd98)  Ligne 153\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireCommandWriter::writeCommand(activemq::transport::Command * command=0x00034e78)  Ligne 72\tC++\n \tvs2005-activemq-example.exe!activemq::transport::IOTransport::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 83 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::transport::TransportFilter::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 147\tC++\n \tvs2005-activemq-example.exe!activemq::transport::ResponseCorrelator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 87 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormatNegotiator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 73 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 1436 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::disposeOf(activemq::connector::openwire::commands::DataStructure * objectId=0x00c91b40)  Ligne 1483\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1315 + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n\t...\n\t[ here, the same message repeated about 50 times ]\n\t...\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::close()  Ligne 87 + 0x19 octets\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::~ActiveMQConsumer()  Ligne 64\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::cleanup()  Ligne 269 + 0x40 octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::~HelloWorldConsumer()  Ligne 180\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x00315b30)  Ligne 340 + 0x2d octets\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Ligne 586 + 0x19 octets\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Ligne 403\tC\n \tKERNEL32.DLL!77e98989() \t\n \tNTDLL.DLL!78465c09() \t\n{quote}\n\nI see no way of properly closing ressources when a disconnection happen\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: closing ressources after an IOException crashes the app\n\nDescription:\nWhen a network error occurs, I want to clean up all the created objects and close the connection and the session.\nSo, when I catch an exception (activemq::io::IOException), either created by from producer.send, or by an asynchronous notification on the ExceptionListener object set for the Connection.\n\nHowever, closing ressources (Consumer, Producer, or Session) always crash the application. This can be seen with the Example code in ActiveMQCPP sources :\n\n- run the example program so that it connects to a distant host (not localhost)\n- physically unplug the network (or shutdown the network connection), and wait\n\nThe program stops with the following message :\n\n{quote}\n...\nSent message #334 from thread 1216\nSent message #335 from thread 1216\nMessage #335 Received: Hello world! from thread 1216\nJMS Exception occured.  Shutting down client.\nresponse from futureResponse was invalid\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 145\n        FILE: ..\\src\\main\\activemq\\transport\\ResponseCorrelator.cpp, LINE: 152\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireFormatNegotiator.c\npp, LINE: 105\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 1468\n        FILE: ..\\src\\main\\activemq\\connector\\openwire\\OpenWireConnector.cpp, LIN\nE: 928\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQSession.cpp, LINE: 703\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 194\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 149\n        FILE: ..\\src\\main\\activemq\\core\\ActiveMQProducer.cpp, LINE: 108\n-----------------------------------------------------\nFinished with the example, ignore errors from this\npoint on as the sockets breaks when we shutdown.\n=====================================================\n{quote}\n\nAnd it generates an access violation, with the following stack trace :\n\n{quote}\n \tNTDLL.DLL!784905a5() \t\n \t[Les frames ci-dessous sont peut-Ãªtre incorrects et/ou manquants, aucun symbole chargÃ© pour NTDLL.DLL]\t\n \tNTDLL.DLL!7847bd5a() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!784ab63e() \t\n \tNTDLL.DLL!7847bf68() \t\n \tNTDLL.DLL!7847bf98() \t\n \tNTDLL.DLL!7847c1ea() \t\n \tmsvcr80d.dll!1024db9c() \t\n \tmsvcr80d.dll!1020faa5() \t\n \tmsvcr80d.dll!1020f839() \t\n \tmsvcr80d.dll!1020f7b9() \t\n \tmsvcr80d.dll!1026902f() \t\n>\tvs2005-activemq-example.exe!std::_Iterator_base::_Adopt(const std::_Container_base * _Parent=0x00033540)  Ligne 166\tC++\n \tvs2005-activemq-example.exe!std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00cb5f21, const std::_Container_base * _Pvector=0x00033540)  Ligne 73\tC++\n \tvs2005-activemq-example.exe!std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >(unsigned char * _Ptr=0x00000009, const std::_Container_base * _Pvector=0x000336dc)  Ligne 309\tC++\n \t00cb5f18()\t\n \tvs2005-activemq-example.exe!std::vector<unsigned char,std::allocator<unsigned char> >::push_back(const unsigned char & _Val=0)  Ligne 800 + 0x24 octets\tC++\n \tvs2005-activemq-example.exe!activemq::io::ByteArrayOutputStream::write(unsigned char c=0)  Ligne 54\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::write(const unsigned char c=0)  Ligne 43\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUnsignedShort(unsigned short value=36)  Ligne 126\tC++\n \tvs2005-activemq-example.exe!activemq::io::DataOutputStream::writeUTF(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\")  Ligne 217\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalString(std::basic_string<char,std::char_traits<char>,std::allocator<char> > value=\"4bf52ac5-df69-4b18-b28d-669a36b2b7f9\", activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 307\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::ConsumerIdMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 131\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::looseMarshalNestedObject(activemq::connector::openwire::commands::DataStructure * o=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 458\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::BaseDataStreamMarshaller::looseMarshalCachedObject(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * data=0x00cb6288, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 98 + 0x10 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::marshal::v2::RemoveInfoMarshaller::looseMarshal(activemq::connector::openwire::OpenWireFormat * wireFormat=0x0031e150, activemq::connector::openwire::commands::DataStructure * dataStructure=0x00034e7c, activemq::io::DataOutputStream * dataOut=0x00cb5df8)  Ligne 124 + 0x35 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormat::marshal(activemq::transport::Command * command=0x00034e78, activemq::io::DataOutputStream * dataOut=0x0031fd98)  Ligne 153\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireCommandWriter::writeCommand(activemq::transport::Command * command=0x00034e78)  Ligne 72\tC++\n \tvs2005-activemq-example.exe!activemq::transport::IOTransport::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 83 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::transport::TransportFilter::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 147\tC++\n \tvs2005-activemq-example.exe!activemq::transport::ResponseCorrelator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 87 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireFormatNegotiator::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 73 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::oneway(activemq::transport::Command * command=0x00034e78)  Ligne 1436 + 0x1d octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::disposeOf(activemq::connector::openwire::commands::DataStructure * objectId=0x00c91b40)  Ligne 1483\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1315 + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n\t...\n\t[ here, the same message repeated about 50 times ]\n\t...\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::~OpenWireConsumerInfo()  Ligne 53\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConsumerInfo::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::openwire::OpenWireConnector::closeResource(activemq::connector::ConnectorResource * resource=0x00c919b8)  Ligne 1318 + 0x32 octets\tC++\n \tvs2005-activemq-example.exe!activemq::connector::BaseConnectorResource::close()  Ligne 60\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::close()  Ligne 87 + 0x19 octets\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::~ActiveMQConsumer()  Ligne 64\tC++\n \tvs2005-activemq-example.exe!activemq::core::ActiveMQConsumer::`scalar deleting destructor'()  + 0xf octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::cleanup()  Ligne 269 + 0x40 octets\tC++\n \tvs2005-activemq-example.exe!HelloWorldConsumer::~HelloWorldConsumer()  Ligne 180\tC++\n \tvs2005-activemq-example.exe!main(int argc=1, char * * argv=0x00315b30)  Ligne 340 + 0x2d octets\tC++\n \tvs2005-activemq-example.exe!__tmainCRTStartup()  Ligne 586 + 0x19 octets\tC\n \tvs2005-activemq-example.exe!mainCRTStartup()  Ligne 403\tC\n \tKERNEL32.DLL!77e98989() \t\n \tNTDLL.DLL!78465c09() \t\n{quote}\n\nI see no way of properly closing ressources when a disconnection happen\n\nComments:\n", "classification": "Classify the issue 'closing ressources after an IOException crashes the app' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-126?\nA: When a network error occurs, I want to clean up all the created objects and close the connection and the session.\nSo, when I catch an exception (activemq::io::IOException), either created by from producer.send, or by an asynchronous notification on the ExceptionListener object set for the Connection.\n\nHowever, closing ressources (Consumer, Producer, or Session) always crash the application. This c"}}
{"issue_key": "AMQCPP-125", "project": "AMQCPP", "title": "Decaf: Random", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-06-10T14:11:20.000+0000", "updated": "2007-06-11T11:48:10.000+0000", "description": "Attached is a patch that implements a Random class that works the same as java.util.Random. This code can probably go into Decaf. The patch puts it in activemq/util for now.\n\nI adapted the code from Harmony's implementation of Random:\n\nhttp://svn.apache.org/viewvc/harmony/enhanced/classlib/trunk/modules/luni/src/main/java/java/util/Random.java?revision=530264&view=markup\n\nI couldn't find a test for java.util.Random in the Harmony sources (just took a quick look), so I used the values from the Mauve test:\n\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/mauve/gnu/testlet/java/util/Random/basic.java?rev=1.5&content-type=text/x-cvsweb-markup&cvsroot=mauve\n\nThe Mauve tests are licensed under the GPL. Does using a few values from this test cause problems as far as licensing of this new code goes? Hopefully not.\n\nThe port to C++ was more or less straightforward. There were three main issues:\n\n1. C++ doesn't have >>>. If I understand >>> correctly, in C++ it's equivalent to doing >> on an unsigned type.\n\n2. You can't shift more than 31 places at a time in a portable manner. This is because at least the Intel shift instructions only look at the bottom 5 bits of the register that tells it how far to shift. As far as I know, the easiest solution is just to shift multiple times.\n\n3. Some java.util.Random methods are synchronized. I haven't included this functionality in the first version of the patch. It should be easy to add.", "comments": [], "text": "Decaf: Random\n\nDescription:\nAttached is a patch that implements a Random class that works the same as java.util.Random. This code can probably go into Decaf. The patch puts it in activemq/util for now.\n\nI adapted the code from Harmony's implementation of Random:\n\nhttp://svn.apache.org/viewvc/harmony/enhanced/classlib/trunk/modules/luni/src/main/java/java/util/Random.java?revision=530264&view=markup\n\nI couldn't find a test for java.util.Random in the Harmony sources (just took a quick look), so I used the values from the Mauve test:\n\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/mauve/gnu/testlet/java/util/Random/basic.java?rev=1.5&content-type=text/x-cvsweb-markup&cvsroot=mauve\n\nThe Mauve tests are licensed under the GPL. Does using a few values from this test cause problems as far as licensing of this new code goes? Hopefully not.\n\nThe port to C++ was more or less straightforward. There were three main issues:\n\n1. C++ doesn't have >>>. If I understand >>> correctly, in C++ it's equivalent to doing >> on an unsigned type.\n\n2. You can't shift more than 31 places at a time in a portable manner. This is because at least the Intel shift instructions only look at the bottom 5 bits of the register that tells it how far to shift. As far as I know, the easiest solution is just to shift multiple times.\n\n3. Some java.util.Random methods are synchronized. I haven't included this functionality in the first version of the patch. It should be easy to add.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Decaf: Random\n\nDescription:\nAttached is a patch that implements a Random class that works the same as java.util.Random. This code can probably go into Decaf. The patch puts it in activemq/util for now.\n\nI adapted the code from Harmony's implementation of Random:\n\nhttp://svn.apache.org/viewvc/harmony/enhanced/classlib/trunk/modules/luni/src/main/java/java/util/Random.java?revision=530264&view=markup\n\nI couldn't find a test for java.util.Random in the Harmony sources (just took a quick look), so I used the values from the Mauve test:\n\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/mauve/gnu/testlet/java/util/Random/basic.java?rev=1.5&content-type=text/x-cvsweb-markup&cvsroot=mauve\n\nThe Mauve tests are licensed under the GPL. Does using a few values from this test cause problems as far as licensing of this new code goes? Hopefully not.\n\nThe port to C++ was more or less straightforward. There were three main issues:\n\n1. C++ doesn't have >>>. If I understand >>> correctly, in C++ it's equivalent to doing >> on an unsigned type.\n\n2. You can't shift more than 31 places at a time in a portable manner. This is because at least the Intel shift instructions only look at the bottom 5 bits of the register that tells it how far to shift. As far as I know, the easiest solution is just to shift multiple times.\n\n3. Some java.util.Random methods are synchronized. I haven't included this functionality in the first version of the patch. It should be easy to add.\n\nComments:\n", "classification": "Classify the issue 'Decaf: Random' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-125?\nA: Attached is a patch that implements a Random class that works the same as java.util.Random. This code can probably go into Decaf. The patch puts it in activemq/util for now.\n\nI adapted the code from Harmony's implementation of Random:\n\nhttp://svn.apache.org/viewvc/harmony/enhanced/classlib/trunk/modules/luni/src/main/java/java/util/Random.java?revision=530264&view=markup\n\nI couldn't find a test fo"}}
{"issue_key": "AMQCPP-124", "project": "AMQCPP", "title": "Provide a ConnectionMetaData interface in CMS", "status": "Closed", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Trivial", "labels": [], "created": "2007-06-06T21:37:26.000+0000", "updated": "2007-09-30T10:26:43.000+0000", "description": "From the JMS 1.1 specification:\n\n4.3.7 ConnectionMetaData\n\nA Connection provides a ConnectionMetaData object. This object provides the latest version of JMS supported by the provider as well as the provider's product name and version.\n\nIt also provides a list of the JMS defined property names supported by the connection.", "comments": [], "text": "Provide a ConnectionMetaData interface in CMS\n\nDescription:\nFrom the JMS 1.1 specification:\n\n4.3.7 ConnectionMetaData\n\nA Connection provides a ConnectionMetaData object. This object provides the latest version of JMS supported by the provider as well as the provider's product name and version.\n\nIt also provides a list of the JMS defined property names supported by the connection.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Provide a ConnectionMetaData interface in CMS\n\nDescription:\nFrom the JMS 1.1 specification:\n\n4.3.7 ConnectionMetaData\n\nA Connection provides a ConnectionMetaData object. This object provides the latest version of JMS supported by the provider as well as the provider's product name and version.\n\nIt also provides a list of the JMS defined property names supported by the connection.\n\nComments:\n", "classification": "Classify the issue 'Provide a ConnectionMetaData interface in CMS' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-124?\nA: From the JMS 1.1 specification:\n\n4.3.7 ConnectionMetaData\n\nA Connection provides a ConnectionMetaData object. This object provides the latest version of JMS supported by the provider as well as the provider's product name and version.\n\nIt also provides a list of the JMS defined property names supported by the connection."}}
{"issue_key": "AMQCPP-123", "project": "AMQCPP", "title": "Link error when trying to link another shared library against AMQCPP on 64-bit Linux", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-06-05T23:27:35.000+0000", "updated": "2007-06-06T11:40:26.000+0000", "description": "When trying to link another shared library against libactivemq-cpp.a on 64-bit Fedora Core 6, I get the following error:\n\n/usr/bin/ld: libactivemq-cpp.a(ActiveMQConnectionFactory.o): relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC\nlibactivemq-cpp.a: could not read symbols: Bad value\n\nAdding -fPIC to the CXXFLAGS seems to do the trick:\n\nIndex: configure.ac\n===================================================================\n--- configure.ac        (revision 544508)\n+++ configure.ac        (working copy)\n@@ -86,7 +86,7 @@\n AM_PATH_CPPUNIT(1.10.2, cppunit=yes, cppunit=no; AC_MSG_RESULT([no. Unit and Integration tests disabled])) \n AM_CONDITIONAL(BUILD_CPPUNIT_TESTS, test x$cppunit = xyes)\n \n-CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long\"\n+CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -fPIC\"\n # CPPUNIT_CXXFLAGS=\"$CPPUNIT_CXXFLAGS -Wno-non-virtual-dtor -Wno-unused-parameter -Wno-uninitialized\"\n LIBS=\"$LIBS\"", "comments": [], "text": "Link error when trying to link another shared library against AMQCPP on 64-bit Linux\n\nDescription:\nWhen trying to link another shared library against libactivemq-cpp.a on 64-bit Fedora Core 6, I get the following error:\n\n/usr/bin/ld: libactivemq-cpp.a(ActiveMQConnectionFactory.o): relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC\nlibactivemq-cpp.a: could not read symbols: Bad value\n\nAdding -fPIC to the CXXFLAGS seems to do the trick:\n\nIndex: configure.ac\n===================================================================\n--- configure.ac        (revision 544508)\n+++ configure.ac        (working copy)\n@@ -86,7 +86,7 @@\n AM_PATH_CPPUNIT(1.10.2, cppunit=yes, cppunit=no; AC_MSG_RESULT([no. Unit and Integration tests disabled])) \n AM_CONDITIONAL(BUILD_CPPUNIT_TESTS, test x$cppunit = xyes)\n \n-CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long\"\n+CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -fPIC\"\n # CPPUNIT_CXXFLAGS=\"$CPPUNIT_CXXFLAGS -Wno-non-virtual-dtor -Wno-unused-parameter -Wno-uninitialized\"\n LIBS=\"$LIBS\"\n\n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Link error when trying to link another shared library against AMQCPP on 64-bit Linux\n\nDescription:\nWhen trying to link another shared library against libactivemq-cpp.a on 64-bit Fedora Core 6, I get the following error:\n\n/usr/bin/ld: libactivemq-cpp.a(ActiveMQConnectionFactory.o): relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC\nlibactivemq-cpp.a: could not read symbols: Bad value\n\nAdding -fPIC to the CXXFLAGS seems to do the trick:\n\nIndex: configure.ac\n===================================================================\n--- configure.ac        (revision 544508)\n+++ configure.ac        (working copy)\n@@ -86,7 +86,7 @@\n AM_PATH_CPPUNIT(1.10.2, cppunit=yes, cppunit=no; AC_MSG_RESULT([no. Unit and Integration tests disabled])) \n AM_CONDITIONAL(BUILD_CPPUNIT_TESTS, test x$cppunit = xyes)\n \n-CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long\"\n+CXXFLAGS=\"$CXXFLAGS -W -Wall -fstrict-aliasing -Wstrict-aliasing=2 -Wno-long-long -fPIC\"\n # CPPUNIT_CXXFLAGS=\"$CPPUNIT_CXXFLAGS -Wno-non-virtual-dtor -Wno-unused-parameter -Wno-uninitialized\"\n LIBS=\"$LIBS\"\n\n\n\nComments:\n", "classification": "Classify the issue 'Link error when trying to link another shared library against AMQCPP on 64-bit Linux' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-123?\nA: When trying to link another shared library against libactivemq-cpp.a on 64-bit Fedora Core 6, I get the following error:\n\n/usr/bin/ld: libactivemq-cpp.a(ActiveMQConnectionFactory.o): relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC\nlibactivemq-cpp.a: could not read symbols: Bad value\n\nAdding -fPIC to the CXXFLAGS seems to do the tric"}}
{"issue_key": "AMQCPP-122", "project": "AMQCPP", "title": "Crash on Windows when rapidly creating and destroying connections", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-03T22:08:40.000+0000", "updated": "2007-06-14T11:12:36.000+0000", "description": "Me again. :)\n\nThe following program crashes within a few seconds on my Windows XP machine. This machine has a Core 2 Duo processor (i. e. 2 cores).\n\nOn my Pentium 4 + Hyperthreading Linux machine is only dies after about a minute with:\n\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Cannot assign requested address\nAborted\n\nHowever, this is to be expected, since the program causes thousands of sockets to be created. This doesn't seem to be the reason it crashes on Windows though.\n\nThe code:\n\n{code:none}\n#include <activemq/core/ActiveMQConnectionFactory.h> \n#include <cms/Connection.h> \n#include <cms/Session.h>\n#include <cms/MessageProducer.h>\n#include <cms/DeliveryMode.h>\n\nint main(int argc, char* argv[]) {                            \n  activemq::core::ActiveMQConnectionFactory connectionFactory(\"tcp://localhost:61613?wireFormat=stomp\");\n  while(true)\n  {\n    cms::Connection* connection = connectionFactory.createConnection(); \n    cms::Session* session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n    cms::Topic* topic = session->createTopic(\"topic\");\n    cms::MessageProducer* producer = session->createProducer(topic);\n    delete producer;\n    delete topic;\n    delete session; \n    delete connection;\n  }\n  return 0;\n}\n{code}\n\nThe stack trace when it crashes:\n\n>\tactivemq-cppd.dll!activemq::io::BufferedInputStream::read()  Line 79 + 0x12 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompHeaderLine()  Line 194 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompCommandHeader(activemq::connector::stomp::StompFrame & frame={...})  Line 101\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readCommand()  Line 59\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 166 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::concurrent::Thread::runCallback(void * param=0x003ad328)  Line 152 + 0x13 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x003adac0)  Line 331\tC\n \tkernel32.dll!7c80b683() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nThe line in BufferedInputStream::read is:\n\nchar returnValue = buffer[head++];\n\nThere is a local variable called bufferSize with a value of 1024. However, the value of head is usually much larger than bufferSize (like more than 10000).", "comments": [], "text": "Crash on Windows when rapidly creating and destroying connections\n\nDescription:\nMe again. :)\n\nThe following program crashes within a few seconds on my Windows XP machine. This machine has a Core 2 Duo processor (i. e. 2 cores).\n\nOn my Pentium 4 + Hyperthreading Linux machine is only dies after about a minute with:\n\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Cannot assign requested address\nAborted\n\nHowever, this is to be expected, since the program causes thousands of sockets to be created. This doesn't seem to be the reason it crashes on Windows though.\n\nThe code:\n\n{code:none}\n#include <activemq/core/ActiveMQConnectionFactory.h> \n#include <cms/Connection.h> \n#include <cms/Session.h>\n#include <cms/MessageProducer.h>\n#include <cms/DeliveryMode.h>\n\nint main(int argc, char* argv[]) {                            \n  activemq::core::ActiveMQConnectionFactory connectionFactory(\"tcp://localhost:61613?wireFormat=stomp\");\n  while(true)\n  {\n    cms::Connection* connection = connectionFactory.createConnection(); \n    cms::Session* session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n    cms::Topic* topic = session->createTopic(\"topic\");\n    cms::MessageProducer* producer = session->createProducer(topic);\n    delete producer;\n    delete topic;\n    delete session; \n    delete connection;\n  }\n  return 0;\n}\n{code}\n\nThe stack trace when it crashes:\n\n>\tactivemq-cppd.dll!activemq::io::BufferedInputStream::read()  Line 79 + 0x12 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompHeaderLine()  Line 194 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompCommandHeader(activemq::connector::stomp::StompFrame & frame={...})  Line 101\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readCommand()  Line 59\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 166 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::concurrent::Thread::runCallback(void * param=0x003ad328)  Line 152 + 0x13 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x003adac0)  Line 331\tC\n \tkernel32.dll!7c80b683() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nThe line in BufferedInputStream::read is:\n\nchar returnValue = buffer[head++];\n\nThere is a local variable called bufferSize with a value of 1024. However, the value of head is usually much larger than bufferSize (like more than 10000).\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Crash on Windows when rapidly creating and destroying connections\n\nDescription:\nMe again. :)\n\nThe following program crashes within a few seconds on my Windows XP machine. This machine has a Core 2 Duo processor (i. e. 2 cores).\n\nOn my Pentium 4 + Hyperthreading Linux machine is only dies after about a minute with:\n\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Cannot assign requested address\nAborted\n\nHowever, this is to be expected, since the program causes thousands of sockets to be created. This doesn't seem to be the reason it crashes on Windows though.\n\nThe code:\n\n{code:none}\n#include <activemq/core/ActiveMQConnectionFactory.h> \n#include <cms/Connection.h> \n#include <cms/Session.h>\n#include <cms/MessageProducer.h>\n#include <cms/DeliveryMode.h>\n\nint main(int argc, char* argv[]) {                            \n  activemq::core::ActiveMQConnectionFactory connectionFactory(\"tcp://localhost:61613?wireFormat=stomp\");\n  while(true)\n  {\n    cms::Connection* connection = connectionFactory.createConnection(); \n    cms::Session* session = connection->createSession(cms::Session::AUTO_ACKNOWLEDGE);\n    cms::Topic* topic = session->createTopic(\"topic\");\n    cms::MessageProducer* producer = session->createProducer(topic);\n    delete producer;\n    delete topic;\n    delete session; \n    delete connection;\n  }\n  return 0;\n}\n{code}\n\nThe stack trace when it crashes:\n\n>\tactivemq-cppd.dll!activemq::io::BufferedInputStream::read()  Line 79 + 0x12 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompHeaderLine()  Line 194 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readStompCommandHeader(activemq::connector::stomp::StompFrame & frame={...})  Line 101\tC++\n \tactivemq-cppd.dll!activemq::connector::stomp::StompCommandReader::readCommand()  Line 59\tC++\n \tactivemq-cppd.dll!activemq::transport::IOTransport::run()  Line 166 + 0x19 bytes\tC++\n \tactivemq-cppd.dll!activemq::concurrent::Thread::runCallback(void * param=0x003ad328)  Line 152 + 0x13 bytes\tC++\n \tmsvcr80d.dll!_callthreadstartex()  Line 348 + 0xf bytes\tC\n \tmsvcr80d.dll!_threadstartex(void * ptd=0x003adac0)  Line 331\tC\n \tkernel32.dll!7c80b683() \t\n \t[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\t\n\nThe line in BufferedInputStream::read is:\n\nchar returnValue = buffer[head++];\n\nThere is a local variable called bufferSize with a value of 1024. However, the value of head is usually much larger than bufferSize (like more than 10000).\n\nComments:\n", "classification": "Classify the issue 'Crash on Windows when rapidly creating and destroying connections' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-122?\nA: Me again. :)\n\nThe following program crashes within a few seconds on my Windows XP machine. This machine has a Core 2 Duo processor (i. e. 2 cores).\n\nOn my Pentium 4 + Hyperthreading Linux machine is only dies after about a minute with:\n\nterminate called after throwing an instance of 'activemq::exceptions::ActiveMQException'\n  what():  Cannot assign requested address\nAborted\n\nHowever, this is to be"}}
{"issue_key": "AMQCPP-121", "project": "AMQCPP", "title": "Possible memory leak in activemq::transport::IOTransport::run", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-06-02T22:47:09.000+0000", "updated": "2007-06-14T11:13:24.000+0000", "description": "There might be a memory leak in activemq::transport::IOTransport::run.\n\nValgrind says:\n\n==20739== 20 bytes in 1 blocks are definitely lost in loss record 126 of 175\n==20739==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20739==    by 0x4776995: activemq::connector::openwire::marshal::v2::ResponseMarshaller::createObject() const (ResponseMarshaller.cpp:40)\n==20739==    by 0x46A433B: activemq::connector::openwire::OpenWireFormat::doUnmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:239)\n==20739==    by 0x46A48C9: activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:185)\n==20739==    by 0x46A6E5D: activemq::connector::openwire::OpenWireCommandReader::readCommand() (OpenWireCommandReader.cpp:71)\n==20739==    by 0x46D3857: activemq::transport::IOTransport::run() (IOTransport.cpp:166)\n==20739==    by 0x4667DE7: activemq::concurrent::Thread::runCallback(void*) (Thread.cpp:152)\n==20739==    by 0x4963DA: start_thread (in /lib/libpthread-2.5.so)\n==20739==    by 0x3F026D: clone (in /lib/libc-2.5.so)\n\nThe code looks like this:\n\nvoid IOTransport::run(){\n    try{\n        while( !closed ){\n            Command* command = reader->readCommand();\n            fire( command );\n        }\n    }\n    catch( exceptions::ActiveMQException& ex ){ /*...*/ }\n    catch( ... ){ /*...*/ }\n}\n\nWhat might be happening here is that readCommand succeeds but that fire throws an exception for some reason. If this happens, command won't be freed.\n\nNot quite sure under what circumstances this happens. If you're not convinced, I can try to narrow down the code that causes the leak.", "comments": [], "text": "Possible memory leak in activemq::transport::IOTransport::run\n\nDescription:\nThere might be a memory leak in activemq::transport::IOTransport::run.\n\nValgrind says:\n\n==20739== 20 bytes in 1 blocks are definitely lost in loss record 126 of 175\n==20739==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20739==    by 0x4776995: activemq::connector::openwire::marshal::v2::ResponseMarshaller::createObject() const (ResponseMarshaller.cpp:40)\n==20739==    by 0x46A433B: activemq::connector::openwire::OpenWireFormat::doUnmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:239)\n==20739==    by 0x46A48C9: activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:185)\n==20739==    by 0x46A6E5D: activemq::connector::openwire::OpenWireCommandReader::readCommand() (OpenWireCommandReader.cpp:71)\n==20739==    by 0x46D3857: activemq::transport::IOTransport::run() (IOTransport.cpp:166)\n==20739==    by 0x4667DE7: activemq::concurrent::Thread::runCallback(void*) (Thread.cpp:152)\n==20739==    by 0x4963DA: start_thread (in /lib/libpthread-2.5.so)\n==20739==    by 0x3F026D: clone (in /lib/libc-2.5.so)\n\nThe code looks like this:\n\nvoid IOTransport::run(){\n    try{\n        while( !closed ){\n            Command* command = reader->readCommand();\n            fire( command );\n        }\n    }\n    catch( exceptions::ActiveMQException& ex ){ /*...*/ }\n    catch( ... ){ /*...*/ }\n}\n\nWhat might be happening here is that readCommand succeeds but that fire throws an exception for some reason. If this happens, command won't be freed.\n\nNot quite sure under what circumstances this happens. If you're not convinced, I can try to narrow down the code that causes the leak.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Possible memory leak in activemq::transport::IOTransport::run\n\nDescription:\nThere might be a memory leak in activemq::transport::IOTransport::run.\n\nValgrind says:\n\n==20739== 20 bytes in 1 blocks are definitely lost in loss record 126 of 175\n==20739==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20739==    by 0x4776995: activemq::connector::openwire::marshal::v2::ResponseMarshaller::createObject() const (ResponseMarshaller.cpp:40)\n==20739==    by 0x46A433B: activemq::connector::openwire::OpenWireFormat::doUnmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:239)\n==20739==    by 0x46A48C9: activemq::connector::openwire::OpenWireFormat::unmarshal(activemq::io::DataInputStream*) (OpenWireFormat.cpp:185)\n==20739==    by 0x46A6E5D: activemq::connector::openwire::OpenWireCommandReader::readCommand() (OpenWireCommandReader.cpp:71)\n==20739==    by 0x46D3857: activemq::transport::IOTransport::run() (IOTransport.cpp:166)\n==20739==    by 0x4667DE7: activemq::concurrent::Thread::runCallback(void*) (Thread.cpp:152)\n==20739==    by 0x4963DA: start_thread (in /lib/libpthread-2.5.so)\n==20739==    by 0x3F026D: clone (in /lib/libc-2.5.so)\n\nThe code looks like this:\n\nvoid IOTransport::run(){\n    try{\n        while( !closed ){\n            Command* command = reader->readCommand();\n            fire( command );\n        }\n    }\n    catch( exceptions::ActiveMQException& ex ){ /*...*/ }\n    catch( ... ){ /*...*/ }\n}\n\nWhat might be happening here is that readCommand succeeds but that fire throws an exception for some reason. If this happens, command won't be freed.\n\nNot quite sure under what circumstances this happens. If you're not convinced, I can try to narrow down the code that causes the leak.\n\nComments:\n", "classification": "Classify the issue 'Possible memory leak in activemq::transport::IOTransport::run' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-121?\nA: There might be a memory leak in activemq::transport::IOTransport::run.\n\nValgrind says:\n\n==20739== 20 bytes in 1 blocks are definitely lost in loss record 126 of 175\n==20739==    at 0x4005BA5: operator new(unsigned) (vg_replace_malloc.c:163)\n==20739==    by 0x4776995: activemq::connector::openwire::marshal::v2::ResponseMarshaller::createObject() const (ResponseMarshaller.cpp:40)\n==20739==    by 0x4"}}
{"issue_key": "AMQCPP-120", "project": "AMQCPP", "title": "Possible memory leak in StompConnector", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-02T21:26:11.000+0000", "updated": "2007-06-02T22:19:24.000+0000", "description": "Valgrind reports a possible memory leak in StompConnector where its constructor does:\n\nthis->transport = new StompConnectionNegotiator( transport, false );\n\nAs far as I can tell, the destructor doesn't have a delete for this.", "comments": [], "text": "Possible memory leak in StompConnector\n\nDescription:\nValgrind reports a possible memory leak in StompConnector where its constructor does:\n\nthis->transport = new StompConnectionNegotiator( transport, false );\n\nAs far as I can tell, the destructor doesn't have a delete for this.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Possible memory leak in StompConnector\n\nDescription:\nValgrind reports a possible memory leak in StompConnector where its constructor does:\n\nthis->transport = new StompConnectionNegotiator( transport, false );\n\nAs far as I can tell, the destructor doesn't have a delete for this.\n\nComments:\n", "classification": "Classify the issue 'Possible memory leak in StompConnector' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-120?\nA: Valgrind reports a possible memory leak in StompConnector where its constructor does:\n\nthis->transport = new StompConnectionNegotiator( transport, false );\n\nAs far as I can tell, the destructor doesn't have a delete for this."}}
{"issue_key": "AMQCPP-119", "project": "AMQCPP", "title": "getClientID segfaults is called after connection has been closed", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-06-02T20:44:26.000+0000", "updated": "2007-06-02T22:25:51.000+0000", "description": "Calling getClientID() on a connection after it has been closed segfaults.\n\n{code:title=main.cpp}#include <iostream>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <cms/Connection.h>\n\nusing namespace activemq::core;\nusing namespace cms;\n\nint main(int argc, char* argv[]) {\n    ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616?wireFormat=openwire\" );\n    cms::Connection* connection = connectionFactory.createConnection();\n    connection->getClientID();\n    connection->close();\n    connection->getClientID();\n    delete connection;\n    connection = NULL;\n    return 0;\n}{code}", "comments": [], "text": "getClientID segfaults is called after connection has been closed\n\nDescription:\nCalling getClientID() on a connection after it has been closed segfaults.\n\n{code:title=main.cpp}#include <iostream>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <cms/Connection.h>\n\nusing namespace activemq::core;\nusing namespace cms;\n\nint main(int argc, char* argv[]) {\n    ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616?wireFormat=openwire\" );\n    cms::Connection* connection = connectionFactory.createConnection();\n    connection->getClientID();\n    connection->close();\n    connection->getClientID();\n    delete connection;\n    connection = NULL;\n    return 0;\n}{code} \n\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: getClientID segfaults is called after connection has been closed\n\nDescription:\nCalling getClientID() on a connection after it has been closed segfaults.\n\n{code:title=main.cpp}#include <iostream>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <cms/Connection.h>\n\nusing namespace activemq::core;\nusing namespace cms;\n\nint main(int argc, char* argv[]) {\n    ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616?wireFormat=openwire\" );\n    cms::Connection* connection = connectionFactory.createConnection();\n    connection->getClientID();\n    connection->close();\n    connection->getClientID();\n    delete connection;\n    connection = NULL;\n    return 0;\n}{code} \n\n\nComments:\n", "classification": "Classify the issue 'getClientID segfaults is called after connection has been closed' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-119?\nA: Calling getClientID() on a connection after it has been closed segfaults.\n\n{code:title=main.cpp}#include <iostream>\n#include <activemq/core/ActiveMQConnectionFactory.h>\n#include <cms/Connection.h>\n\nusing namespace activemq::core;\nusing namespace cms;\n\nint main(int argc, char* argv[]) {\n    ActiveMQConnectionFactory connectionFactory( \"tcp://localhost:61616?wireFormat=openwire\" );\n    cms::Connecti"}}
{"issue_key": "AMQCPP-118", "project": "AMQCPP", "title": "Provide a way to allocate and free with the same allocator", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-05-29T20:39:42.000+0000", "updated": "2007-06-07T18:27:47.000+0000", "description": "Cross-runtime allocation and deallocation can cause problems on Windows (and maybe other platforms) where you can have code linked against more than one runtime in the same program. There should be a way to be sure that you allocate and deallocate AMQCPP objects using code linked against the same runtime (i.e. allocate and deallocate from the same heap).\n\nMore details in this thread:\n\n[http://www.nabble.com/Licensing-and-Porting-Issue-for-the-CMS-(ActiveMQ-CPP)-on-Visual-Studio-6-from-Visual-Studio-8-t3777279s2354.html]\n\nand here:\n\nhttp://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx", "comments": [], "text": "Provide a way to allocate and free with the same allocator\n\nDescription:\nCross-runtime allocation and deallocation can cause problems on Windows (and maybe other platforms) where you can have code linked against more than one runtime in the same program. There should be a way to be sure that you allocate and deallocate AMQCPP objects using code linked against the same runtime (i.e. allocate and deallocate from the same heap).\n\nMore details in this thread:\n\n[http://www.nabble.com/Licensing-and-Porting-Issue-for-the-CMS-(ActiveMQ-CPP)-on-Visual-Studio-6-from-Visual-Studio-8-t3777279s2354.html]\n\nand here:\n\nhttp://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Provide a way to allocate and free with the same allocator\n\nDescription:\nCross-runtime allocation and deallocation can cause problems on Windows (and maybe other platforms) where you can have code linked against more than one runtime in the same program. There should be a way to be sure that you allocate and deallocate AMQCPP objects using code linked against the same runtime (i.e. allocate and deallocate from the same heap).\n\nMore details in this thread:\n\n[http://www.nabble.com/Licensing-and-Porting-Issue-for-the-CMS-(ActiveMQ-CPP)-on-Visual-Studio-6-from-Visual-Studio-8-t3777279s2354.html]\n\nand here:\n\nhttp://blogs.msdn.com/oldnewthing/archive/2006/09/15/755966.aspx\n\nComments:\n", "classification": "Classify the issue 'Provide a way to allocate and free with the same allocator' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-118?\nA: Cross-runtime allocation and deallocation can cause problems on Windows (and maybe other platforms) where you can have code linked against more than one runtime in the same program. There should be a way to be sure that you allocate and deallocate AMQCPP objects using code linked against the same runtime (i.e. allocate and deallocate from the same heap).\n\nMore details in this thread:\n\n[http://www."}}
{"issue_key": "AMQCPP-117", "project": "AMQCPP", "title": "ActiveMQBytesMessage::getBodyBytes crashes if body length is zero", "status": "Resolved", "reporter": "Albert Strasheim", "assignee": "Timothy A. Bish", "priority": "Major", "labels": [], "created": "2007-05-24T16:59:26.000+0000", "updated": "2007-05-24T17:26:33.000+0000", "description": "On Windows with a Debug build, ActiveMQBytesMessage::getBodyBytes crashes when called if body length is zero.\n\nThe following friendly error pops up:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: C:\\Python24\\python.exe\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector\nLine: 741\n\nExpression: vector subscript out of range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\nProposed patch attached (check for length greater than zero, if not return NULL0.", "comments": [], "text": "ActiveMQBytesMessage::getBodyBytes crashes if body length is zero\n\nDescription:\nOn Windows with a Debug build, ActiveMQBytesMessage::getBodyBytes crashes when called if body length is zero.\n\nThe following friendly error pops up:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: C:\\Python24\\python.exe\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector\nLine: 741\n\nExpression: vector subscript out of range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\nProposed patch attached (check for length greater than zero, if not return NULL0.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: ActiveMQBytesMessage::getBodyBytes crashes if body length is zero\n\nDescription:\nOn Windows with a Debug build, ActiveMQBytesMessage::getBodyBytes crashes when called if body length is zero.\n\nThe following friendly error pops up:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: C:\\Python24\\python.exe\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector\nLine: 741\n\nExpression: vector subscript out of range\n\nFor information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts.\n\n(Press Retry to debug the application)\n---------------------------\nAbort   Retry   Ignore   \n---------------------------\n\nProposed patch attached (check for length greater than zero, if not return NULL0.\n\nComments:\n", "classification": "Classify the issue 'ActiveMQBytesMessage::getBodyBytes crashes if body length is zero' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-117?\nA: On Windows with a Debug build, ActiveMQBytesMessage::getBodyBytes crashes when called if body length is zero.\n\nThe following friendly error pops up:\n\n---------------------------\nMicrosoft Visual C++ Debug Library\n---------------------------\nDebug Assertion Failed!\n\nProgram: C:\\Python24\\python.exe\nFile: C:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\vector\nLine: 741\n\nExpression: vector subsc"}}
{"issue_key": "AMQCPP-116", "project": "AMQCPP", "title": "quick improvements to CMS example code", "status": "Resolved", "reporter": "Greg Griffin", "assignee": "Timothy A. Bish", "priority": "Minor", "labels": [], "created": "2007-05-23T07:42:02.000+0000", "updated": "2007-05-23T13:24:53.000+0000", "description": "In the CMS example code, http://activemq.apache.org/cms/example.html :\n\n  * the producer's counting starts at zero, but the consumer's starts at 1, so what's printed makes it seem like the code somehow sends an extra message. Can fix by:\n        printf( \"Sent message #%d from thread %s\\n\", ix+1, threadIdStr.c_str() );\n                                                                                                ^^\n        or change how the loop is done\n\n   * in snippet:\n    // Give the consumer a but to start up.\n    Thread::sleep( 75 );\n          \"but\" should be \"bit\"", "comments": [], "text": "quick improvements to CMS example code\n\nDescription:\nIn the CMS example code, http://activemq.apache.org/cms/example.html :\n\n  * the producer's counting starts at zero, but the consumer's starts at 1, so what's printed makes it seem like the code somehow sends an extra message. Can fix by:\n        printf( \"Sent message #%d from thread %s\\n\", ix+1, threadIdStr.c_str() );\n                                                                                                ^^\n        or change how the loop is done\n\n   * in snippet:\n    // Give the consumer a but to start up.\n    Thread::sleep( 75 );\n          \"but\" should be \"bit\"\n    \n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: quick improvements to CMS example code\n\nDescription:\nIn the CMS example code, http://activemq.apache.org/cms/example.html :\n\n  * the producer's counting starts at zero, but the consumer's starts at 1, so what's printed makes it seem like the code somehow sends an extra message. Can fix by:\n        printf( \"Sent message #%d from thread %s\\n\", ix+1, threadIdStr.c_str() );\n                                                                                                ^^\n        or change how the loop is done\n\n   * in snippet:\n    // Give the consumer a but to start up.\n    Thread::sleep( 75 );\n          \"but\" should be \"bit\"\n    \n\nComments:\n", "classification": "Classify the issue 'quick improvements to CMS example code' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-116?\nA: In the CMS example code, http://activemq.apache.org/cms/example.html :\n\n  * the producer's counting starts at zero, but the consumer's starts at 1, so what's printed makes it seem like the code somehow sends an extra message. Can fix by:\n        printf( \"Sent message #%d from thread %s\\n\", ix+1, threadIdStr.c_str() );\n                                                                                "}}
{"issue_key": "AMQCPP-115", "project": "AMQCPP", "title": "Change build to create dynamic libraries", "status": "Resolved", "reporter": "Nathan Christopher Mittler", "assignee": "Nathan Christopher Mittler", "priority": "Minor", "labels": [], "created": "2007-05-18T12:36:31.000+0000", "updated": "2007-07-14T13:20:13.000+0000", "description": "Based on a flurry of user requests, we need to add support for generating dynamic libraries to our automake scripts and the msvc project.", "comments": [], "text": "Change build to create dynamic libraries\n\nDescription:\nBased on a flurry of user requests, we need to add support for generating dynamic libraries to our automake scripts and the msvc project.\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Change build to create dynamic libraries\n\nDescription:\nBased on a flurry of user requests, we need to add support for generating dynamic libraries to our automake scripts and the msvc project.\n\nComments:\n", "classification": "Classify the issue 'Change build to create dynamic libraries' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-115?\nA: Based on a flurry of user requests, we need to add support for generating dynamic libraries to our automake scripts and the msvc project."}}
{"issue_key": "AMQCPP-114", "project": "AMQCPP", "title": "Compression not supported with C++ client", "status": "Closed", "reporter": "Eddie Epstein", "assignee": "Nathan Christopher Mittler", "priority": "Major", "labels": [], "created": "2007-04-27T20:52:32.000+0000", "updated": "2007-04-27T21:17:24.000+0000", "description": "Using ActiveMQ broker 4.1.1, the C++ client seems to ignore the fact that incoming messages are compressed, delivering the compressed payload to the listener. Outgoing reply messages from C++ are marked as compressed, but this generates an error with the Java consumer expecting a compressed payload.\n\nI could not find any documentation that compression was not supported with the C++ client.\n\nEddie Epstein", "comments": [], "text": "Compression not supported with C++ client\n\nDescription:\nUsing ActiveMQ broker 4.1.1, the C++ client seems to ignore the fact that incoming messages are compressed, delivering the compressed payload to the listener. Outgoing reply messages from C++ are marked as compressed, but this generates an error with the Java consumer expecting a compressed payload.\n\nI could not find any documentation that compression was not supported with the C++ client.\n\nEddie Epstein\n\nComments:", "derived_tasks": {"summarization": "Summarize this issue: Compression not supported with C++ client\n\nDescription:\nUsing ActiveMQ broker 4.1.1, the C++ client seems to ignore the fact that incoming messages are compressed, delivering the compressed payload to the listener. Outgoing reply messages from C++ are marked as compressed, but this generates an error with the Java consumer expecting a compressed payload.\n\nI could not find any documentation that compression was not supported with the C++ client.\n\nEddie Epstein\n\nComments:\n", "classification": "Classify the issue 'Compression not supported with C++ client' into categories like 'Bug', 'Improvement', 'Task', or 'Feature'.", "qna": "Q: What is the main problem described in issue AMQCPP-114?\nA: Using ActiveMQ broker 4.1.1, the C++ client seems to ignore the fact that incoming messages are compressed, delivering the compressed payload to the listener. Outgoing reply messages from C++ are marked as compressed, but this generates an error with the Java consumer expecting a compressed payload.\n\nI could not find any documentation that compression was not supported with the C++ client.\n\nEddie "}}
